"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@grpc";
exports.ids = ["vendor-chunks/@grpc"];
exports.modules = {

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/admin.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addAdminServicesToServer = exports.registerAdminService = void 0;\nconst registeredAdminServices = [];\nfunction registerAdminService(getServiceDefinition, getHandlers) {\n    registeredAdminServices.push({\n        getServiceDefinition,\n        getHandlers\n    });\n}\nexports.registerAdminService = registerAdminService;\nfunction addAdminServicesToServer(server) {\n    for (const { getServiceDefinition, getHandlers } of registeredAdminServices){\n        server.addService(getServiceDefinition(), getHandlers());\n    }\n}\nexports.addAdminServicesToServer = addAdminServicesToServer; //# sourceMappingURL=admin.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYWRtaW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdDQUFnQyxHQUFHQSw0QkFBNEIsR0FBRyxLQUFLO0FBQ3ZFLE1BQU1JLDBCQUEwQixFQUFFO0FBQ2xDLFNBQVNELHFCQUFxQkUsb0JBQW9CLEVBQUVDLFdBQVc7SUFDM0RGLHdCQUF3QkcsSUFBSSxDQUFDO1FBQUVGO1FBQXNCQztJQUFZO0FBQ3JFO0FBQ0FOLDRCQUE0QixHQUFHRztBQUMvQixTQUFTRCx5QkFBeUJNLE1BQU07SUFDcEMsS0FBSyxNQUFNLEVBQUVILG9CQUFvQixFQUFFQyxXQUFXLEVBQUUsSUFBSUYsd0JBQXlCO1FBQ3pFSSxPQUFPQyxVQUFVLENBQUNKLHdCQUF3QkM7SUFDOUM7QUFDSjtBQUNBTixnQ0FBZ0MsR0FBR0UsMEJBQ25DLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FzaG1pdHQtZ3VwdGEvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYWRtaW4uanM/OTg0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXIgPSBleHBvcnRzLnJlZ2lzdGVyQWRtaW5TZXJ2aWNlID0gdm9pZCAwO1xuY29uc3QgcmVnaXN0ZXJlZEFkbWluU2VydmljZXMgPSBbXTtcbmZ1bmN0aW9uIHJlZ2lzdGVyQWRtaW5TZXJ2aWNlKGdldFNlcnZpY2VEZWZpbml0aW9uLCBnZXRIYW5kbGVycykge1xuICAgIHJlZ2lzdGVyZWRBZG1pblNlcnZpY2VzLnB1c2goeyBnZXRTZXJ2aWNlRGVmaW5pdGlvbiwgZ2V0SGFuZGxlcnMgfSk7XG59XG5leHBvcnRzLnJlZ2lzdGVyQWRtaW5TZXJ2aWNlID0gcmVnaXN0ZXJBZG1pblNlcnZpY2U7XG5mdW5jdGlvbiBhZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXIoc2VydmVyKSB7XG4gICAgZm9yIChjb25zdCB7IGdldFNlcnZpY2VEZWZpbml0aW9uLCBnZXRIYW5kbGVycyB9IG9mIHJlZ2lzdGVyZWRBZG1pblNlcnZpY2VzKSB7XG4gICAgICAgIHNlcnZlci5hZGRTZXJ2aWNlKGdldFNlcnZpY2VEZWZpbml0aW9uKCksIGdldEhhbmRsZXJzKCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyID0gYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRtaW4uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyIiwicmVnaXN0ZXJBZG1pblNlcnZpY2UiLCJyZWdpc3RlcmVkQWRtaW5TZXJ2aWNlcyIsImdldFNlcnZpY2VEZWZpbml0aW9uIiwiZ2V0SGFuZGxlcnMiLCJwdXNoIiwic2VydmVyIiwiYWRkU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BackoffTimeout = void 0;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */ function uniformRandom(min, max) {\n    return Math.random() * (max - min) + min;\n}\nclass BackoffTimeout {\n    constructor(callback, options){\n        this.callback = callback;\n        /**\n         * The delay time at the start, and after each reset.\n         */ this.initialDelay = INITIAL_BACKOFF_MS;\n        /**\n         * The exponential backoff multiplier.\n         */ this.multiplier = BACKOFF_MULTIPLIER;\n        /**\n         * The maximum delay time\n         */ this.maxDelay = MAX_BACKOFF_MS;\n        /**\n         * The maximum fraction by which the delay time can randomly vary after\n         * applying the multiplier.\n         */ this.jitter = BACKOFF_JITTER;\n        /**\n         * Indicates whether the timer is currently running.\n         */ this.running = false;\n        /**\n         * Indicates whether the timer should keep the Node process running if no\n         * other async operation is doing so.\n         */ this.hasRef = true;\n        /**\n         * The time that the currently running timer was started. Only valid if\n         * running is true.\n         */ this.startTime = new Date();\n        if (options) {\n            if (options.initialDelay) {\n                this.initialDelay = options.initialDelay;\n            }\n            if (options.multiplier) {\n                this.multiplier = options.multiplier;\n            }\n            if (options.jitter) {\n                this.jitter = options.jitter;\n            }\n            if (options.maxDelay) {\n                this.maxDelay = options.maxDelay;\n            }\n        }\n        this.nextDelay = this.initialDelay;\n        this.timerId = setTimeout(()=>{}, 0);\n        clearTimeout(this.timerId);\n    }\n    runTimer(delay) {\n        var _a, _b;\n        clearTimeout(this.timerId);\n        this.timerId = setTimeout(()=>{\n            this.callback();\n            this.running = false;\n        }, delay);\n        if (!this.hasRef) {\n            (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    /**\n     * Call the callback after the current amount of delay time\n     */ runOnce() {\n        this.running = true;\n        this.startTime = new Date();\n        this.runTimer(this.nextDelay);\n        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n        const jitterMagnitude = nextBackoff * this.jitter;\n        this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n    }\n    /**\n     * Stop the timer. The callback will not be called until `runOnce` is called\n     * again.\n     */ stop() {\n        clearTimeout(this.timerId);\n        this.running = false;\n    }\n    /**\n     * Reset the delay time to its initial value. If the timer is still running,\n     * retroactively apply that reset to the current timer.\n     */ reset() {\n        this.nextDelay = this.initialDelay;\n        if (this.running) {\n            const now = new Date();\n            const newEndTime = this.startTime;\n            newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\n            clearTimeout(this.timerId);\n            if (now < newEndTime) {\n                this.runTimer(newEndTime.getTime() - now.getTime());\n            } else {\n                this.running = false;\n            }\n        }\n    }\n    /**\n     * Check whether the timer is currently running.\n     */ isRunning() {\n        return this.running;\n    }\n    /**\n     * Set that while the timer is running, it should keep the Node process\n     * running.\n     */ ref() {\n        var _a, _b;\n        this.hasRef = true;\n        (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * Set that while the timer is running, it should not keep the Node process\n     * running.\n     */ unref() {\n        var _a, _b;\n        this.hasRef = false;\n        (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n}\nexports.BackoffTimeout = BackoffTimeout; //# sourceMappingURL=backoff-timeout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYmFja29mZi10aW1lb3V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBRyxLQUFLO0FBQzlCLE1BQU1HLHFCQUFxQjtBQUMzQixNQUFNQyxxQkFBcUI7QUFDM0IsTUFBTUMsaUJBQWlCO0FBQ3ZCLE1BQU1DLGlCQUFpQjtBQUN2Qjs7OztDQUlDLEdBQ0QsU0FBU0MsY0FBY0MsR0FBRyxFQUFFQyxHQUFHO0lBQzNCLE9BQU9DLEtBQUtDLE1BQU0sS0FBTUYsQ0FBQUEsTUFBTUQsR0FBRSxJQUFLQTtBQUN6QztBQUNBLE1BQU1OO0lBQ0ZVLFlBQVlDLFFBQVEsRUFBRUMsT0FBTyxDQUFFO1FBQzNCLElBQUksQ0FBQ0QsUUFBUSxHQUFHQTtRQUNoQjs7U0FFQyxHQUNELElBQUksQ0FBQ0UsWUFBWSxHQUFHWjtRQUNwQjs7U0FFQyxHQUNELElBQUksQ0FBQ2EsVUFBVSxHQUFHWjtRQUNsQjs7U0FFQyxHQUNELElBQUksQ0FBQ2EsUUFBUSxHQUFHWjtRQUNoQjs7O1NBR0MsR0FDRCxJQUFJLENBQUNhLE1BQU0sR0FBR1o7UUFDZDs7U0FFQyxHQUNELElBQUksQ0FBQ2EsT0FBTyxHQUFHO1FBQ2Y7OztTQUdDLEdBQ0QsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZDs7O1NBR0MsR0FDRCxJQUFJLENBQUNDLFNBQVMsR0FBRyxJQUFJQztRQUNyQixJQUFJUixTQUFTO1lBQ1QsSUFBSUEsUUFBUUMsWUFBWSxFQUFFO2dCQUN0QixJQUFJLENBQUNBLFlBQVksR0FBR0QsUUFBUUMsWUFBWTtZQUM1QztZQUNBLElBQUlELFFBQVFFLFVBQVUsRUFBRTtnQkFDcEIsSUFBSSxDQUFDQSxVQUFVLEdBQUdGLFFBQVFFLFVBQVU7WUFDeEM7WUFDQSxJQUFJRixRQUFRSSxN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MkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNobWl0dC1ndXB0YS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9iYWNrb2ZmLXRpbWVvdXQuanM/ZmU0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYWNrb2ZmVGltZW91dCA9IHZvaWQgMDtcbmNvbnN0IElOSVRJQUxfQkFDS09GRl9NUyA9IDEwMDA7XG5jb25zdCBCQUNLT0ZGX01VTFRJUExJRVIgPSAxLjY7XG5jb25zdCBNQVhfQkFDS09GRl9NUyA9IDEyMDAwMDtcbmNvbnN0IEJBQ0tPRkZfSklUVEVSID0gMC4yO1xuLyoqXG4gKiBHZXQgYSBudW1iZXIgdW5pZm9ybWx5IGF0IHJhbmRvbSBpbiB0aGUgcmFuZ2UgW21pbiwgbWF4KVxuICogQHBhcmFtIG1pblxuICogQHBhcmFtIG1heFxuICovXG5mdW5jdGlvbiB1bmlmb3JtUmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcbn1cbmNsYXNzIEJhY2tvZmZUaW1lb3V0IHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVsYXkgdGltZSBhdCB0aGUgc3RhcnQsIGFuZCBhZnRlciBlYWNoIHJlc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbml0aWFsRGVsYXkgPSBJTklUSUFMX0JBQ0tPRkZfTVM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZXhwb25lbnRpYWwgYmFja29mZiBtdWx0aXBsaWVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tdWx0aXBsaWVyID0gQkFDS09GRl9NVUxUSVBMSUVSO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gZGVsYXkgdGltZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXhEZWxheSA9IE1BWF9CQUNLT0ZGX01TO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gZnJhY3Rpb24gYnkgd2hpY2ggdGhlIGRlbGF5IHRpbWUgY2FuIHJhbmRvbWx5IHZhcnkgYWZ0ZXJcbiAgICAgICAgICogYXBwbHlpbmcgdGhlIG11bHRpcGxpZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmppdHRlciA9IEJBQ0tPRkZfSklUVEVSO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRpbWVyIGlzIGN1cnJlbnRseSBydW5uaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGltZXIgc2hvdWxkIGtlZXAgdGhlIE5vZGUgcHJvY2VzcyBydW5uaW5nIGlmIG5vXG4gICAgICAgICAqIG90aGVyIGFzeW5jIG9wZXJhdGlvbiBpcyBkb2luZyBzby5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzUmVmID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIHRoYXQgdGhlIGN1cnJlbnRseSBydW5uaW5nIHRpbWVyIHdhcyBzdGFydGVkLiBPbmx5IHZhbGlkIGlmXG4gICAgICAgICAqIHJ1bm5pbmcgaXMgdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmluaXRpYWxEZWxheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbERlbGF5ID0gb3B0aW9ucy5pbml0aWFsRGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tdWx0aXBsaWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBsaWVyID0gb3B0aW9ucy5tdWx0aXBsaWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaml0dGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5qaXR0ZXIgPSBvcHRpb25zLmppdHRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1heERlbGF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXhEZWxheSA9IG9wdGlvbnMubWF4RGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0RGVsYXkgPSB0aGlzLmluaXRpYWxEZWxheTtcbiAgICAgICAgdGhpcy50aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7IH0sIDApO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICB9XG4gICAgcnVuVGltZXIoZGVsYXkpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XG4gICAgICAgIHRoaXMudGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjaygpO1xuICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1JlZikge1xuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy50aW1lcklkKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIGNhbGxiYWNrIGFmdGVyIHRoZSBjdXJyZW50IGFtb3VudCBvZiBkZWxheSB0aW1lXG4gICAgICovXG4gICAgcnVuT25jZSgpIHtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLnJ1blRpbWVyKHRoaXMubmV4dERlbGF5KTtcbiAgICAgICAgY29uc3QgbmV4dEJhY2tvZmYgPSBNYXRoLm1pbih0aGlzLm5leHREZWxheSAqIHRoaXMubXVsdGlwbGllciwgdGhpcy5tYXhEZWxheSk7XG4gICAgICAgIGNvbnN0IGppdHRlck1hZ25pdHVkZSA9IG5leHRCYWNrb2ZmICogdGhpcy5qaXR0ZXI7XG4gICAgICAgIHRoaXMubmV4dERlbGF5ID1cbiAgICAgICAgICAgIG5leHRCYWNrb2ZmICsgdW5pZm9ybVJhbmRvbSgtaml0dGVyTWFnbml0dWRlLCBqaXR0ZXJNYWduaXR1ZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSB0aW1lci4gVGhlIGNhbGxiYWNrIHdpbGwgbm90IGJlIGNhbGxlZCB1bnRpbCBgcnVuT25jZWAgaXMgY2FsbGVkXG4gICAgICogYWdhaW4uXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgZGVsYXkgdGltZSB0byBpdHMgaW5pdGlhbCB2YWx1ZS4gSWYgdGhlIHRpbWVyIGlzIHN0aWxsIHJ1bm5pbmcsXG4gICAgICogcmV0cm9hY3RpdmVseSBhcHBseSB0aGF0IHJlc2V0IHRvIHRoZSBjdXJyZW50IHRpbWVyLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLm5leHREZWxheSA9IHRoaXMuaW5pdGlhbERlbGF5O1xuICAgICAgICBpZiAodGhpcy5ydW5uaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgbmV3RW5kVGltZSA9IHRoaXMuc3RhcnRUaW1lO1xuICAgICAgICAgICAgbmV3RW5kVGltZS5zZXRNaWxsaXNlY29uZHMobmV3RW5kVGltZS5nZXRNaWxsaXNlY29uZHMoKSArIHRoaXMubmV4dERlbGF5KTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xuICAgICAgICAgICAgaWYgKG5vdyA8IG5ld0VuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1blRpbWVyKG5ld0VuZFRpbWUuZ2V0VGltZSgpIC0gbm93LmdldFRpbWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSB0aW1lciBpcyBjdXJyZW50bHkgcnVubmluZy5cbiAgICAgKi9cbiAgICBpc1J1bm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bm5pbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGF0IHdoaWxlIHRoZSB0aW1lciBpcyBydW5uaW5nLCBpdCBzaG91bGQga2VlcCB0aGUgTm9kZSBwcm9jZXNzXG4gICAgICogcnVubmluZy5cbiAgICAgKi9cbiAgICByZWYoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuaGFzUmVmID0gdHJ1ZTtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy50aW1lcklkKS5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoYXQgd2hpbGUgdGhlIHRpbWVyIGlzIHJ1bm5pbmcsIGl0IHNob3VsZCBub3Qga2VlcCB0aGUgTm9kZSBwcm9jZXNzXG4gICAgICogcnVubmluZy5cbiAgICAgKi9cbiAgICB1bnJlZigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5oYXNSZWYgPSBmYWxzZTtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy50aW1lcklkKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFja29mZlRpbWVvdXQgPSBCYWNrb2ZmVGltZW91dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tvZmYtdGltZW91dC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJCYWNrb2ZmVGltZW91dCIsIklOSVRJQUxfQkFDS09GRl9NUyIsIkJBQ0tPRkZfTVVMVElQTElFUiIsIk1BWF9CQUNLT0ZGX01TIiwiQkFDS09GRl9KSVRURVIiLCJ1bmlmb3JtUmFuZG9tIiwibWluIiwibWF4IiwiTWF0aCIsInJhbmRvbSIsImNvbnN0cnVjdG9yIiwiY2FsbGJhY2siLCJvcHRpb25zIiwiaW5pdGlhbERlbGF5IiwibXVsdGlwbGllciIsIm1heERlbGF5Iiwiaml0dGVyIiwicnVubmluZyIsImhhc1JlZiIsInN0YXJ0VGltZSIsIkRhdGUiLCJuZXh0RGVsYXkiLCJ0aW1lcklkIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInJ1blRpbWVyIiwiZGVsYXkiLCJfYSIsIl9iIiwidW5yZWYiLCJjYWxsIiwicnVuT25jZSIsIm5leHRCYWNrb2ZmIiwiaml0dGVyTWFnbml0dWRlIiwic3RvcCIsInJlc2V0Iiwibm93IiwibmV3RW5kVGltZSIsInNldE1pbGxpc2Vjb25kcyIsImdldE1pbGxpc2Vjb25kcyIsImdldFRpbWUiLCJpc1J1bm5pbmciLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials-filter.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-credentials-filter.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CallCredentialsFilterFactory = exports.CallCredentialsFilter = void 0;\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nclass CallCredentialsFilter extends filter_1.BaseFilter {\n    constructor(channel, stream){\n        var _a, _b;\n        super();\n        this.channel = channel;\n        this.stream = stream;\n        this.channel = channel;\n        this.stream = stream;\n        const splitPath = stream.getMethod().split(\"/\");\n        let serviceName = \"\";\n        /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n         * by '/', the first item should be empty and the second should be the\n         * service name */ if (splitPath.length >= 2) {\n            serviceName = splitPath[1];\n        }\n        const hostname = (_b = (_a = uri_parser_1.splitHostPort(stream.getHost())) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : \"localhost\";\n        /* Currently, call credentials are only allowed on HTTPS connections, so we\n         * can assume that the scheme is \"https\" */ this.serviceUrl = `https://${hostname}/${serviceName}`;\n    }\n    async sendMetadata(metadata) {\n        const credentials = this.stream.getCredentials();\n        const credsMetadata = credentials.generateMetadata({\n            service_url: this.serviceUrl\n        });\n        const resultMetadata = await metadata;\n        try {\n            resultMetadata.merge(await credsMetadata);\n        } catch (error) {\n            this.stream.cancelWithStatus(constants_1.Status.UNAUTHENTICATED, `Failed to retrieve auth metadata with error: ${error.message}`);\n            return Promise.reject(\"Failed to retrieve auth metadata\");\n        }\n        if (resultMetadata.get(\"authorization\").length > 1) {\n            this.stream.cancelWithStatus(constants_1.Status.INTERNAL, '\"authorization\" metadata cannot have multiple values');\n            return Promise.reject('\"authorization\" metadata cannot have multiple values');\n        }\n        return resultMetadata;\n    }\n}\nexports.CallCredentialsFilter = CallCredentialsFilter;\nclass CallCredentialsFilterFactory {\n    constructor(channel){\n        this.channel = channel;\n        this.channel = channel;\n    }\n    createFilter(callStream) {\n        return new CallCredentialsFilter(this.channel, callStream);\n    }\n}\nexports.CallCredentialsFilterFactory = CallCredentialsFilterFactory; //# sourceMappingURL=call-credentials-filter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1jcmVkZW50aWFscy1maWx0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9DQUFvQyxHQUFHQSw2QkFBNkIsR0FBRyxLQUFLO0FBQzVFLE1BQU1JLFdBQVdDLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1FLGVBQWVGLG1CQUFPQSxDQUFDLGdGQUFjO0FBQzNDLE1BQU1GLDhCQUE4QkMsU0FBU0ksVUFBVTtJQUNuREMsWUFBWUMsT0FBTyxFQUFFQyxNQUFNLENBQUU7UUFDekIsSUFBSUMsSUFBSUM7UUFDUixLQUFLO1FBQ0wsSUFBSSxDQUFDSCxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDRCxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2QsTUFBTUcsWUFBWUgsT0FBT0ksU0FBUyxHQUFHQyxLQUFLLENBQUM7UUFDM0MsSUFBSUMsY0FBYztRQUNsQjs7d0JBRWdCLEdBQ2hCLElBQUlILFVBQVVJLE1BQU0sSUFBSSxHQUFHO1lBQ3ZCRCxjQUFjSCxTQUFTLENBQUMsRUFBRTtRQUM5QjtRQUNBLE1BQU1LLFdBQVcsQ0FBQ04sS0FBSyxDQUFDRCxLQUFLTCxhQUFhYSxhQUFhLENBQUNULE9BQU9VLE9BQU8sR0FBRSxNQUFPLFFBQVFULE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR1UsSUFBSSxNQUFNLFFBQVFULE9BQU8sS0FBSyxJQUFJQSxLQUFLO1FBQzFKO2lEQUN5QyxHQUN6QyxJQUFJLENBQUNVLFVBQVUsR0FBRyxDQUFDLFFBQVEsRUFBRUosU0FBUyxDQUFDLEVBQUVGLFlBQVksQ0FBQztJQUMxRDtJQUNBLE1BQU1PLGFBQWFDLFFBQVEsRUFBRTtRQUN6QixNQUFNQyxjQUFjLElBQUksQ0FBQ2YsTUFBTSxDQUFDZ0IsY0FBYztRQUM5QyxNQUFNQyxnQkFBZ0JGLFlBQVlHLGdCQUFnQixDQUFDO1lBQy9DQyxhQUFhLElBQUksQ0FBQ1AsVUFBVTtRQUNoQztRQUNBLE1BQU1RLGlCQUFpQixNQUFNTjtRQUM3QixJQUFJO1lBQ0FNLGVBQWVDLEtBQUssQ0FBQyxNQUFNSjtRQUMvQixFQUNBLE9BQU9LLE9BQU87WUFDVixJQUFJLENBQUN0QixNQUFNLENBQUN1QixnQkFBZ0IsQ0FBQzVCLFlBQVk2QixNQUFNLENBQUNDLGVBQWUsRUFBRSxDQUFDLDZDQUE2QyxFQUFFSCxNQUFNSSxPQUFPLENBQUMsQ0FBQztZQUNoSSxPQUFPQyxRQUFRQyxNQUFNLENBQUM7UUFDMUI7UUFDQSxJQUFJUixlQUFlUyxHQUFHLENBQUMsaUJBQWlCdEIsTUFBTSxHQUFHLEdBQUc7WUFDaEQsSUFBSSxDQUFDUCxNQUFNLENBQUN1QixnQkFBZ0IsQ0FBQzVCLFlBQVk2QixNQUFNLENBQUNNLFFBQVEsRUFBRTtZQUMxRCxPQUFPSCxRQUFRQyxNQUFNLENBQUM7UUFDMUI7UUFDQSxPQUFPUjtJQUNYO0FBQ0o7QUFDQS9CLDZCQUE2QixHQUFHRztBQUNoQyxNQUFNRDtJQUNGTyxZQUFZQyxPQUFPLENBQUU7UUFDakIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ25CO0lBQ0FnQyxhQUFhQyxVQUFVLEVBQUU7UUFDckIsT0FBTyxJQUFJeEMsc0JBQXNCLElBQUksQ0FBQ08sT0FBTyxFQUFFaUM7SUFDbkQ7QUFDSjtBQUNBM0Msb0NBQW9DLEdBQUdFLDhCQUN2QyxtREFBbUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc2htaXR0LWd1cHRhLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NhbGwtY3JlZGVudGlhbHMtZmlsdGVyLmpzPzc0MWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2FsbENyZWRlbnRpYWxzRmlsdGVyRmFjdG9yeSA9IGV4cG9ydHMuQ2FsbENyZWRlbnRpYWxzRmlsdGVyID0gdm9pZCAwO1xuY29uc3QgZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9maWx0ZXJcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jbGFzcyBDYWxsQ3JlZGVudGlhbHNGaWx0ZXIgZXh0ZW5kcyBmaWx0ZXJfMS5CYXNlRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBzdHJlYW0pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICBjb25zdCBzcGxpdFBhdGggPSBzdHJlYW0uZ2V0TWV0aG9kKCkuc3BsaXQoJy8nKTtcbiAgICAgICAgbGV0IHNlcnZpY2VOYW1lID0gJyc7XG4gICAgICAgIC8qIFRoZSBzdGFuZGFyZCBwYXRoIGZvcm1hdCBpcyBcIi97c2VydmljZU5hbWV9L3ttZXRob2ROYW1lfVwiLCBzbyBpZiB3ZSBzcGxpdFxuICAgICAgICAgKiBieSAnLycsIHRoZSBmaXJzdCBpdGVtIHNob3VsZCBiZSBlbXB0eSBhbmQgdGhlIHNlY29uZCBzaG91bGQgYmUgdGhlXG4gICAgICAgICAqIHNlcnZpY2UgbmFtZSAqL1xuICAgICAgICBpZiAoc3BsaXRQYXRoLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBzZXJ2aWNlTmFtZSA9IHNwbGl0UGF0aFsxXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3N0bmFtZSA9IChfYiA9IChfYSA9IHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KHN0cmVhbS5nZXRIb3N0KCkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaG9zdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2xvY2FsaG9zdCc7XG4gICAgICAgIC8qIEN1cnJlbnRseSwgY2FsbCBjcmVkZW50aWFscyBhcmUgb25seSBhbGxvd2VkIG9uIEhUVFBTIGNvbm5lY3Rpb25zLCBzbyB3ZVxuICAgICAgICAgKiBjYW4gYXNzdW1lIHRoYXQgdGhlIHNjaGVtZSBpcyBcImh0dHBzXCIgKi9cbiAgICAgICAgdGhpcy5zZXJ2aWNlVXJsID0gYGh0dHBzOi8vJHtob3N0bmFtZX0vJHtzZXJ2aWNlTmFtZX1gO1xuICAgIH1cbiAgICBhc3luYyBzZW5kTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgY3JlZGVudGlhbHMgPSB0aGlzLnN0cmVhbS5nZXRDcmVkZW50aWFscygpO1xuICAgICAgICBjb25zdCBjcmVkc01ldGFkYXRhID0gY3JlZGVudGlhbHMuZ2VuZXJhdGVNZXRhZGF0YSh7XG4gICAgICAgICAgICBzZXJ2aWNlX3VybDogdGhpcy5zZXJ2aWNlVXJsLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0TWV0YWRhdGEgPSBhd2FpdCBtZXRhZGF0YTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdE1ldGFkYXRhLm1lcmdlKGF3YWl0IGNyZWRzTWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0uY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuVU5BVVRIRU5USUNBVEVELCBgRmFpbGVkIHRvIHJldHJpZXZlIGF1dGggbWV0YWRhdGEgd2l0aCBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdGYWlsZWQgdG8gcmV0cmlldmUgYXV0aCBtZXRhZGF0YScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHRNZXRhZGF0YS5nZXQoJ2F1dGhvcml6YXRpb24nKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCwgJ1wiYXV0aG9yaXphdGlvblwiIG1ldGFkYXRhIGNhbm5vdCBoYXZlIG11bHRpcGxlIHZhbHVlcycpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdcImF1dGhvcml6YXRpb25cIiBtZXRhZGF0YSBjYW5ub3QgaGF2ZSBtdWx0aXBsZSB2YWx1ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0TWV0YWRhdGE7XG4gICAgfVxufVxuZXhwb3J0cy5DYWxsQ3JlZGVudGlhbHNGaWx0ZXIgPSBDYWxsQ3JlZGVudGlhbHNGaWx0ZXI7XG5jbGFzcyBDYWxsQ3JlZGVudGlhbHNGaWx0ZXJGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgfVxuICAgIGNyZWF0ZUZpbHRlcihjYWxsU3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2FsbENyZWRlbnRpYWxzRmlsdGVyKHRoaXMuY2hhbm5lbCwgY2FsbFN0cmVhbSk7XG4gICAgfVxufVxuZXhwb3J0cy5DYWxsQ3JlZGVudGlhbHNGaWx0ZXJGYWN0b3J5ID0gQ2FsbENyZWRlbnRpYWxzRmlsdGVyRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGwtY3JlZGVudGlhbHMtZmlsdGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkNhbGxDcmVkZW50aWFsc0ZpbHRlckZhY3RvcnkiLCJDYWxsQ3JlZGVudGlhbHNGaWx0ZXIiLCJmaWx0ZXJfMSIsInJlcXVpcmUiLCJjb25zdGFudHNfMSIsInVyaV9wYXJzZXJfMSIsIkJhc2VGaWx0ZXIiLCJjb25zdHJ1Y3RvciIsImNoYW5uZWwiLCJzdHJlYW0iLCJfYSIsIl9iIiwic3BsaXRQYXRoIiwiZ2V0TWV0aG9kIiwic3BsaXQiLCJzZXJ2aWNlTmFtZSIsImxlbmd0aCIsImhvc3RuYW1lIiwic3BsaXRIb3N0UG9ydCIsImdldEhvc3QiLCJob3N0Iiwic2VydmljZVVybCIsInNlbmRNZXRhZGF0YSIsIm1ldGFkYXRhIiwiY3JlZGVudGlhbHMiLCJnZXRDcmVkZW50aWFscyIsImNyZWRzTWV0YWRhdGEiLCJnZW5lcmF0ZU1ldGFkYXRhIiwic2VydmljZV91cmwiLCJyZXN1bHRNZXRhZGF0YSIsIm1lcmdlIiwiZXJyb3IiLCJjYW5jZWxXaXRoU3RhdHVzIiwiU3RhdHVzIiwiVU5BVVRIRU5USUNBVEVEIiwibWVzc2FnZSIsIlByb21pc2UiLCJyZWplY3QiLCJnZXQiLCJJTlRFUk5BTCIsImNyZWF0ZUZpbHRlciIsImNhbGxTdHJlYW0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials-filter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js":
/*!******************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-credentials.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CallCredentials = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nfunction isCurrentOauth2Client(client) {\n    return \"getRequestHeaders\" in client && typeof client.getRequestHeaders === \"function\";\n}\n/**\n * A class that represents a generic method of adding authentication-related\n * metadata on a per-request basis.\n */ class CallCredentials {\n    /**\n     * Creates a new CallCredentials object from a given function that generates\n     * Metadata objects.\n     * @param metadataGenerator A function that accepts a set of options, and\n     * generates a Metadata object based on these options, which is passed back\n     * to the caller via a supplied (err, metadata) callback.\n     */ static createFromMetadataGenerator(metadataGenerator) {\n        return new SingleCallCredentials(metadataGenerator);\n    }\n    /**\n     * Create a gRPC credential from a Google credential object.\n     * @param googleCredentials The authentication client to use.\n     * @return The resulting CallCredentials object.\n     */ static createFromGoogleCredential(googleCredentials) {\n        return CallCredentials.createFromMetadataGenerator((options, callback)=>{\n            let getHeaders;\n            if (isCurrentOauth2Client(googleCredentials)) {\n                getHeaders = googleCredentials.getRequestHeaders(options.service_url);\n            } else {\n                getHeaders = new Promise((resolve, reject)=>{\n                    googleCredentials.getRequestMetadata(options.service_url, (err, headers)=>{\n                        if (err) {\n                            reject(err);\n                            return;\n                        }\n                        resolve(headers);\n                    });\n                });\n            }\n            getHeaders.then((headers)=>{\n                const metadata = new metadata_1.Metadata();\n                for (const key of Object.keys(headers)){\n                    metadata.add(key, headers[key]);\n                }\n                callback(null, metadata);\n            }, (err)=>{\n                callback(err);\n            });\n        });\n    }\n    static createEmpty() {\n        return new EmptyCallCredentials();\n    }\n}\nexports.CallCredentials = CallCredentials;\nclass ComposedCallCredentials extends CallCredentials {\n    constructor(creds){\n        super();\n        this.creds = creds;\n    }\n    async generateMetadata(options) {\n        const base = new metadata_1.Metadata();\n        const generated = await Promise.all(this.creds.map((cred)=>cred.generateMetadata(options)));\n        for (const gen of generated){\n            base.merge(gen);\n        }\n        return base;\n    }\n    compose(other) {\n        return new ComposedCallCredentials(this.creds.concat([\n            other\n        ]));\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ComposedCallCredentials) {\n            return this.creds.every((value, index)=>value._equals(other.creds[index]));\n        } else {\n            return false;\n        }\n    }\n}\nclass SingleCallCredentials extends CallCredentials {\n    constructor(metadataGenerator){\n        super();\n        this.metadataGenerator = metadataGenerator;\n    }\n    generateMetadata(options) {\n        return new Promise((resolve, reject)=>{\n            this.metadataGenerator(options, (err, metadata)=>{\n                if (metadata !== undefined) {\n                    resolve(metadata);\n                } else {\n                    reject(err);\n                }\n            });\n        });\n    }\n    compose(other) {\n        return new ComposedCallCredentials([\n            this,\n            other\n        ]);\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof SingleCallCredentials) {\n            return this.metadataGenerator === other.metadataGenerator;\n        } else {\n            return false;\n        }\n    }\n}\nclass EmptyCallCredentials extends CallCredentials {\n    generateMetadata(options) {\n        return Promise.resolve(new metadata_1.Metadata());\n    }\n    compose(other) {\n        return other;\n    }\n    _equals(other) {\n        return other instanceof EmptyCallCredentials;\n    }\n} //# sourceMappingURL=call-credentials.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1jcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUJBQXVCLEdBQUcsS0FBSztBQUMvQixNQUFNRyxhQUFhQyxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxTQUFTQyxzQkFBc0JDLE1BQU07SUFDakMsT0FBUSx1QkFBdUJBLFVBQzNCLE9BQU9BLE9BQU9DLGlCQUFpQixLQUFLO0FBQzVDO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTUw7SUFDRjs7Ozs7O0tBTUMsR0FDRCxPQUFPTSw0QkFBNEJDLGlCQUFpQixFQUFFO1FBQ2xELE9BQU8sSUFBSUMsc0JBQXNCRDtJQUNyQztJQUNBOzs7O0tBSUMsR0FDRCxPQUFPRSwyQkFBMkJDLGlCQUFpQixFQUFFO1FBQ2pELE9BQU9WLGdCQUFnQk0sMkJBQTJCLENBQUMsQ0FBQ0ssU0FBU0M7WUFDekQsSUFBSUM7WUFDSixJQUFJVixzQkFBc0JPLG9CQUFvQjtnQkFDMUNHLGFBQWFILGtCQUFrQkwsaUJBQWlCLENBQUNNLFFBQVFHLFdBQVc7WUFDeEUsT0FDSztnQkFDREQsYUFBYSxJQUFJRSxRQUFRLENBQUNDLFNBQVNDO29CQUMvQlAsa0JBQWtCUSxrQkFBa0IsQ0FBQ1AsUUFBUUcsV0FBVyxFQUFFLENBQUNLLEtBQUtDO3dCQUM1RCxJQUFJRCxLQUFLOzRCQUNMRixPQUFPRTs0QkFDUDt3QkFDSjt3QkFDQUgsUUFBUUk7b0JBQ1o7Z0JBQ0o7WUFDSjtZQUNBUCxXQUFXUSxJQUFJLENBQUMsQ0FBQ0Q7Z0JBQ2IsTUFBTUUsV0FBVyxJQUFJckIsV0FBV3NCLFFBQVE7Z0JBQ3hDLEtBQUssTUFBTUMsT0FBTzVCLE9BQU82QixJQUFJLENBQUNMLFNBQVU7b0JBQ3BDRSxTQUFTSSxHQUFHLENBQUNGLEtBQUtKLE9BQU8sQ0FBQ0ksSUFBSTtnQkFDbEM7Z0JBQ0FaLFNBQVMsTUFBTVU7WUFDbkIsR0FBRyxDQUFDSDtnQkFDQVAsU0FBU087WUFDYjtRQUNKO0lBQ0o7SUFDQSxPQUFPUSxjQUFjO1FBQ2pCLE9BQU8sSUFBSUM7SUFDZjtBQUNKO0FBQ0E5Qix1QkFBdUIsR0FBR0U7QUFDMUIsTUFBTTZCLGdDQUFnQzdCO0lBQ2xDOEIsWUFBWUMsS0FBSyxDQUFFO1FBQ2YsS0FBSztRQUNMLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtJQUNqQjtJQUNBLE1BQU1DLGlCQUFpQnJCLE9BQU8sRUFBRTtRQUM1QixNQUFNc0IsT0FBTyxJQUFJaEMsV0FBV3NCLFFBQVE7UUFDcEMsTUFBTVcsWUFBWSxNQUFNbkIsUUFBUW9CLEdBQUcsQ0FBQyxJQUFJLENBQUNKLEtBQUssQ0FBQ0ssR0FBRyxDQUFDLENBQUNDLE9BQVNBLEtBQUtMLGdCQUFnQixDQUFDckI7UUFDbkYsS0FBSyxNQUFNMkIsT0FBT0osVUFBVztZQUN6QkQsS0FBS00sS0FBSyxDQUFDRDtRQUNmO1FBQ0EsT0FBT0w7SUFDWDtJQUNBTyxRQUFRQyxLQUFLLEVBQUU7UUFDWCxPQUFPLElBQUlaLHdCQUF3QixJQUFJLENBQUNFLEtBQUssQ0FBQ1csTUFBTSxDQUFDO1lBQUNEO1NBQU07SUFDaEU7SUFDQUUsUUFBUUYsS0FBSyxFQUFFO1FBQ1gsSUFBSSxJQUFJLEtBQUtBLE9BQU87WUFDaEIsT0FBTztRQUNYO1FBQ0EsSUFBSUEsaUJBQWlCWix5QkFBeUI7WUFDMUMsT0FBTyxJQUFJLENBQUNFLEtBQUssQ0FBQ2EsS0FBSyxDQUFDLENBQUM3QyxPQUFPOEMsUUFBVTlDLE1BQU00QyxPQUFPLENBQUNGLE1BQU1WLEtBQUssQ0FBQ2MsTUFBTTtRQUM5RSxPQUNLO1lBQ0QsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBLE1BQU1yQyw4QkFBOEJSO0lBQ2hDOEIsWUFBWXZCLGlCQUFpQixDQUFFO1FBQzNCLEtBQUs7UUFDTCxJQUFJLENBQUNBLGlCQUFpQixHQUFHQTtJQUM3QjtJQUNBeUIsaUJBQWlCckIsT0FBTyxFQUFFO1FBQ3RCLE9BQU8sSUFBSUksUUFBUSxDQUFDQyxTQUFTQztZQUN6QixJQUFJLENBQUNWLGlCQUFpQixDQUFDSSxTQUFTLENBQUNRLEtBQUtHO2dCQUNsQyxJQUFJQSxhQUFhd0IsV0FBVztvQkFDeEI5QixRQUFRTTtnQkFDWixPQUNLO29CQUNETCxPQUFPRTtnQkFDWDtZQUNKO1FBQ0o7SUFDSjtJQUNBcUIsUUFBUUMsS0FBSyxFQUFFO1FBQ1gsT0FBTyxJQUFJWix3QkFBd0I7WUFBQyxJQUFJO1lBQUVZO1NBQU07SUFDcEQ7SUFDQUUsUUFBUUYsS0FBSyxFQUFFO1FBQ1gsSUFBSSxJQUFJLEtBQUtBLE9BQU87WUFDaEIsT0FBTztRQUNYO1FBQ0EsSUFBSUEsaUJBQWlCakMsdUJBQXVCO1lBQ3hDLE9BQU8sSUFBSSxDQUFDRCxpQkFBaUIsS0FBS2tDLE1BQU1sQyxpQkFBaUI7UUFDN0QsT0FDSztZQUNELE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQSxNQUFNcUIsNkJBQTZCNUI7SUFDL0JnQyxpQkFBaUJyQixPQUFPLEVBQUU7UUFDdEIsT0FBT0ksUUFBUUMsT0FBTyxDQUFDLElBQUlmLFdBQVdzQixRQUFRO0lBQ2xEO0lBQ0FpQixRQUFRQyxLQUFLLEVBQUU7UUFDWCxPQUFPQTtJQUNYO0lBQ0FFLFFBQVFGLEtBQUssRUFBRTtRQUNYLE9BQU9BLGlCQUFpQmI7SUFDNUI7QUFDSixFQUNBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2FzaG1pdHQtZ3VwdGEvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1jcmVkZW50aWFscy5qcz8yOGIyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNhbGxDcmVkZW50aWFscyA9IHZvaWQgMDtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmZ1bmN0aW9uIGlzQ3VycmVudE9hdXRoMkNsaWVudChjbGllbnQpIHtcbiAgICByZXR1cm4gKCdnZXRSZXF1ZXN0SGVhZGVycycgaW4gY2xpZW50ICYmXG4gICAgICAgIHR5cGVvZiBjbGllbnQuZ2V0UmVxdWVzdEhlYWRlcnMgPT09ICdmdW5jdGlvbicpO1xufVxuLyoqXG4gKiBBIGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhIGdlbmVyaWMgbWV0aG9kIG9mIGFkZGluZyBhdXRoZW50aWNhdGlvbi1yZWxhdGVkXG4gKiBtZXRhZGF0YSBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzLlxuICovXG5jbGFzcyBDYWxsQ3JlZGVudGlhbHMge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ2FsbENyZWRlbnRpYWxzIG9iamVjdCBmcm9tIGEgZ2l2ZW4gZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXNcbiAgICAgKiBNZXRhZGF0YSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSBtZXRhZGF0YUdlbmVyYXRvciBBIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhIHNldCBvZiBvcHRpb25zLCBhbmRcbiAgICAgKiBnZW5lcmF0ZXMgYSBNZXRhZGF0YSBvYmplY3QgYmFzZWQgb24gdGhlc2Ugb3B0aW9ucywgd2hpY2ggaXMgcGFzc2VkIGJhY2tcbiAgICAgKiB0byB0aGUgY2FsbGVyIHZpYSBhIHN1cHBsaWVkIChlcnIsIG1ldGFkYXRhKSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRnJvbU1ldGFkYXRhR2VuZXJhdG9yKG1ldGFkYXRhR2VuZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2luZ2xlQ2FsbENyZWRlbnRpYWxzKG1ldGFkYXRhR2VuZXJhdG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZ1JQQyBjcmVkZW50aWFsIGZyb20gYSBHb29nbGUgY3JlZGVudGlhbCBvYmplY3QuXG4gICAgICogQHBhcmFtIGdvb2dsZUNyZWRlbnRpYWxzIFRoZSBhdXRoZW50aWNhdGlvbiBjbGllbnQgdG8gdXNlLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3VsdGluZyBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGcm9tR29vZ2xlQ3JlZGVudGlhbChnb29nbGVDcmVkZW50aWFscykge1xuICAgICAgICByZXR1cm4gQ2FsbENyZWRlbnRpYWxzLmNyZWF0ZUZyb21NZXRhZGF0YUdlbmVyYXRvcigob3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGxldCBnZXRIZWFkZXJzO1xuICAgICAgICAgICAgaWYgKGlzQ3VycmVudE9hdXRoMkNsaWVudChnb29nbGVDcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgICAgICBnZXRIZWFkZXJzID0gZ29vZ2xlQ3JlZGVudGlhbHMuZ2V0UmVxdWVzdEhlYWRlcnMob3B0aW9ucy5zZXJ2aWNlX3VybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZXRIZWFkZXJzID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnb29nbGVDcmVkZW50aWFscy5nZXRSZXF1ZXN0TWV0YWRhdGEob3B0aW9ucy5zZXJ2aWNlX3VybCwgKGVyciwgaGVhZGVycykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2V0SGVhZGVycy50aGVuKChoZWFkZXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhLmFkZChrZXksIGhlYWRlcnNba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW1wdHlDYWxsQ3JlZGVudGlhbHMoKTtcbiAgICB9XG59XG5leHBvcnRzLkNhbGxDcmVkZW50aWFscyA9IENhbGxDcmVkZW50aWFscztcbmNsYXNzIENvbXBvc2VkQ2FsbENyZWRlbnRpYWxzIGV4dGVuZHMgQ2FsbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihjcmVkcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNyZWRzID0gY3JlZHM7XG4gICAgfVxuICAgIGFzeW5jIGdlbmVyYXRlTWV0YWRhdGEob3B0aW9ucykge1xuICAgICAgICBjb25zdCBiYXNlID0gbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKTtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVkID0gYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5jcmVkcy5tYXAoKGNyZWQpID0+IGNyZWQuZ2VuZXJhdGVNZXRhZGF0YShvcHRpb25zKSkpO1xuICAgICAgICBmb3IgKGNvbnN0IGdlbiBvZiBnZW5lcmF0ZWQpIHtcbiAgICAgICAgICAgIGJhc2UubWVyZ2UoZ2VuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG4gICAgY29tcG9zZShvdGhlcikge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2VkQ2FsbENyZWRlbnRpYWxzKHRoaXMuY3JlZHMuY29uY2F0KFtvdGhlcl0pKTtcbiAgICB9XG4gICAgX2VxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENvbXBvc2VkQ2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVkcy5ldmVyeSgodmFsdWUsIGluZGV4KSA9PiB2YWx1ZS5fZXF1YWxzKG90aGVyLmNyZWRzW2luZGV4XSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU2luZ2xlQ2FsbENyZWRlbnRpYWxzIGV4dGVuZHMgQ2FsbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRhZGF0YUdlbmVyYXRvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhR2VuZXJhdG9yID0gbWV0YWRhdGFHZW5lcmF0b3I7XG4gICAgfVxuICAgIGdlbmVyYXRlTWV0YWRhdGEob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YUdlbmVyYXRvcihvcHRpb25zLCAoZXJyLCBtZXRhZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb21wb3NlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9zZWRDYWxsQ3JlZGVudGlhbHMoW3RoaXMsIG90aGVyXSk7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBTaW5nbGVDYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ldGFkYXRhR2VuZXJhdG9yID09PSBvdGhlci5tZXRhZGF0YUdlbmVyYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIEVtcHR5Q2FsbENyZWRlbnRpYWxzIGV4dGVuZHMgQ2FsbENyZWRlbnRpYWxzIHtcbiAgICBnZW5lcmF0ZU1ldGFkYXRhKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpKTtcbiAgICB9XG4gICAgY29tcG9zZShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgRW1wdHlDYWxsQ3JlZGVudGlhbHM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FsbC1jcmVkZW50aWFscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDYWxsQ3JlZGVudGlhbHMiLCJtZXRhZGF0YV8xIiwicmVxdWlyZSIsImlzQ3VycmVudE9hdXRoMkNsaWVudCIsImNsaWVudCIsImdldFJlcXVlc3RIZWFkZXJzIiwiY3JlYXRlRnJvbU1ldGFkYXRhR2VuZXJhdG9yIiwibWV0YWRhdGFHZW5lcmF0b3IiLCJTaW5nbGVDYWxsQ3JlZGVudGlhbHMiLCJjcmVhdGVGcm9tR29vZ2xlQ3JlZGVudGlhbCIsImdvb2dsZUNyZWRlbnRpYWxzIiwib3B0aW9ucyIsImNhbGxiYWNrIiwiZ2V0SGVhZGVycyIsInNlcnZpY2VfdXJsIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJnZXRSZXF1ZXN0TWV0YWRhdGEiLCJlcnIiLCJoZWFkZXJzIiwidGhlbiIsIm1ldGFkYXRhIiwiTWV0YWRhdGEiLCJrZXkiLCJrZXlzIiwiYWRkIiwiY3JlYXRlRW1wdHkiLCJFbXB0eUNhbGxDcmVkZW50aWFscyIsIkNvbXBvc2VkQ2FsbENyZWRlbnRpYWxzIiwiY29uc3RydWN0b3IiLCJjcmVkcyIsImdlbmVyYXRlTWV0YWRhdGEiLCJiYXNlIiwiZ2VuZXJhdGVkIiwiYWxsIiwibWFwIiwiY3JlZCIsImdlbiIsIm1lcmdlIiwiY29tcG9zZSIsIm90aGVyIiwiY29uY2F0IiwiX2VxdWFscyIsImV2ZXJ5IiwiaW5kZXgiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/call-stream.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-stream.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Http2CallStream = exports.InterceptingListenerImpl = exports.isInterceptingListener = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = \"call_stream\";\nconst { HTTP2_HEADER_STATUS, HTTP2_HEADER_CONTENT_TYPE, NGHTTP2_CANCEL } = http2.constants;\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */ function getSystemErrorName(errno) {\n    for (const [name, num] of Object.entries(os.constants.errno)){\n        if (num === errno) {\n            return name;\n        }\n    }\n    return \"Unknown system error \" + errno;\n}\nfunction getMinDeadline(deadlineList) {\n    let minValue = Infinity;\n    for (const deadline of deadlineList){\n        const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;\n        if (deadlineMsecs < minValue) {\n            minValue = deadlineMsecs;\n        }\n    }\n    return minValue;\n}\nfunction isInterceptingListener(listener) {\n    return listener.onReceiveMetadata !== undefined && listener.onReceiveMetadata.length === 1;\n}\nexports.isInterceptingListener = isInterceptingListener;\nclass InterceptingListenerImpl {\n    constructor(listener, nextListener){\n        this.listener = listener;\n        this.nextListener = nextListener;\n        this.processingMetadata = false;\n        this.hasPendingMessage = false;\n        this.processingMessage = false;\n        this.pendingStatus = null;\n    }\n    processPendingMessage() {\n        if (this.hasPendingMessage) {\n            this.nextListener.onReceiveMessage(this.pendingMessage);\n            this.pendingMessage = null;\n            this.hasPendingMessage = false;\n        }\n    }\n    processPendingStatus() {\n        if (this.pendingStatus) {\n            this.nextListener.onReceiveStatus(this.pendingStatus);\n        }\n    }\n    onReceiveMetadata(metadata) {\n        this.processingMetadata = true;\n        this.listener.onReceiveMetadata(metadata, (metadata)=>{\n            this.processingMetadata = false;\n            this.nextListener.onReceiveMetadata(metadata);\n            this.processPendingMessage();\n            this.processPendingStatus();\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onReceiveMessage(message) {\n        /* If this listener processes messages asynchronously, the last message may\n         * be reordered with respect to the status */ this.processingMessage = true;\n        this.listener.onReceiveMessage(message, (msg)=>{\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessage = msg;\n                this.hasPendingMessage = true;\n            } else {\n                this.nextListener.onReceiveMessage(msg);\n                this.processPendingStatus();\n            }\n        });\n    }\n    onReceiveStatus(status) {\n        this.listener.onReceiveStatus(status, (processedStatus)=>{\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingStatus = processedStatus;\n            } else {\n                this.nextListener.onReceiveStatus(processedStatus);\n            }\n        });\n    }\n}\nexports.InterceptingListenerImpl = InterceptingListenerImpl;\nclass Http2CallStream {\n    constructor(methodName, channel, options, filterStackFactory, channelCallCredentials, callNumber){\n        this.methodName = methodName;\n        this.channel = channel;\n        this.options = options;\n        this.channelCallCredentials = channelCallCredentials;\n        this.callNumber = callNumber;\n        this.http2Stream = null;\n        this.pendingRead = false;\n        this.isWriteFilterPending = false;\n        this.pendingWrite = null;\n        this.pendingWriteCallback = null;\n        this.writesClosed = false;\n        this.decoder = new stream_decoder_1.StreamDecoder();\n        this.isReadFilterPending = false;\n        this.canPush = false;\n        /**\n         * Indicates that an 'end' event has come from the http2 stream, so there\n         * will be no more data events.\n         */ this.readsClosed = false;\n        this.statusOutput = false;\n        this.unpushedReadMessages = [];\n        this.unfilteredReadMessages = [];\n        // Status code mapped from :status. To be used if grpc-status is not received\n        this.mappedStatusCode = constants_1.Status.UNKNOWN;\n        // This is populated (non-null) if and only if the call has ended\n        this.finalStatus = null;\n        this.subchannel = null;\n        this.listener = null;\n        this.internalError = null;\n        this.configDeadline = Infinity;\n        this.statusWatchers = [];\n        this.streamEndWatchers = [];\n        this.callStatsTracker = null;\n        this.filterStack = filterStackFactory.createFilter(this);\n        this.credentials = channelCallCredentials;\n        this.disconnectListener = ()=>{\n            this.endCall({\n                code: constants_1.Status.UNAVAILABLE,\n                details: \"Connection dropped\",\n                metadata: new metadata_1.Metadata()\n            });\n        };\n        if (this.options.parentCall && this.options.flags & constants_1.Propagate.CANCELLATION) {\n            this.options.parentCall.on(\"cancelled\", ()=>{\n                this.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled by parent call\");\n            });\n        }\n    }\n    outputStatus() {\n        var _a;\n        /* Precondition: this.finalStatus !== null */ if (this.listener && !this.statusOutput) {\n            this.statusOutput = true;\n            const filteredStatus = this.filterStack.receiveTrailers(this.finalStatus);\n            this.trace(\"ended with status: code=\" + filteredStatus.code + ' details=\"' + filteredStatus.details + '\"');\n            this.statusWatchers.forEach((watcher)=>watcher(filteredStatus));\n            /* We delay the actual action of bubbling up the status to insulate the\n             * cleanup code in this class from any errors that may be thrown in the\n             * upper layers as a result of bubbling up the status. In particular,\n             * if the status is not OK, the \"error\" event may be emitted\n             * synchronously at the top level, which will result in a thrown error if\n             * the user does not handle that event. */ process.nextTick(()=>{\n                var _a;\n                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);\n            });\n            /* Leave the http2 stream in flowing state to drain incoming messages, to\n             * ensure that the stream closure completes. The call stream already does\n             * not push more messages after the status is output, so the messages go\n             * nowhere either way. */ (_a = this.http2Stream) === null || _a === void 0 ? void 0 : _a.resume();\n            if (this.subchannel) {\n                this.subchannel.callUnref();\n                this.subchannel.removeDisconnectListener(this.disconnectListener);\n            }\n        }\n    }\n    trace(text) {\n        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, \"[\" + this.callNumber + \"] \" + text);\n    }\n    /**\n     * On first call, emits a 'status' event with the given StatusObject.\n     * Subsequent calls are no-ops.\n     * @param status The status of the call.\n     */ endCall(status) {\n        /* If the status is OK and a new status comes in (e.g. from a\n         * deserialization failure), that new status takes priority */ if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\n            this.finalStatus = status;\n            this.maybeOutputStatus();\n        }\n        this.destroyHttp2Stream();\n    }\n    maybeOutputStatus() {\n        if (this.finalStatus !== null) {\n            /* The combination check of readsClosed and that the two message buffer\n             * arrays are empty checks that there all incoming data has been fully\n             * processed */ if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && this.unfilteredReadMessages.length === 0 && !this.isReadFilterPending) {\n                this.outputStatus();\n            }\n        }\n    }\n    push(message) {\n        this.trace(\"pushing to reader message of length \" + (message instanceof Buffer ? message.length : null));\n        this.canPush = false;\n        process.nextTick(()=>{\n            var _a;\n            /* If we have already output the status any later messages should be\n             * ignored, and can cause out-of-order operation errors higher up in the\n             * stack. Checking as late as possible here to avoid any race conditions.\n             */ if (this.statusOutput) {\n                return;\n            }\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMessage(message);\n            this.maybeOutputStatus();\n        });\n    }\n    handleFilterError(error) {\n        this.cancelWithStatus(constants_1.Status.INTERNAL, error.message);\n    }\n    handleFilteredRead(message) {\n        /* If we the call has already ended with an error, we don't want to do\n         * anything with this message. Dropping it on the floor is correct\n         * behavior */ if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n            this.maybeOutputStatus();\n            return;\n        }\n        this.isReadFilterPending = false;\n        if (this.canPush) {\n            this.http2Stream.pause();\n            this.push(message);\n        } else {\n            this.trace(\"unpushedReadMessages.push message of length \" + message.length);\n            this.unpushedReadMessages.push(message);\n        }\n        if (this.unfilteredReadMessages.length > 0) {\n            /* nextMessage is guaranteed not to be undefined because\n               unfilteredReadMessages is non-empty */ const nextMessage = this.unfilteredReadMessages.shift();\n            this.filterReceivedMessage(nextMessage);\n        }\n    }\n    filterReceivedMessage(framedMessage) {\n        /* If we the call has already ended with an error, we don't want to do\n         * anything with this message. Dropping it on the floor is correct\n         * behavior */ if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n            this.maybeOutputStatus();\n            return;\n        }\n        this.trace(\"filterReceivedMessage of length \" + framedMessage.length);\n        this.isReadFilterPending = true;\n        this.filterStack.receiveMessage(Promise.resolve(framedMessage)).then(this.handleFilteredRead.bind(this), this.handleFilterError.bind(this));\n    }\n    tryPush(messageBytes) {\n        if (this.isReadFilterPending) {\n            this.trace(\"unfilteredReadMessages.push message of length \" + (messageBytes && messageBytes.length));\n            this.unfilteredReadMessages.push(messageBytes);\n        } else {\n            this.filterReceivedMessage(messageBytes);\n        }\n    }\n    handleTrailers(headers) {\n        this.streamEndWatchers.forEach((watcher)=>watcher(true));\n        let headersString = \"\";\n        for (const header of Object.keys(headers)){\n            headersString += \"\t\t\" + header + \": \" + headers[header] + \"\\n\";\n        }\n        this.trace(\"Received server trailers:\\n\" + headersString);\n        let metadata;\n        try {\n            metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        } catch (e) {\n            metadata = new metadata_1.Metadata();\n        }\n        const metadataMap = metadata.getMap();\n        let code = this.mappedStatusCode;\n        if (code === constants_1.Status.UNKNOWN && typeof metadataMap[\"grpc-status\"] === \"string\") {\n            const receivedStatus = Number(metadataMap[\"grpc-status\"]);\n            if (receivedStatus in constants_1.Status) {\n                code = receivedStatus;\n                this.trace(\"received status code \" + receivedStatus + \" from server\");\n            }\n            metadata.remove(\"grpc-status\");\n        }\n        let details = \"\";\n        if (typeof metadataMap[\"grpc-message\"] === \"string\") {\n            try {\n                details = decodeURI(metadataMap[\"grpc-message\"]);\n            } catch (e) {\n                details = metadataMap[\"grpc-message\"];\n            }\n            metadata.remove(\"grpc-message\");\n            this.trace('received status details string \"' + details + '\" from server');\n        }\n        const status = {\n            code,\n            details,\n            metadata\n        };\n        // This is a no-op if the call was already ended when handling headers.\n        this.endCall(status);\n    }\n    writeMessageToStream(message, callback) {\n        var _a;\n        (_a = this.callStatsTracker) === null || _a === void 0 ? void 0 : _a.addMessageSent();\n        this.http2Stream.write(message, callback);\n    }\n    attachHttp2Stream(stream, subchannel, extraFilters, callStatsTracker) {\n        this.filterStack.push(extraFilters);\n        if (this.finalStatus !== null) {\n            stream.close(NGHTTP2_CANCEL);\n        } else {\n            this.trace(\"attachHttp2Stream from subchannel \" + subchannel.getAddress());\n            this.http2Stream = stream;\n            this.subchannel = subchannel;\n            this.callStatsTracker = callStatsTracker;\n            subchannel.addDisconnectListener(this.disconnectListener);\n            subchannel.callRef();\n            stream.on(\"response\", (headers, flags)=>{\n                var _a;\n                let headersString = \"\";\n                for (const header of Object.keys(headers)){\n                    headersString += \"\t\t\" + header + \": \" + headers[header] + \"\\n\";\n                }\n                this.trace(\"Received server headers:\\n\" + headersString);\n                switch(headers[\":status\"]){\n                    // TODO(murgatroid99): handle 100 and 101\n                    case 400:\n                        this.mappedStatusCode = constants_1.Status.INTERNAL;\n                        break;\n                    case 401:\n                        this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n                        break;\n                    case 403:\n                        this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n                        break;\n                    case 404:\n                        this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n                        break;\n                    case 429:\n                    case 502:\n                    case 503:\n                    case 504:\n                        this.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n                        break;\n                    default:\n                        this.mappedStatusCode = constants_1.Status.UNKNOWN;\n                }\n                if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n                    this.handleTrailers(headers);\n                } else {\n                    let metadata;\n                    try {\n                        metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n                    } catch (error) {\n                        this.endCall({\n                            code: constants_1.Status.UNKNOWN,\n                            details: error.message,\n                            metadata: new metadata_1.Metadata()\n                        });\n                        return;\n                    }\n                    try {\n                        const finalMetadata = this.filterStack.receiveMetadata(metadata);\n                        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMetadata(finalMetadata);\n                    } catch (error) {\n                        this.endCall({\n                            code: constants_1.Status.UNKNOWN,\n                            details: error.message,\n                            metadata: new metadata_1.Metadata()\n                        });\n                    }\n                }\n            });\n            stream.on(\"trailers\", (headers)=>{\n                this.handleTrailers(headers);\n            });\n            stream.on(\"data\", (data)=>{\n                /* If the status has already been output, allow the http2 stream to\n                 * drain without processing the data. */ if (this.statusOutput) {\n                    return;\n                }\n                this.trace(\"receive HTTP/2 data frame of length \" + data.length);\n                const messages = this.decoder.write(data);\n                for (const message of messages){\n                    this.trace(\"parsed message of length \" + message.length);\n                    this.callStatsTracker.addMessageReceived();\n                    this.tryPush(message);\n                }\n            });\n            stream.on(\"end\", ()=>{\n                this.readsClosed = true;\n                this.maybeOutputStatus();\n            });\n            stream.on(\"close\", ()=>{\n                /* Use process.next tick to ensure that this code happens after any\n                 * \"error\" event that may be emitted at about the same time, so that\n                 * we can bubble up the error message from that event. */ process.nextTick(()=>{\n                    var _a;\n                    this.trace(\"HTTP/2 stream closed with code \" + stream.rstCode);\n                    /* If we have a final status with an OK status code, that means that\n                     * we have received all of the messages and we have processed the\n                     * trailers and the call completed successfully, so it doesn't matter\n                     * how the stream ends after that */ if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                        return;\n                    }\n                    let code;\n                    let details = \"\";\n                    switch(stream.rstCode){\n                        case http2.constants.NGHTTP2_NO_ERROR:\n                            /* If we get a NO_ERROR code and we already have a status, the\n                             * stream completed properly and we just haven't fully processed\n                             * it yet */ if (this.finalStatus !== null) {\n                                return;\n                            }\n                            code = constants_1.Status.INTERNAL;\n                            details = `Received RST_STREAM with code ${stream.rstCode}`;\n                            break;\n                        case http2.constants.NGHTTP2_REFUSED_STREAM:\n                            code = constants_1.Status.UNAVAILABLE;\n                            details = \"Stream refused by server\";\n                            break;\n                        case http2.constants.NGHTTP2_CANCEL:\n                            code = constants_1.Status.CANCELLED;\n                            details = \"Call cancelled\";\n                            break;\n                        case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n                            code = constants_1.Status.RESOURCE_EXHAUSTED;\n                            details = \"Bandwidth exhausted or memory limit exceeded\";\n                            break;\n                        case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n                            code = constants_1.Status.PERMISSION_DENIED;\n                            details = \"Protocol not secure enough\";\n                            break;\n                        case http2.constants.NGHTTP2_INTERNAL_ERROR:\n                            code = constants_1.Status.INTERNAL;\n                            if (this.internalError === null) {\n                                /* This error code was previously handled in the default case, and\n                                 * there are several instances of it online, so I wanted to\n                                 * preserve the original error message so that people find existing\n                                 * information in searches, but also include the more recognizable\n                                 * \"Internal server error\" message. */ details = `Received RST_STREAM with code ${stream.rstCode} (Internal server error)`;\n                            } else {\n                                if (this.internalError.code === \"ECONNRESET\" || this.internalError.code === \"ETIMEDOUT\") {\n                                    code = constants_1.Status.UNAVAILABLE;\n                                    details = this.internalError.message;\n                                } else {\n                                    /* The \"Received RST_STREAM with code ...\" error is preserved\n                                     * here for continuity with errors reported online, but the\n                                     * error message at the end will probably be more relevant in\n                                     * most cases. */ details = `Received RST_STREAM with code ${stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n                                }\n                            }\n                            break;\n                        default:\n                            code = constants_1.Status.INTERNAL;\n                            details = `Received RST_STREAM with code ${stream.rstCode}`;\n                    }\n                    // This is a no-op if trailers were received at all.\n                    // This is OK, because status codes emitted here correspond to more\n                    // catastrophic issues that prevent us from receiving trailers in the\n                    // first place.\n                    this.endCall({\n                        code,\n                        details,\n                        metadata: new metadata_1.Metadata()\n                    });\n                });\n            });\n            stream.on(\"error\", (err)=>{\n                /* We need an error handler here to stop \"Uncaught Error\" exceptions\n                 * from bubbling up. However, errors here should all correspond to\n                 * \"close\" events, where we will handle the error more granularly */ /* Specifically looking for stream errors that were *not* constructed\n                 * from a RST_STREAM response here:\n                 * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n                 */ if (err.code !== \"ERR_HTTP2_STREAM_ERROR\") {\n                    this.trace(\"Node error event: message=\" + err.message + \" code=\" + err.code + \" errno=\" + getSystemErrorName(err.errno) + \" syscall=\" + err.syscall);\n                    this.internalError = err;\n                }\n                this.streamEndWatchers.forEach((watcher)=>watcher(false));\n            });\n            if (this.pendingWrite) {\n                if (!this.pendingWriteCallback) {\n                    throw new Error(\"Invalid state in write handling code\");\n                }\n                this.trace(\"sending data chunk of length \" + this.pendingWrite.length + \" (deferred)\");\n                try {\n                    this.writeMessageToStream(this.pendingWrite, this.pendingWriteCallback);\n                } catch (error) {\n                    this.endCall({\n                        code: constants_1.Status.UNAVAILABLE,\n                        details: `Write failed with error ${error.message}`,\n                        metadata: new metadata_1.Metadata()\n                    });\n                }\n            }\n            this.maybeCloseWrites();\n        }\n    }\n    start(metadata, listener) {\n        this.trace(\"Sending metadata\");\n        this.listener = listener;\n        this.channel._startCallStream(this, metadata);\n        this.maybeOutputStatus();\n    }\n    destroyHttp2Stream() {\n        var _a;\n        // The http2 stream could already have been destroyed if cancelWithStatus\n        // is called in response to an internal http2 error.\n        if (this.http2Stream !== null && !this.http2Stream.destroyed) {\n            /* If the call has ended with an OK status, communicate that when closing\n             * the stream, partly to avoid a situation in which we detect an error\n             * RST_STREAM as a result after we have the status */ let code;\n            if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                code = http2.constants.NGHTTP2_NO_ERROR;\n            } else {\n                code = http2.constants.NGHTTP2_CANCEL;\n            }\n            this.trace(\"close http2 stream with code \" + code);\n            this.http2Stream.close(code);\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.trace(\"cancelWithStatus code: \" + status + ' details: \"' + details + '\"');\n        this.endCall({\n            code: status,\n            details,\n            metadata: new metadata_1.Metadata()\n        });\n    }\n    getDeadline() {\n        const deadlineList = [\n            this.options.deadline\n        ];\n        if (this.options.parentCall && this.options.flags & constants_1.Propagate.DEADLINE) {\n            deadlineList.push(this.options.parentCall.getDeadline());\n        }\n        if (this.configDeadline) {\n            deadlineList.push(this.configDeadline);\n        }\n        return getMinDeadline(deadlineList);\n    }\n    getCredentials() {\n        return this.credentials;\n    }\n    setCredentials(credentials) {\n        this.credentials = this.channelCallCredentials.compose(credentials);\n    }\n    getStatus() {\n        return this.finalStatus;\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n    }\n    getMethod() {\n        return this.methodName;\n    }\n    getHost() {\n        return this.options.host;\n    }\n    setConfigDeadline(configDeadline) {\n        this.configDeadline = configDeadline;\n    }\n    addStatusWatcher(watcher) {\n        this.statusWatchers.push(watcher);\n    }\n    addStreamEndWatcher(watcher) {\n        this.streamEndWatchers.push(watcher);\n    }\n    addFilters(extraFilters) {\n        this.filterStack.push(extraFilters);\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n    startRead() {\n        /* If the stream has ended with an error, we should not emit any more\n         * messages and we should communicate that the stream has ended */ if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n            this.readsClosed = true;\n            this.maybeOutputStatus();\n            return;\n        }\n        this.canPush = true;\n        if (this.http2Stream === null) {\n            this.pendingRead = true;\n        } else {\n            if (this.unpushedReadMessages.length > 0) {\n                const nextMessage = this.unpushedReadMessages.shift();\n                this.push(nextMessage);\n                return;\n            }\n            /* Only resume reading from the http2Stream if we don't have any pending\n             * messages to emit */ this.http2Stream.resume();\n        }\n    }\n    maybeCloseWrites() {\n        if (this.writesClosed && !this.isWriteFilterPending && this.http2Stream !== null) {\n            this.trace(\"calling end() on HTTP/2 stream\");\n            this.http2Stream.end();\n        }\n    }\n    sendMessageWithContext(context, message) {\n        this.trace(\"write() called with message of length \" + message.length);\n        const writeObj = {\n            message,\n            flags: context.flags\n        };\n        const cb = (error)=>{\n            var _a, _b;\n            let code = constants_1.Status.UNAVAILABLE;\n            if (((_a = error) === null || _a === void 0 ? void 0 : _a.code) === \"ERR_STREAM_WRITE_AFTER_END\") {\n                code = constants_1.Status.INTERNAL;\n            }\n            if (error) {\n                this.cancelWithStatus(code, `Write error: ${error.message}`);\n            }\n            (_b = context.callback) === null || _b === void 0 ? void 0 : _b.call(context);\n        };\n        this.isWriteFilterPending = true;\n        this.filterStack.sendMessage(Promise.resolve(writeObj)).then((message)=>{\n            this.isWriteFilterPending = false;\n            if (this.http2Stream === null) {\n                this.trace(\"deferring writing data chunk of length \" + message.message.length);\n                this.pendingWrite = message.message;\n                this.pendingWriteCallback = cb;\n            } else {\n                this.trace(\"sending data chunk of length \" + message.message.length);\n                try {\n                    this.writeMessageToStream(message.message, cb);\n                } catch (error) {\n                    this.endCall({\n                        code: constants_1.Status.UNAVAILABLE,\n                        details: `Write failed with error ${error.message}`,\n                        metadata: new metadata_1.Metadata()\n                    });\n                }\n                this.maybeCloseWrites();\n            }\n        }, this.handleFilterError.bind(this));\n    }\n    halfClose() {\n        this.trace(\"end() called\");\n        this.writesClosed = true;\n        this.maybeCloseWrites();\n    }\n}\nexports.Http2CallStream = Http2CallStream; //# sourceMappingURL=call-stream.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1zdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHVCQUF1QixHQUFHQSxnQ0FBZ0MsR0FBR0EsOEJBQThCLEdBQUcsS0FBSztBQUNuRyxNQUFNSyxRQUFRQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUM3QixNQUFNQyxLQUFLRCxtQkFBT0EsQ0FBQyxjQUFJO0FBQ3ZCLE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1HLGFBQWFILG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1JLG1CQUFtQkosbUJBQU9BLENBQUMsd0ZBQWtCO0FBQ25ELE1BQU1LLFVBQVVMLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1NLGNBQWNOLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1PLGNBQWM7QUFDcEIsTUFBTSxFQUFFQyxtQkFBbUIsRUFBRUMseUJBQXlCLEVBQUVDLGNBQWMsRUFBRyxHQUFHWCxNQUFNWSxTQUFTO0FBQzNGOzs7OztDQUtDLEdBQ0QsU0FBU0MsbUJBQW1CQyxLQUFLO0lBQzdCLEtBQUssTUFBTSxDQUFDQyxNQUFNQyxJQUFJLElBQUl2QixPQUFPd0IsT0FBTyxDQUFDZixHQUFHVSxTQUFTLENBQUNFLEtBQUssRUFBRztRQUMxRCxJQUFJRSxRQUFRRixPQUFPO1lBQ2YsT0FBT0M7UUFDWDtJQUNKO0lBQ0EsT0FBTywwQkFBMEJEO0FBQ3JDO0FBQ0EsU0FBU0ksZUFBZUMsWUFBWTtJQUNoQyxJQUFJQyxXQUFXQztJQUNmLEtBQUssTUFBTUMsWUFBWUgsYUFBYztRQUNqQyxNQUFNSSxnQkFBZ0JELG9CQUFvQkUsT0FBT0YsU0FBU0csT0FBTyxLQUFLSDtRQUN0RSxJQUFJQyxnQkFBZ0JILFVBQVU7WUFDMUJBLFdBQVdH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b0JBQW9CLEdBQUc7WUFDNUIsSUFBSSxJQUFJLENBQUNGLFdBQVcsS0FBSyxNQUFNO2dCQUMzQixJQUFJLENBQUM0QyxLQUFLLENBQUMsNENBQTRDdEQsUUFBUUEsT0FBTyxDQUFDYixNQUFNO2dCQUM3RSxJQUFJLENBQUMwQixZQUFZLEdBQUdiLFFBQVFBLE9BQU87Z0JBQ25DLElBQUksQ0FBQ2Msb0JBQW9CLEdBQUc2STtZQUNoQyxPQUNLO2dCQUNELElBQUksQ0FBQ3JHLEtBQUssQ0FBQyxrQ0FBa0N0RCxRQUFRQSxPQUFPLENBQUNiLE1BQU07Z0JBQ25FLElBQUk7b0JBQ0EsSUFBSSxDQUFDZ0gsb0JBQW9CLENBQUNuRyxRQUFRQSxPQUFPLEVBQUUySjtnQkFDL0MsRUFDQSxPQUFPcEYsT0FBTztvQkFDVixJQUFJLENBQUNqQyxPQUFPLENBQUM7d0JBQ1RDLE1BQU05RSxZQUFZZ0UsTUFBTSxDQUFDZSxXQUFXO3dCQUNwQ0MsU0FBUyxDQUFDLHdCQUF3QixFQUFFOEIsTUFBTXZFLE9BQU8sQ0FBQyxDQUFDO3dCQUNuREQsVUFBVSxJQUFJckMsV0FBV2dGLFFBQVE7b0JBQ3JDO2dCQUNKO2dCQUNBLElBQUksQ0FBQ3VGLGdCQUFnQjtZQUN6QjtRQUNKLEdBQUcsSUFBSSxDQUFDM0QsaUJBQWlCLENBQUNhLElBQUksQ0FBQyxJQUFJO0lBQ3ZDO0lBQ0EyRSxZQUFZO1FBQ1IsSUFBSSxDQUFDeEcsS0FBSyxDQUFDO1FBQ1gsSUFBSSxDQUFDdkMsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ2tILGdCQUFnQjtJQUN6QjtBQUNKO0FBQ0FoTCx1QkFBdUIsR0FBR0UsaUJBQzFCLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2FzaG1pdHQtZ3VwdGEvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1zdHJlYW0uanM/OWIwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IdHRwMkNhbGxTdHJlYW0gPSBleHBvcnRzLkludGVyY2VwdGluZ0xpc3RlbmVySW1wbCA9IGV4cG9ydHMuaXNJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IHZvaWQgMDtcbmNvbnN0IGh0dHAyID0gcmVxdWlyZShcImh0dHAyXCIpO1xuY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IHN0cmVhbV9kZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9zdHJlYW0tZGVjb2RlclwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzIgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdjYWxsX3N0cmVhbSc7XG5jb25zdCB7IEhUVFAyX0hFQURFUl9TVEFUVVMsIEhUVFAyX0hFQURFUl9DT05URU5UX1RZUEUsIE5HSFRUUDJfQ0FOQ0VMLCB9ID0gaHR0cDIuY29uc3RhbnRzO1xuLyoqXG4gKiBTaG91bGQgZG8gYXBwcm94aW1hdGVseSB0aGUgc2FtZSB0aGluZyBhcyB1dGlsLmdldFN5c3RlbUVycm9yTmFtZSBidXQgdGhlXG4gKiBUeXBlU2NyaXB0IHR5cGVzIGRvbid0IGhhdmUgdGhhdCBmdW5jdGlvbiBmb3Igc29tZSByZWFzb24gc28gSSBqdXN0IG1hZGUgbXlcbiAqIG93bi5cbiAqIEBwYXJhbSBlcnJub1xuICovXG5mdW5jdGlvbiBnZXRTeXN0ZW1FcnJvck5hbWUoZXJybm8pIHtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBudW1dIG9mIE9iamVjdC5lbnRyaWVzKG9zLmNvbnN0YW50cy5lcnJubykpIHtcbiAgICAgICAgaWYgKG51bSA9PT0gZXJybm8pIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnVW5rbm93biBzeXN0ZW0gZXJyb3IgJyArIGVycm5vO1xufVxuZnVuY3Rpb24gZ2V0TWluRGVhZGxpbmUoZGVhZGxpbmVMaXN0KSB7XG4gICAgbGV0IG1pblZhbHVlID0gSW5maW5pdHk7XG4gICAgZm9yIChjb25zdCBkZWFkbGluZSBvZiBkZWFkbGluZUxpc3QpIHtcbiAgICAgICAgY29uc3QgZGVhZGxpbmVNc2VjcyA9IGRlYWRsaW5lIGluc3RhbmNlb2YgRGF0ZSA/IGRlYWRsaW5lLmdldFRpbWUoKSA6IGRlYWRsaW5lO1xuICAgICAgICBpZiAoZGVhZGxpbmVNc2VjcyA8IG1pblZhbHVlKSB7XG4gICAgICAgICAgICBtaW5WYWx1ZSA9IGRlYWRsaW5lTXNlY3M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pblZhbHVlO1xufVxuZnVuY3Rpb24gaXNJbnRlcmNlcHRpbmdMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHJldHVybiAobGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBsaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YS5sZW5ndGggPT09IDEpO1xufVxuZXhwb3J0cy5pc0ludGVyY2VwdGluZ0xpc3RlbmVyID0gaXNJbnRlcmNlcHRpbmdMaXN0ZW5lcjtcbmNsYXNzIEludGVyY2VwdGluZ0xpc3RlbmVySW1wbCB7XG4gICAgY29uc3RydWN0b3IobGlzdGVuZXIsIG5leHRMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMubmV4dExpc3RlbmVyID0gbmV4dExpc3RlbmVyO1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc1BlbmRpbmdNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nU3RhdHVzID0gbnVsbDtcbiAgICB9XG4gICAgcHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNQZW5kaW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSh0aGlzLnBlbmRpbmdNZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5oYXNQZW5kaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NQZW5kaW5nU3RhdHVzKCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nU3RhdHVzKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXModGhpcy5wZW5kaW5nU3RhdHVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IHRydWU7XG4gICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEsIChtZXRhZGF0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nU3RhdHVzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAvKiBJZiB0aGlzIGxpc3RlbmVyIHByb2Nlc3NlcyBtZXNzYWdlcyBhc3luY2hyb25vdXNseSwgdGhlIGxhc3QgbWVzc2FnZSBtYXlcbiAgICAgICAgICogYmUgcmVvcmRlcmVkIHdpdGggcmVzcGVjdCB0byB0aGUgc3RhdHVzICovXG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSB0cnVlO1xuICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSwgKG1zZykgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG1zZztcbiAgICAgICAgICAgICAgICB0aGlzLmhhc1BlbmRpbmdNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nU3RhdHVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvblJlY2VpdmVTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKHN0YXR1cywgKHByb2Nlc3NlZFN0YXR1cykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhIHx8IHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdTdGF0dXMgPSBwcm9jZXNzZWRTdGF0dXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMocHJvY2Vzc2VkU3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnRlcmNlcHRpbmdMaXN0ZW5lckltcGwgPSBJbnRlcmNlcHRpbmdMaXN0ZW5lckltcGw7XG5jbGFzcyBIdHRwMkNhbGxTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZE5hbWUsIGNoYW5uZWwsIG9wdGlvbnMsIGZpbHRlclN0YWNrRmFjdG9yeSwgY2hhbm5lbENhbGxDcmVkZW50aWFscywgY2FsbE51bWJlcikge1xuICAgICAgICB0aGlzLm1ldGhvZE5hbWUgPSBtZXRob2ROYW1lO1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNoYW5uZWxDYWxsQ3JlZGVudGlhbHMgPSBjaGFubmVsQ2FsbENyZWRlbnRpYWxzO1xuICAgICAgICB0aGlzLmNhbGxOdW1iZXIgPSBjYWxsTnVtYmVyO1xuICAgICAgICB0aGlzLmh0dHAyU3RyZWFtID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nUmVhZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzV3JpdGVGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ1dyaXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nV3JpdGVDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMud3JpdGVzQ2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBzdHJlYW1fZGVjb2Rlcl8xLlN0cmVhbURlY29kZXIoKTtcbiAgICAgICAgdGhpcy5pc1JlYWRGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FuUHVzaCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgYW4gJ2VuZCcgZXZlbnQgaGFzIGNvbWUgZnJvbSB0aGUgaHR0cDIgc3RyZWFtLCBzbyB0aGVyZVxuICAgICAgICAgKiB3aWxsIGJlIG5vIG1vcmUgZGF0YSBldmVudHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlYWRzQ2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdHVzT3V0cHV0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMudW5wdXNoZWRSZWFkTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgdGhpcy51bmZpbHRlcmVkUmVhZE1lc3NhZ2VzID0gW107XG4gICAgICAgIC8vIFN0YXR1cyBjb2RlIG1hcHBlZCBmcm9tIDpzdGF0dXMuIFRvIGJlIHVzZWQgaWYgZ3JwYy1zdGF0dXMgaXMgbm90IHJlY2VpdmVkXG4gICAgICAgIHRoaXMubWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOO1xuICAgICAgICAvLyBUaGlzIGlzIHBvcHVsYXRlZCAobm9uLW51bGwpIGlmIGFuZCBvbmx5IGlmIHRoZSBjYWxsIGhhcyBlbmRlZFxuICAgICAgICB0aGlzLmZpbmFsU3RhdHVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxFcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuY29uZmlnRGVhZGxpbmUgPSBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5zdGF0dXNXYXRjaGVycyA9IFtdO1xuICAgICAgICB0aGlzLnN0cmVhbUVuZFdhdGNoZXJzID0gW107XG4gICAgICAgIHRoaXMuY2FsbFN0YXRzVHJhY2tlciA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2sgPSBmaWx0ZXJTdGFja0ZhY3RvcnkuY3JlYXRlRmlsdGVyKHRoaXMpO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gY2hhbm5lbENhbGxDcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0TGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVuZENhbGwoe1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiAnQ29ubmVjdGlvbiBkcm9wcGVkJyxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhcmVudENhbGwgJiZcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5mbGFncyAmIGNvbnN0YW50c18xLlByb3BhZ2F0ZS5DQU5DRUxMQVRJT04pIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wYXJlbnRDYWxsLm9uKCdjYW5jZWxsZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdDYW5jZWxsZWQgYnkgcGFyZW50IGNhbGwnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG91dHB1dFN0YXR1cygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvKiBQcmVjb25kaXRpb246IHRoaXMuZmluYWxTdGF0dXMgIT09IG51bGwgKi9cbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXIgJiYgIXRoaXMuc3RhdHVzT3V0cHV0KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c091dHB1dCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZFN0YXR1cyA9IHRoaXMuZmlsdGVyU3RhY2sucmVjZWl2ZVRyYWlsZXJzKHRoaXMuZmluYWxTdGF0dXMpO1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnZW5kZWQgd2l0aCBzdGF0dXM6IGNvZGU9JyArXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRTdGF0dXMuY29kZSArXG4gICAgICAgICAgICAgICAgJyBkZXRhaWxzPVwiJyArXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRTdGF0dXMuZGV0YWlscyArXG4gICAgICAgICAgICAgICAgJ1wiJyk7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c1dhdGNoZXJzLmZvckVhY2god2F0Y2hlciA9PiB3YXRjaGVyKGZpbHRlcmVkU3RhdHVzKSk7XG4gICAgICAgICAgICAvKiBXZSBkZWxheSB0aGUgYWN0dWFsIGFjdGlvbiBvZiBidWJibGluZyB1cCB0aGUgc3RhdHVzIHRvIGluc3VsYXRlIHRoZVxuICAgICAgICAgICAgICogY2xlYW51cCBjb2RlIGluIHRoaXMgY2xhc3MgZnJvbSBhbnkgZXJyb3JzIHRoYXQgbWF5IGJlIHRocm93biBpbiB0aGVcbiAgICAgICAgICAgICAqIHVwcGVyIGxheWVycyBhcyBhIHJlc3VsdCBvZiBidWJibGluZyB1cCB0aGUgc3RhdHVzLiBJbiBwYXJ0aWN1bGFyLFxuICAgICAgICAgICAgICogaWYgdGhlIHN0YXR1cyBpcyBub3QgT0ssIHRoZSBcImVycm9yXCIgZXZlbnQgbWF5IGJlIGVtaXR0ZWRcbiAgICAgICAgICAgICAqIHN5bmNocm9ub3VzbHkgYXQgdGhlIHRvcCBsZXZlbCwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSB0aHJvd24gZXJyb3IgaWZcbiAgICAgICAgICAgICAqIHRoZSB1c2VyIGRvZXMgbm90IGhhbmRsZSB0aGF0IGV2ZW50LiAqL1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMubGlzdGVuZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vblJlY2VpdmVTdGF0dXMoZmlsdGVyZWRTdGF0dXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKiBMZWF2ZSB0aGUgaHR0cDIgc3RyZWFtIGluIGZsb3dpbmcgc3RhdGUgdG8gZHJhaW4gaW5jb21pbmcgbWVzc2FnZXMsIHRvXG4gICAgICAgICAgICAgKiBlbnN1cmUgdGhhdCB0aGUgc3RyZWFtIGNsb3N1cmUgY29tcGxldGVzLiBUaGUgY2FsbCBzdHJlYW0gYWxyZWFkeSBkb2VzXG4gICAgICAgICAgICAgKiBub3QgcHVzaCBtb3JlIG1lc3NhZ2VzIGFmdGVyIHRoZSBzdGF0dXMgaXMgb3V0cHV0LCBzbyB0aGUgbWVzc2FnZXMgZ29cbiAgICAgICAgICAgICAqIG5vd2hlcmUgZWl0aGVyIHdheS4gKi9cbiAgICAgICAgICAgIChfYSA9IHRoaXMuaHR0cDJTdHJlYW0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXN1bWUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1YmNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWwuY2FsbFVucmVmKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsLnJlbW92ZURpc2Nvbm5lY3RMaXN0ZW5lcih0aGlzLmRpc2Nvbm5lY3RMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18yLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICdbJyArIHRoaXMuY2FsbE51bWJlciArICddICcgKyB0ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT24gZmlyc3QgY2FsbCwgZW1pdHMgYSAnc3RhdHVzJyBldmVudCB3aXRoIHRoZSBnaXZlbiBTdGF0dXNPYmplY3QuXG4gICAgICogU3Vic2VxdWVudCBjYWxscyBhcmUgbm8tb3BzLlxuICAgICAqIEBwYXJhbSBzdGF0dXMgVGhlIHN0YXR1cyBvZiB0aGUgY2FsbC5cbiAgICAgKi9cbiAgICBlbmRDYWxsKHN0YXR1cykge1xuICAgICAgICAvKiBJZiB0aGUgc3RhdHVzIGlzIE9LIGFuZCBhIG5ldyBzdGF0dXMgY29tZXMgaW4gKGUuZy4gZnJvbSBhXG4gICAgICAgICAqIGRlc2VyaWFsaXphdGlvbiBmYWlsdXJlKSwgdGhhdCBuZXcgc3RhdHVzIHRha2VzIHByaW9yaXR5ICovXG4gICAgICAgIGlmICh0aGlzLmZpbmFsU3RhdHVzID09PSBudWxsIHx8IHRoaXMuZmluYWxTdGF0dXMuY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmFsU3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgICAgdGhpcy5tYXliZU91dHB1dFN0YXR1cygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdHJveUh0dHAyU3RyZWFtKCk7XG4gICAgfVxuICAgIG1heWJlT3V0cHV0U3RhdHVzKCkge1xuICAgICAgICBpZiAodGhpcy5maW5hbFN0YXR1cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLyogVGhlIGNvbWJpbmF0aW9uIGNoZWNrIG9mIHJlYWRzQ2xvc2VkIGFuZCB0aGF0IHRoZSB0d28gbWVzc2FnZSBidWZmZXJcbiAgICAgICAgICAgICAqIGFycmF5cyBhcmUgZW1wdHkgY2hlY2tzIHRoYXQgdGhlcmUgYWxsIGluY29taW5nIGRhdGEgaGFzIGJlZW4gZnVsbHlcbiAgICAgICAgICAgICAqIHByb2Nlc3NlZCAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMuY29kZSAhPT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMucmVhZHNDbG9zZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnB1c2hlZFJlYWRNZXNzYWdlcy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bmZpbHRlcmVkUmVhZE1lc3NhZ2VzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5pc1JlYWRGaWx0ZXJQZW5kaW5nKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHVzaChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3B1c2hpbmcgdG8gcmVhZGVyIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgK1xuICAgICAgICAgICAgKG1lc3NhZ2UgaW5zdGFuY2VvZiBCdWZmZXIgPyBtZXNzYWdlLmxlbmd0aCA6IG51bGwpKTtcbiAgICAgICAgdGhpcy5jYW5QdXNoID0gZmFsc2U7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgLyogSWYgd2UgaGF2ZSBhbHJlYWR5IG91dHB1dCB0aGUgc3RhdHVzIGFueSBsYXRlciBtZXNzYWdlcyBzaG91bGQgYmVcbiAgICAgICAgICAgICAqIGlnbm9yZWQsIGFuZCBjYW4gY2F1c2Ugb3V0LW9mLW9yZGVyIG9wZXJhdGlvbiBlcnJvcnMgaGlnaGVyIHVwIGluIHRoZVxuICAgICAgICAgICAgICogc3RhY2suIENoZWNraW5nIGFzIGxhdGUgYXMgcG9zc2libGUgaGVyZSB0byBhdm9pZCBhbnkgcmFjZSBjb25kaXRpb25zLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0dXNPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmxpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMubWF5YmVPdXRwdXRTdGF0dXMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZUZpbHRlckVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBoYW5kbGVGaWx0ZXJlZFJlYWQobWVzc2FnZSkge1xuICAgICAgICAvKiBJZiB3ZSB0aGUgY2FsbCBoYXMgYWxyZWFkeSBlbmRlZCB3aXRoIGFuIGVycm9yLCB3ZSBkb24ndCB3YW50IHRvIGRvXG4gICAgICAgICAqIGFueXRoaW5nIHdpdGggdGhpcyBtZXNzYWdlLiBEcm9wcGluZyBpdCBvbiB0aGUgZmxvb3IgaXMgY29ycmVjdFxuICAgICAgICAgKiBiZWhhdmlvciAqL1xuICAgICAgICBpZiAodGhpcy5maW5hbFN0YXR1cyAhPT0gbnVsbCAmJiB0aGlzLmZpbmFsU3RhdHVzLmNvZGUgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgdGhpcy5tYXliZU91dHB1dFN0YXR1cygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNSZWFkRmlsdGVyUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5jYW5QdXNoKSB7XG4gICAgICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLnBhdXNlKCk7XG4gICAgICAgICAgICB0aGlzLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCd1bnB1c2hlZFJlYWRNZXNzYWdlcy5wdXNoIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgKyBtZXNzYWdlLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnVucHVzaGVkUmVhZE1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudW5maWx0ZXJlZFJlYWRNZXNzYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvKiBuZXh0TWVzc2FnZSBpcyBndWFyYW50ZWVkIG5vdCB0byBiZSB1bmRlZmluZWQgYmVjYXVzZVxuICAgICAgICAgICAgICAgdW5maWx0ZXJlZFJlYWRNZXNzYWdlcyBpcyBub24tZW1wdHkgKi9cbiAgICAgICAgICAgIGNvbnN0IG5leHRNZXNzYWdlID0gdGhpcy51bmZpbHRlcmVkUmVhZE1lc3NhZ2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICB0aGlzLmZpbHRlclJlY2VpdmVkTWVzc2FnZShuZXh0TWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmlsdGVyUmVjZWl2ZWRNZXNzYWdlKGZyYW1lZE1lc3NhZ2UpIHtcbiAgICAgICAgLyogSWYgd2UgdGhlIGNhbGwgaGFzIGFscmVhZHkgZW5kZWQgd2l0aCBhbiBlcnJvciwgd2UgZG9uJ3Qgd2FudCB0byBkb1xuICAgICAgICAgKiBhbnl0aGluZyB3aXRoIHRoaXMgbWVzc2FnZS4gRHJvcHBpbmcgaXQgb24gdGhlIGZsb29yIGlzIGNvcnJlY3RcbiAgICAgICAgICogYmVoYXZpb3IgKi9cbiAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMgIT09IG51bGwgJiYgdGhpcy5maW5hbFN0YXR1cy5jb2RlICE9PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgIHRoaXMubWF5YmVPdXRwdXRTdGF0dXMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlKCdmaWx0ZXJSZWNlaXZlZE1lc3NhZ2Ugb2YgbGVuZ3RoICcgKyBmcmFtZWRNZXNzYWdlLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuaXNSZWFkRmlsdGVyUGVuZGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2tcbiAgICAgICAgICAgIC5yZWNlaXZlTWVzc2FnZShQcm9taXNlLnJlc29sdmUoZnJhbWVkTWVzc2FnZSkpXG4gICAgICAgICAgICAudGhlbih0aGlzLmhhbmRsZUZpbHRlcmVkUmVhZC5iaW5kKHRoaXMpLCB0aGlzLmhhbmRsZUZpbHRlckVycm9yLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICB0cnlQdXNoKG1lc3NhZ2VCeXRlcykge1xuICAgICAgICBpZiAodGhpcy5pc1JlYWRGaWx0ZXJQZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCd1bmZpbHRlcmVkUmVhZE1lc3NhZ2VzLnB1c2ggbWVzc2FnZSBvZiBsZW5ndGggJyArXG4gICAgICAgICAgICAgICAgKG1lc3NhZ2VCeXRlcyAmJiBtZXNzYWdlQnl0ZXMubGVuZ3RoKSk7XG4gICAgICAgICAgICB0aGlzLnVuZmlsdGVyZWRSZWFkTWVzc2FnZXMucHVzaChtZXNzYWdlQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJSZWNlaXZlZE1lc3NhZ2UobWVzc2FnZUJ5dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVUcmFpbGVycyhoZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtRW5kV2F0Y2hlcnMuZm9yRWFjaCh3YXRjaGVyID0+IHdhdGNoZXIodHJ1ZSkpO1xuICAgICAgICBsZXQgaGVhZGVyc1N0cmluZyA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgaGVhZGVyc1N0cmluZyArPSAnXFx0XFx0JyArIGhlYWRlciArICc6ICcgKyBoZWFkZXJzW2hlYWRlcl0gKyAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBzZXJ2ZXIgdHJhaWxlcnM6XFxuJyArIGhlYWRlcnNTdHJpbmcpO1xuICAgICAgICBsZXQgbWV0YWRhdGE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZXRhZGF0YSA9IG1ldGFkYXRhXzEuTWV0YWRhdGEuZnJvbUh0dHAySGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhTWFwID0gbWV0YWRhdGEuZ2V0TWFwKCk7XG4gICAgICAgIGxldCBjb2RlID0gdGhpcy5tYXBwZWRTdGF0dXNDb2RlO1xuICAgICAgICBpZiAoY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV04gJiZcbiAgICAgICAgICAgIHR5cGVvZiBtZXRhZGF0YU1hcFsnZ3JwYy1zdGF0dXMnXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY2VpdmVkU3RhdHVzID0gTnVtYmVyKG1ldGFkYXRhTWFwWydncnBjLXN0YXR1cyddKTtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlZFN0YXR1cyBpbiBjb25zdGFudHNfMS5TdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gcmVjZWl2ZWRTdGF0dXM7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgncmVjZWl2ZWQgc3RhdHVzIGNvZGUgJyArIHJlY2VpdmVkU3RhdHVzICsgJyBmcm9tIHNlcnZlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YWRhdGEucmVtb3ZlKCdncnBjLXN0YXR1cycpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZXRhaWxzID0gJyc7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0YWRhdGFNYXBbJ2dycGMtbWVzc2FnZSddID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzID0gZGVjb2RlVVJJKG1ldGFkYXRhTWFwWydncnBjLW1lc3NhZ2UnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGRldGFpbHMgPSBtZXRhZGF0YU1hcFsnZ3JwYy1tZXNzYWdlJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXRhZGF0YS5yZW1vdmUoJ2dycGMtbWVzc2FnZScpO1xuICAgICAgICAgICAgdGhpcy50cmFjZSgncmVjZWl2ZWQgc3RhdHVzIGRldGFpbHMgc3RyaW5nIFwiJyArIGRldGFpbHMgKyAnXCIgZnJvbSBzZXJ2ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0dXMgPSB7IGNvZGUsIGRldGFpbHMsIG1ldGFkYXRhIH07XG4gICAgICAgIC8vIFRoaXMgaXMgYSBuby1vcCBpZiB0aGUgY2FsbCB3YXMgYWxyZWFkeSBlbmRlZCB3aGVuIGhhbmRsaW5nIGhlYWRlcnMuXG4gICAgICAgIHRoaXMuZW5kQ2FsbChzdGF0dXMpO1xuICAgIH1cbiAgICB3cml0ZU1lc3NhZ2VUb1N0cmVhbShtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbFN0YXRzVHJhY2tlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZE1lc3NhZ2VTZW50KCk7XG4gICAgICAgIHRoaXMuaHR0cDJTdHJlYW0ud3JpdGUobWVzc2FnZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBhdHRhY2hIdHRwMlN0cmVhbShzdHJlYW0sIHN1YmNoYW5uZWwsIGV4dHJhRmlsdGVycywgY2FsbFN0YXRzVHJhY2tlcikge1xuICAgICAgICB0aGlzLmZpbHRlclN0YWNrLnB1c2goZXh0cmFGaWx0ZXJzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0cmVhbS5jbG9zZShOR0hUVFAyX0NBTkNFTCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdhdHRhY2hIdHRwMlN0cmVhbSBmcm9tIHN1YmNoYW5uZWwgJyArIHN1YmNoYW5uZWwuZ2V0QWRkcmVzcygpKTtcbiAgICAgICAgICAgIHRoaXMuaHR0cDJTdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWwgPSBzdWJjaGFubmVsO1xuICAgICAgICAgICAgdGhpcy5jYWxsU3RhdHNUcmFja2VyID0gY2FsbFN0YXRzVHJhY2tlcjtcbiAgICAgICAgICAgIHN1YmNoYW5uZWwuYWRkRGlzY29ubmVjdExpc3RlbmVyKHRoaXMuZGlzY29ubmVjdExpc3RlbmVyKTtcbiAgICAgICAgICAgIHN1YmNoYW5uZWwuY2FsbFJlZigpO1xuICAgICAgICAgICAgc3RyZWFtLm9uKCdyZXNwb25zZScsIChoZWFkZXJzLCBmbGFncykgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBsZXQgaGVhZGVyc1N0cmluZyA9ICcnO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaGVhZGVyIG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNTdHJpbmcgKz0gJ1xcdFxcdCcgKyBoZWFkZXIgKyAnOiAnICsgaGVhZGVyc1toZWFkZXJdICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIHNlcnZlciBoZWFkZXJzOlxcbicgKyBoZWFkZXJzU3RyaW5nKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGhlYWRlcnNbJzpzdGF0dXMnXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKG11cmdhdHJvaWQ5OSk6IGhhbmRsZSAxMDAgYW5kIDEwMVxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQwMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQwMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTkFVVEhFTlRJQ0FURUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0MDM6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuUEVSTUlTU0lPTl9ERU5JRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0MDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQyOTpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1MDI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTAzOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDUwNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBwZWRTdGF0dXNDb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV047XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmbGFncyAmIGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0ZMQUdfRU5EX1NUUkVBTSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVRyYWlsZXJzKGhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgPSBtZXRhZGF0YV8xLk1ldGFkYXRhLmZyb21IdHRwMkhlYWRlcnMoaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZENhbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxNZXRhZGF0YSA9IHRoaXMuZmlsdGVyU3RhY2sucmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMubGlzdGVuZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vblJlY2VpdmVNZXRhZGF0YShmaW5hbE1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kQ2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV04sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdHJlYW0ub24oJ3RyYWlsZXJzJywgKGhlYWRlcnMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVRyYWlsZXJzKGhlYWRlcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdHJlYW0ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIC8qIElmIHRoZSBzdGF0dXMgaGFzIGFscmVhZHkgYmVlbiBvdXRwdXQsIGFsbG93IHRoZSBodHRwMiBzdHJlYW0gdG9cbiAgICAgICAgICAgICAgICAgKiBkcmFpbiB3aXRob3V0IHByb2Nlc3NpbmcgdGhlIGRhdGEuICovXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgncmVjZWl2ZSBIVFRQLzIgZGF0YSBmcmFtZSBvZiBsZW5ndGggJyArIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlcyA9IHRoaXMuZGVjb2Rlci53cml0ZShkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgncGFyc2VkIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgKyBtZXNzYWdlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFN0YXRzVHJhY2tlci5hZGRNZXNzYWdlUmVjZWl2ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlQdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXliZU91dHB1dFN0YXR1cygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdHJlYW0ub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8qIFVzZSBwcm9jZXNzLm5leHQgdGljayB0byBlbnN1cmUgdGhhdCB0aGlzIGNvZGUgaGFwcGVucyBhZnRlciBhbnlcbiAgICAgICAgICAgICAgICAgKiBcImVycm9yXCIgZXZlbnQgdGhhdCBtYXkgYmUgZW1pdHRlZCBhdCBhYm91dCB0aGUgc2FtZSB0aW1lLCBzbyB0aGF0XG4gICAgICAgICAgICAgICAgICogd2UgY2FuIGJ1YmJsZSB1cCB0aGUgZXJyb3IgbWVzc2FnZSBmcm9tIHRoYXQgZXZlbnQuICovXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnSFRUUC8yIHN0cmVhbSBjbG9zZWQgd2l0aCBjb2RlICcgKyBzdHJlYW0ucnN0Q29kZSk7XG4gICAgICAgICAgICAgICAgICAgIC8qIElmIHdlIGhhdmUgYSBmaW5hbCBzdGF0dXMgd2l0aCBhbiBPSyBzdGF0dXMgY29kZSwgdGhhdCBtZWFucyB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAqIHdlIGhhdmUgcmVjZWl2ZWQgYWxsIG9mIHRoZSBtZXNzYWdlcyBhbmQgd2UgaGF2ZSBwcm9jZXNzZWQgdGhlXG4gICAgICAgICAgICAgICAgICAgICAqIHRyYWlsZXJzIGFuZCB0aGUgY2FsbCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LCBzbyBpdCBkb2Vzbid0IG1hdHRlclxuICAgICAgICAgICAgICAgICAgICAgKiBob3cgdGhlIHN0cmVhbSBlbmRzIGFmdGVyIHRoYXQgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLmZpbmFsU3RhdHVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2RlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGV0YWlscyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0cmVhbS5yc3RDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX05PX0VSUk9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIElmIHdlIGdldCBhIE5PX0VSUk9SIGNvZGUgYW5kIHdlIGFscmVhZHkgaGF2ZSBhIHN0YXR1cywgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogc3RyZWFtIGNvbXBsZXRlZCBwcm9wZXJseSBhbmQgd2UganVzdCBoYXZlbid0IGZ1bGx5IHByb2Nlc3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGl0IHlldCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmFsU3RhdHVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gYFJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlICR7c3RyZWFtLnJzdENvZGV9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfUkVGVVNFRF9TVFJFQU06XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gJ1N0cmVhbSByZWZ1c2VkIGJ5IHNlcnZlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0NBTkNFTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gJ0NhbGwgY2FuY2VsbGVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfRU5IQU5DRV9ZT1VSX0NBTE06XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9ICdCYW5kd2lkdGggZXhoYXVzdGVkIG9yIG1lbW9yeSBsaW1pdCBleGNlZWRlZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0lOQURFUVVBVEVfU0VDVVJJVFk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5QRVJNSVNTSU9OX0RFTklFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gJ1Byb3RvY29sIG5vdCBzZWN1cmUgZW5vdWdoJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfSU5URVJOQUxfRVJST1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnRlcm5hbEVycm9yID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRoaXMgZXJyb3IgY29kZSB3YXMgcHJldmlvdXNseSBoYW5kbGVkIGluIHRoZSBkZWZhdWx0IGNhc2UsIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGVyZSBhcmUgc2V2ZXJhbCBpbnN0YW5jZXMgb2YgaXQgb25saW5lLCBzbyBJIHdhbnRlZCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBwcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgZXJyb3IgbWVzc2FnZSBzbyB0aGF0IHBlb3BsZSBmaW5kIGV4aXN0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGluZm9ybWF0aW9uIGluIHNlYXJjaGVzLCBidXQgYWxzbyBpbmNsdWRlIHRoZSBtb3JlIHJlY29nbml6YWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBcIkludGVybmFsIHNlcnZlciBlcnJvclwiIG1lc3NhZ2UuICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSBgUmVjZWl2ZWQgUlNUX1NUUkVBTSB3aXRoIGNvZGUgJHtzdHJlYW0ucnN0Q29kZX0gKEludGVybmFsIHNlcnZlciBlcnJvcilgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJuYWxFcnJvci5jb2RlID09PSAnRUNPTk5SRVNFVCcgfHwgdGhpcy5pbnRlcm5hbEVycm9yLmNvZGUgPT09ICdFVElNRURPVVQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9IHRoaXMuaW50ZXJuYWxFcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogVGhlIFwiUmVjZWl2ZWQgUlNUX1NUUkVBTSB3aXRoIGNvZGUgLi4uXCIgZXJyb3IgaXMgcHJlc2VydmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBoZXJlIGZvciBjb250aW51aXR5IHdpdGggZXJyb3JzIHJlcG9ydGVkIG9ubGluZSwgYnV0IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogZXJyb3IgbWVzc2FnZSBhdCB0aGUgZW5kIHdpbGwgcHJvYmFibHkgYmUgbW9yZSByZWxldmFudCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogbW9zdCBjYXNlcy4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSBgUmVjZWl2ZWQgUlNUX1NUUkVBTSB3aXRoIGNvZGUgJHtzdHJlYW0ucnN0Q29kZX0gdHJpZ2dlcmVkIGJ5IGludGVybmFsIGNsaWVudCBlcnJvcjogJHt0aGlzLmludGVybmFsRXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSBgUmVjZWl2ZWQgUlNUX1NUUkVBTSB3aXRoIGNvZGUgJHtzdHJlYW0ucnN0Q29kZX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBuby1vcCBpZiB0cmFpbGVycyB3ZXJlIHJlY2VpdmVkIGF0IGFsbC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBPSywgYmVjYXVzZSBzdGF0dXMgY29kZXMgZW1pdHRlZCBoZXJlIGNvcnJlc3BvbmQgdG8gbW9yZVxuICAgICAgICAgICAgICAgICAgICAvLyBjYXRhc3Ryb3BoaWMgaXNzdWVzIHRoYXQgcHJldmVudCB1cyBmcm9tIHJlY2VpdmluZyB0cmFpbGVycyBpbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgcGxhY2UuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kQ2FsbCh7IGNvZGUsIGRldGFpbHMsIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIC8qIFdlIG5lZWQgYW4gZXJyb3IgaGFuZGxlciBoZXJlIHRvIHN0b3AgXCJVbmNhdWdodCBFcnJvclwiIGV4Y2VwdGlvbnNcbiAgICAgICAgICAgICAgICAgKiBmcm9tIGJ1YmJsaW5nIHVwLiBIb3dldmVyLCBlcnJvcnMgaGVyZSBzaG91bGQgYWxsIGNvcnJlc3BvbmQgdG9cbiAgICAgICAgICAgICAgICAgKiBcImNsb3NlXCIgZXZlbnRzLCB3aGVyZSB3ZSB3aWxsIGhhbmRsZSB0aGUgZXJyb3IgbW9yZSBncmFudWxhcmx5ICovXG4gICAgICAgICAgICAgICAgLyogU3BlY2lmaWNhbGx5IGxvb2tpbmcgZm9yIHN0cmVhbSBlcnJvcnMgdGhhdCB3ZXJlICpub3QqIGNvbnN0cnVjdGVkXG4gICAgICAgICAgICAgICAgICogZnJvbSBhIFJTVF9TVFJFQU0gcmVzcG9uc2UgaGVyZTpcbiAgICAgICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi84Yjg2MjBkNTgwMzE0MDUwMTc1OTgzNDAyZGZkZGYyNjc0ZThlMjJhL2xpYi9pbnRlcm5hbC9odHRwMi9jb3JlLmpzI0wyMjY3XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlICE9PSAnRVJSX0hUVFAyX1NUUkVBTV9FUlJPUicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnTm9kZSBlcnJvciBldmVudDogbWVzc2FnZT0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgY29kZT0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5jb2RlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgZXJybm89JyArXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRTeXN0ZW1FcnJvck5hbWUoZXJyLmVycm5vKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIHN5c2NhbGw9JyArXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIuc3lzY2FsbCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxFcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1FbmRXYXRjaGVycy5mb3JFYWNoKHdhdGNoZXIgPT4gd2F0Y2hlcihmYWxzZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nV3JpdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGVuZGluZ1dyaXRlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlIGluIHdyaXRlIGhhbmRsaW5nIGNvZGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnc2VuZGluZyBkYXRhIGNodW5rIG9mIGxlbmd0aCAnICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nV3JpdGUubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAgICAgJyAoZGVmZXJyZWQpJyk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZU1lc3NhZ2VUb1N0cmVhbSh0aGlzLnBlbmRpbmdXcml0ZSwgdGhpcy5wZW5kaW5nV3JpdGVDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZENhbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFdyaXRlIGZhaWxlZCB3aXRoIGVycm9yICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXliZUNsb3NlV3JpdGVzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQobWV0YWRhdGEsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ1NlbmRpbmcgbWV0YWRhdGEnKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLmNoYW5uZWwuX3N0YXJ0Q2FsbFN0cmVhbSh0aGlzLCBtZXRhZGF0YSk7XG4gICAgICAgIHRoaXMubWF5YmVPdXRwdXRTdGF0dXMoKTtcbiAgICB9XG4gICAgZGVzdHJveUh0dHAyU3RyZWFtKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIFRoZSBodHRwMiBzdHJlYW0gY291bGQgYWxyZWFkeSBoYXZlIGJlZW4gZGVzdHJveWVkIGlmIGNhbmNlbFdpdGhTdGF0dXNcbiAgICAgICAgLy8gaXMgY2FsbGVkIGluIHJlc3BvbnNlIHRvIGFuIGludGVybmFsIGh0dHAyIGVycm9yLlxuICAgICAgICBpZiAodGhpcy5odHRwMlN0cmVhbSAhPT0gbnVsbCAmJiAhdGhpcy5odHRwMlN0cmVhbS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIC8qIElmIHRoZSBjYWxsIGhhcyBlbmRlZCB3aXRoIGFuIE9LIHN0YXR1cywgY29tbXVuaWNhdGUgdGhhdCB3aGVuIGNsb3NpbmdcbiAgICAgICAgICAgICAqIHRoZSBzdHJlYW0sIHBhcnRseSB0byBhdm9pZCBhIHNpdHVhdGlvbiBpbiB3aGljaCB3ZSBkZXRlY3QgYW4gZXJyb3JcbiAgICAgICAgICAgICAqIFJTVF9TVFJFQU0gYXMgYSByZXN1bHQgYWZ0ZXIgd2UgaGF2ZSB0aGUgc3RhdHVzICovXG4gICAgICAgICAgICBsZXQgY29kZTtcbiAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy5maW5hbFN0YXR1cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfTk9fRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfQ0FOQ0VMO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFjZSgnY2xvc2UgaHR0cDIgc3RyZWFtIHdpdGggY29kZSAnICsgY29kZSk7XG4gICAgICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLmNsb3NlKGNvZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NhbmNlbFdpdGhTdGF0dXMgY29kZTogJyArIHN0YXR1cyArICcgZGV0YWlsczogXCInICsgZGV0YWlscyArICdcIicpO1xuICAgICAgICB0aGlzLmVuZENhbGwoeyBjb2RlOiBzdGF0dXMsIGRldGFpbHMsIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpIH0pO1xuICAgIH1cbiAgICBnZXREZWFkbGluZSgpIHtcbiAgICAgICAgY29uc3QgZGVhZGxpbmVMaXN0ID0gW3RoaXMub3B0aW9ucy5kZWFkbGluZV07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGFyZW50Q2FsbCAmJiB0aGlzLm9wdGlvbnMuZmxhZ3MgJiBjb25zdGFudHNfMS5Qcm9wYWdhdGUuREVBRExJTkUpIHtcbiAgICAgICAgICAgIGRlYWRsaW5lTGlzdC5wdXNoKHRoaXMub3B0aW9ucy5wYXJlbnRDYWxsLmdldERlYWRsaW5lKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ0RlYWRsaW5lKSB7XG4gICAgICAgICAgICBkZWFkbGluZUxpc3QucHVzaCh0aGlzLmNvbmZpZ0RlYWRsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0TWluRGVhZGxpbmUoZGVhZGxpbmVMaXN0KTtcbiAgICB9XG4gICAgZ2V0Q3JlZGVudGlhbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWRlbnRpYWxzO1xuICAgIH1cbiAgICBzZXRDcmVkZW50aWFscyhjcmVkZW50aWFscykge1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gdGhpcy5jaGFubmVsQ2FsbENyZWRlbnRpYWxzLmNvbXBvc2UoY3JlZGVudGlhbHMpO1xuICAgIH1cbiAgICBnZXRTdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmFsU3RhdHVzO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5zdWJjaGFubmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0QWRkcmVzcygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLmNoYW5uZWwuZ2V0VGFyZ2V0KCk7XG4gICAgfVxuICAgIGdldE1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0aG9kTmFtZTtcbiAgICB9XG4gICAgZ2V0SG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ob3N0O1xuICAgIH1cbiAgICBzZXRDb25maWdEZWFkbGluZShjb25maWdEZWFkbGluZSkge1xuICAgICAgICB0aGlzLmNvbmZpZ0RlYWRsaW5lID0gY29uZmlnRGVhZGxpbmU7XG4gICAgfVxuICAgIGFkZFN0YXR1c1dhdGNoZXIod2F0Y2hlcikge1xuICAgICAgICB0aGlzLnN0YXR1c1dhdGNoZXJzLnB1c2god2F0Y2hlcik7XG4gICAgfVxuICAgIGFkZFN0cmVhbUVuZFdhdGNoZXIod2F0Y2hlcikge1xuICAgICAgICB0aGlzLnN0cmVhbUVuZFdhdGNoZXJzLnB1c2god2F0Y2hlcik7XG4gICAgfVxuICAgIGFkZEZpbHRlcnMoZXh0cmFGaWx0ZXJzKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2sucHVzaChleHRyYUZpbHRlcnMpO1xuICAgIH1cbiAgICBnZXRDYWxsTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsTnVtYmVyO1xuICAgIH1cbiAgICBzdGFydFJlYWQoKSB7XG4gICAgICAgIC8qIElmIHRoZSBzdHJlYW0gaGFzIGVuZGVkIHdpdGggYW4gZXJyb3IsIHdlIHNob3VsZCBub3QgZW1pdCBhbnkgbW9yZVxuICAgICAgICAgKiBtZXNzYWdlcyBhbmQgd2Ugc2hvdWxkIGNvbW11bmljYXRlIHRoYXQgdGhlIHN0cmVhbSBoYXMgZW5kZWQgKi9cbiAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMgIT09IG51bGwgJiYgdGhpcy5maW5hbFN0YXR1cy5jb2RlICE9PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgIHRoaXMucmVhZHNDbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tYXliZU91dHB1dFN0YXR1cygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FuUHVzaCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmh0dHAyU3RyZWFtID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdSZWFkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnVucHVzaGVkUmVhZE1lc3NhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0TWVzc2FnZSA9IHRoaXMudW5wdXNoZWRSZWFkTWVzc2FnZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2gobmV4dE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIE9ubHkgcmVzdW1lIHJlYWRpbmcgZnJvbSB0aGUgaHR0cDJTdHJlYW0gaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgcGVuZGluZ1xuICAgICAgICAgICAgICogbWVzc2FnZXMgdG8gZW1pdCAqL1xuICAgICAgICAgICAgdGhpcy5odHRwMlN0cmVhbS5yZXN1bWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXliZUNsb3NlV3JpdGVzKCkge1xuICAgICAgICBpZiAodGhpcy53cml0ZXNDbG9zZWQgJiZcbiAgICAgICAgICAgICF0aGlzLmlzV3JpdGVGaWx0ZXJQZW5kaW5nICYmXG4gICAgICAgICAgICB0aGlzLmh0dHAyU3RyZWFtICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdjYWxsaW5nIGVuZCgpIG9uIEhUVFAvMiBzdHJlYW0nKTtcbiAgICAgICAgICAgIHRoaXMuaHR0cDJTdHJlYW0uZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3dyaXRlKCkgY2FsbGVkIHdpdGggbWVzc2FnZSBvZiBsZW5ndGggJyArIG1lc3NhZ2UubGVuZ3RoKTtcbiAgICAgICAgY29uc3Qgd3JpdGVPYmogPSB7XG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgZmxhZ3M6IGNvbnRleHQuZmxhZ3MsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNiID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgbGV0IGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEU7XG4gICAgICAgICAgICBpZiAoKChfYSA9IGVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgPT09ICdFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCcpIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxXaXRoU3RhdHVzKGNvZGUsIGBXcml0ZSBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9iID0gY29udGV4dC5jYWxsYmFjaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoY29udGV4dCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNXcml0ZUZpbHRlclBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmZpbHRlclN0YWNrLnNlbmRNZXNzYWdlKFByb21pc2UucmVzb2x2ZSh3cml0ZU9iaikpLnRoZW4oKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNXcml0ZUZpbHRlclBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmh0dHAyU3RyZWFtID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnZGVmZXJyaW5nIHdyaXRpbmcgZGF0YSBjaHVuayBvZiBsZW5ndGggJyArIG1lc3NhZ2UubWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1dyaXRlID0gbWVzc2FnZS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1dyaXRlQ2FsbGJhY2sgPSBjYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ3NlbmRpbmcgZGF0YSBjaHVuayBvZiBsZW5ndGggJyArIG1lc3NhZ2UubWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVNZXNzYWdlVG9TdHJlYW0obWVzc2FnZS5tZXNzYWdlLCBjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZENhbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFdyaXRlIGZhaWxlZCB3aXRoIGVycm9yICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubWF5YmVDbG9zZVdyaXRlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLmhhbmRsZUZpbHRlckVycm9yLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBoYWxmQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ2VuZCgpIGNhbGxlZCcpO1xuICAgICAgICB0aGlzLndyaXRlc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubWF5YmVDbG9zZVdyaXRlcygpO1xuICAgIH1cbn1cbmV4cG9ydHMuSHR0cDJDYWxsU3RyZWFtID0gSHR0cDJDYWxsU3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FsbC1zdHJlYW0uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSHR0cDJDYWxsU3RyZWFtIiwiSW50ZXJjZXB0aW5nTGlzdGVuZXJJbXBsIiwiaXNJbnRlcmNlcHRpbmdMaXN0ZW5lciIsImh0dHAyIiwicmVxdWlyZSIsIm9zIiwiY29uc3RhbnRzXzEiLCJtZXRhZGF0YV8xIiwic3RyZWFtX2RlY29kZXJfMSIsImxvZ2dpbmciLCJjb25zdGFudHNfMiIsIlRSQUNFUl9OQU1FIiwiSFRUUDJfSEVBREVSX1NUQVRVUyIsIkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEUiLCJOR0hUVFAyX0NBTkNFTCIsImNvbnN0YW50cyIsImdldFN5c3RlbUVycm9yTmFtZSIsImVycm5vIiwibmFtZSIsIm51bSIsImVudHJpZXMiLCJnZXRNaW5EZWFkbGluZSIsImRlYWRsaW5lTGlzdCIsIm1pblZhbHVlIiwiSW5maW5pdHkiLCJkZWFkbGluZSIsImRlYWRsaW5lTXNlY3MiLCJEYXRlIiwiZ2V0VGltZSIsImxpc3RlbmVyIiwib25SZWNlaXZlTWV0YWRhdGEiLCJ1bmRlZmluZWQiLCJsZW5ndGgiLCJjb25zdHJ1Y3RvciIsIm5leHRMaXN0ZW5lciIsInByb2Nlc3NpbmdNZXRhZGF0YSIsImhhc1BlbmRpbmdNZXNzYWdlIiwicHJvY2Vzc2luZ01lc3NhZ2UiLCJwZW5kaW5nU3RhdHVzIiwicHJvY2Vzc1BlbmRpbmdNZXNzYWdlIiwib25SZWNlaXZlTWVzc2FnZSIsInBlbmRpbmdNZXNzYWdlIiwicHJvY2Vzc1BlbmRpbmdTdGF0dXMiLCJvblJlY2VpdmVTdGF0dXMiLCJtZXRhZGF0YSIsIm1lc3NhZ2UiLCJtc2ciLCJzdGF0dXMiLCJwcm9jZXNzZWRTdGF0dXMiLCJtZXRob2ROYW1lIiwiY2hhbm5lbCIsIm9wdGlvbnMiLCJmaWx0ZXJTdGFja0ZhY3RvcnkiLCJjaGFubmVsQ2FsbENyZWRlbnRpYWxzIiwiY2FsbE51bWJlciIsImh0dHAyU3RyZWFtIiwicGVuZGluZ1JlYWQiLCJpc1dyaXRlRmlsdGVyUGVuZGluZyIsInBlbmRpbmdXcml0ZSIsInBlbmRpbmdXcml0ZUNhbGxiYWNrIiwid3JpdGVzQ2xvc2VkIiwiZGVjb2RlciIsIlN0cmVhbURlY29kZXIiLCJpc1JlYWRGaWx0ZXJQZW5kaW5nIiwiY2FuUHVzaCIsInJlYWRzQ2xvc2VkIiwic3RhdHVzT3V0cHV0IiwidW5wdXNoZWRSZWFkTWVzc2FnZXMiLCJ1bmZpbHRlcmVkUmVhZE1lc3NhZ2VzIiwibWFwcGVkU3RhdHVzQ29kZSIsIlN0YXR1cyIsIlVOS05PV04iLCJmaW5hbFN0YXR1cyIsInN1YmNoYW5uZWwiLCJpbnRlcm5hbEVycm9yIiwiY29uZmlnRGVhZGxpbmUiLCJzdGF0dXNXYXRjaGVycyIsInN0cmVhbUVuZFdhdGNoZXJzIiwiY2FsbFN0YXRzVHJhY2tlciIsImZpbHRlclN0YWNrIiwiY3JlYXRlRmlsdGVyIiwiY3JlZGVudGlhbHMiLCJkaXNjb25uZWN0TGlzdGVuZXIiLCJlbmRDYWxsIiwiY29kZSIsIlVOQVZBSUxBQkxFIiwiZGV0YWlscyIsIk1ldGFkYXRhIiwicGFyZW50Q2FsbCIsImZsYWdzIiwiUHJvcGFnYXRlIiwiQ0FOQ0VMTEFUSU9OIiwib24iLCJjYW5jZWxXaXRoU3RhdHVzIiwiQ0FOQ0VMTEVEIiwib3V0cHV0U3RhdHVzIiwiX2EiLCJmaWx0ZXJlZFN0YXR1cyIsInJlY2VpdmVUcmFpbGVycyIsInRyYWNlIiwiZm9yRWFjaCIsIndhdGNoZXIiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJyZXN1bWUiLCJjYWxsVW5yZWYiLCJyZW1vdmVEaXNjb25uZWN0TGlzdGVuZXIiLCJ0ZXh0IiwiTG9nVmVyYm9zaXR5IiwiREVCVUciLCJPSyIsIm1heWJlT3V0cHV0U3RhdHVzIiwiZGVzdHJveUh0dHAyU3RyZWFtIiwicHVzaCIsIkJ1ZmZlciIsImhhbmRsZUZpbHRlckVycm9yIiwiZXJyb3IiLCJJTlRFUk5BTCIsImhhbmRsZUZpbHRlcmVkUmVhZCIsInBhdXNlIiwibmV4dE1lc3NhZ2UiLCJzaGlmdCIsImZpbHRlclJlY2VpdmVkTWVzc2FnZSIsImZyYW1lZE1lc3NhZ2UiLCJyZWNlaXZlTWVzc2FnZSIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImJpbmQiLCJ0cnlQdXNoIiwibWVzc2FnZUJ5dGVzIiwiaGFuZGxlVHJhaWxlcnMiLCJoZWFkZXJzIiwiaGVhZGVyc1N0cmluZyIsImhlYWRlciIsImtleXMiLCJmcm9tSHR0cDJIZWFkZXJzIiwiZSIsIm1ldGFkYXRhTWFwIiwiZ2V0TWFwIiwicmVjZWl2ZWRTdGF0dXMiLCJOdW1iZXIiLCJyZW1vdmUiLCJkZWNvZGVVUkkiLCJ3cml0ZU1lc3NhZ2VUb1N0cmVhbSIsImNhbGxiYWNrIiwiYWRkTWVzc2FnZVNlbnQiLCJ3cml0ZSIsImF0dGFjaEh0dHAyU3RyZWFtIiwic3RyZWFtIiwiZXh0cmFGaWx0ZXJzIiwiY2xvc2UiLCJnZXRBZGRyZXNzIiwiYWRkRGlzY29ubmVjdExpc3RlbmVyIiwiY2FsbFJlZiIsIlVOQVVUSEVOVElDQVRFRCIsIlBFUk1JU1NJT05fREVOSUVEIiwiVU5JTVBMRU1FTlRFRCIsIk5HSFRUUDJfRkxBR19FTkRfU1RSRUFNIiwiZmluYWxNZXRhZGF0YSIsInJlY2VpdmVNZXRhZGF0YSIsImRhdGEiLCJtZXNzYWdlcyIsImFkZE1lc3NhZ2VSZWNlaXZlZCIsInJzdENvZGUiLCJOR0hUVFAyX05PX0VSUk9SIiwiTkdIVFRQMl9SRUZVU0VEX1NUUkVBTSIsIk5HSFRUUDJfRU5IQU5DRV9ZT1VSX0NBTE0iLCJSRVNPVVJDRV9FWEhBVVNURUQiLCJOR0hUVFAyX0lOQURFUVVBVEVfU0VDVVJJVFkiLCJOR0hUVFAyX0lOVEVSTkFMX0VSUk9SIiwiZXJyIiwic3lzY2FsbCIsIkVycm9yIiwibWF5YmVDbG9zZVdyaXRlcyIsInN0YXJ0IiwiX3N0YXJ0Q2FsbFN0cmVhbSIsImRlc3Ryb3llZCIsImdldERlYWRsaW5lIiwiREVBRExJTkUiLCJnZXRDcmVkZW50aWFscyIsInNldENyZWRlbnRpYWxzIiwiY29tcG9zZSIsImdldFN0YXR1cyIsImdldFBlZXIiLCJfYiIsImdldFRhcmdldCIsImdldE1ldGhvZCIsImdldEhvc3QiLCJob3N0Iiwic2V0Q29uZmlnRGVhZGxpbmUiLCJhZGRTdGF0dXNXYXRjaGVyIiwiYWRkU3RyZWFtRW5kV2F0Y2hlciIsImFkZEZpbHRlcnMiLCJnZXRDYWxsTnVtYmVyIiwic3RhcnRSZWFkIiwiZW5kIiwic2VuZE1lc3NhZ2VXaXRoQ29udGV4dCIsImNvbnRleHQiLCJ3cml0ZU9iaiIsImNiIiwiY2FsbCIsInNlbmRNZXNzYWdlIiwiaGFsZkNsb3NlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/call-stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/call.js":
/*!******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ClientDuplexStreamImpl = exports.ClientWritableStreamImpl = exports.ClientReadableStreamImpl = exports.ClientUnaryCallImpl = exports.callErrorFromStatus = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\n/**\n * Construct a ServiceError from a StatusObject. This function exists primarily\n * as an attempt to make the error stack trace clearly communicate that the\n * error is not necessarily a problem in gRPC itself.\n * @param status\n */ function callErrorFromStatus(status, callerStack) {\n    const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;\n    const error = new Error(message);\n    const stack = `${error.stack}\\nfor call at\\n${callerStack}`;\n    return Object.assign(new Error(message), status, {\n        stack\n    });\n}\nexports.callErrorFromStatus = callErrorFromStatus;\nclass ClientUnaryCallImpl extends events_1.EventEmitter {\n    constructor(){\n        super();\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled on client\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n}\nexports.ClientUnaryCallImpl = ClientUnaryCallImpl;\nclass ClientReadableStreamImpl extends stream_1.Readable {\n    constructor(deserialize){\n        super({\n            objectMode: true\n        });\n        this.deserialize = deserialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled on client\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    _read(_size) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n}\nexports.ClientReadableStreamImpl = ClientReadableStreamImpl;\nclass ClientWritableStreamImpl extends stream_1.Writable {\n    constructor(serialize){\n        super({\n            objectMode: true\n        });\n        this.serialize = serialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled on client\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    _write(chunk, encoding, cb) {\n        var _a;\n        const context = {\n            callback: cb\n        };\n        const flags = Number(encoding);\n        if (!Number.isNaN(flags)) {\n            context.flags = flags;\n        }\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n    _final(cb) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n        cb();\n    }\n}\nexports.ClientWritableStreamImpl = ClientWritableStreamImpl;\nclass ClientDuplexStreamImpl extends stream_1.Duplex {\n    constructor(serialize, deserialize){\n        super({\n            objectMode: true\n        });\n        this.serialize = serialize;\n        this.deserialize = deserialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled on client\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    _read(_size) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n    _write(chunk, encoding, cb) {\n        var _a;\n        const context = {\n            callback: cb\n        };\n        const flags = Number(encoding);\n        if (!Number.isNaN(flags)) {\n            context.flags = flags;\n        }\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n    _final(cb) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n        cb();\n    }\n}\nexports.ClientDuplexStreamImpl = ClientDuplexStreamImpl; //# sourceMappingURL=call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsOEJBQThCLEdBQUdBLGdDQUFnQyxHQUFHQSxnQ0FBZ0MsR0FBR0EsMkJBQTJCLEdBQUdBLDJCQUEyQixHQUFHLEtBQUs7QUFDeEssTUFBTU8sV0FBV0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsOEVBQWE7QUFDekM7Ozs7O0NBS0MsR0FDRCxTQUFTRixvQkFBb0JLLE1BQU0sRUFBRUMsV0FBVztJQUM1QyxNQUFNQyxVQUFVLENBQUMsRUFBRUYsT0FBT0csSUFBSSxDQUFDLENBQUMsRUFBRUosWUFBWUssTUFBTSxDQUFDSixPQUFPRyxJQUFJLENBQUMsQ0FBQyxFQUFFLEVBQUVILE9BQU9LLE9BQU8sQ0FBQyxDQUFDO0lBQ3RGLE1BQU1DLFFBQVEsSUFBSUMsTUFBTUw7SUFDeEIsTUFBTU0sUUFBUSxDQUFDLEVBQUVGLE1BQU1FLEtBQUssQ0FBQyxlQUFlLEVBQUVQLFlBQVksQ0FBQztJQUMzRCxPQUFPZCxPQUFPc0IsTUFBTSxDQUFDLElBQUlGLE1BQU1MLFVBQVVGLFFBQVE7UUFBRVE7SUFBTTtBQUM3RDtBQUNBbkIsMkJBQTJCLEdBQUdNO0FBQzlCLE1BQU1ELDRCQUE0QkUsU0FBU2MsWUFBWTtJQUNuREMsYUFBYztRQUNWLEtBQUs7SUFDVDtJQUNBQyxTQUFTO1FBQ0wsSUFBSUM7UUFDSEEsQ0FBQUEsS0FBSyxJQUFJLENBQUNDLElBQUksTUFBTSxRQUFRRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdFLGdCQUFnQixDQUFDaEIsWUFBWUssTUFBTSxDQUFDWSxTQUFTLEVBQUU7SUFDNUc7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IndlYnBhY2s6Ly9hc2htaXR0LWd1cHRhLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NhbGwuanM/ZmUzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DbGllbnREdXBsZXhTdHJlYW1JbXBsID0gZXhwb3J0cy5DbGllbnRXcml0YWJsZVN0cmVhbUltcGwgPSBleHBvcnRzLkNsaWVudFJlYWRhYmxlU3RyZWFtSW1wbCA9IGV4cG9ydHMuQ2xpZW50VW5hcnlDYWxsSW1wbCA9IGV4cG9ydHMuY2FsbEVycm9yRnJvbVN0YXR1cyA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuLyoqXG4gKiBDb25zdHJ1Y3QgYSBTZXJ2aWNlRXJyb3IgZnJvbSBhIFN0YXR1c09iamVjdC4gVGhpcyBmdW5jdGlvbiBleGlzdHMgcHJpbWFyaWx5XG4gKiBhcyBhbiBhdHRlbXB0IHRvIG1ha2UgdGhlIGVycm9yIHN0YWNrIHRyYWNlIGNsZWFybHkgY29tbXVuaWNhdGUgdGhhdCB0aGVcbiAqIGVycm9yIGlzIG5vdCBuZWNlc3NhcmlseSBhIHByb2JsZW0gaW4gZ1JQQyBpdHNlbGYuXG4gKiBAcGFyYW0gc3RhdHVzXG4gKi9cbmZ1bmN0aW9uIGNhbGxFcnJvckZyb21TdGF0dXMoc3RhdHVzLCBjYWxsZXJTdGFjaykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgJHtzdGF0dXMuY29kZX0gJHtjb25zdGFudHNfMS5TdGF0dXNbc3RhdHVzLmNvZGVdfTogJHtzdGF0dXMuZGV0YWlsc31gO1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIGNvbnN0IHN0YWNrID0gYCR7ZXJyb3Iuc3RhY2t9XFxuZm9yIGNhbGwgYXRcXG4ke2NhbGxlclN0YWNrfWA7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKG1lc3NhZ2UpLCBzdGF0dXMsIHsgc3RhY2sgfSk7XG59XG5leHBvcnRzLmNhbGxFcnJvckZyb21TdGF0dXMgPSBjYWxsRXJyb3JGcm9tU3RhdHVzO1xuY2xhc3MgQ2xpZW50VW5hcnlDYWxsSW1wbCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdDYW5jZWxsZWQgb24gY2xpZW50Jyk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICd1bmtub3duJztcbiAgICB9XG59XG5leHBvcnRzLkNsaWVudFVuYXJ5Q2FsbEltcGwgPSBDbGllbnRVbmFyeUNhbGxJbXBsO1xuY2xhc3MgQ2xpZW50UmVhZGFibGVTdHJlYW1JbXBsIGV4dGVuZHMgc3RyZWFtXzEuUmVhZGFibGUge1xuICAgIGNvbnN0cnVjdG9yKGRlc2VyaWFsaXplKSB7XG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELCAnQ2FuY2VsbGVkIG9uIGNsaWVudCcpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UGVlcigpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAndW5rbm93bic7XG4gICAgfVxuICAgIF9yZWFkKF9zaXplKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnRSZWFkKCk7XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnRSZWFkYWJsZVN0cmVhbUltcGwgPSBDbGllbnRSZWFkYWJsZVN0cmVhbUltcGw7XG5jbGFzcyBDbGllbnRXcml0YWJsZVN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5Xcml0YWJsZSB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWFsaXplKSB7XG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdDYW5jZWxsZWQgb24gY2xpZW50Jyk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICd1bmtub3duJztcbiAgICB9XG4gICAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmbGFncyA9IE51bWJlcihlbmNvZGluZyk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGZsYWdzKSkge1xuICAgICAgICAgICAgY29udGV4dC5mbGFncyA9IGZsYWdzO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgY2h1bmspO1xuICAgIH1cbiAgICBfZmluYWwoY2IpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYWxmQ2xvc2UoKTtcbiAgICAgICAgY2IoKTtcbiAgICB9XG59XG5leHBvcnRzLkNsaWVudFdyaXRhYmxlU3RyZWFtSW1wbCA9IENsaWVudFdyaXRhYmxlU3RyZWFtSW1wbDtcbmNsYXNzIENsaWVudER1cGxleFN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5EdXBsZXgge1xuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUpIHtcbiAgICAgICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELCAnQ2FuY2VsbGVkIG9uIGNsaWVudCcpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UGVlcigpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAndW5rbm93bic7XG4gICAgfVxuICAgIF9yZWFkKF9zaXplKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnRSZWFkKCk7XG4gICAgfVxuICAgIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBOdW1iZXIoZW5jb2RpbmcpO1xuICAgICAgICBpZiAoIU51bWJlci5pc05hTihmbGFncykpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIGNodW5rKTtcbiAgICB9XG4gICAgX2ZpbmFsKGNiKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFsZkNsb3NlKCk7XG4gICAgICAgIGNiKCk7XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnREdXBsZXhTdHJlYW1JbXBsID0gQ2xpZW50RHVwbGV4U3RyZWFtSW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2xpZW50RHVwbGV4U3RyZWFtSW1wbCIsIkNsaWVudFdyaXRhYmxlU3RyZWFtSW1wbCIsIkNsaWVudFJlYWRhYmxlU3RyZWFtSW1wbCIsIkNsaWVudFVuYXJ5Q2FsbEltcGwiLCJjYWxsRXJyb3JGcm9tU3RhdHVzIiwiZXZlbnRzXzEiLCJyZXF1aXJlIiwic3RyZWFtXzEiLCJjb25zdGFudHNfMSIsInN0YXR1cyIsImNhbGxlclN0YWNrIiwibWVzc2FnZSIsImNvZGUiLCJTdGF0dXMiLCJkZXRhaWxzIiwiZXJyb3IiLCJFcnJvciIsInN0YWNrIiwiYXNzaWduIiwiRXZlbnRFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJjYW5jZWwiLCJfYSIsImNhbGwiLCJjYW5jZWxXaXRoU3RhdHVzIiwiQ0FOQ0VMTEVEIiwiZ2V0UGVlciIsIl9iIiwiUmVhZGFibGUiLCJkZXNlcmlhbGl6ZSIsIm9iamVjdE1vZGUiLCJfcmVhZCIsIl9zaXplIiwic3RhcnRSZWFkIiwiV3JpdGFibGUiLCJzZXJpYWxpemUiLCJfd3JpdGUiLCJjaHVuayIsImVuY29kaW5nIiwiY2IiLCJjb250ZXh0IiwiY2FsbGJhY2siLCJmbGFncyIsIk51bWJlciIsImlzTmFOIiwic2VuZE1lc3NhZ2VXaXRoQ29udGV4dCIsIl9maW5hbCIsImhhbGZDbG9zZSIsIkR1cGxleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/call.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-credentials.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ChannelCredentials = void 0;\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction verifyIsBufferOrNull(obj, friendlyName) {\n    if (obj && !(obj instanceof Buffer)) {\n        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\n    }\n}\nfunction bufferOrNullEqual(buf1, buf2) {\n    if (buf1 === null && buf2 === null) {\n        return true;\n    } else {\n        return buf1 !== null && buf2 !== null && buf1.equals(buf2);\n    }\n}\n/**\n * A class that contains credentials for communicating over a channel, as well\n * as a set of per-call credentials, which are applied to every method call made\n * over a channel initialized with an instance of this class.\n */ class ChannelCredentials {\n    constructor(callCredentials){\n        this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();\n    }\n    /**\n     * Gets the set of per-call credentials associated with this instance.\n     */ _getCallCredentials() {\n        return this.callCredentials;\n    }\n    /**\n     * Return a new ChannelCredentials instance with a given set of credentials.\n     * The resulting instance can be used to construct a Channel that communicates\n     * over TLS.\n     * @param rootCerts The root certificate data.\n     * @param privateKey The client certificate private key, if available.\n     * @param certChain The client certificate key chain, if available.\n     * @param verifyOptions Additional options to modify certificate verification\n     */ static createSsl(rootCerts, privateKey, certChain, verifyOptions) {\n        var _a;\n        verifyIsBufferOrNull(rootCerts, \"Root certificate\");\n        verifyIsBufferOrNull(privateKey, \"Private key\");\n        verifyIsBufferOrNull(certChain, \"Certificate chain\");\n        if (privateKey && !certChain) {\n            throw new Error(\"Private key must be given with accompanying certificate chain\");\n        }\n        if (!privateKey && certChain) {\n            throw new Error(\"Certificate chain must be given with accompanying private key\");\n        }\n        const secureContext = tls_1.createSecureContext({\n            ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : tls_helpers_1.getDefaultRootsData()) !== null && _a !== void 0 ? _a : undefined,\n            key: privateKey !== null && privateKey !== void 0 ? privateKey : undefined,\n            cert: certChain !== null && certChain !== void 0 ? certChain : undefined,\n            ciphers: tls_helpers_1.CIPHER_SUITES\n        });\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n    }\n    /**\n     * Return a new ChannelCredentials instance with credentials created using\n     * the provided secureContext. The resulting instances can be used to\n     * construct a Channel that communicates over TLS. gRPC will not override\n     * anything in the provided secureContext, so the environment variables\n     * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will\n     * not be applied.\n     * @param secureContext The return value of tls.createSecureContext()\n     * @param verifyOptions Additional options to modify certificate verification\n     */ static createFromSecureContext(secureContext, verifyOptions) {\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n    }\n    /**\n     * Return a new ChannelCredentials instance with no credentials.\n     */ static createInsecure() {\n        return new InsecureChannelCredentialsImpl();\n    }\n}\nexports.ChannelCredentials = ChannelCredentials;\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\n    constructor(callCredentials){\n        super(callCredentials);\n    }\n    compose(callCredentials) {\n        throw new Error(\"Cannot compose insecure credentials\");\n    }\n    _getConnectionOptions() {\n        return null;\n    }\n    _isSecure() {\n        return false;\n    }\n    _equals(other) {\n        return other instanceof InsecureChannelCredentialsImpl;\n    }\n}\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\n    constructor(secureContext, verifyOptions){\n        super();\n        this.secureContext = secureContext;\n        this.verifyOptions = verifyOptions;\n        this.connectionOptions = {\n            secureContext\n        };\n        // Node asserts that this option is a function, so we cannot pass undefined\n        if (verifyOptions === null || verifyOptions === void 0 ? void 0 : verifyOptions.checkServerIdentity) {\n            this.connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;\n        }\n    }\n    compose(callCredentials) {\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);\n    }\n    _getConnectionOptions() {\n        // Copy to prevent callers from mutating this.connectionOptions\n        return Object.assign({}, this.connectionOptions);\n    }\n    _isSecure() {\n        return true;\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof SecureChannelCredentialsImpl) {\n            return this.secureContext === other.secureContext && this.verifyOptions.checkServerIdentity === other.verifyOptions.checkServerIdentity;\n        } else {\n            return false;\n        }\n    }\n}\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\n    constructor(channelCredentials, callCreds){\n        super(callCreds);\n        this.channelCredentials = channelCredentials;\n    }\n    compose(callCredentials) {\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n        return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);\n    }\n    _getConnectionOptions() {\n        return this.channelCredentials._getConnectionOptions();\n    }\n    _isSecure() {\n        return true;\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ComposedChannelCredentialsImpl) {\n            return this.channelCredentials._equals(other.channelCredentials) && this.callCredentials._equals(other.callCredentials);\n        } else {\n            return false;\n        }\n    }\n} //# sourceMappingURL=channel-credentials.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1jcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMEJBQTBCLEdBQUcsS0FBSztBQUNsQyxNQUFNRyxRQUFRQyxtQkFBT0EsQ0FBQyxnQkFBSztBQUMzQixNQUFNQyxxQkFBcUJELG1CQUFPQSxDQUFDLDRGQUFvQjtBQUN2RCxNQUFNRSxnQkFBZ0JGLG1CQUFPQSxDQUFDLGtGQUFlO0FBQzdDLDhEQUE4RDtBQUM5RCxTQUFTRyxxQkFBcUJDLEdBQUcsRUFBRUMsWUFBWTtJQUMzQyxJQUFJRCxPQUFPLENBQUVBLENBQUFBLGVBQWVFLE1BQUssR0FBSTtRQUNqQyxNQUFNLElBQUlDLFVBQVUsQ0FBQyxFQUFFRixhQUFhLGdDQUFnQyxDQUFDO0lBQ3pFO0FBQ0o7QUFDQSxTQUFTRyxrQkFBa0JDLElBQUksRUFBRUMsSUFBSTtJQUNqQyxJQUFJRCxTQUFTLFFBQVFDLFNBQVMsTUFBTTtRQUNoQyxPQUFPO0lBQ1gsT0FDSztRQUNELE9BQU9ELFNBQVMsUUFBUUMsU0FBUyxRQUFRRCxLQUFLRSxNQUFNLENBQUNEO0lBQ3pEO0FBQ0o7QUFDQTs7OztDQUlDLEdBQ0QsTUFBTVo7SUFDRmMsWUFBWUMsZUFBZSxDQUFFO1FBQ3pCLElBQUksQ0FBQ0EsZUFBZSxHQUFHQSxtQkFBbUJaLG1CQUFtQmEsZUFBZSxDQUFDQyxXQUFXO0lBQzVGO0lBQ0E7O0tBRUMsR0FDREMsc0JBQXNCO1FBQ2xCLE9BQU8sSUFBSSxDQUFDSCxlQUFlO0lBQy9CO0lBQ0E7Ozs7Ozs7O0tBUUMsR0FDRCxPQUFPSSxVQUFVQyxTQUFTLEVBQUVDLFVBQVUsRUFBRUMsU0FBUyxFQUFFQyxhQUFhLEVBQUU7UUFDOUQsSUFBSUM7UUFDSm5CLHFCQUFxQmUsV0FBVztRQUNoQ2YscUJB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Q0E7UUFDTixJQUFJLENBQUNELGtCQUFrQixHQUFHQTtJQUM5QjtJQUNBVixRQUFReEIsZUFBZSxFQUFFO1FBQ3JCLE1BQU0rQiwwQkFBMEIsSUFBSSxDQUFDL0IsZUFBZSxDQUFDd0IsT0FBTyxDQUFDeEI7UUFDN0QsT0FBTyxJQUFJZ0MsK0JBQStCLElBQUksQ0FBQ0Usa0JBQWtCLEVBQUVIO0lBQ3ZFO0lBQ0FOLHdCQUF3QjtRQUNwQixPQUFPLElBQUksQ0FBQ1Msa0JBQWtCLENBQUNULHFCQUFxQjtJQUN4RDtJQUNBQyxZQUFZO1FBQ1IsT0FBTztJQUNYO0lBQ0FDLFFBQVFDLEtBQUssRUFBRTtRQUNYLElBQUksSUFBSSxLQUFLQSxPQUFPO1lBQ2hCLE9BQU87UUFDWDtRQUNBLElBQUlBLGlCQUFpQkksZ0NBQWdDO1lBQ2pELE9BQVEsSUFBSSxDQUFDRSxrQkFBa0IsQ0FBQ1AsT0FBTyxDQUFDQyxNQUFNTSxrQkFBa0IsS0FDNUQsSUFBSSxDQUFDbEMsZUFBZSxDQUFDMkIsT0FBTyxDQUFDQyxNQUFNNUIsZUFBZTtRQUMxRCxPQUNLO1lBQ0QsT0FBTztRQUNYO0lBQ0o7QUFDSixFQUNBLCtDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FzaG1pdHQtZ3VwdGEvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1jcmVkZW50aWFscy5qcz84ZTcwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoYW5uZWxDcmVkZW50aWFscyA9IHZvaWQgMDtcbmNvbnN0IHRsc18xID0gcmVxdWlyZShcInRsc1wiKTtcbmNvbnN0IGNhbGxfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL2NhbGwtY3JlZGVudGlhbHNcIik7XG5jb25zdCB0bHNfaGVscGVyc18xID0gcmVxdWlyZShcIi4vdGxzLWhlbHBlcnNcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gdmVyaWZ5SXNCdWZmZXJPck51bGwob2JqLCBmcmllbmRseU5hbWUpIHtcbiAgICBpZiAob2JqICYmICEob2JqIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2ZyaWVuZGx5TmFtZX0sIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgQnVmZmVyLmApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1ZmZlck9yTnVsbEVxdWFsKGJ1ZjEsIGJ1ZjIpIHtcbiAgICBpZiAoYnVmMSA9PT0gbnVsbCAmJiBidWYyID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJ1ZjEgIT09IG51bGwgJiYgYnVmMiAhPT0gbnVsbCAmJiBidWYxLmVxdWFscyhidWYyKTtcbiAgICB9XG59XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBjb250YWlucyBjcmVkZW50aWFscyBmb3IgY29tbXVuaWNhdGluZyBvdmVyIGEgY2hhbm5lbCwgYXMgd2VsbFxuICogYXMgYSBzZXQgb2YgcGVyLWNhbGwgY3JlZGVudGlhbHMsIHdoaWNoIGFyZSBhcHBsaWVkIHRvIGV2ZXJ5IG1ldGhvZCBjYWxsIG1hZGVcbiAqIG92ZXIgYSBjaGFubmVsIGluaXRpYWxpemVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAqL1xuY2xhc3MgQ2hhbm5lbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhpcy5jYWxsQ3JlZGVudGlhbHMgPSBjYWxsQ3JlZGVudGlhbHMgfHwgY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVFbXB0eSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzZXQgb2YgcGVyLWNhbGwgY3JlZGVudGlhbHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgX2dldENhbGxDcmVkZW50aWFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbENyZWRlbnRpYWxzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgQ2hhbm5lbENyZWRlbnRpYWxzIGluc3RhbmNlIHdpdGggYSBnaXZlbiBzZXQgb2YgY3JlZGVudGlhbHMuXG4gICAgICogVGhlIHJlc3VsdGluZyBpbnN0YW5jZSBjYW4gYmUgdXNlZCB0byBjb25zdHJ1Y3QgYSBDaGFubmVsIHRoYXQgY29tbXVuaWNhdGVzXG4gICAgICogb3ZlciBUTFMuXG4gICAgICogQHBhcmFtIHJvb3RDZXJ0cyBUaGUgcm9vdCBjZXJ0aWZpY2F0ZSBkYXRhLlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IFRoZSBjbGllbnQgY2VydGlmaWNhdGUgcHJpdmF0ZSBrZXksIGlmIGF2YWlsYWJsZS5cbiAgICAgKiBAcGFyYW0gY2VydENoYWluIFRoZSBjbGllbnQgY2VydGlmaWNhdGUga2V5IGNoYWluLCBpZiBhdmFpbGFibGUuXG4gICAgICogQHBhcmFtIHZlcmlmeU9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIG1vZGlmeSBjZXJ0aWZpY2F0ZSB2ZXJpZmljYXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU3NsKHJvb3RDZXJ0cywgcHJpdmF0ZUtleSwgY2VydENoYWluLCB2ZXJpZnlPcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmVyaWZ5SXNCdWZmZXJPck51bGwocm9vdENlcnRzLCAnUm9vdCBjZXJ0aWZpY2F0ZScpO1xuICAgICAgICB2ZXJpZnlJc0J1ZmZlck9yTnVsbChwcml2YXRlS2V5LCAnUHJpdmF0ZSBrZXknKTtcbiAgICAgICAgdmVyaWZ5SXNCdWZmZXJPck51bGwoY2VydENoYWluLCAnQ2VydGlmaWNhdGUgY2hhaW4nKTtcbiAgICAgICAgaWYgKHByaXZhdGVLZXkgJiYgIWNlcnRDaGFpbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcml2YXRlIGtleSBtdXN0IGJlIGdpdmVuIHdpdGggYWNjb21wYW55aW5nIGNlcnRpZmljYXRlIGNoYWluJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcml2YXRlS2V5ICYmIGNlcnRDaGFpbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDZXJ0aWZpY2F0ZSBjaGFpbiBtdXN0IGJlIGdpdmVuIHdpdGggYWNjb21wYW55aW5nIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VjdXJlQ29udGV4dCA9IHRsc18xLmNyZWF0ZVNlY3VyZUNvbnRleHQoe1xuICAgICAgICAgICAgY2E6IChfYSA9IHJvb3RDZXJ0cyAhPT0gbnVsbCAmJiByb290Q2VydHMgIT09IHZvaWQgMCA/IHJvb3RDZXJ0cyA6IHRsc19oZWxwZXJzXzEuZ2V0RGVmYXVsdFJvb3RzRGF0YSgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBrZXk6IHByaXZhdGVLZXkgIT09IG51bGwgJiYgcHJpdmF0ZUtleSAhPT0gdm9pZCAwID8gcHJpdmF0ZUtleSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNlcnQ6IGNlcnRDaGFpbiAhPT0gbnVsbCAmJiBjZXJ0Q2hhaW4gIT09IHZvaWQgMCA/IGNlcnRDaGFpbiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNpcGhlcnM6IHRsc19oZWxwZXJzXzEuQ0lQSEVSX1NVSVRFUyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgU2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbChzZWN1cmVDb250ZXh0LCB2ZXJpZnlPcHRpb25zICE9PSBudWxsICYmIHZlcmlmeU9wdGlvbnMgIT09IHZvaWQgMCA/IHZlcmlmeU9wdGlvbnMgOiB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBDaGFubmVsQ3JlZGVudGlhbHMgaW5zdGFuY2Ugd2l0aCBjcmVkZW50aWFscyBjcmVhdGVkIHVzaW5nXG4gICAgICogdGhlIHByb3ZpZGVkIHNlY3VyZUNvbnRleHQuIFRoZSByZXN1bHRpbmcgaW5zdGFuY2VzIGNhbiBiZSB1c2VkIHRvXG4gICAgICogY29uc3RydWN0IGEgQ2hhbm5lbCB0aGF0IGNvbW11bmljYXRlcyBvdmVyIFRMUy4gZ1JQQyB3aWxsIG5vdCBvdmVycmlkZVxuICAgICAqIGFueXRoaW5nIGluIHRoZSBwcm92aWRlZCBzZWN1cmVDb250ZXh0LCBzbyB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgICogR1JQQ19TU0xfQ0lQSEVSX1NVSVRFUyBhbmQgR1JQQ19ERUZBVUxUX1NTTF9ST09UU19GSUxFX1BBVEggd2lsbFxuICAgICAqIG5vdCBiZSBhcHBsaWVkLlxuICAgICAqIEBwYXJhbSBzZWN1cmVDb250ZXh0IFRoZSByZXR1cm4gdmFsdWUgb2YgdGxzLmNyZWF0ZVNlY3VyZUNvbnRleHQoKVxuICAgICAqIEBwYXJhbSB2ZXJpZnlPcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBtb2RpZnkgY2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZyb21TZWN1cmVDb250ZXh0KHNlY3VyZUNvbnRleHQsIHZlcmlmeU9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsKHNlY3VyZUNvbnRleHQsIHZlcmlmeU9wdGlvbnMgIT09IG51bGwgJiYgdmVyaWZ5T3B0aW9ucyAhPT0gdm9pZCAwID8gdmVyaWZ5T3B0aW9ucyA6IHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IENoYW5uZWxDcmVkZW50aWFscyBpbnN0YW5jZSB3aXRoIG5vIGNyZWRlbnRpYWxzLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJbnNlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwoKTtcbiAgICB9XG59XG5leHBvcnRzLkNoYW5uZWxDcmVkZW50aWFscyA9IENoYW5uZWxDcmVkZW50aWFscztcbmNsYXNzIEluc2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCBleHRlbmRzIENoYW5uZWxDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3IoY2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgIHN1cGVyKGNhbGxDcmVkZW50aWFscyk7XG4gICAgfVxuICAgIGNvbXBvc2UoY2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXBvc2UgaW5zZWN1cmUgY3JlZGVudGlhbHMnKTtcbiAgICB9XG4gICAgX2dldENvbm5lY3Rpb25PcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgX2lzU2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgSW5zZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsO1xuICAgIH1cbn1cbmNsYXNzIFNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwgZXh0ZW5kcyBDaGFubmVsQ3JlZGVudGlhbHMge1xuICAgIGNvbnN0cnVjdG9yKHNlY3VyZUNvbnRleHQsIHZlcmlmeU9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZWN1cmVDb250ZXh0ID0gc2VjdXJlQ29udGV4dDtcbiAgICAgICAgdGhpcy52ZXJpZnlPcHRpb25zID0gdmVyaWZ5T3B0aW9ucztcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHNlY3VyZUNvbnRleHRcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTm9kZSBhc3NlcnRzIHRoYXQgdGhpcyBvcHRpb24gaXMgYSBmdW5jdGlvbiwgc28gd2UgY2Fubm90IHBhc3MgdW5kZWZpbmVkXG4gICAgICAgIGlmICh2ZXJpZnlPcHRpb25zID09PSBudWxsIHx8IHZlcmlmeU9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZlcmlmeU9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uT3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5ID0gdmVyaWZ5T3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvc2UoY2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkQ2FsbENyZWRlbnRpYWxzID0gdGhpcy5jYWxsQ3JlZGVudGlhbHMuY29tcG9zZShjYWxsQ3JlZGVudGlhbHMpO1xuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2VkQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCh0aGlzLCBjb21iaW5lZENhbGxDcmVkZW50aWFscyk7XG4gICAgfVxuICAgIF9nZXRDb25uZWN0aW9uT3B0aW9ucygpIHtcbiAgICAgICAgLy8gQ29weSB0byBwcmV2ZW50IGNhbGxlcnMgZnJvbSBtdXRhdGluZyB0aGlzLmNvbm5lY3Rpb25PcHRpb25zXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbm5lY3Rpb25PcHRpb25zKTtcbiAgICB9XG4gICAgX2lzU2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX2VxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5zZWN1cmVDb250ZXh0ID09PSBvdGhlci5zZWN1cmVDb250ZXh0ICYmXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJpZnlPcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkgPT09IG90aGVyLnZlcmlmeU9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBDb21wb3NlZENoYW5uZWxDcmVkZW50aWFsc0ltcGwgZXh0ZW5kcyBDaGFubmVsQ3JlZGVudGlhbHMge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxDcmVkZW50aWFscywgY2FsbENyZWRzKSB7XG4gICAgICAgIHN1cGVyKGNhbGxDcmVkcyk7XG4gICAgICAgIHRoaXMuY2hhbm5lbENyZWRlbnRpYWxzID0gY2hhbm5lbENyZWRlbnRpYWxzO1xuICAgIH1cbiAgICBjb21wb3NlKGNhbGxDcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCBjb21iaW5lZENhbGxDcmVkZW50aWFscyA9IHRoaXMuY2FsbENyZWRlbnRpYWxzLmNvbXBvc2UoY2FsbENyZWRlbnRpYWxzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NlZENoYW5uZWxDcmVkZW50aWFsc0ltcGwodGhpcy5jaGFubmVsQ3JlZGVudGlhbHMsIGNvbWJpbmVkQ2FsbENyZWRlbnRpYWxzKTtcbiAgICB9XG4gICAgX2dldENvbm5lY3Rpb25PcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsQ3JlZGVudGlhbHMuX2dldENvbm5lY3Rpb25PcHRpb25zKCk7XG4gICAgfVxuICAgIF9pc1NlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDb21wb3NlZENoYW5uZWxDcmVkZW50aWFsc0ltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGFubmVsQ3JlZGVudGlhbHMuX2VxdWFscyhvdGhlci5jaGFubmVsQ3JlZGVudGlhbHMpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsQ3JlZGVudGlhbHMuX2VxdWFscyhvdGhlci5jYWxsQ3JlZGVudGlhbHMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5uZWwtY3JlZGVudGlhbHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2hhbm5lbENyZWRlbnRpYWxzIiwidGxzXzEiLCJyZXF1aXJlIiwiY2FsbF9jcmVkZW50aWFsc18xIiwidGxzX2hlbHBlcnNfMSIsInZlcmlmeUlzQnVmZmVyT3JOdWxsIiwib2JqIiwiZnJpZW5kbHlOYW1lIiwiQnVmZmVyIiwiVHlwZUVycm9yIiwiYnVmZmVyT3JOdWxsRXF1YWwiLCJidWYxIiwiYnVmMiIsImVxdWFscyIsImNvbnN0cnVjdG9yIiwiY2FsbENyZWRlbnRpYWxzIiwiQ2FsbENyZWRlbnRpYWxzIiwiY3JlYXRlRW1wdHkiLCJfZ2V0Q2FsbENyZWRlbnRpYWxzIiwiY3JlYXRlU3NsIiwicm9vdENlcnRzIiwicHJpdmF0ZUtleSIsImNlcnRDaGFpbiIsInZlcmlmeU9wdGlvbnMiLCJfYSIsIkVycm9yIiwic2VjdXJlQ29udGV4dCIsImNyZWF0ZVNlY3VyZUNvbnRleHQiLCJjYSIsImdldERlZmF1bHRSb290c0RhdGEiLCJ1bmRlZmluZWQiLCJrZXkiLCJjZXJ0IiwiY2lwaGVycyIsIkNJUEhFUl9TVUlURVMiLCJTZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsIiwiY3JlYXRlRnJvbVNlY3VyZUNvbnRleHQiLCJjcmVhdGVJbnNlY3VyZSIsIkluc2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCIsImNvbXBvc2UiLCJfZ2V0Q29ubmVjdGlvbk9wdGlvbnMiLCJfaXNTZWN1cmUiLCJfZXF1YWxzIiwib3RoZXIiLCJjb25uZWN0aW9uT3B0aW9ucyIsImNoZWNrU2VydmVySWRlbnRpdHkiLCJjb21iaW5lZENhbGxDcmVkZW50aWFscyIsIkNvbXBvc2VkQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCIsImFzc2lnbiIsImNoYW5uZWxDcmVkZW50aWFscyIsImNhbGxDcmVkcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-options.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-options.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.channelOptionsEqual = exports.recognizedOptions = void 0;\n/**\n * This is for checking provided options at runtime. This is an object for\n * easier membership checking.\n */ exports.recognizedOptions = {\n    \"grpc.ssl_target_name_override\": true,\n    \"grpc.primary_user_agent\": true,\n    \"grpc.secondary_user_agent\": true,\n    \"grpc.default_authority\": true,\n    \"grpc.keepalive_time_ms\": true,\n    \"grpc.keepalive_timeout_ms\": true,\n    \"grpc.keepalive_permit_without_calls\": true,\n    \"grpc.service_config\": true,\n    \"grpc.max_concurrent_streams\": true,\n    \"grpc.initial_reconnect_backoff_ms\": true,\n    \"grpc.max_reconnect_backoff_ms\": true,\n    \"grpc.use_local_subchannel_pool\": true,\n    \"grpc.max_send_message_length\": true,\n    \"grpc.max_receive_message_length\": true,\n    \"grpc.enable_http_proxy\": true,\n    \"grpc.enable_channelz\": true,\n    \"grpc.dns_min_time_between_resolutions_ms\": true,\n    \"grpc-node.max_session_memory\": true\n};\nfunction channelOptionsEqual(options1, options2) {\n    const keys1 = Object.keys(options1).sort();\n    const keys2 = Object.keys(options2).sort();\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for(let i = 0; i < keys1.length; i += 1){\n        if (keys1[i] !== keys2[i]) {\n            return false;\n        }\n        if (options1[keys1[i]] !== options2[keys2[i]]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.channelOptionsEqual = channelOptionsEqual; //# sourceMappingURL=channel-options.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1vcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQkFBMkIsR0FBR0EseUJBQXlCLEdBQUcsS0FBSztBQUMvRDs7O0NBR0MsR0FDREEseUJBQXlCLEdBQUc7SUFDeEIsaUNBQWlDO0lBQ2pDLDJCQUEyQjtJQUMzQiw2QkFBNkI7SUFDN0IsMEJBQTBCO0lBQzFCLDBCQUEwQjtJQUMxQiw2QkFBNkI7SUFDN0IsdUNBQXVDO0lBQ3ZDLHVCQUF1QjtJQUN2QiwrQkFBK0I7SUFDL0IscUNBQXFDO0lBQ3JDLGlDQUFpQztJQUNqQyxrQ0FBa0M7SUFDbEMsZ0NBQWdDO0lBQ2hDLG1DQUFtQztJQUNuQywwQkFBMEI7SUFDMUIsd0JBQXdCO0lBQ3hCLDRDQUE0QztJQUM1QyxnQ0FBZ0M7QUFDcEM7QUFDQSxTQUFTRSxvQkFBb0JFLFFBQVEsRUFBRUMsUUFBUTtJQUMzQyxNQUFNQyxRQUFRUixPQUFPUyxJQUFJLENBQUNILFVBQVVJLElBQUk7SUFDeEMsTUFBTUMsUUFBUVgsT0FBT1MsSUFBSSxDQUFDRixVQUFVRyxJQUFJO0lBQ3hDLElBQUlGLE1BQU1JLE1BQU0sS0FBS0QsTUFBTUMsTUFBTSxFQUFFO1FBQy9CLE9BQU87SUFDWDtJQUNBLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTCxNQUFNSSxNQUFNLEVBQUVDLEtBQUssRUFBRztRQUN0QyxJQUFJTCxLQUFLLENBQUNLLEVBQUUsS0FBS0YsS0FBSyxDQUFDRSxFQUFFLEVBQUU7WUFDdkIsT0FBTztRQUNYO1FBQ0EsSUFBSVAsUUFBUSxDQUFDRSxLQUFLLENBQUNLLEVBQUUsQ0FBQyxLQUFLTixRQUFRLENBQUNJLEtBQUssQ0FBQ0UsRUFBRSxDQUFDLEVBQUU7WUFDM0MsT0FBTztRQUNYO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFDQVgsMkJBQTJCLEdBQUdFLHFCQUM5QiwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc2htaXR0LWd1cHRhLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NoYW5uZWwtb3B0aW9ucy5qcz83NzZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNoYW5uZWxPcHRpb25zRXF1YWwgPSBleHBvcnRzLnJlY29nbml6ZWRPcHRpb25zID0gdm9pZCAwO1xuLyoqXG4gKiBUaGlzIGlzIGZvciBjaGVja2luZyBwcm92aWRlZCBvcHRpb25zIGF0IHJ1bnRpbWUuIFRoaXMgaXMgYW4gb2JqZWN0IGZvclxuICogZWFzaWVyIG1lbWJlcnNoaXAgY2hlY2tpbmcuXG4gKi9cbmV4cG9ydHMucmVjb2duaXplZE9wdGlvbnMgPSB7XG4gICAgJ2dycGMuc3NsX3RhcmdldF9uYW1lX292ZXJyaWRlJzogdHJ1ZSxcbiAgICAnZ3JwYy5wcmltYXJ5X3VzZXJfYWdlbnQnOiB0cnVlLFxuICAgICdncnBjLnNlY29uZGFyeV91c2VyX2FnZW50JzogdHJ1ZSxcbiAgICAnZ3JwYy5kZWZhdWx0X2F1dGhvcml0eSc6IHRydWUsXG4gICAgJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnOiB0cnVlLFxuICAgICdncnBjLmtlZXBhbGl2ZV90aW1lb3V0X21zJzogdHJ1ZSxcbiAgICAnZ3JwYy5rZWVwYWxpdmVfcGVybWl0X3dpdGhvdXRfY2FsbHMnOiB0cnVlLFxuICAgICdncnBjLnNlcnZpY2VfY29uZmlnJzogdHJ1ZSxcbiAgICAnZ3JwYy5tYXhfY29uY3VycmVudF9zdHJlYW1zJzogdHJ1ZSxcbiAgICAnZ3JwYy5pbml0aWFsX3JlY29ubmVjdF9iYWNrb2ZmX21zJzogdHJ1ZSxcbiAgICAnZ3JwYy5tYXhfcmVjb25uZWN0X2JhY2tvZmZfbXMnOiB0cnVlLFxuICAgICdncnBjLnVzZV9sb2NhbF9zdWJjaGFubmVsX3Bvb2wnOiB0cnVlLFxuICAgICdncnBjLm1heF9zZW5kX21lc3NhZ2VfbGVuZ3RoJzogdHJ1ZSxcbiAgICAnZ3JwYy5tYXhfcmVjZWl2ZV9tZXNzYWdlX2xlbmd0aCc6IHRydWUsXG4gICAgJ2dycGMuZW5hYmxlX2h0dHBfcHJveHknOiB0cnVlLFxuICAgICdncnBjLmVuYWJsZV9jaGFubmVseic6IHRydWUsXG4gICAgJ2dycGMuZG5zX21pbl90aW1lX2JldHdlZW5fcmVzb2x1dGlvbnNfbXMnOiB0cnVlLFxuICAgICdncnBjLW5vZGUubWF4X3Nlc3Npb25fbWVtb3J5JzogdHJ1ZSxcbn07XG5mdW5jdGlvbiBjaGFubmVsT3B0aW9uc0VxdWFsKG9wdGlvbnMxLCBvcHRpb25zMikge1xuICAgIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXMob3B0aW9uczEpLnNvcnQoKTtcbiAgICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9wdGlvbnMyKS5zb3J0KCk7XG4gICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzMS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoa2V5czFbaV0gIT09IGtleXMyW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMxW2tleXMxW2ldXSAhPT0gb3B0aW9uczJba2V5czJbaV1dKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmNoYW5uZWxPcHRpb25zRXF1YWwgPSBjaGFubmVsT3B0aW9uc0VxdWFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbm5lbC1vcHRpb25zLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNoYW5uZWxPcHRpb25zRXF1YWwiLCJyZWNvZ25pemVkT3B0aW9ucyIsIm9wdGlvbnMxIiwib3B0aW9uczIiLCJrZXlzMSIsImtleXMiLCJzb3J0Iiwia2V5czIiLCJsZW5ndGgiLCJpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/channel.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ChannelImplementation = void 0;\nconst call_stream_1 = __webpack_require__(/*! ./call-stream */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-stream.js\");\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nconst resolving_load_balancer_1 = __webpack_require__(/*! ./resolving-load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\");\nconst subchannel_pool_1 = __webpack_require__(/*! ./subchannel-pool */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\nconst call_credentials_filter_1 = __webpack_require__(/*! ./call-credentials-filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials-filter.js\");\nconst deadline_filter_1 = __webpack_require__(/*! ./deadline-filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/deadline-filter.js\");\nconst compression_filter_1 = __webpack_require__(/*! ./compression-filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst max_message_size_filter_1 = __webpack_require__(/*! ./max-message-size-filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js\");\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */ const MAX_TIMEOUT_TIME = 2147483647;\nlet nextCallNumber = 0;\nfunction getNewCallNumber() {\n    const callNumber = nextCallNumber;\n    nextCallNumber += 1;\n    if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n        nextCallNumber = 0;\n    }\n    return callNumber;\n}\nconst INAPPROPRIATE_CONTROL_PLANE_CODES = [\n    constants_1.Status.OK,\n    constants_1.Status.INVALID_ARGUMENT,\n    constants_1.Status.NOT_FOUND,\n    constants_1.Status.ALREADY_EXISTS,\n    constants_1.Status.FAILED_PRECONDITION,\n    constants_1.Status.ABORTED,\n    constants_1.Status.OUT_OF_RANGE,\n    constants_1.Status.DATA_LOSS\n];\nfunction restrictControlPlaneStatusCode(code, details) {\n    if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {\n        return {\n            code: constants_1.Status.INTERNAL,\n            details: `Invalid status from control plane: ${code} ${constants_1.Status[code]} ${details}`\n        };\n    } else {\n        return {\n            code,\n            details\n        };\n    }\n}\nclass ChannelImplementation {\n    constructor(target, credentials, options){\n        var _a, _b, _c, _d;\n        this.credentials = credentials;\n        this.options = options;\n        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n        this.currentPicker = new picker_1.UnavailablePicker();\n        /**\n         * Calls queued up to get a call config. Should only be populated before the\n         * first time the resolver returns a result, which includes the ConfigSelector.\n         */ this.configSelectionQueue = [];\n        this.pickQueue = [];\n        this.connectivityStateWatchers = [];\n        this.configSelector = null;\n        /**\n         * This is the error from the name resolver if it failed most recently. It\n         * is only used to end calls that start while there is no config selector\n         * and the name resolver is in backoff, so it should be nulled if\n         * configSelector becomes set or the channel state becomes anything other\n         * than TRANSIENT_FAILURE.\n         */ this.currentResolutionError = null;\n        // Channelz info\n        this.channelzEnabled = true;\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n        if (typeof target !== \"string\") {\n            throw new TypeError(\"Channel target must be a string\");\n        }\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n            throw new TypeError(\"Channel credentials must be a ChannelCredentials object\");\n        }\n        if (options) {\n            if (typeof options !== \"object\") {\n                throw new TypeError(\"Channel options must be an object\");\n            }\n        }\n        this.originalTarget = target;\n        const originalTargetUri = uri_parser_1.parseUri(target);\n        if (originalTargetUri === null) {\n            throw new Error(`Could not parse target name \"${target}\"`);\n        }\n        /* This ensures that the target has a scheme that is registered with the\n         * resolver */ const defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);\n        if (defaultSchemeMapResult === null) {\n            throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n        }\n        this.callRefTimer = setInterval(()=>{}, MAX_TIMEOUT_TIME);\n        (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        if (this.options[\"grpc.enable_channelz\"] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.channelzRef = channelz_1.registerChannelzChannel(target, ()=>this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Channel created\");\n        }\n        if (this.options[\"grpc.default_authority\"]) {\n            this.defaultAuthority = this.options[\"grpc.default_authority\"];\n        } else {\n            this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);\n        }\n        const proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options);\n        this.target = proxyMapResult.target;\n        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n         * the grpc.use_local_subchannel_pool channel option means. */ this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_c = options[\"grpc.use_local_subchannel_pool\"]) !== null && _c !== void 0 ? _c : 0) === 0);\n        const channelControlHelper = {\n            createSubchannel: (subchannelAddress, subchannelArgs)=>{\n                const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\n                if (this.channelzEnabled) {\n                    this.channelzTrace.addTrace(\"CT_INFO\", \"Created subchannel or used existing subchannel\", subchannel.getChannelzRef());\n                }\n                return subchannel;\n            },\n            updateState: (connectivityState, picker)=>{\n                this.currentPicker = picker;\n                const queueCopy = this.pickQueue.slice();\n                this.pickQueue = [];\n                this.callRefTimerUnref();\n                for (const { callStream, callMetadata, callConfig, dynamicFilters } of queueCopy){\n                    this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                }\n                this.updateState(connectivityState);\n            },\n            requestReresolution: ()=>{\n                // This should never be called.\n                throw new Error(\"Resolving load balancer should never call requestReresolution\");\n            },\n            addChannelzChild: (child)=>{\n                if (this.channelzEnabled) {\n                    this.childrenTracker.refChild(child);\n                }\n            },\n            removeChannelzChild: (child)=>{\n                if (this.channelzEnabled) {\n                    this.childrenTracker.unrefChild(child);\n                }\n            }\n        };\n        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, (configSelector)=>{\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace(\"CT_INFO\", \"Address resolution succeeded\");\n            }\n            this.configSelector = configSelector;\n            this.currentResolutionError = null;\n            /* We process the queue asynchronously to ensure that the corresponding\n             * load balancer update has completed. */ process.nextTick(()=>{\n                const localQueue = this.configSelectionQueue;\n                this.configSelectionQueue = [];\n                this.callRefTimerUnref();\n                for (const { callStream, callMetadata } of localQueue){\n                    this.tryGetConfig(callStream, callMetadata);\n                }\n                this.configSelectionQueue = [];\n            });\n        }, (status)=>{\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace(\"CT_WARNING\", \"Address resolution failed with code \" + status.code + ' and details \"' + status.details + '\"');\n            }\n            if (this.configSelectionQueue.length > 0) {\n                this.trace(\"Name resolution failed with calls queued for config selection\");\n            }\n            if (this.configSelector === null) {\n                this.currentResolutionError = Object.assign(Object.assign({}, restrictControlPlaneStatusCode(status.code, status.details)), {\n                    metadata: status.metadata\n                });\n            }\n            const localQueue = this.configSelectionQueue;\n            this.configSelectionQueue = [];\n            this.callRefTimerUnref();\n            for (const { callStream, callMetadata } of localQueue){\n                if (callMetadata.getOptions().waitForReady) {\n                    this.callRefTimerRef();\n                    this.configSelectionQueue.push({\n                        callStream,\n                        callMetadata\n                    });\n                } else {\n                    callStream.cancelWithStatus(status.code, status.details);\n                }\n            }\n        });\n        this.filterStackFactory = new filter_stack_1.FilterStackFactory([\n            new call_credentials_filter_1.CallCredentialsFilterFactory(this),\n            new deadline_filter_1.DeadlineFilterFactory(this),\n            new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options),\n            new compression_filter_1.CompressionFilterFactory(this, this.options)\n        ]);\n        this.trace(\"Channel constructed with options \" + JSON.stringify(options, undefined, 2));\n        const error = new Error();\n        logging_1.trace(constants_1.LogVerbosity.DEBUG, \"channel_stacktrace\", \"(\" + this.channelzRef.id + \") \" + \"Channel constructed \\n\" + ((_d = error.stack) === null || _d === void 0 ? void 0 : _d.substring(error.stack.indexOf(\"\\n\") + 1)));\n    }\n    getChannelzInfo() {\n        return {\n            target: this.originalTarget,\n            state: this.connectivityState,\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            children: this.childrenTracker.getChildLists()\n        };\n    }\n    trace(text, verbosityOverride) {\n        logging_1.trace(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, \"channel\", \"(\" + this.channelzRef.id + \") \" + uri_parser_1.uriToString(this.target) + \" \" + text);\n    }\n    callRefTimerRef() {\n        var _a, _b, _c, _d;\n        // If the hasRef function does not exist, always run the code\n        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n            this.trace(\"callRefTimer.ref | configSelectionQueue.length=\" + this.configSelectionQueue.length + \" pickQueue.length=\" + this.pickQueue.length);\n            (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n        }\n    }\n    callRefTimerUnref() {\n        var _a, _b;\n        // If the hasRef function does not exist, always run the code\n        if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n            this.trace(\"callRefTimer.unref | configSelectionQueue.length=\" + this.configSelectionQueue.length + \" pickQueue.length=\" + this.pickQueue.length);\n            (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    pushPick(callStream, callMetadata, callConfig, dynamicFilters) {\n        this.pickQueue.push({\n            callStream,\n            callMetadata,\n            callConfig,\n            dynamicFilters\n        });\n        this.callRefTimerRef();\n    }\n    /**\n     * Check the picker output for the given call and corresponding metadata,\n     * and take any relevant actions. Should not be called while iterating\n     * over pickQueue.\n     * @param callStream\n     * @param callMetadata\n     */ tryPick(callStream, callMetadata, callConfig, dynamicFilters) {\n        var _a, _b;\n        const pickResult = this.currentPicker.pick({\n            metadata: callMetadata,\n            extraPickInfo: callConfig.pickInformation\n        });\n        const subchannelString = pickResult.subchannel ? \"(\" + pickResult.subchannel.getChannelzRef().id + \") \" + pickResult.subchannel.getAddress() : \"\" + pickResult.subchannel;\n        this.trace(\"Pick result for call [\" + callStream.getCallNumber() + \"]: \" + picker_1.PickResultType[pickResult.pickResultType] + \" subchannel: \" + subchannelString + \" status: \" + ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) + \" \" + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));\n        switch(pickResult.pickResultType){\n            case picker_1.PickResultType.COMPLETE:\n                if (pickResult.subchannel === null) {\n                    callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, \"Request dropped by load balancing policy\");\n                // End the call with an error\n                } else {\n                    /* If the subchannel is not in the READY state, that indicates a bug\n                     * somewhere in the load balancer or picker. So, we log an error and\n                     * queue the pick to be tried again later. */ if (pickResult.subchannel.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) {\n                        logging_1.log(constants_1.LogVerbosity.ERROR, \"Error: COMPLETE pick result subchannel \" + subchannelString + \" has state \" + connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()]);\n                        this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n                        break;\n                    }\n                    /* We need to clone the callMetadata here because the transparent\n                     * retry code in the promise resolution handler use the same\n                     * callMetadata object, so it needs to stay unmodified */ callStream.filterStack.sendMetadata(Promise.resolve(callMetadata.clone())).then((finalMetadata)=>{\n                        var _a, _b, _c;\n                        const subchannelState = pickResult.subchannel.getConnectivityState();\n                        if (subchannelState === connectivity_state_1.ConnectivityState.READY) {\n                            try {\n                                const pickExtraFilters = pickResult.extraFilterFactories.map((factory)=>factory.createFilter(callStream));\n                                (_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getRealSubchannel().startCallStream(finalMetadata, callStream, [\n                                    ...dynamicFilters,\n                                    ...pickExtraFilters\n                                ]);\n                                /* If we reach this point, the call stream has started\n                                 * successfully */ (_b = callConfig.onCommitted) === null || _b === void 0 ? void 0 : _b.call(callConfig);\n                                (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);\n                            } catch (error) {\n                                const errorCode = error.code;\n                                if (errorCode === \"ERR_HTTP2_GOAWAY_SESSION\" || errorCode === \"ERR_HTTP2_INVALID_SESSION\") {\n                                    /* An error here indicates that something went wrong with\n                                     * the picked subchannel's http2 stream right before we\n                                     * tried to start the stream. We are handling a promise\n                                     * result here, so this is asynchronous with respect to the\n                                     * original tryPick call, so calling it again is not\n                                     * recursive. We call tryPick immediately instead of\n                                     * queueing this pick again because handling the queue is\n                                     * triggered by state changes, and we want to immediately\n                                     * check if the state has already changed since the\n                                     * previous tryPick call. We do this instead of cancelling\n                                     * the stream because the correct behavior may be\n                                     * re-queueing instead, based on the logic in the rest of\n                                     * tryPick */ this.trace(\"Failed to start call on picked subchannel \" + subchannelString + \" with error \" + error.message + \". Retrying pick\", constants_1.LogVerbosity.INFO);\n                                    this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                                } else {\n                                    this.trace(\"Failed to start call on picked subchanel \" + subchannelString + \" with error \" + error.message + \". Ending call\", constants_1.LogVerbosity.INFO);\n                                    callStream.cancelWithStatus(constants_1.Status.INTERNAL, `Failed to start HTTP/2 stream with error: ${error.message}`);\n                                }\n                            }\n                        } else {\n                            /* The logic for doing this here is the same as in the catch\n                             * block above */ this.trace(\"Picked subchannel \" + subchannelString + \" has state \" + connectivity_state_1.ConnectivityState[subchannelState] + \" after metadata filters. Retrying pick\", constants_1.LogVerbosity.INFO);\n                            this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                        }\n                    }, (error)=>{\n                        // We assume the error code isn't 0 (Status.OK)\n                        const { code, details } = restrictControlPlaneStatusCode(typeof error.code === \"number\" ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n                        callStream.cancelWithStatus(code, details);\n                    });\n                }\n                break;\n            case picker_1.PickResultType.QUEUE:\n                this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n                break;\n            case picker_1.PickResultType.TRANSIENT_FAILURE:\n                if (callMetadata.getOptions().waitForReady) {\n                    this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n                } else {\n                    const { code, details } = restrictControlPlaneStatusCode(pickResult.status.code, pickResult.status.details);\n                    callStream.cancelWithStatus(code, details);\n                }\n                break;\n            case picker_1.PickResultType.DROP:\n                const { code, details } = restrictControlPlaneStatusCode(pickResult.status.code, pickResult.status.details);\n                callStream.cancelWithStatus(code, details);\n                break;\n            default:\n                throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);\n        }\n    }\n    removeConnectivityStateWatcher(watcherObject) {\n        const watcherIndex = this.connectivityStateWatchers.findIndex((value)=>value === watcherObject);\n        if (watcherIndex >= 0) {\n            this.connectivityStateWatchers.splice(watcherIndex, 1);\n        }\n    }\n    updateState(newState) {\n        logging_1.trace(constants_1.LogVerbosity.DEBUG, \"connectivity_state\", \"(\" + this.channelzRef.id + \") \" + uri_parser_1.uriToString(this.target) + \" \" + connectivity_state_1.ConnectivityState[this.connectivityState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", connectivity_state_1.ConnectivityState[this.connectivityState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        }\n        this.connectivityState = newState;\n        const watchersCopy = this.connectivityStateWatchers.slice();\n        for (const watcherObject of watchersCopy){\n            if (newState !== watcherObject.currentState) {\n                if (watcherObject.timer) {\n                    clearTimeout(watcherObject.timer);\n                }\n                this.removeConnectivityStateWatcher(watcherObject);\n                watcherObject.callback();\n            }\n        }\n        if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n            this.currentResolutionError = null;\n        }\n    }\n    tryGetConfig(stream, metadata) {\n        if (stream.getStatus() !== null) {\n            /* If the stream has a status, it has already finished and we don't need\n             * to take any more actions on it. */ return;\n        }\n        if (this.configSelector === null) {\n            /* This branch will only be taken at the beginning of the channel's life,\n             * before the resolver ever returns a result. So, the\n             * ResolvingLoadBalancer may be idle and if so it needs to be kicked\n             * because it now has a pending request. */ this.resolvingLoadBalancer.exitIdle();\n            if (this.currentResolutionError && !metadata.getOptions().waitForReady) {\n                stream.cancelWithStatus(this.currentResolutionError.code, this.currentResolutionError.details);\n            } else {\n                this.configSelectionQueue.push({\n                    callStream: stream,\n                    callMetadata: metadata\n                });\n                this.callRefTimerRef();\n            }\n        } else {\n            const callConfig = this.configSelector(stream.getMethod(), metadata);\n            if (callConfig.status === constants_1.Status.OK) {\n                if (callConfig.methodConfig.timeout) {\n                    const deadline = new Date();\n                    deadline.setSeconds(deadline.getSeconds() + callConfig.methodConfig.timeout.seconds);\n                    deadline.setMilliseconds(deadline.getMilliseconds() + callConfig.methodConfig.timeout.nanos / 1000000);\n                    stream.setConfigDeadline(deadline);\n                    // Refreshing the filters makes the deadline filter pick up the new deadline\n                    stream.filterStack.refresh();\n                }\n                if (callConfig.dynamicFilterFactories.length > 0) {\n                    /* These dynamicFilters are the mechanism for implementing gRFC A39:\n                     * https://github.com/grpc/proposal/blob/master/A39-xds-http-filters.md\n                     * We run them here instead of with the rest of the filters because\n                     * that spec says \"the xDS HTTP filters will run in between name\n                     * resolution and load balancing\".\n                     *\n                     * We use the filter stack here to simplify the multi-filter async\n                     * waterfall logic, but we pass along the underlying list of filters\n                     * to avoid having nested filter stacks when combining it with the\n                     * original filter stack. We do not pass along the original filter\n                     * factory list because these filters may need to persist data\n                     * between sending headers and other operations. */ const dynamicFilterStackFactory = new filter_stack_1.FilterStackFactory(callConfig.dynamicFilterFactories);\n                    const dynamicFilterStack = dynamicFilterStackFactory.createFilter(stream);\n                    dynamicFilterStack.sendMetadata(Promise.resolve(metadata)).then((filteredMetadata)=>{\n                        this.tryPick(stream, filteredMetadata, callConfig, dynamicFilterStack.getFilters());\n                    });\n                } else {\n                    this.tryPick(stream, metadata, callConfig, []);\n                }\n            } else {\n                const { code, details } = restrictControlPlaneStatusCode(callConfig.status, \"Failed to route call to method \" + stream.getMethod());\n                stream.cancelWithStatus(code, details);\n            }\n        }\n    }\n    _startCallStream(stream, metadata) {\n        this.tryGetConfig(stream, metadata.clone());\n    }\n    close() {\n        this.resolvingLoadBalancer.destroy();\n        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);\n        clearInterval(this.callRefTimer);\n        if (this.channelzEnabled) {\n            channelz_1.unregisterChannelzRef(this.channelzRef);\n        }\n        this.subchannelPool.unrefUnusedSubchannels();\n    }\n    getTarget() {\n        return uri_parser_1.uriToString(this.target);\n    }\n    getConnectivityState(tryToConnect) {\n        const connectivityState = this.connectivityState;\n        if (tryToConnect) {\n            this.resolvingLoadBalancer.exitIdle();\n        }\n        return connectivityState;\n    }\n    watchConnectivityState(currentState, deadline, callback) {\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            throw new Error(\"Channel has been shut down\");\n        }\n        let timer = null;\n        if (deadline !== Infinity) {\n            const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n            const now = new Date();\n            if (deadline === -Infinity || deadlineDate <= now) {\n                process.nextTick(callback, new Error(\"Deadline passed without connectivity state change\"));\n                return;\n            }\n            timer = setTimeout(()=>{\n                this.removeConnectivityStateWatcher(watcherObject);\n                callback(new Error(\"Deadline passed without connectivity state change\"));\n            }, deadlineDate.getTime() - now.getTime());\n        }\n        const watcherObject = {\n            currentState,\n            callback,\n            timer\n        };\n        this.connectivityStateWatchers.push(watcherObject);\n    }\n    /**\n     * Get the channelz reference object for this channel. The returned value is\n     * garbage if channelz is disabled for this channel.\n     * @returns\n     */ getChannelzRef() {\n        return this.channelzRef;\n    }\n    createCall(method, deadline, host, parentCall, propagateFlags) {\n        if (typeof method !== \"string\") {\n            throw new TypeError(\"Channel#createCall: method must be a string\");\n        }\n        if (!(typeof deadline === \"number\" || deadline instanceof Date)) {\n            throw new TypeError(\"Channel#createCall: deadline must be a number or Date\");\n        }\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            throw new Error(\"Channel has been shut down\");\n        }\n        const callNumber = getNewCallNumber();\n        this.trace(\"createCall [\" + callNumber + '] method=\"' + method + '\", deadline=' + deadline);\n        const finalOptions = {\n            deadline: deadline,\n            flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n            host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n            parentCall: parentCall\n        };\n        const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);\n        if (this.channelzEnabled) {\n            this.callTracker.addCallStarted();\n            stream.addStatusWatcher((status)=>{\n                if (status.code === constants_1.Status.OK) {\n                    this.callTracker.addCallSucceeded();\n                } else {\n                    this.callTracker.addCallFailed();\n                }\n            });\n        }\n        return stream;\n    }\n}\nexports.ChannelImplementation = ChannelImplementation; //# sourceMappingURL=channel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNkJBQTZCLEdBQUcsS0FBSztBQUNyQyxNQUFNRyxnQkFBZ0JDLG1CQUFPQSxDQUFDLGtGQUFlO0FBQzdDLE1BQU1DLHdCQUF3QkQsbUJBQU9BLENBQUMsa0dBQXVCO0FBQzdELE1BQU1FLDRCQUE0QkYsbUJBQU9BLENBQUMsMEdBQTJCO0FBQ3JFLE1BQU1HLG9CQUFvQkgsbUJBQU9BLENBQUMsMEZBQW1CO0FBQ3JELE1BQU1JLFdBQVdKLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DLE1BQU1LLGNBQWNMLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1NLGlCQUFpQk4sbUJBQU9BLENBQUMsb0ZBQWdCO0FBQy9DLE1BQU1PLDRCQUE0QlAsbUJBQU9BLENBQUMsMEdBQTJCO0FBQ3JFLE1BQU1RLG9CQUFvQlIsbUJBQU9BLENBQUMsMEZBQW1CO0FBQ3JELE1BQU1TLHVCQUF1QlQsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1VLGFBQWFWLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1XLFlBQVlYLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ3JDLE1BQU1ZLDRCQUE0QlosbUJBQU9BLENBQUMsMEdBQTJCO0FBQ3JFLE1BQU1hLGVBQWViLG1CQUFPQSxDQUFDLGdGQUFjO0FBQzNDLE1BQU1jLGVBQWVkLG1CQUFPQSxDQUFDLGdGQUFjO0FBQzNDLE1BQU1lLHVCQUF1QmYsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1nQixhQUFhaEIsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkM7O0NBRUMsR0FDRCxNQUFNaUIsbUJBQW1CO0FBQ3pCLElBQUlDLGlCQUFpQjtBQUNyQixTQUFTQztJQUNMLE1BQU1DLGFB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LGNBQWNzUCxlQUFlLENBQUNSLFFBQVEsSUFBSSxFQUFFSSxjQUFjLElBQUksQ0FBQ3BILGtCQUFrQixFQUFFLElBQUksQ0FBQ3JGLFdBQVcsQ0FBQzhNLG1CQUFtQixJQUFJbE87UUFDOUksSUFBSSxJQUFJLENBQUNvQyxlQUFlLEVBQUU7WUFDdEIsSUFBSSxDQUFDQyxXQUFXLENBQUM4TCxjQUFjO1lBQy9CL0MsT0FBT2dELGdCQUFnQixDQUFDcEksQ0FBQUE7Z0JBQ3BCLElBQUlBLE9BQU9sRixJQUFJLEtBQUs3QixZQUFZbUIsTUFBTSxDQUFDQyxFQUFFLEVBQUU7b0JBQ3ZDLElBQUksQ0FBQ2dDLFdBQVcsQ0FBQ2dNLGdCQUFnQjtnQkFDckMsT0FDSztvQkFDRCxJQUFJLENBQUNoTSxXQUFXLENBQUNpTSxhQUFhO2dCQUNsQztZQUNKO1FBQ0o7UUFDQSxPQUFPbEQ7SUFDWDtBQUNKO0FBQ0E1TSw2QkFBNkIsR0FBR0UsdUJBQ2hDLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FzaG1pdHQtZ3VwdGEvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC5qcz9jZDhhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoYW5uZWxJbXBsZW1lbnRhdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGNhbGxfc3RyZWFtXzEgPSByZXF1aXJlKFwiLi9jYWxsLXN0cmVhbVwiKTtcbmNvbnN0IGNoYW5uZWxfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWwtY3JlZGVudGlhbHNcIik7XG5jb25zdCByZXNvbHZpbmdfbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2aW5nLWxvYWQtYmFsYW5jZXJcIik7XG5jb25zdCBzdWJjaGFubmVsX3Bvb2xfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtcG9vbFwiKTtcbmNvbnN0IHBpY2tlcl8xID0gcmVxdWlyZShcIi4vcGlja2VyXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBmaWx0ZXJfc3RhY2tfMSA9IHJlcXVpcmUoXCIuL2ZpbHRlci1zdGFja1wiKTtcbmNvbnN0IGNhbGxfY3JlZGVudGlhbHNfZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9jYWxsLWNyZWRlbnRpYWxzLWZpbHRlclwiKTtcbmNvbnN0IGRlYWRsaW5lX2ZpbHRlcl8xID0gcmVxdWlyZShcIi4vZGVhZGxpbmUtZmlsdGVyXCIpO1xuY29uc3QgY29tcHJlc3Npb25fZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9jb21wcmVzc2lvbi1maWx0ZXJcIik7XG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5jb25zdCBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgbWF4X21lc3NhZ2Vfc2l6ZV9maWx0ZXJfMSA9IHJlcXVpcmUoXCIuL21heC1tZXNzYWdlLXNpemUtZmlsdGVyXCIpO1xuY29uc3QgaHR0cF9wcm94eV8xID0gcmVxdWlyZShcIi4vaHR0cF9wcm94eVwiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IGNoYW5uZWx6XzEgPSByZXF1aXJlKFwiLi9jaGFubmVselwiKTtcbi8qKlxuICogU2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdGltZXJzLmh0bWwjdGltZXJzX3NldGludGVydmFsX2NhbGxiYWNrX2RlbGF5X2FyZ3NcbiAqL1xuY29uc3QgTUFYX1RJTUVPVVRfVElNRSA9IDIxNDc0ODM2NDc7XG5sZXQgbmV4dENhbGxOdW1iZXIgPSAwO1xuZnVuY3Rpb24gZ2V0TmV3Q2FsbE51bWJlcigpIHtcbiAgICBjb25zdCBjYWxsTnVtYmVyID0gbmV4dENhbGxOdW1iZXI7XG4gICAgbmV4dENhbGxOdW1iZXIgKz0gMTtcbiAgICBpZiAobmV4dENhbGxOdW1iZXIgPj0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgbmV4dENhbGxOdW1iZXIgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbE51bWJlcjtcbn1cbmNvbnN0IElOQVBQUk9QUklBVEVfQ09OVFJPTF9QTEFORV9DT0RFUyA9IFtcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuT0ssXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLklOVkFMSURfQVJHVU1FTlQsXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuQUxSRUFEWV9FWElTVFMsXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLkZBSUxFRF9QUkVDT05ESVRJT04sXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLkFCT1JURUQsXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLk9VVF9PRl9SQU5HRSxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuREFUQV9MT1NTXG5dO1xuZnVuY3Rpb24gcmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlKGNvZGUsIGRldGFpbHMpIHtcbiAgICBpZiAoSU5BUFBST1BSSUFURV9DT05UUk9MX1BMQU5FX0NPREVTLmluY2x1ZGVzKGNvZGUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICBkZXRhaWxzOiBgSW52YWxpZCBzdGF0dXMgZnJvbSBjb250cm9sIHBsYW5lOiAke2NvZGV9ICR7Y29uc3RhbnRzXzEuU3RhdHVzW2NvZGVdfSAke2RldGFpbHN9YFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgY29kZSwgZGV0YWlscyB9O1xuICAgIH1cbn1cbmNsYXNzIENoYW5uZWxJbXBsZW1lbnRhdGlvbiB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBjcmVkZW50aWFscywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIHRoaXMuY3VycmVudFBpY2tlciA9IG5ldyBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbHMgcXVldWVkIHVwIHRvIGdldCBhIGNhbGwgY29uZmlnLiBTaG91bGQgb25seSBiZSBwb3B1bGF0ZWQgYmVmb3JlIHRoZVxuICAgICAgICAgKiBmaXJzdCB0aW1lIHRoZSByZXNvbHZlciByZXR1cm5zIGEgcmVzdWx0LCB3aGljaCBpbmNsdWRlcyB0aGUgQ29uZmlnU2VsZWN0b3IuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlID0gW107XG4gICAgICAgIHRoaXMucGlja1F1ZXVlID0gW107XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycyA9IFtdO1xuICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIGVycm9yIGZyb20gdGhlIG5hbWUgcmVzb2x2ZXIgaWYgaXQgZmFpbGVkIG1vc3QgcmVjZW50bHkuIEl0XG4gICAgICAgICAqIGlzIG9ubHkgdXNlZCB0byBlbmQgY2FsbHMgdGhhdCBzdGFydCB3aGlsZSB0aGVyZSBpcyBubyBjb25maWcgc2VsZWN0b3JcbiAgICAgICAgICogYW5kIHRoZSBuYW1lIHJlc29sdmVyIGlzIGluIGJhY2tvZmYsIHNvIGl0IHNob3VsZCBiZSBudWxsZWQgaWZcbiAgICAgICAgICogY29uZmlnU2VsZWN0b3IgYmVjb21lcyBzZXQgb3IgdGhlIGNoYW5uZWwgc3RhdGUgYmVjb21lcyBhbnl0aGluZyBvdGhlclxuICAgICAgICAgKiB0aGFuIFRSQU5TSUVOVF9GQUlMVVJFLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yID0gbnVsbDtcbiAgICAgICAgLy8gQ2hhbm5lbHogaW5mb1xuICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FsbFRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyKCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXIoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsIHRhcmdldCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoY3JlZGVudGlhbHMgaW5zdGFuY2VvZiBjaGFubmVsX2NyZWRlbnRpYWxzXzEuQ2hhbm5lbENyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCBjcmVkZW50aWFscyBtdXN0IGJlIGEgQ2hhbm5lbENyZWRlbnRpYWxzIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCBvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcmlnaW5hbFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxUYXJnZXRVcmkgPSB1cmlfcGFyc2VyXzEucGFyc2VVcmkodGFyZ2V0KTtcbiAgICAgICAgaWYgKG9yaWdpbmFsVGFyZ2V0VXJpID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSB0YXJnZXQgbmFtZSBcIiR7dGFyZ2V0fVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHRhcmdldCBoYXMgYSBzY2hlbWUgdGhhdCBpcyByZWdpc3RlcmVkIHdpdGggdGhlXG4gICAgICAgICAqIHJlc29sdmVyICovXG4gICAgICAgIGNvbnN0IGRlZmF1bHRTY2hlbWVNYXBSZXN1bHQgPSByZXNvbHZlcl8xLm1hcFVyaURlZmF1bHRTY2hlbWUob3JpZ2luYWxUYXJnZXRVcmkpO1xuICAgICAgICBpZiAoZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBhIGRlZmF1bHQgc2NoZW1lIGZvciB0YXJnZXQgbmFtZSBcIiR7dGFyZ2V0fVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsUmVmVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7IH0sIE1BWF9USU1FT1VUX1RJTUUpO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNhbGxSZWZUaW1lcikudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1snZ3JwYy5lbmFibGVfY2hhbm5lbHonXSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVselRyYWNlKCk7XG4gICAgICAgIHRoaXMuY2hhbm5lbHpSZWYgPSBjaGFubmVsel8xLnJlZ2lzdGVyQ2hhbm5lbHpDaGFubmVsKHRhcmdldCwgKCkgPT4gdGhpcy5nZXRDaGFubmVsekluZm8oKSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDaGFubmVsIGNyZWF0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zWydncnBjLmRlZmF1bHRfYXV0aG9yaXR5J10pIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdEF1dGhvcml0eSA9IHRoaXMub3B0aW9uc1snZ3JwYy5kZWZhdWx0X2F1dGhvcml0eSddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0QXV0aG9yaXR5ID0gcmVzb2x2ZXJfMS5nZXREZWZhdWx0QXV0aG9yaXR5KGRlZmF1bHRTY2hlbWVNYXBSZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3h5TWFwUmVzdWx0ID0gaHR0cF9wcm94eV8xLm1hcFByb3h5TmFtZShkZWZhdWx0U2NoZW1lTWFwUmVzdWx0LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBwcm94eU1hcFJlc3VsdC50YXJnZXQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgcHJveHlNYXBSZXN1bHQuZXh0cmFPcHRpb25zKTtcbiAgICAgICAgLyogVGhlIGdsb2JhbCBib29sZWFuIHBhcmFtZXRlciB0byBnZXRTdWJjaGFubmVsUG9vbCBoYXMgdGhlIGludmVyc2UgbWVhbmluZyB0byB3aGF0XG4gICAgICAgICAqIHRoZSBncnBjLnVzZV9sb2NhbF9zdWJjaGFubmVsX3Bvb2wgY2hhbm5lbCBvcHRpb24gbWVhbnMuICovXG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbFBvb2wgPSBzdWJjaGFubmVsX3Bvb2xfMS5nZXRTdWJjaGFubmVsUG9vbCgoKF9jID0gb3B0aW9uc1snZ3JwYy51c2VfbG9jYWxfc3ViY2hhbm5lbF9wb29sJ10pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDApID09PSAwKTtcbiAgICAgICAgY29uc3QgY2hhbm5lbENvbnRyb2xIZWxwZXIgPSB7XG4gICAgICAgICAgICBjcmVhdGVTdWJjaGFubmVsOiAoc3ViY2hhbm5lbEFkZHJlc3MsIHN1YmNoYW5uZWxBcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbCA9IHRoaXMuc3ViY2hhbm5lbFBvb2wuZ2V0T3JDcmVhdGVTdWJjaGFubmVsKHRoaXMudGFyZ2V0LCBzdWJjaGFubmVsQWRkcmVzcywgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBzdWJjaGFubmVsQXJncyksIHRoaXMuY3JlZGVudGlhbHMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQ3JlYXRlZCBzdWJjaGFubmVsIG9yIHVzZWQgZXhpc3Rpbmcgc3ViY2hhbm5lbCcsIHN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdWJjaGFubmVsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlOiAoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBpY2tlciA9IHBpY2tlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBxdWV1ZUNvcHkgPSB0aGlzLnBpY2tRdWV1ZS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGlja1F1ZXVlID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsUmVmVGltZXJVbnJlZigpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBjYWxsU3RyZWFtLCBjYWxsTWV0YWRhdGEsIGNhbGxDb25maWcsIGR5bmFtaWNGaWx0ZXJzIH0gb2YgcXVldWVDb3B5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5UGljayhjYWxsU3RyZWFtLCBjYWxsTWV0YWRhdGEsIGNhbGxDb25maWcsIGR5bmFtaWNGaWx0ZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWVzdFJlcmVzb2x1dGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGJlIGNhbGxlZC5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc29sdmluZyBsb2FkIGJhbGFuY2VyIHNob3VsZCBuZXZlciBjYWxsIHJlcXVlc3RSZXJlc29sdXRpb24nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRDaGFubmVsekNoaWxkOiAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIucmVmQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVDaGFubmVsekNoaWxkOiAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIudW5yZWZDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlc29sdmluZ0xvYWRCYWxhbmNlciA9IG5ldyByZXNvbHZpbmdfbG9hZF9iYWxhbmNlcl8xLlJlc29sdmluZ0xvYWRCYWxhbmNlcih0aGlzLnRhcmdldCwgY2hhbm5lbENvbnRyb2xIZWxwZXIsIG9wdGlvbnMsIChjb25maWdTZWxlY3RvcikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0FkZHJlc3MgcmVzb2x1dGlvbiBzdWNjZWVkZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0b3IgPSBjb25maWdTZWxlY3RvcjtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvciA9IG51bGw7XG4gICAgICAgICAgICAvKiBXZSBwcm9jZXNzIHRoZSBxdWV1ZSBhc3luY2hyb25vdXNseSB0byBlbnN1cmUgdGhhdCB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAgICAgICAgICogbG9hZCBiYWxhbmNlciB1cGRhdGUgaGFzIGNvbXBsZXRlZC4gKi9cbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsUXVldWUgPSB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclVucmVmKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IGNhbGxTdHJlYW0sIGNhbGxNZXRhZGF0YSB9IG9mIGxvY2FsUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlHZXRDb25maWcoY2FsbFN0cmVhbSwgY2FsbE1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZSA9IFtdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfV0FSTklORycsICdBZGRyZXNzIHJlc29sdXRpb24gZmFpbGVkIHdpdGggY29kZSAnICsgc3RhdHVzLmNvZGUgKyAnIGFuZCBkZXRhaWxzIFwiJyArIHN0YXR1cy5kZXRhaWxzICsgJ1wiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnTmFtZSByZXNvbHV0aW9uIGZhaWxlZCB3aXRoIGNhbGxzIHF1ZXVlZCBmb3IgY29uZmlnIHNlbGVjdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnU2VsZWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uRXJyb3IgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZShzdGF0dXMuY29kZSwgc3RhdHVzLmRldGFpbHMpKSwgeyBtZXRhZGF0YTogc3RhdHVzLm1ldGFkYXRhIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxRdWV1ZSA9IHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWU7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlID0gW107XG4gICAgICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclVucmVmKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgY2FsbFN0cmVhbSwgY2FsbE1ldGFkYXRhIH0gb2YgbG9jYWxRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsTWV0YWRhdGEuZ2V0T3B0aW9ucygpLndhaXRGb3JSZWFkeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclJlZigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlLnB1c2goeyBjYWxsU3RyZWFtLCBjYWxsTWV0YWRhdGEgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsU3RyZWFtLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLmNvZGUsIHN0YXR1cy5kZXRhaWxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZpbHRlclN0YWNrRmFjdG9yeSA9IG5ldyBmaWx0ZXJfc3RhY2tfMS5GaWx0ZXJTdGFja0ZhY3RvcnkoW1xuICAgICAgICAgICAgbmV3IGNhbGxfY3JlZGVudGlhbHNfZmlsdGVyXzEuQ2FsbENyZWRlbnRpYWxzRmlsdGVyRmFjdG9yeSh0aGlzKSxcbiAgICAgICAgICAgIG5ldyBkZWFkbGluZV9maWx0ZXJfMS5EZWFkbGluZUZpbHRlckZhY3RvcnkodGhpcyksXG4gICAgICAgICAgICBuZXcgbWF4X21lc3NhZ2Vfc2l6ZV9maWx0ZXJfMS5NYXhNZXNzYWdlU2l6ZUZpbHRlckZhY3RvcnkodGhpcy5vcHRpb25zKSxcbiAgICAgICAgICAgIG5ldyBjb21wcmVzc2lvbl9maWx0ZXJfMS5Db21wcmVzc2lvbkZpbHRlckZhY3RvcnkodGhpcywgdGhpcy5vcHRpb25zKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMudHJhY2UoJ0NoYW5uZWwgY29uc3RydWN0ZWQgd2l0aCBvcHRpb25zICcgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zLCB1bmRlZmluZWQsIDIpKTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgbG9nZ2luZ18xLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ2NoYW5uZWxfc3RhY2t0cmFjZScsICcoJyArIHRoaXMuY2hhbm5lbHpSZWYuaWQgKyAnKSAnICsgJ0NoYW5uZWwgY29uc3RydWN0ZWQgXFxuJyArICgoX2QgPSBlcnJvci5zdGFjaykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnN1YnN0cmluZyhlcnJvci5zdGFjay5pbmRleE9mKCdcXG4nKSArIDEpKSk7XG4gICAgfVxuICAgIGdldENoYW5uZWx6SW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy5vcmlnaW5hbFRhcmdldCxcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlLFxuICAgICAgICAgICAgdHJhY2U6IHRoaXMuY2hhbm5lbHpUcmFjZSxcbiAgICAgICAgICAgIGNhbGxUcmFja2VyOiB0aGlzLmNhbGxUcmFja2VyLFxuICAgICAgICAgICAgY2hpbGRyZW46IHRoaXMuY2hpbGRyZW5UcmFja2VyLmdldENoaWxkTGlzdHMoKVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0cmFjZSh0ZXh0LCB2ZXJib3NpdHlPdmVycmlkZSkge1xuICAgICAgICBsb2dnaW5nXzEudHJhY2UodmVyYm9zaXR5T3ZlcnJpZGUgIT09IG51bGwgJiYgdmVyYm9zaXR5T3ZlcnJpZGUgIT09IHZvaWQgMCA/IHZlcmJvc2l0eU92ZXJyaWRlIDogY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAnY2hhbm5lbCcsICcoJyArIHRoaXMuY2hhbm5lbHpSZWYuaWQgKyAnKSAnICsgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRoaXMudGFyZ2V0KSArICcgJyArIHRleHQpO1xuICAgIH1cbiAgICBjYWxsUmVmVGltZXJSZWYoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgLy8gSWYgdGhlIGhhc1JlZiBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdCwgYWx3YXlzIHJ1biB0aGUgY29kZVxuICAgICAgICBpZiAoISgoX2IgPSAoX2EgPSB0aGlzLmNhbGxSZWZUaW1lcikuaGFzUmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdjYWxsUmVmVGltZXIucmVmIHwgY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoPScgK1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAnIHBpY2tRdWV1ZS5sZW5ndGg9JyArXG4gICAgICAgICAgICAgICAgdGhpcy5waWNrUXVldWUubGVuZ3RoKTtcbiAgICAgICAgICAgIChfZCA9IChfYyA9IHRoaXMuY2FsbFJlZlRpbWVyKS5yZWYpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxsUmVmVGltZXJVbnJlZigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgLy8gSWYgdGhlIGhhc1JlZiBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdCwgYWx3YXlzIHJ1biB0aGUgY29kZVxuICAgICAgICBpZiAoIXRoaXMuY2FsbFJlZlRpbWVyLmhhc1JlZiB8fCB0aGlzLmNhbGxSZWZUaW1lci5oYXNSZWYoKSkge1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnY2FsbFJlZlRpbWVyLnVucmVmIHwgY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoPScgK1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAnIHBpY2tRdWV1ZS5sZW5ndGg9JyArXG4gICAgICAgICAgICAgICAgdGhpcy5waWNrUXVldWUubGVuZ3RoKTtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2FsbFJlZlRpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHB1c2hQaWNrKGNhbGxTdHJlYW0sIGNhbGxNZXRhZGF0YSwgY2FsbENvbmZpZywgZHluYW1pY0ZpbHRlcnMpIHtcbiAgICAgICAgdGhpcy5waWNrUXVldWUucHVzaCh7IGNhbGxTdHJlYW0sIGNhbGxNZXRhZGF0YSwgY2FsbENvbmZpZywgZHluYW1pY0ZpbHRlcnMgfSk7XG4gICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyUmVmKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoZSBwaWNrZXIgb3V0cHV0IGZvciB0aGUgZ2l2ZW4gY2FsbCBhbmQgY29ycmVzcG9uZGluZyBtZXRhZGF0YSxcbiAgICAgKiBhbmQgdGFrZSBhbnkgcmVsZXZhbnQgYWN0aW9ucy4gU2hvdWxkIG5vdCBiZSBjYWxsZWQgd2hpbGUgaXRlcmF0aW5nXG4gICAgICogb3ZlciBwaWNrUXVldWUuXG4gICAgICogQHBhcmFtIGNhbGxTdHJlYW1cbiAgICAgKiBAcGFyYW0gY2FsbE1ldGFkYXRhXG4gICAgICovXG4gICAgdHJ5UGljayhjYWxsU3RyZWFtLCBjYWxsTWV0YWRhdGEsIGNhbGxDb25maWcsIGR5bmFtaWNGaWx0ZXJzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHBpY2tSZXN1bHQgPSB0aGlzLmN1cnJlbnRQaWNrZXIucGljayh7XG4gICAgICAgICAgICBtZXRhZGF0YTogY2FsbE1ldGFkYXRhLFxuICAgICAgICAgICAgZXh0cmFQaWNrSW5mbzogY2FsbENvbmZpZy5waWNrSW5mb3JtYXRpb24sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzdWJjaGFubmVsU3RyaW5nID0gcGlja1Jlc3VsdC5zdWJjaGFubmVsID9cbiAgICAgICAgICAgICcoJyArIHBpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpLmlkICsgJykgJyArIHBpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRBZGRyZXNzKCkgOlxuICAgICAgICAgICAgJycgKyBwaWNrUmVzdWx0LnN1YmNoYW5uZWw7XG4gICAgICAgIHRoaXMudHJhY2UoJ1BpY2sgcmVzdWx0IGZvciBjYWxsIFsnICtcbiAgICAgICAgICAgIGNhbGxTdHJlYW0uZ2V0Q2FsbE51bWJlcigpICtcbiAgICAgICAgICAgICddOiAnICtcbiAgICAgICAgICAgIHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlW3BpY2tSZXN1bHQucGlja1Jlc3VsdFR5cGVdICtcbiAgICAgICAgICAgICcgc3ViY2hhbm5lbDogJyArXG4gICAgICAgICAgICBzdWJjaGFubmVsU3RyaW5nICtcbiAgICAgICAgICAgICcgc3RhdHVzOiAnICsgKChfYSA9IHBpY2tSZXN1bHQuc3RhdHVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgK1xuICAgICAgICAgICAgJyAnICsgKChfYiA9IHBpY2tSZXN1bHQuc3RhdHVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGV0YWlscykpO1xuICAgICAgICBzd2l0Y2ggKHBpY2tSZXN1bHQucGlja1Jlc3VsdFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuQ09NUExFVEU6XG4gICAgICAgICAgICAgICAgaWYgKHBpY2tSZXN1bHQuc3ViY2hhbm5lbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsU3RyZWFtLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLCAnUmVxdWVzdCBkcm9wcGVkIGJ5IGxvYWQgYmFsYW5jaW5nIHBvbGljeScpO1xuICAgICAgICAgICAgICAgICAgICAvLyBFbmQgdGhlIGNhbGwgd2l0aCBhbiBlcnJvclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLyogSWYgdGhlIHN1YmNoYW5uZWwgaXMgbm90IGluIHRoZSBSRUFEWSBzdGF0ZSwgdGhhdCBpbmRpY2F0ZXMgYSBidWdcbiAgICAgICAgICAgICAgICAgICAgICogc29tZXdoZXJlIGluIHRoZSBsb2FkIGJhbGFuY2VyIG9yIHBpY2tlci4gU28sIHdlIGxvZyBhbiBlcnJvciBhbmRcbiAgICAgICAgICAgICAgICAgICAgICogcXVldWUgdGhlIHBpY2sgdG8gYmUgdHJpZWQgYWdhaW4gbGF0ZXIuICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChwaWNrUmVzdWx0LnN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnaW5nXzEubG9nKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgJ0Vycm9yOiBDT01QTEVURSBwaWNrIHJlc3VsdCBzdWJjaGFubmVsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxTdHJpbmcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgaGFzIHN0YXRlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3BpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hQaWNrKGNhbGxTdHJlYW0sIGNhbGxNZXRhZGF0YSwgY2FsbENvbmZpZywgZHluYW1pY0ZpbHRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLyogV2UgbmVlZCB0byBjbG9uZSB0aGUgY2FsbE1ldGFkYXRhIGhlcmUgYmVjYXVzZSB0aGUgdHJhbnNwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICogcmV0cnkgY29kZSBpbiB0aGUgcHJvbWlzZSByZXNvbHV0aW9uIGhhbmRsZXIgdXNlIHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgICAgICAqIGNhbGxNZXRhZGF0YSBvYmplY3QsIHNvIGl0IG5lZWRzIHRvIHN0YXkgdW5tb2RpZmllZCAqL1xuICAgICAgICAgICAgICAgICAgICBjYWxsU3RyZWFtLmZpbHRlclN0YWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VuZE1ldGFkYXRhKFByb21pc2UucmVzb2x2ZShjYWxsTWV0YWRhdGEuY2xvbmUoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoZmluYWxNZXRhZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsU3RhdGUgPSBwaWNrUmVzdWx0LnN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJjaGFubmVsU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGlja0V4dHJhRmlsdGVycyA9IHBpY2tSZXN1bHQuZXh0cmFGaWx0ZXJGYWN0b3JpZXMubWFwKGZhY3RvcnkgPT4gZmFjdG9yeS5jcmVhdGVGaWx0ZXIoY2FsbFN0cmVhbSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBwaWNrUmVzdWx0LnN1YmNoYW5uZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRSZWFsU3ViY2hhbm5lbCgpLnN0YXJ0Q2FsbFN0cmVhbShmaW5hbE1ldGFkYXRhLCBjYWxsU3RyZWFtLCBbLi4uZHluYW1pY0ZpbHRlcnMsIC4uLnBpY2tFeHRyYUZpbHRlcnNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogSWYgd2UgcmVhY2ggdGhpcyBwb2ludCwgdGhlIGNhbGwgc3RyZWFtIGhhcyBzdGFydGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHN1Y2Nlc3NmdWxseSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2IgPSBjYWxsQ29uZmlnLm9uQ29tbWl0dGVkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChjYWxsQ29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9jID0gcGlja1Jlc3VsdC5vbkNhbGxTdGFydGVkKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChwaWNrUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IGVycm9yLmNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvckNvZGUgPT09ICdFUlJfSFRUUDJfR09BV0FZX1NFU1NJT04nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGUgPT09ICdFUlJfSFRUUDJfSU5WQUxJRF9TRVNTSU9OJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogQW4gZXJyb3IgaGVyZSBpbmRpY2F0ZXMgdGhhdCBzb21ldGhpbmcgd2VudCB3cm9uZyB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGUgcGlja2VkIHN1YmNoYW5uZWwncyBodHRwMiBzdHJlYW0gcmlnaHQgYmVmb3JlIHdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB0cmllZCB0byBzdGFydCB0aGUgc3RyZWFtLiBXZSBhcmUgaGFuZGxpbmcgYSBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiByZXN1bHQgaGVyZSwgc28gdGhpcyBpcyBhc3luY2hyb25vdXMgd2l0aCByZXNwZWN0IHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogb3JpZ2luYWwgdHJ5UGljayBjYWxsLCBzbyBjYWxsaW5nIGl0IGFnYWluIGlzIG5vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogcmVjdXJzaXZlLiBXZSBjYWxsIHRyeVBpY2sgaW1tZWRpYXRlbHkgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogcXVldWVpbmcgdGhpcyBwaWNrIGFnYWluIGJlY2F1c2UgaGFuZGxpbmcgdGhlIHF1ZXVlIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB0cmlnZ2VyZWQgYnkgc3RhdGUgY2hhbmdlcywgYW5kIHdlIHdhbnQgdG8gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGNoZWNrIGlmIHRoZSBzdGF0ZSBoYXMgYWxyZWFkeSBjaGFuZ2VkIHNpbmNlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogcHJldmlvdXMgdHJ5UGljayBjYWxsLiBXZSBkbyB0aGlzIGluc3RlYWQgb2YgY2FuY2VsbGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogdGhlIHN0cmVhbSBiZWNhdXNlIHRoZSBjb3JyZWN0IGJlaGF2aW9yIG1heSBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogcmUtcXVldWVpbmcgaW5zdGVhZCwgYmFzZWQgb24gdGhlIGxvZ2ljIGluIHRoZSByZXN0IG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB0cnlQaWNrICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdGYWlsZWQgdG8gc3RhcnQgY2FsbCBvbiBwaWNrZWQgc3ViY2hhbm5lbCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJjaGFubmVsU3RyaW5nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHdpdGggZXJyb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy4gUmV0cnlpbmcgcGljaycsIGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5JTkZPKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5UGljayhjYWxsU3RyZWFtLCBjYWxsTWV0YWRhdGEsIGNhbGxDb25maWcsIGR5bmFtaWNGaWx0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0ZhaWxlZCB0byBzdGFydCBjYWxsIG9uIHBpY2tlZCBzdWJjaGFuZWwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFN0cmluZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB3aXRoIGVycm9yICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcuIEVuZGluZyBjYWxsJywgY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LklORk8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFN0cmVhbS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCwgYEZhaWxlZCB0byBzdGFydCBIVFRQLzIgc3RyZWFtIHdpdGggZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRoZSBsb2dpYyBmb3IgZG9pbmcgdGhpcyBoZXJlIGlzIHRoZSBzYW1lIGFzIGluIHRoZSBjYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGJsb2NrIGFib3ZlICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUGlja2VkIHN1YmNoYW5uZWwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxTdHJpbmcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGhhcyBzdGF0ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbc3ViY2hhbm5lbFN0YXRlXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgYWZ0ZXIgbWV0YWRhdGEgZmlsdGVycy4gUmV0cnlpbmcgcGljaycsIGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5JTkZPKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeVBpY2soY2FsbFN0cmVhbSwgY2FsbE1ldGFkYXRhLCBjYWxsQ29uZmlnLCBkeW5hbWljRmlsdGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXNzdW1lIHRoZSBlcnJvciBjb2RlIGlzbid0IDAgKFN0YXR1cy5PSylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY29kZSwgZGV0YWlscyB9ID0gcmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlKHR5cGVvZiBlcnJvci5jb2RlID09PSAnbnVtYmVyJyA/IGVycm9yLmNvZGUgOiBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTiwgYEdldHRpbmcgbWV0YWRhdGEgZnJvbSBwbHVnaW4gZmFpbGVkIHdpdGggZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxTdHJlYW0uY2FuY2VsV2l0aFN0YXR1cyhjb2RlLCBkZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5RVUVVRTpcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hQaWNrKGNhbGxTdHJlYW0sIGNhbGxNZXRhZGF0YSwgY2FsbENvbmZpZywgZHluYW1pY0ZpbHRlcnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5UUkFOU0lFTlRfRkFJTFVSRTpcbiAgICAgICAgICAgICAgICBpZiAoY2FsbE1ldGFkYXRhLmdldE9wdGlvbnMoKS53YWl0Rm9yUmVhZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoUGljayhjYWxsU3RyZWFtLCBjYWxsTWV0YWRhdGEsIGNhbGxDb25maWcsIGR5bmFtaWNGaWx0ZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY29kZSwgZGV0YWlscyB9ID0gcmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlKHBpY2tSZXN1bHQuc3RhdHVzLmNvZGUsIHBpY2tSZXN1bHQuc3RhdHVzLmRldGFpbHMpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsU3RyZWFtLmNhbmNlbFdpdGhTdGF0dXMoY29kZSwgZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5EUk9QOlxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29kZSwgZGV0YWlscyB9ID0gcmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlKHBpY2tSZXN1bHQuc3RhdHVzLmNvZGUsIHBpY2tSZXN1bHQuc3RhdHVzLmRldGFpbHMpO1xuICAgICAgICAgICAgICAgIGNhbGxTdHJlYW0uY2FuY2VsV2l0aFN0YXR1cyhjb2RlLCBkZXRhaWxzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXRlOiB1bmtub3duIHBpY2tSZXN1bHRUeXBlICR7cGlja1Jlc3VsdC5waWNrUmVzdWx0VHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVDb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXIod2F0Y2hlck9iamVjdCkge1xuICAgICAgICBjb25zdCB3YXRjaGVySW5kZXggPSB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcnMuZmluZEluZGV4KCh2YWx1ZSkgPT4gdmFsdWUgPT09IHdhdGNoZXJPYmplY3QpO1xuICAgICAgICBpZiAod2F0Y2hlckluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5zcGxpY2Uod2F0Y2hlckluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICBsb2dnaW5nXzEudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAnY29ubmVjdGl2aXR5X3N0YXRlJywgJygnICsgdGhpcy5jaGFubmVselJlZi5pZCArICcpICcgK1xuICAgICAgICAgICAgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRoaXMudGFyZ2V0KSArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jb25uZWN0aXZpdHlTdGF0ZV0gK1xuICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jb25uZWN0aXZpdHlTdGF0ZV0gKyAnIC0+ICcgKyBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgY29uc3Qgd2F0Y2hlcnNDb3B5ID0gdGhpcy5jb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXJzLnNsaWNlKCk7XG4gICAgICAgIGZvciAoY29uc3Qgd2F0Y2hlck9iamVjdCBvZiB3YXRjaGVyc0NvcHkpIHtcbiAgICAgICAgICAgIGlmIChuZXdTdGF0ZSAhPT0gd2F0Y2hlck9iamVjdC5jdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAod2F0Y2hlck9iamVjdC50aW1lcikge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQod2F0Y2hlck9iamVjdC50aW1lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVXYXRjaGVyKHdhdGNoZXJPYmplY3QpO1xuICAgICAgICAgICAgICAgIHdhdGNoZXJPYmplY3QuY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3U3RhdGUgIT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uRXJyb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyeUdldENvbmZpZyhzdHJlYW0sIG1ldGFkYXRhKSB7XG4gICAgICAgIGlmIChzdHJlYW0uZ2V0U3RhdHVzKCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8qIElmIHRoZSBzdHJlYW0gaGFzIGEgc3RhdHVzLCBpdCBoYXMgYWxyZWFkeSBmaW5pc2hlZCBhbmQgd2UgZG9uJ3QgbmVlZFxuICAgICAgICAgICAgICogdG8gdGFrZSBhbnkgbW9yZSBhY3Rpb25zIG9uIGl0LiAqL1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ1NlbGVjdG9yID09PSBudWxsKSB7XG4gICAgICAgICAgICAvKiBUaGlzIGJyYW5jaCB3aWxsIG9ubHkgYmUgdGFrZW4gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY2hhbm5lbCdzIGxpZmUsXG4gICAgICAgICAgICAgKiBiZWZvcmUgdGhlIHJlc29sdmVyIGV2ZXIgcmV0dXJucyBhIHJlc3VsdC4gU28sIHRoZVxuICAgICAgICAgICAgICogUmVzb2x2aW5nTG9hZEJhbGFuY2VyIG1heSBiZSBpZGxlIGFuZCBpZiBzbyBpdCBuZWVkcyB0byBiZSBraWNrZWRcbiAgICAgICAgICAgICAqIGJlY2F1c2UgaXQgbm93IGhhcyBhIHBlbmRpbmcgcmVxdWVzdC4gKi9cbiAgICAgICAgICAgIHRoaXMucmVzb2x2aW5nTG9hZEJhbGFuY2VyLmV4aXRJZGxlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yICYmICFtZXRhZGF0YS5nZXRPcHRpb25zKCkud2FpdEZvclJlYWR5KSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmNhbmNlbFdpdGhTdGF0dXModGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yLmNvZGUsIHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvci5kZXRhaWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxTdHJlYW06IHN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbE1ldGFkYXRhOiBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclJlZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2FsbENvbmZpZyA9IHRoaXMuY29uZmlnU2VsZWN0b3Ioc3RyZWFtLmdldE1ldGhvZCgpLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICBpZiAoY2FsbENvbmZpZy5zdGF0dXMgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsQ29uZmlnLm1ldGhvZENvbmZpZy50aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlYWRsaW5lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVhZGxpbmUuc2V0U2Vjb25kcyhkZWFkbGluZS5nZXRTZWNvbmRzKCkgKyBjYWxsQ29uZmlnLm1ldGhvZENvbmZpZy50aW1lb3V0LnNlY29uZHMpO1xuICAgICAgICAgICAgICAgICAgICBkZWFkbGluZS5zZXRNaWxsaXNlY29uZHMoZGVhZGxpbmUuZ2V0TWlsbGlzZWNvbmRzKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbENvbmZpZy5tZXRob2RDb25maWcudGltZW91dC5uYW5vcyAvIDEwMDAwMDApO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0uc2V0Q29uZmlnRGVhZGxpbmUoZGVhZGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWZyZXNoaW5nIHRoZSBmaWx0ZXJzIG1ha2VzIHRoZSBkZWFkbGluZSBmaWx0ZXIgcGljayB1cCB0aGUgbmV3IGRlYWRsaW5lXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5maWx0ZXJTdGFjay5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYWxsQ29uZmlnLmR5bmFtaWNGaWx0ZXJGYWN0b3JpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvKiBUaGVzZSBkeW5hbWljRmlsdGVycyBhcmUgdGhlIG1lY2hhbmlzbSBmb3IgaW1wbGVtZW50aW5nIGdSRkMgQTM5OlxuICAgICAgICAgICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9wcm9wb3NhbC9ibG9iL21hc3Rlci9BMzkteGRzLWh0dHAtZmlsdGVycy5tZFxuICAgICAgICAgICAgICAgICAgICAgKiBXZSBydW4gdGhlbSBoZXJlIGluc3RlYWQgb2Ygd2l0aCB0aGUgcmVzdCBvZiB0aGUgZmlsdGVycyBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAgICAqIHRoYXQgc3BlYyBzYXlzIFwidGhlIHhEUyBIVFRQIGZpbHRlcnMgd2lsbCBydW4gaW4gYmV0d2VlbiBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAqIHJlc29sdXRpb24gYW5kIGxvYWQgYmFsYW5jaW5nXCIuXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqIFdlIHVzZSB0aGUgZmlsdGVyIHN0YWNrIGhlcmUgdG8gc2ltcGxpZnkgdGhlIG11bHRpLWZpbHRlciBhc3luY1xuICAgICAgICAgICAgICAgICAgICAgKiB3YXRlcmZhbGwgbG9naWMsIGJ1dCB3ZSBwYXNzIGFsb25nIHRoZSB1bmRlcmx5aW5nIGxpc3Qgb2YgZmlsdGVyc1xuICAgICAgICAgICAgICAgICAgICAgKiB0byBhdm9pZCBoYXZpbmcgbmVzdGVkIGZpbHRlciBzdGFja3Mgd2hlbiBjb21iaW5pbmcgaXQgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICogb3JpZ2luYWwgZmlsdGVyIHN0YWNrLiBXZSBkbyBub3QgcGFzcyBhbG9uZyB0aGUgb3JpZ2luYWwgZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgICAqIGZhY3RvcnkgbGlzdCBiZWNhdXNlIHRoZXNlIGZpbHRlcnMgbWF5IG5lZWQgdG8gcGVyc2lzdCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAqIGJldHdlZW4gc2VuZGluZyBoZWFkZXJzIGFuZCBvdGhlciBvcGVyYXRpb25zLiAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkeW5hbWljRmlsdGVyU3RhY2tGYWN0b3J5ID0gbmV3IGZpbHRlcl9zdGFja18xLkZpbHRlclN0YWNrRmFjdG9yeShjYWxsQ29uZmlnLmR5bmFtaWNGaWx0ZXJGYWN0b3JpZXMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkeW5hbWljRmlsdGVyU3RhY2sgPSBkeW5hbWljRmlsdGVyU3RhY2tGYWN0b3J5LmNyZWF0ZUZpbHRlcihzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljRmlsdGVyU3RhY2suc2VuZE1ldGFkYXRhKFByb21pc2UucmVzb2x2ZShtZXRhZGF0YSkpLnRoZW4oZmlsdGVyZWRNZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeVBpY2soc3RyZWFtLCBmaWx0ZXJlZE1ldGFkYXRhLCBjYWxsQ29uZmlnLCBkeW5hbWljRmlsdGVyU3RhY2suZ2V0RmlsdGVycygpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeVBpY2soc3RyZWFtLCBtZXRhZGF0YSwgY2FsbENvbmZpZywgW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29kZSwgZGV0YWlscyB9ID0gcmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlKGNhbGxDb25maWcuc3RhdHVzLCAnRmFpbGVkIHRvIHJvdXRlIGNhbGwgdG8gbWV0aG9kICcgKyBzdHJlYW0uZ2V0TWV0aG9kKCkpO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5jYW5jZWxXaXRoU3RhdHVzKGNvZGUsIGRldGFpbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9zdGFydENhbGxTdHJlYW0oc3RyZWFtLCBtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLnRyeUdldENvbmZpZyhzdHJlYW0sIG1ldGFkYXRhLmNsb25lKCkpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOKTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNhbGxSZWZUaW1lcik7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYodGhpcy5jaGFubmVselJlZik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJjaGFubmVsUG9vbC51bnJlZlVudXNlZFN1YmNoYW5uZWxzKCk7XG4gICAgfVxuICAgIGdldFRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZyh0aGlzLnRhcmdldCk7XG4gICAgfVxuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKHRyeVRvQ29ubmVjdCkge1xuICAgICAgICBjb25zdCBjb25uZWN0aXZpdHlTdGF0ZSA9IHRoaXMuY29ubmVjdGl2aXR5U3RhdGU7XG4gICAgICAgIGlmICh0cnlUb0Nvbm5lY3QpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2aW5nTG9hZEJhbGFuY2VyLmV4aXRJZGxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpdml0eVN0YXRlO1xuICAgIH1cbiAgICB3YXRjaENvbm5lY3Rpdml0eVN0YXRlKGN1cnJlbnRTdGF0ZSwgZGVhZGxpbmUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5TSFVURE9XTikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGFubmVsIGhhcyBiZWVuIHNodXQgZG93bicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgICAgIGlmIChkZWFkbGluZSAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlYWRsaW5lRGF0ZSA9IGRlYWRsaW5lIGluc3RhbmNlb2YgRGF0ZSA/IGRlYWRsaW5lIDogbmV3IERhdGUoZGVhZGxpbmUpO1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGlmIChkZWFkbGluZSA9PT0gLUluZmluaXR5IHx8IGRlYWRsaW5lRGF0ZSA8PSBub3cpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBuZXcgRXJyb3IoJ0RlYWRsaW5lIHBhc3NlZCB3aXRob3V0IGNvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2UnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcih3YXRjaGVyT2JqZWN0KTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0RlYWRsaW5lIHBhc3NlZCB3aXRob3V0IGNvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2UnKSk7XG4gICAgICAgICAgICB9LCBkZWFkbGluZURhdGUuZ2V0VGltZSgpIC0gbm93LmdldFRpbWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2F0Y2hlck9iamVjdCA9IHtcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSxcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgdGltZXIsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5wdXNoKHdhdGNoZXJPYmplY3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNoYW5uZWx6IHJlZmVyZW5jZSBvYmplY3QgZm9yIHRoaXMgY2hhbm5lbC4gVGhlIHJldHVybmVkIHZhbHVlIGlzXG4gICAgICogZ2FyYmFnZSBpZiBjaGFubmVseiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjaGFubmVsLlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZ2V0Q2hhbm5lbHpSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWx6UmVmO1xuICAgIH1cbiAgICBjcmVhdGVDYWxsKG1ldGhvZCwgZGVhZGxpbmUsIGhvc3QsIHBhcmVudENhbGwsIHByb3BhZ2F0ZUZsYWdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCNjcmVhdGVDYWxsOiBtZXRob2QgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHR5cGVvZiBkZWFkbGluZSA9PT0gJ251bWJlcicgfHwgZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCNjcmVhdGVDYWxsOiBkZWFkbGluZSBtdXN0IGJlIGEgbnVtYmVyIG9yIERhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV04pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hhbm5lbCBoYXMgYmVlbiBzaHV0IGRvd24nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWxsTnVtYmVyID0gZ2V0TmV3Q2FsbE51bWJlcigpO1xuICAgICAgICB0aGlzLnRyYWNlKCdjcmVhdGVDYWxsIFsnICtcbiAgICAgICAgICAgIGNhbGxOdW1iZXIgK1xuICAgICAgICAgICAgJ10gbWV0aG9kPVwiJyArXG4gICAgICAgICAgICBtZXRob2QgK1xuICAgICAgICAgICAgJ1wiLCBkZWFkbGluZT0nICtcbiAgICAgICAgICAgIGRlYWRsaW5lKTtcbiAgICAgICAgY29uc3QgZmluYWxPcHRpb25zID0ge1xuICAgICAgICAgICAgZGVhZGxpbmU6IGRlYWRsaW5lLFxuICAgICAgICAgICAgZmxhZ3M6IHByb3BhZ2F0ZUZsYWdzICE9PSBudWxsICYmIHByb3BhZ2F0ZUZsYWdzICE9PSB2b2lkIDAgPyBwcm9wYWdhdGVGbGFncyA6IGNvbnN0YW50c18xLlByb3BhZ2F0ZS5ERUZBVUxUUyxcbiAgICAgICAgICAgIGhvc3Q6IGhvc3QgIT09IG51bGwgJiYgaG9zdCAhPT0gdm9pZCAwID8gaG9zdCA6IHRoaXMuZGVmYXVsdEF1dGhvcml0eSxcbiAgICAgICAgICAgIHBhcmVudENhbGw6IHBhcmVudENhbGwsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBjYWxsX3N0cmVhbV8xLkh0dHAyQ2FsbFN0cmVhbShtZXRob2QsIHRoaXMsIGZpbmFsT3B0aW9ucywgdGhpcy5maWx0ZXJTdGFja0ZhY3RvcnksIHRoaXMuY3JlZGVudGlhbHMuX2dldENhbGxDcmVkZW50aWFscygpLCBjYWxsTnVtYmVyKTtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxTdGFydGVkKCk7XG4gICAgICAgICAgICBzdHJlYW0uYWRkU3RhdHVzV2F0Y2hlcihzdGF0dXMgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbFN1Y2NlZWRlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG59XG5leHBvcnRzLkNoYW5uZWxJbXBsZW1lbnRhdGlvbiA9IENoYW5uZWxJbXBsZW1lbnRhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5uZWwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2hhbm5lbEltcGxlbWVudGF0aW9uIiwiY2FsbF9zdHJlYW1fMSIsInJlcXVpcmUiLCJjaGFubmVsX2NyZWRlbnRpYWxzXzEiLCJyZXNvbHZpbmdfbG9hZF9iYWxhbmNlcl8xIiwic3ViY2hhbm5lbF9wb29sXzEiLCJwaWNrZXJfMSIsImNvbnN0YW50c18xIiwiZmlsdGVyX3N0YWNrXzEiLCJjYWxsX2NyZWRlbnRpYWxzX2ZpbHRlcl8xIiwiZGVhZGxpbmVfZmlsdGVyXzEiLCJjb21wcmVzc2lvbl9maWx0ZXJfMSIsInJlc29sdmVyXzEiLCJsb2dnaW5nXzEiLCJtYXhfbWVzc2FnZV9zaXplX2ZpbHRlcl8xIiwiaHR0cF9wcm94eV8xIiwidXJpX3BhcnNlcl8xIiwiY29ubmVjdGl2aXR5X3N0YXRlXzEiLCJjaGFubmVsel8xIiwiTUFYX1RJTUVPVVRfVElNRSIsIm5leHRDYWxsTnVtYmVyIiwiZ2V0TmV3Q2FsbE51bWJlciIsImNhbGxOdW1iZXIiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiSU5BUFBST1BSSUFURV9DT05UUk9MX1BMQU5FX0NPREVTIiwiU3RhdHVzIiwiT0siLCJJTlZBTElEX0FSR1VNRU5UIiwiTk9UX0ZPVU5EIiwiQUxSRUFEWV9FWElTVFMiLCJGQUlMRURfUFJFQ09ORElUSU9OIiwiQUJPUlRFRCIsIk9VVF9PRl9SQU5HRSIsIkRBVEFfTE9TUyIsInJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZSIsImNvZGUiLCJkZXRhaWxzIiwiaW5jbHVkZXMiLCJJTlRFUk5BTCIsImNvbnN0cnVjdG9yIiwidGFyZ2V0IiwiY3JlZGVudGlhbHMiLCJvcHRpb25zIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJjb25uZWN0aXZpdHlTdGF0ZSIsIkNvbm5lY3Rpdml0eVN0YXRlIiwiSURMRSIsImN1cnJlbnRQaWNrZXIiLCJVbmF2YWlsYWJsZVBpY2tlciIsImNvbmZpZ1NlbGVjdGlvblF1ZXVlIiwicGlja1F1ZXVlIiwiY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycyIsImNvbmZpZ1NlbGVjdG9yIiwiY3VycmVudFJlc29sdXRpb25FcnJvciIsImNoYW5uZWx6RW5hYmxlZCIsImNhbGxUcmFja2VyIiwiQ2hhbm5lbHpDYWxsVHJhY2tlciIsImNoaWxkcmVuVHJhY2tlciIsIkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyIiwiVHlwZUVycm9yIiwiQ2hhbm5lbENyZWRlbnRpYWxzIiwib3JpZ2luYWxUYXJnZXQiLCJvcmlnaW5hbFRhcmdldFVyaSIsInBhcnNlVXJpIiwiRXJyb3IiLCJkZWZhdWx0U2NoZW1lTWFwUmVzdWx0IiwibWFwVXJpRGVmYXVsdFNjaGVtZSIsImNhbGxSZWZUaW1lciIsInNldEludGVydmFsIiwidW5yZWYiLCJjYWxsIiwiY2hhbm5lbHpUcmFjZSIsIkNoYW5uZWx6VHJhY2UiLCJjaGFubmVselJlZiIsInJlZ2lzdGVyQ2hhbm5lbHpDaGFubmVsIiwiZ2V0Q2hhbm5lbHpJbmZvIiwiYWRkVHJhY2UiLCJkZWZhdWx0QXV0aG9yaXR5IiwiZ2V0RGVmYXVsdEF1dGhvcml0eSIsInByb3h5TWFwUmVzdWx0IiwibWFwUHJveHlOYW1lIiwiYXNzaWduIiwiZXh0cmFPcHRpb25zIiwic3ViY2hhbm5lbFBvb2wiLCJnZXRTdWJjaGFubmVsUG9vbCIsImNoYW5uZWxDb250cm9sSGVscGVyIiwiY3JlYXRlU3ViY2hhbm5lbCIsInN1YmNoYW5uZWxBZGRyZXNzIiwic3ViY2hhbm5lbEFyZ3MiLCJzdWJjaGFubmVsIiwiZ2V0T3JDcmVhdGVTdWJjaGFubmVsIiwiZ2V0Q2hhbm5lbHpSZWYiLCJ1cGRhdGVTdGF0ZSIsInBpY2tlciIsInF1ZXVlQ29weSIsInNsaWNlIiwiY2FsbFJlZlRpbWVyVW5yZWYiLCJjYWxsU3RyZWFtIiwiY2FsbE1ldGFkYXRhIiwiY2FsbENvbmZpZyIsImR5bmFtaWNGaWx0ZXJzIiwidHJ5UGljayIsInJlcXVlc3RSZXJlc29sdXRpb24iLCJhZGRDaGFubmVsekNoaWxkIiwiY2hpbGQiLCJyZWZDaGlsZCIsInJlbW92ZUNoYW5uZWx6Q2hpbGQiLCJ1bnJlZkNoaWxkIiwicmVzb2x2aW5nTG9hZEJhbGFuY2VyIiwiUmVzb2x2aW5nTG9hZEJhbGFuY2VyIiwicHJvY2VzcyIsIm5leHRUaWNrIiwibG9jYWxRdWV1ZSIsInRyeUdldENvbmZpZyIsInN0YXR1cyIsImxlbmd0aCIsInRyYWNlIiwibWV0YWRhdGEiLCJnZXRPcHRpb25zIiwid2FpdEZvclJlYWR5IiwiY2FsbFJlZlRpbWVyUmVmIiwicHVzaCIsImNhbmNlbFdpdGhTdGF0dXMiLCJmaWx0ZXJTdGFja0ZhY3RvcnkiLCJGaWx0ZXJTdGFja0ZhY3RvcnkiLCJDYWxsQ3JlZGVudGlhbHNGaWx0ZXJGYWN0b3J5IiwiRGVhZGxpbmVGaWx0ZXJGYWN0b3J5IiwiTWF4TWVzc2FnZVNpemVGaWx0ZXJGYWN0b3J5IiwiQ29tcHJlc3Npb25GaWx0ZXJGYWN0b3J5IiwiSlNPTiIsInN0cmluZ2lmeSIsInVuZGVmaW5lZCIsImVycm9yIiwiTG9nVmVyYm9zaXR5IiwiREVCVUciLCJpZCIsInN0YWNrIiwic3Vic3RyaW5nIiwiaW5kZXhPZiIsInN0YXRlIiwiY2hpbGRyZW4iLCJnZXRDaGlsZExpc3RzIiwidGV4dCIsInZlcmJvc2l0eU92ZXJyaWRlIiwidXJpVG9TdHJpbmciLCJoYXNSZWYiLCJyZWYiLCJwdXNoUGljayIsInBpY2tSZXN1bHQiLCJwaWNrIiwiZXh0cmFQaWNrSW5mbyIsInBpY2tJbmZvcm1hdGlvbiIsInN1YmNoYW5uZWxTdHJpbmciLCJnZXRBZGRyZXNzIiwiZ2V0Q2FsbE51bWJlciIsIlBpY2tSZXN1bHRUeXBlIiwicGlja1Jlc3VsdFR5cGUiLCJDT01QTEVURSIsIlVOQVZBSUxBQkxFIiwiZ2V0Q29ubmVjdGl2aXR5U3RhdGUiLCJSRUFEWSIsImxvZyIsIkVSUk9SIiwiZmlsdGVyU3RhY2siLCJzZW5kTWV0YWRhdGEiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNsb25lIiwidGhlbiIsImZpbmFsTWV0YWRhdGEiLCJzdWJjaGFubmVsU3RhdGUiLCJwaWNrRXh0cmFGaWx0ZXJzIiwiZXh0cmFGaWx0ZXJGYWN0b3JpZXMiLCJtYXAiLCJmYWN0b3J5IiwiY3JlYXRlRmlsdGVyIiwiZ2V0UmVhbFN1YmNoYW5uZWwiLCJzdGFydENhbGxTdHJlYW0iLCJvbkNvbW1pdHRlZCIsIm9uQ2FsbFN0YXJ0ZWQiLCJlcnJvckNvZGUiLCJtZXNzYWdlIiwiSU5GTyIsIlVOS05PV04iLCJRVUVVRSIsIlRSQU5TSUVOVF9GQUlMVVJFIiwiRFJPUCIsInJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlciIsIndhdGNoZXJPYmplY3QiLCJ3YXRjaGVySW5kZXgiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJuZXdTdGF0ZSIsIndhdGNoZXJzQ29weSIsImN1cnJlbnRTdGF0ZSIsInRpbWVyIiwiY2xlYXJUaW1lb3V0IiwiY2FsbGJhY2siLCJzdHJlYW0iLCJnZXRTdGF0dXMiLCJleGl0SWRsZSIsImdldE1ldGhvZCIsIm1ldGhvZENvbmZpZyIsInRpbWVvdXQiLCJkZWFkbGluZSIsIkRhdGUiLCJzZXRTZWNvbmRzIiwiZ2V0U2Vjb25kcyIsInNlY29uZHMiLCJzZXRNaWxsaXNlY29uZHMiLCJnZXRNaWxsaXNlY29uZHMiLCJuYW5vcyIsInNldENvbmZpZ0RlYWRsaW5lIiwicmVmcmVzaCIsImR5bmFtaWNGaWx0ZXJGYWN0b3JpZXMiLCJkeW5hbWljRmlsdGVyU3RhY2tGYWN0b3J5IiwiZHluYW1pY0ZpbHRlclN0YWNrIiwiZmlsdGVyZWRNZXRhZGF0YSIsImdldEZpbHRlcnMiLCJfc3RhcnRDYWxsU3RyZWFtIiwiY2xvc2UiLCJkZXN0cm95IiwiU0hVVERPV04iLCJjbGVhckludGVydmFsIiwidW5yZWdpc3RlckNoYW5uZWx6UmVmIiwidW5yZWZVbnVzZWRTdWJjaGFubmVscyIsImdldFRhcmdldCIsInRyeVRvQ29ubmVjdCIsIndhdGNoQ29ubmVjdGl2aXR5U3RhdGUiLCJJbmZpbml0eSIsImRlYWRsaW5lRGF0ZSIsIm5vdyIsInNldFRpbWVvdXQiLCJnZXRUaW1lIiwiY3JlYXRlQ2FsbCIsIm1ldGhvZCIsImhvc3QiLCJwYXJlbnRDYWxsIiwicHJvcGFnYXRlRmxhZ3MiLCJmaW5hbE9wdGlvbnMiLCJmbGFncyIsIlByb3BhZ2F0ZSIsIkRFRkFVTFRTIiwiSHR0cDJDYWxsU3RyZWFtIiwiX2dldENhbGxDcmVkZW50aWFscyIsImFkZENhbGxTdGFydGVkIiwiYWRkU3RhdHVzV2F0Y2hlciIsImFkZENhbGxTdWNjZWVkZWQiLCJhZGRDYWxsRmFpbGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/channel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channelz.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = exports.getChannelzServiceDefinition = exports.getChannelzHandlers = exports.unregisterChannelzRef = exports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTracker = exports.ChannelzChildrenTracker = exports.ChannelzTrace = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst admin_1 = __webpack_require__(/*! ./admin */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\nfunction channelRefToMessage(ref) {\n    return {\n        channel_id: ref.id,\n        name: ref.name\n    };\n}\nfunction subchannelRefToMessage(ref) {\n    return {\n        subchannel_id: ref.id,\n        name: ref.name\n    };\n}\nfunction serverRefToMessage(ref) {\n    return {\n        server_id: ref.id\n    };\n}\nfunction socketRefToMessage(ref) {\n    return {\n        socket_id: ref.id,\n        name: ref.name\n    };\n}\n/**\n * The loose upper bound on the number of events that should be retained in a\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\n * number that should be large enough to contain the recent relevant\n * information, but small enough to not use excessive memory.\n */ const TARGET_RETAINED_TRACES = 32;\nclass ChannelzTrace {\n    constructor(){\n        this.events = [];\n        this.eventsLogged = 0;\n        this.creationTimestamp = new Date();\n    }\n    addTrace(severity, description, child) {\n        const timestamp = new Date();\n        this.events.push({\n            description: description,\n            severity: severity,\n            timestamp: timestamp,\n            childChannel: (child === null || child === void 0 ? void 0 : child.kind) === \"channel\" ? child : undefined,\n            childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === \"subchannel\" ? child : undefined\n        });\n        // Whenever the trace array gets too large, discard the first half\n        if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\n            this.events = this.events.slice(TARGET_RETAINED_TRACES);\n        }\n        this.eventsLogged += 1;\n    }\n    getTraceMessage() {\n        return {\n            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n            num_events_logged: this.eventsLogged,\n            events: this.events.map((event)=>{\n                return {\n                    description: event.description,\n                    severity: event.severity,\n                    timestamp: dateToProtoTimestamp(event.timestamp),\n                    channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,\n                    subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null\n                };\n            })\n        };\n    }\n}\nexports.ChannelzTrace = ChannelzTrace;\nclass ChannelzChildrenTracker {\n    constructor(){\n        this.channelChildren = new Map();\n        this.subchannelChildren = new Map();\n        this.socketChildren = new Map();\n    }\n    refChild(child) {\n        var _a, _b, _c;\n        switch(child.kind){\n            case \"channel\":\n                {\n                    let trackedChild = (_a = this.channelChildren.get(child.id)) !== null && _a !== void 0 ? _a : {\n                        ref: child,\n                        count: 0\n                    };\n                    trackedChild.count += 1;\n                    this.channelChildren.set(child.id, trackedChild);\n                    break;\n                }\n            case \"subchannel\":\n                {\n                    let trackedChild = (_b = this.subchannelChildren.get(child.id)) !== null && _b !== void 0 ? _b : {\n                        ref: child,\n                        count: 0\n                    };\n                    trackedChild.count += 1;\n                    this.subchannelChildren.set(child.id, trackedChild);\n                    break;\n                }\n            case \"socket\":\n                {\n                    let trackedChild = (_c = this.socketChildren.get(child.id)) !== null && _c !== void 0 ? _c : {\n                        ref: child,\n                        count: 0\n                    };\n                    trackedChild.count += 1;\n                    this.socketChildren.set(child.id, trackedChild);\n                    break;\n                }\n        }\n    }\n    unrefChild(child) {\n        switch(child.kind){\n            case \"channel\":\n                {\n                    let trackedChild = this.channelChildren.get(child.id);\n                    if (trackedChild !== undefined) {\n                        trackedChild.count -= 1;\n                        if (trackedChild.count === 0) {\n                            this.channelChildren.delete(child.id);\n                        } else {\n                            this.channelChildren.set(child.id, trackedChild);\n                        }\n                    }\n                    break;\n                }\n            case \"subchannel\":\n                {\n                    let trackedChild = this.subchannelChildren.get(child.id);\n                    if (trackedChild !== undefined) {\n                        trackedChild.count -= 1;\n                        if (trackedChild.count === 0) {\n                            this.subchannelChildren.delete(child.id);\n                        } else {\n                            this.subchannelChildren.set(child.id, trackedChild);\n                        }\n                    }\n                    break;\n                }\n            case \"socket\":\n                {\n                    let trackedChild = this.socketChildren.get(child.id);\n                    if (trackedChild !== undefined) {\n                        trackedChild.count -= 1;\n                        if (trackedChild.count === 0) {\n                            this.socketChildren.delete(child.id);\n                        } else {\n                            this.socketChildren.set(child.id, trackedChild);\n                        }\n                    }\n                    break;\n                }\n        }\n    }\n    getChildLists() {\n        const channels = [];\n        for (const { ref } of this.channelChildren.values()){\n            channels.push(ref);\n        }\n        const subchannels = [];\n        for (const { ref } of this.subchannelChildren.values()){\n            subchannels.push(ref);\n        }\n        const sockets = [];\n        for (const { ref } of this.socketChildren.values()){\n            sockets.push(ref);\n        }\n        return {\n            channels,\n            subchannels,\n            sockets\n        };\n    }\n}\nexports.ChannelzChildrenTracker = ChannelzChildrenTracker;\nclass ChannelzCallTracker {\n    constructor(){\n        this.callsStarted = 0;\n        this.callsSucceeded = 0;\n        this.callsFailed = 0;\n        this.lastCallStartedTimestamp = null;\n    }\n    addCallStarted() {\n        this.callsStarted += 1;\n        this.lastCallStartedTimestamp = new Date();\n    }\n    addCallSucceeded() {\n        this.callsSucceeded += 1;\n    }\n    addCallFailed() {\n        this.callsFailed += 1;\n    }\n}\nexports.ChannelzCallTracker = ChannelzCallTracker;\nlet nextId = 1;\nfunction getNextId() {\n    return nextId++;\n}\nconst channels = [];\nconst subchannels = [];\nconst servers = [];\nconst sockets = [];\nfunction registerChannelzChannel(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = {\n        id,\n        name,\n        kind: \"channel\"\n    };\n    if (channelzEnabled) {\n        channels[id] = {\n            ref,\n            getInfo\n        };\n    }\n    return ref;\n}\nexports.registerChannelzChannel = registerChannelzChannel;\nfunction registerChannelzSubchannel(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = {\n        id,\n        name,\n        kind: \"subchannel\"\n    };\n    if (channelzEnabled) {\n        subchannels[id] = {\n            ref,\n            getInfo\n        };\n    }\n    return ref;\n}\nexports.registerChannelzSubchannel = registerChannelzSubchannel;\nfunction registerChannelzServer(getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = {\n        id,\n        kind: \"server\"\n    };\n    if (channelzEnabled) {\n        servers[id] = {\n            ref,\n            getInfo\n        };\n    }\n    return ref;\n}\nexports.registerChannelzServer = registerChannelzServer;\nfunction registerChannelzSocket(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = {\n        id,\n        name,\n        kind: \"socket\"\n    };\n    if (channelzEnabled) {\n        sockets[id] = {\n            ref,\n            getInfo\n        };\n    }\n    return ref;\n}\nexports.registerChannelzSocket = registerChannelzSocket;\nfunction unregisterChannelzRef(ref) {\n    switch(ref.kind){\n        case \"channel\":\n            delete channels[ref.id];\n            return;\n        case \"subchannel\":\n            delete subchannels[ref.id];\n            return;\n        case \"server\":\n            delete servers[ref.id];\n            return;\n        case \"socket\":\n            delete sockets[ref.id];\n            return;\n    }\n}\nexports.unregisterChannelzRef = unregisterChannelzRef;\n/**\n * Parse a single section of an IPv6 address as two bytes\n * @param addressSection A hexadecimal string of length up to 4\n * @returns The pair of bytes representing this address section\n */ function parseIPv6Section(addressSection) {\n    const numberValue = Number.parseInt(addressSection, 16);\n    return [\n        numberValue / 256 | 0,\n        numberValue % 256\n    ];\n}\n/**\n * Parse a chunk of an IPv6 address string to some number of bytes\n * @param addressChunk Some number of segments of up to 4 hexadecimal\n *   characters each, joined by colons.\n * @returns The list of bytes representing this address chunk\n */ function parseIPv6Chunk(addressChunk) {\n    if (addressChunk === \"\") {\n        return [];\n    }\n    const bytePairs = addressChunk.split(\":\").map((section)=>parseIPv6Section(section));\n    const result = [];\n    return result.concat(...bytePairs);\n}\n/**\n * Converts an IPv4 or IPv6 address from string representation to binary\n * representation\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\n * @returns\n */ function ipAddressStringToBuffer(ipAddress) {\n    if (net_1.isIPv4(ipAddress)) {\n        return Buffer.from(Uint8Array.from(ipAddress.split(\".\").map((segment)=>Number.parseInt(segment))));\n    } else if (net_1.isIPv6(ipAddress)) {\n        let leftSection;\n        let rightSection;\n        const doubleColonIndex = ipAddress.indexOf(\"::\");\n        if (doubleColonIndex === -1) {\n            leftSection = ipAddress;\n            rightSection = \"\";\n        } else {\n            leftSection = ipAddress.substring(0, doubleColonIndex);\n            rightSection = ipAddress.substring(doubleColonIndex + 2);\n        }\n        const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\n        const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\n        const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);\n        return Buffer.concat([\n            leftBuffer,\n            middleBuffer,\n            rightBuffer\n        ]);\n    } else {\n        return null;\n    }\n}\nfunction connectivityStateToMessage(state) {\n    switch(state){\n        case connectivity_state_1.ConnectivityState.CONNECTING:\n            return {\n                state: \"CONNECTING\"\n            };\n        case connectivity_state_1.ConnectivityState.IDLE:\n            return {\n                state: \"IDLE\"\n            };\n        case connectivity_state_1.ConnectivityState.READY:\n            return {\n                state: \"READY\"\n            };\n        case connectivity_state_1.ConnectivityState.SHUTDOWN:\n            return {\n                state: \"SHUTDOWN\"\n            };\n        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n            return {\n                state: \"TRANSIENT_FAILURE\"\n            };\n        default:\n            return {\n                state: \"UNKNOWN\"\n            };\n    }\n}\nfunction dateToProtoTimestamp(date) {\n    if (!date) {\n        return null;\n    }\n    const millisSinceEpoch = date.getTime();\n    return {\n        seconds: millisSinceEpoch / 1000 | 0,\n        nanos: millisSinceEpoch % 1000 * 1000000\n    };\n}\nfunction getChannelMessage(channelEntry) {\n    const resolvedInfo = channelEntry.getInfo();\n    return {\n        ref: channelRefToMessage(channelEntry.ref),\n        data: {\n            target: resolvedInfo.target,\n            state: connectivityStateToMessage(resolvedInfo.state),\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage()\n        },\n        channel_ref: resolvedInfo.children.channels.map((ref)=>channelRefToMessage(ref)),\n        subchannel_ref: resolvedInfo.children.subchannels.map((ref)=>subchannelRefToMessage(ref))\n    };\n}\nfunction GetChannel(call, callback) {\n    const channelId = Number.parseInt(call.request.channel_id);\n    const channelEntry = channels[channelId];\n    if (channelEntry === undefined) {\n        callback({\n            \"code\": constants_1.Status.NOT_FOUND,\n            \"details\": \"No channel data found for id \" + channelId\n        });\n        return;\n    }\n    callback(null, {\n        channel: getChannelMessage(channelEntry)\n    });\n}\nfunction GetTopChannels(call, callback) {\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resultList = [];\n    let i = Number.parseInt(call.request.start_channel_id);\n    for(; i < channels.length; i++){\n        const channelEntry = channels[i];\n        if (channelEntry === undefined) {\n            continue;\n        }\n        resultList.push(getChannelMessage(channelEntry));\n        if (resultList.length >= maxResults) {\n            break;\n        }\n    }\n    callback(null, {\n        channel: resultList,\n        end: i >= servers.length\n    });\n}\nfunction getServerMessage(serverEntry) {\n    const resolvedInfo = serverEntry.getInfo();\n    return {\n        ref: serverRefToMessage(serverEntry.ref),\n        data: {\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage()\n        },\n        listen_socket: resolvedInfo.listenerChildren.sockets.map((ref)=>socketRefToMessage(ref))\n    };\n}\nfunction GetServer(call, callback) {\n    const serverId = Number.parseInt(call.request.server_id);\n    const serverEntry = servers[serverId];\n    if (serverEntry === undefined) {\n        callback({\n            \"code\": constants_1.Status.NOT_FOUND,\n            \"details\": \"No server data found for id \" + serverId\n        });\n        return;\n    }\n    callback(null, {\n        server: getServerMessage(serverEntry)\n    });\n}\nfunction GetServers(call, callback) {\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resultList = [];\n    let i = Number.parseInt(call.request.start_server_id);\n    for(; i < servers.length; i++){\n        const serverEntry = servers[i];\n        if (serverEntry === undefined) {\n            continue;\n        }\n        resultList.push(getServerMessage(serverEntry));\n        if (resultList.length >= maxResults) {\n            break;\n        }\n    }\n    callback(null, {\n        server: resultList,\n        end: i >= servers.length\n    });\n}\nfunction GetSubchannel(call, callback) {\n    const subchannelId = Number.parseInt(call.request.subchannel_id);\n    const subchannelEntry = subchannels[subchannelId];\n    if (subchannelEntry === undefined) {\n        callback({\n            \"code\": constants_1.Status.NOT_FOUND,\n            \"details\": \"No subchannel data found for id \" + subchannelId\n        });\n        return;\n    }\n    const resolvedInfo = subchannelEntry.getInfo();\n    const subchannelMessage = {\n        ref: subchannelRefToMessage(subchannelEntry.ref),\n        data: {\n            target: resolvedInfo.target,\n            state: connectivityStateToMessage(resolvedInfo.state),\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage()\n        },\n        socket_ref: resolvedInfo.children.sockets.map((ref)=>socketRefToMessage(ref))\n    };\n    callback(null, {\n        subchannel: subchannelMessage\n    });\n}\nfunction subchannelAddressToAddressMessage(subchannelAddress) {\n    var _a;\n    if (subchannel_address_1.isTcpSubchannelAddress(subchannelAddress)) {\n        return {\n            address: \"tcpip_address\",\n            tcpip_address: {\n                ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : undefined,\n                port: subchannelAddress.port\n            }\n        };\n    } else {\n        return {\n            address: \"uds_address\",\n            uds_address: {\n                filename: subchannelAddress.path\n            }\n        };\n    }\n}\nfunction GetSocket(call, callback) {\n    var _a, _b, _c, _d, _e;\n    const socketId = Number.parseInt(call.request.socket_id);\n    const socketEntry = sockets[socketId];\n    if (socketEntry === undefined) {\n        callback({\n            \"code\": constants_1.Status.NOT_FOUND,\n            \"details\": \"No socket data found for id \" + socketId\n        });\n        return;\n    }\n    const resolvedInfo = socketEntry.getInfo();\n    const securityMessage = resolvedInfo.security ? {\n        model: \"tls\",\n        tls: {\n            cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? \"standard_name\" : \"other_name\",\n            standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : undefined,\n            other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : undefined,\n            local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : undefined,\n            remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : undefined\n        }\n    } : null;\n    const socketMessage = {\n        ref: socketRefToMessage(socketEntry.ref),\n        local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,\n        remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,\n        remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : undefined,\n        security: securityMessage,\n        data: {\n            keep_alives_sent: resolvedInfo.keepAlivesSent,\n            streams_started: resolvedInfo.streamsStarted,\n            streams_succeeded: resolvedInfo.streamsSucceeded,\n            streams_failed: resolvedInfo.streamsFailed,\n            last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),\n            last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),\n            messages_received: resolvedInfo.messagesReceived,\n            messages_sent: resolvedInfo.messagesSent,\n            last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),\n            last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),\n            local_flow_control_window: resolvedInfo.localFlowControlWindow ? {\n                value: resolvedInfo.localFlowControlWindow\n            } : null,\n            remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? {\n                value: resolvedInfo.remoteFlowControlWindow\n            } : null\n        }\n    };\n    callback(null, {\n        socket: socketMessage\n    });\n}\nfunction GetServerSockets(call, callback) {\n    const serverId = Number.parseInt(call.request.server_id);\n    const serverEntry = servers[serverId];\n    if (serverEntry === undefined) {\n        callback({\n            \"code\": constants_1.Status.NOT_FOUND,\n            \"details\": \"No server data found for id \" + serverId\n        });\n        return;\n    }\n    const startId = Number.parseInt(call.request.start_socket_id);\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resolvedInfo = serverEntry.getInfo();\n    // If we wanted to include listener sockets in the result, this line would\n    // instead say\n    // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\n    const allSockets = resolvedInfo.sessionChildren.sockets.sort((ref1, ref2)=>ref1.id - ref2.id);\n    const resultList = [];\n    let i = 0;\n    for(; i < allSockets.length; i++){\n        if (allSockets[i].id >= startId) {\n            resultList.push(socketRefToMessage(allSockets[i]));\n            if (resultList.length >= maxResults) {\n                break;\n            }\n        }\n    }\n    callback(null, {\n        socket_ref: resultList,\n        end: i >= allSockets.length\n    });\n}\nfunction getChannelzHandlers() {\n    return {\n        GetChannel,\n        GetTopChannels,\n        GetServer,\n        GetServers,\n        GetSubchannel,\n        GetSocket,\n        GetServerSockets\n    };\n}\nexports.getChannelzHandlers = getChannelzHandlers;\nlet loadedChannelzDefinition = null;\nfunction getChannelzServiceDefinition() {\n    if (loadedChannelzDefinition) {\n        return loadedChannelzDefinition;\n    }\n    /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n     * runtime for users who will not use/enable channelz. */ const loaderLoadSync = (__webpack_require__(/*! @grpc/proto-loader */ \"(ssr)/./node_modules/@grpc/proto-loader/build/src/index.js\").loadSync);\n    const loadedProto = loaderLoadSync(\"channelz.proto\", {\n        keepCase: true,\n        longs: String,\n        enums: String,\n        defaults: true,\n        oneofs: true,\n        includeDirs: [\n            `${__dirname}/../../proto`\n        ]\n    });\n    const channelzGrpcObject = make_client_1.loadPackageDefinition(loadedProto);\n    loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;\n    return loadedChannelzDefinition;\n}\nexports.getChannelzServiceDefinition = getChannelzServiceDefinition;\nfunction setup() {\n    admin_1.registerAdminService(getChannelzServiceDefinition, getChannelzHandlers);\n}\nexports.setup = setup; //# sourceMappingURL=channelz.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbHouanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGFBQWEsR0FBR0Esb0NBQW9DLEdBQUdBLDJCQUEyQixHQUFHQSw2QkFBNkIsR0FBR0EsOEJBQThCLEdBQUdBLDhCQUE4QixHQUFHQSxrQ0FBa0MsR0FBR0EsK0JBQStCLEdBQUdBLDJCQUEyQixHQUFHQSwrQkFBK0IsR0FBR0EscUJBQXFCLEdBQUcsS0FBSztBQUMzVixNQUFNYSxRQUFRQyxtQkFBT0EsQ0FBQyxnQkFBSztBQUMzQixNQUFNQyx1QkFBdUJELG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRyx1QkFBdUJILG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNSSxVQUFVSixtQkFBT0EsQ0FBQyxzRUFBUztBQUNqQyxNQUFNSyxnQkFBZ0JMLG1CQUFPQSxDQUFDLGtGQUFlO0FBQzdDLFNBQVNNLG9CQUFvQkMsR0FBRztJQUM1QixPQUFPO1FBQ0hDLFlBQVlELElBQUlFLEVBQUU7UUFDbEJDLE1BQU1ILElBQUlHLElBQUk7SUFDbEI7QUFDSjtBQUNBLFNBQVNDLHVCQUF1QkosR0FBRztJQUMvQixPQUFPO1FBQ0hLLGVBQWVMLElBQUlFLEVBQUU7UUFDckJDLE1BQU1ILElBQUlHLElBQUk7SUFDbEI7QUFDSjtBQUNBLFNBQVNHLG1CQUFtQk4sR0FBRztJQUMzQixPQUFPO1FBQ0hPLFdBQVdQLElBQUlFLEVBQUU7SUFDckI7QUFDSjtBQUNBLFNBQVNNLG1CQUFtQlIsR0FBRztJQUMzQixPQUFPO1FBQ0hTLFdBQVdULElBQUlFLEVBQUU7UUFDakJDLE1BQU1ILElBQUlHLElBQUk7SUFDbEI7QUFDSjtBQUNBOzs7OztDQUtDLEdB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UUFDWkcsS0FBS0YsS0FBS2tGLFdBQVc3TCxNQUFNO0lBQy9CO0FBQ0o7QUFDQSxTQUFTM0M7SUFDTCxPQUFPO1FBQ0gwSTtRQUNBUTtRQUNBVztRQUNBRztRQUNBRTtRQUNBaUI7UUFDQWtEO0lBQ0o7QUFDSjtBQUNBek8sMkJBQTJCLEdBQUdJO0FBQzlCLElBQUk2TywyQkFBMkI7QUFDL0IsU0FBUzlPO0lBQ0wsSUFBSThPLDBCQUEwQjtRQUMxQixPQUFPQTtJQUNYO0lBQ0E7MkRBQ3VELEdBQ3ZELE1BQU1DLGlCQUFpQnBPLHNIQUFzQztJQUM3RCxNQUFNc08sY0FBY0YsZUFBZSxrQkFBa0I7UUFDakRHLFVBQVU7UUFDVkMsT0FBT0M7UUFDUEMsT0FBT0Q7UUFDUEUsVUFBVTtRQUNWQyxRQUFRO1FBQ1JDLGFBQWE7WUFDVCxDQUFDLEVBQUVDLFVBQVUsWUFBWSxDQUFDO1NBQzdCO0lBQ0w7SUFDQSxNQUFNQyxxQkFBcUIxTyxjQUFjMk8scUJBQXFCLENBQUNWO0lBQy9ESCwyQkFBMkJZLG1CQUFtQkUsSUFBSSxDQUFDQyxRQUFRLENBQUNDLEVBQUUsQ0FBQ0MsUUFBUSxDQUFDQyxPQUFPO0lBQy9FLE9BQU9sQjtBQUNYO0FBQ0FqUCxvQ0FBb0MsR0FBR0c7QUFDdkMsU0FBU0Q7SUFDTGdCLFFBQVFrUCxvQkFBb0IsQ0FBQ2pRLDhCQUE4QkM7QUFDL0Q7QUFDQUosYUFBYSxHQUFHRSxPQUNoQixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc2htaXR0LWd1cHRhLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NoYW5uZWx6LmpzPzYyNzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0dXAgPSBleHBvcnRzLmdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24gPSBleHBvcnRzLmdldENoYW5uZWx6SGFuZGxlcnMgPSBleHBvcnRzLnVucmVnaXN0ZXJDaGFubmVselJlZiA9IGV4cG9ydHMucmVnaXN0ZXJDaGFubmVselNvY2tldCA9IGV4cG9ydHMucmVnaXN0ZXJDaGFubmVselNlcnZlciA9IGV4cG9ydHMucmVnaXN0ZXJDaGFubmVselN1YmNoYW5uZWwgPSBleHBvcnRzLnJlZ2lzdGVyQ2hhbm5lbHpDaGFubmVsID0gZXhwb3J0cy5DaGFubmVsekNhbGxUcmFja2VyID0gZXhwb3J0cy5DaGFubmVsekNoaWxkcmVuVHJhY2tlciA9IGV4cG9ydHMuQ2hhbm5lbHpUcmFjZSA9IHZvaWQgMDtcbmNvbnN0IG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IGFkbWluXzEgPSByZXF1aXJlKFwiLi9hZG1pblwiKTtcbmNvbnN0IG1ha2VfY2xpZW50XzEgPSByZXF1aXJlKFwiLi9tYWtlLWNsaWVudFwiKTtcbmZ1bmN0aW9uIGNoYW5uZWxSZWZUb01lc3NhZ2UocmVmKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hhbm5lbF9pZDogcmVmLmlkLFxuICAgICAgICBuYW1lOiByZWYubmFtZVxuICAgIH07XG59XG5mdW5jdGlvbiBzdWJjaGFubmVsUmVmVG9NZXNzYWdlKHJlZikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YmNoYW5uZWxfaWQ6IHJlZi5pZCxcbiAgICAgICAgbmFtZTogcmVmLm5hbWVcbiAgICB9O1xufVxuZnVuY3Rpb24gc2VydmVyUmVmVG9NZXNzYWdlKHJlZikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlcnZlcl9pZDogcmVmLmlkXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNvY2tldFJlZlRvTWVzc2FnZShyZWYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzb2NrZXRfaWQ6IHJlZi5pZCxcbiAgICAgICAgbmFtZTogcmVmLm5hbWVcbiAgICB9O1xufVxuLyoqXG4gKiBUaGUgbG9vc2UgdXBwZXIgYm91bmQgb24gdGhlIG51bWJlciBvZiBldmVudHMgdGhhdCBzaG91bGQgYmUgcmV0YWluZWQgaW4gYVxuICogdHJhY2UuIFRoaXMgbWF5IGJlIGV4Y2VlZGVkIGJ5IHVwIHRvIGEgZmFjdG9yIG9mIDIuIEFyYml0cmFyaWx5IGNob3NlbiBhcyBhXG4gKiBudW1iZXIgdGhhdCBzaG91bGQgYmUgbGFyZ2UgZW5vdWdoIHRvIGNvbnRhaW4gdGhlIHJlY2VudCByZWxldmFudFxuICogaW5mb3JtYXRpb24sIGJ1dCBzbWFsbCBlbm91Z2ggdG8gbm90IHVzZSBleGNlc3NpdmUgbWVtb3J5LlxuICovXG5jb25zdCBUQVJHRVRfUkVUQUlORURfVFJBQ0VTID0gMzI7XG5jbGFzcyBDaGFubmVselRyYWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5ldmVudHNMb2dnZWQgPSAwO1xuICAgICAgICB0aGlzLmNyZWF0aW9uVGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgYWRkVHJhY2Uoc2V2ZXJpdHksIGRlc2NyaXB0aW9uLCBjaGlsZCkge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHNldmVyaXR5OiBzZXZlcml0eSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgICAgICAgICAgY2hpbGRDaGFubmVsOiAoY2hpbGQgPT09IG51bGwgfHwgY2hpbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoaWxkLmtpbmQpID09PSAnY2hhbm5lbCcgPyBjaGlsZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNoaWxkU3ViY2hhbm5lbDogKGNoaWxkID09PSBudWxsIHx8IGNoaWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGlsZC5raW5kKSA9PT0gJ3N1YmNoYW5uZWwnID8gY2hpbGQgOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdoZW5ldmVyIHRoZSB0cmFjZSBhcnJheSBnZXRzIHRvbyBsYXJnZSwgZGlzY2FyZCB0aGUgZmlyc3QgaGFsZlxuICAgICAgICBpZiAodGhpcy5ldmVudHMubGVuZ3RoID49IFRBUkdFVF9SRVRBSU5FRF9UUkFDRVMgKiAyKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IHRoaXMuZXZlbnRzLnNsaWNlKFRBUkdFVF9SRVRBSU5FRF9UUkFDRVMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRzTG9nZ2VkICs9IDE7XG4gICAgfVxuICAgIGdldFRyYWNlTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0aW9uX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAodGhpcy5jcmVhdGlvblRpbWVzdGFtcCksXG4gICAgICAgICAgICBudW1fZXZlbnRzX2xvZ2dlZDogdGhpcy5ldmVudHNMb2dnZWQsXG4gICAgICAgICAgICBldmVudHM6IHRoaXMuZXZlbnRzLm1hcChldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGV2ZW50LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzZXZlcml0eTogZXZlbnQuc2V2ZXJpdHksXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAoZXZlbnQudGltZXN0YW1wKSxcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbF9yZWY6IGV2ZW50LmNoaWxkQ2hhbm5lbCA/IGNoYW5uZWxSZWZUb01lc3NhZ2UoZXZlbnQuY2hpbGRDaGFubmVsKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxfcmVmOiBldmVudC5jaGlsZFN1YmNoYW5uZWwgPyBzdWJjaGFubmVsUmVmVG9NZXNzYWdlKGV2ZW50LmNoaWxkU3ViY2hhbm5lbCkgOiBudWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5DaGFubmVselRyYWNlID0gQ2hhbm5lbHpUcmFjZTtcbmNsYXNzIENoYW5uZWx6Q2hpbGRyZW5UcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsQ2hpbGRyZW4gPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbENoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNvY2tldENoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICByZWZDaGlsZChjaGlsZCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgc3dpdGNoIChjaGlsZC5raW5kKSB7XG4gICAgICAgICAgICBjYXNlICdjaGFubmVsJzoge1xuICAgICAgICAgICAgICAgIGxldCB0cmFja2VkQ2hpbGQgPSAoX2EgPSB0aGlzLmNoYW5uZWxDaGlsZHJlbi5nZXQoY2hpbGQuaWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7IHJlZjogY2hpbGQsIGNvdW50OiAwIH07XG4gICAgICAgICAgICAgICAgdHJhY2tlZENoaWxkLmNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsQ2hpbGRyZW4uc2V0KGNoaWxkLmlkLCB0cmFja2VkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc3ViY2hhbm5lbCc6IHtcbiAgICAgICAgICAgICAgICBsZXQgdHJhY2tlZENoaWxkID0gKF9iID0gdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4uZ2V0KGNoaWxkLmlkKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogeyByZWY6IGNoaWxkLCBjb3VudDogMCB9O1xuICAgICAgICAgICAgICAgIHRyYWNrZWRDaGlsZC5jb3VudCArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbENoaWxkcmVuLnNldChjaGlsZC5pZCwgdHJhY2tlZENoaWxkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3NvY2tldCc6IHtcbiAgICAgICAgICAgICAgICBsZXQgdHJhY2tlZENoaWxkID0gKF9jID0gdGhpcy5zb2NrZXRDaGlsZHJlbi5nZXQoY2hpbGQuaWQpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7IHJlZjogY2hpbGQsIGNvdW50OiAwIH07XG4gICAgICAgICAgICAgICAgdHJhY2tlZENoaWxkLmNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXRDaGlsZHJlbi5zZXQoY2hpbGQuaWQsIHRyYWNrZWRDaGlsZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5yZWZDaGlsZChjaGlsZCkge1xuICAgICAgICBzd2l0Y2ggKGNoaWxkLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NoYW5uZWwnOiB7XG4gICAgICAgICAgICAgICAgbGV0IHRyYWNrZWRDaGlsZCA9IHRoaXMuY2hhbm5lbENoaWxkcmVuLmdldChjaGlsZC5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrZWRDaGlsZC5jb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tlZENoaWxkLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxDaGlsZHJlbi5kZWxldGUoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsQ2hpbGRyZW4uc2V0KGNoaWxkLmlkLCB0cmFja2VkQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc3ViY2hhbm5lbCc6IHtcbiAgICAgICAgICAgICAgICBsZXQgdHJhY2tlZENoaWxkID0gdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4uZ2V0KGNoaWxkLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tlZENoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tlZENoaWxkLmNvdW50IC09IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFja2VkQ2hpbGQuY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbENoaWxkcmVuLmRlbGV0ZShjaGlsZC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbi5zZXQoY2hpbGQuaWQsIHRyYWNrZWRDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdzb2NrZXQnOiB7XG4gICAgICAgICAgICAgICAgbGV0IHRyYWNrZWRDaGlsZCA9IHRoaXMuc29ja2V0Q2hpbGRyZW4uZ2V0KGNoaWxkLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tlZENoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tlZENoaWxkLmNvdW50IC09IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFja2VkQ2hpbGQuY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0Q2hpbGRyZW4uZGVsZXRlKGNoaWxkLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0Q2hpbGRyZW4uc2V0KGNoaWxkLmlkLCB0cmFja2VkQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldENoaWxkTGlzdHMoKSB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgeyByZWYgfSBvZiB0aGlzLmNoYW5uZWxDaGlsZHJlbi52YWx1ZXMoKSkge1xuICAgICAgICAgICAgY2hhbm5lbHMucHVzaChyZWYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YmNoYW5uZWxzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgeyByZWYgfSBvZiB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbi52YWx1ZXMoKSkge1xuICAgICAgICAgICAgc3ViY2hhbm5lbHMucHVzaChyZWYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvY2tldHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IHJlZiB9IG9mIHRoaXMuc29ja2V0Q2hpbGRyZW4udmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHNvY2tldHMucHVzaChyZWYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYW5uZWxzLCBzdWJjaGFubmVscywgc29ja2V0cyB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXIgPSBDaGFubmVsekNoaWxkcmVuVHJhY2tlcjtcbmNsYXNzIENoYW5uZWx6Q2FsbFRyYWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNhbGxzU3RhcnRlZCA9IDA7XG4gICAgICAgIHRoaXMuY2FsbHNTdWNjZWVkZWQgPSAwO1xuICAgICAgICB0aGlzLmNhbGxzRmFpbGVkID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXAgPSBudWxsO1xuICAgIH1cbiAgICBhZGRDYWxsU3RhcnRlZCgpIHtcbiAgICAgICAgdGhpcy5jYWxsc1N0YXJ0ZWQgKz0gMTtcbiAgICAgICAgdGhpcy5sYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgICBhZGRDYWxsU3VjY2VlZGVkKCkge1xuICAgICAgICB0aGlzLmNhbGxzU3VjY2VlZGVkICs9IDE7XG4gICAgfVxuICAgIGFkZENhbGxGYWlsZWQoKSB7XG4gICAgICAgIHRoaXMuY2FsbHNGYWlsZWQgKz0gMTtcbiAgICB9XG59XG5leHBvcnRzLkNoYW5uZWx6Q2FsbFRyYWNrZXIgPSBDaGFubmVsekNhbGxUcmFja2VyO1xubGV0IG5leHRJZCA9IDE7XG5mdW5jdGlvbiBnZXROZXh0SWQoKSB7XG4gICAgcmV0dXJuIG5leHRJZCsrO1xufVxuY29uc3QgY2hhbm5lbHMgPSBbXTtcbmNvbnN0IHN1YmNoYW5uZWxzID0gW107XG5jb25zdCBzZXJ2ZXJzID0gW107XG5jb25zdCBzb2NrZXRzID0gW107XG5mdW5jdGlvbiByZWdpc3RlckNoYW5uZWx6Q2hhbm5lbChuYW1lLCBnZXRJbmZvLCBjaGFubmVsekVuYWJsZWQpIHtcbiAgICBjb25zdCBpZCA9IGdldE5leHRJZCgpO1xuICAgIGNvbnN0IHJlZiA9IHsgaWQsIG5hbWUsIGtpbmQ6ICdjaGFubmVsJyB9O1xuICAgIGlmIChjaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgY2hhbm5lbHNbaWRdID0geyByZWYsIGdldEluZm8gfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbn1cbmV4cG9ydHMucmVnaXN0ZXJDaGFubmVsekNoYW5uZWwgPSByZWdpc3RlckNoYW5uZWx6Q2hhbm5lbDtcbmZ1bmN0aW9uIHJlZ2lzdGVyQ2hhbm5lbHpTdWJjaGFubmVsKG5hbWUsIGdldEluZm8sIGNoYW5uZWx6RW5hYmxlZCkge1xuICAgIGNvbnN0IGlkID0gZ2V0TmV4dElkKCk7XG4gICAgY29uc3QgcmVmID0geyBpZCwgbmFtZSwga2luZDogJ3N1YmNoYW5uZWwnIH07XG4gICAgaWYgKGNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICBzdWJjaGFubmVsc1tpZF0gPSB7IHJlZiwgZ2V0SW5mbyB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVmO1xufVxuZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbCA9IHJlZ2lzdGVyQ2hhbm5lbHpTdWJjaGFubmVsO1xuZnVuY3Rpb24gcmVnaXN0ZXJDaGFubmVselNlcnZlcihnZXRJbmZvLCBjaGFubmVsekVuYWJsZWQpIHtcbiAgICBjb25zdCBpZCA9IGdldE5leHRJZCgpO1xuICAgIGNvbnN0IHJlZiA9IHsgaWQsIGtpbmQ6ICdzZXJ2ZXInIH07XG4gICAgaWYgKGNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICBzZXJ2ZXJzW2lkXSA9IHsgcmVmLCBnZXRJbmZvIH07XG4gICAgfVxuICAgIHJldHVybiByZWY7XG59XG5leHBvcnRzLnJlZ2lzdGVyQ2hhbm5lbHpTZXJ2ZXIgPSByZWdpc3RlckNoYW5uZWx6U2VydmVyO1xuZnVuY3Rpb24gcmVnaXN0ZXJDaGFubmVselNvY2tldChuYW1lLCBnZXRJbmZvLCBjaGFubmVsekVuYWJsZWQpIHtcbiAgICBjb25zdCBpZCA9IGdldE5leHRJZCgpO1xuICAgIGNvbnN0IHJlZiA9IHsgaWQsIG5hbWUsIGtpbmQ6ICdzb2NrZXQnIH07XG4gICAgaWYgKGNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICBzb2NrZXRzW2lkXSA9IHsgcmVmLCBnZXRJbmZvIH07XG4gICAgfVxuICAgIHJldHVybiByZWY7XG59XG5leHBvcnRzLnJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQgPSByZWdpc3RlckNoYW5uZWx6U29ja2V0O1xuZnVuY3Rpb24gdW5yZWdpc3RlckNoYW5uZWx6UmVmKHJlZikge1xuICAgIHN3aXRjaCAocmVmLmtpbmQpIHtcbiAgICAgICAgY2FzZSAnY2hhbm5lbCc6XG4gICAgICAgICAgICBkZWxldGUgY2hhbm5lbHNbcmVmLmlkXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAnc3ViY2hhbm5lbCc6XG4gICAgICAgICAgICBkZWxldGUgc3ViY2hhbm5lbHNbcmVmLmlkXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAnc2VydmVyJzpcbiAgICAgICAgICAgIGRlbGV0ZSBzZXJ2ZXJzW3JlZi5pZF07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgJ3NvY2tldCc6XG4gICAgICAgICAgICBkZWxldGUgc29ja2V0c1tyZWYuaWRdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgIH1cbn1cbmV4cG9ydHMudW5yZWdpc3RlckNoYW5uZWx6UmVmID0gdW5yZWdpc3RlckNoYW5uZWx6UmVmO1xuLyoqXG4gKiBQYXJzZSBhIHNpbmdsZSBzZWN0aW9uIG9mIGFuIElQdjYgYWRkcmVzcyBhcyB0d28gYnl0ZXNcbiAqIEBwYXJhbSBhZGRyZXNzU2VjdGlvbiBBIGhleGFkZWNpbWFsIHN0cmluZyBvZiBsZW5ndGggdXAgdG8gNFxuICogQHJldHVybnMgVGhlIHBhaXIgb2YgYnl0ZXMgcmVwcmVzZW50aW5nIHRoaXMgYWRkcmVzcyBzZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSVB2NlNlY3Rpb24oYWRkcmVzc1NlY3Rpb24pIHtcbiAgICBjb25zdCBudW1iZXJWYWx1ZSA9IE51bWJlci5wYXJzZUludChhZGRyZXNzU2VjdGlvbiwgMTYpO1xuICAgIHJldHVybiBbbnVtYmVyVmFsdWUgLyAyNTYgfCAwLCBudW1iZXJWYWx1ZSAlIDI1Nl07XG59XG4vKipcbiAqIFBhcnNlIGEgY2h1bmsgb2YgYW4gSVB2NiBhZGRyZXNzIHN0cmluZyB0byBzb21lIG51bWJlciBvZiBieXRlc1xuICogQHBhcmFtIGFkZHJlc3NDaHVuayBTb21lIG51bWJlciBvZiBzZWdtZW50cyBvZiB1cCB0byA0IGhleGFkZWNpbWFsXG4gKiAgIGNoYXJhY3RlcnMgZWFjaCwgam9pbmVkIGJ5IGNvbG9ucy5cbiAqIEByZXR1cm5zIFRoZSBsaXN0IG9mIGJ5dGVzIHJlcHJlc2VudGluZyB0aGlzIGFkZHJlc3MgY2h1bmtcbiAqL1xuZnVuY3Rpb24gcGFyc2VJUHY2Q2h1bmsoYWRkcmVzc0NodW5rKSB7XG4gICAgaWYgKGFkZHJlc3NDaHVuayA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBieXRlUGFpcnMgPSBhZGRyZXNzQ2h1bmsuc3BsaXQoJzonKS5tYXAoc2VjdGlvbiA9PiBwYXJzZUlQdjZTZWN0aW9uKHNlY3Rpb24pKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICByZXR1cm4gcmVzdWx0LmNvbmNhdCguLi5ieXRlUGFpcnMpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBJUHY0IG9yIElQdjYgYWRkcmVzcyBmcm9tIHN0cmluZyByZXByZXNlbnRhdGlvbiB0byBiaW5hcnlcbiAqIHJlcHJlc2VudGF0aW9uXG4gKiBAcGFyYW0gaXBBZGRyZXNzIGFuIElQIGFkZHJlc3MgaW4gc3RhbmRhcmQgSVB2NCBvciBJUHY2IHRleHQgZm9ybWF0XG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBpcEFkZHJlc3NTdHJpbmdUb0J1ZmZlcihpcEFkZHJlc3MpIHtcbiAgICBpZiAobmV0XzEuaXNJUHY0KGlwQWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFVpbnQ4QXJyYXkuZnJvbShpcEFkZHJlc3Muc3BsaXQoJy4nKS5tYXAoc2VnbWVudCA9PiBOdW1iZXIucGFyc2VJbnQoc2VnbWVudCkpKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5ldF8xLmlzSVB2NihpcEFkZHJlc3MpKSB7XG4gICAgICAgIGxldCBsZWZ0U2VjdGlvbjtcbiAgICAgICAgbGV0IHJpZ2h0U2VjdGlvbjtcbiAgICAgICAgY29uc3QgZG91YmxlQ29sb25JbmRleCA9IGlwQWRkcmVzcy5pbmRleE9mKCc6OicpO1xuICAgICAgICBpZiAoZG91YmxlQ29sb25JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGxlZnRTZWN0aW9uID0gaXBBZGRyZXNzO1xuICAgICAgICAgICAgcmlnaHRTZWN0aW9uID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZWZ0U2VjdGlvbiA9IGlwQWRkcmVzcy5zdWJzdHJpbmcoMCwgZG91YmxlQ29sb25JbmRleCk7XG4gICAgICAgICAgICByaWdodFNlY3Rpb24gPSBpcEFkZHJlc3Muc3Vic3RyaW5nKGRvdWJsZUNvbG9uSW5kZXggKyAyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZWZ0QnVmZmVyID0gQnVmZmVyLmZyb20ocGFyc2VJUHY2Q2h1bmsobGVmdFNlY3Rpb24pKTtcbiAgICAgICAgY29uc3QgcmlnaHRCdWZmZXIgPSBCdWZmZXIuZnJvbShwYXJzZUlQdjZDaHVuayhyaWdodFNlY3Rpb24pKTtcbiAgICAgICAgY29uc3QgbWlkZGxlQnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2IC0gbGVmdEJ1ZmZlci5sZW5ndGggLSByaWdodEJ1ZmZlci5sZW5ndGgsIDApO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbbGVmdEJ1ZmZlciwgbWlkZGxlQnVmZmVyLCByaWdodEJ1ZmZlcl0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gY29ubmVjdGl2aXR5U3RhdGVUb01lc3NhZ2Uoc3RhdGUpIHtcbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdDT05ORUNUSU5HJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ0lETEUnXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ1JFQURZJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5TSFVURE9XTjpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdTSFVURE9XTidcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkU6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnVFJBTlNJRU5UX0ZBSUxVUkUnXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ1VOS05PV04nXG4gICAgICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRhdGVUb1Byb3RvVGltZXN0YW1wKGRhdGUpIHtcbiAgICBpZiAoIWRhdGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG1pbGxpc1NpbmNlRXBvY2ggPSBkYXRlLmdldFRpbWUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZWNvbmRzOiAobWlsbGlzU2luY2VFcG9jaCAvIDEwMDApIHwgMCxcbiAgICAgICAgbmFub3M6IChtaWxsaXNTaW5jZUVwb2NoICUgMTAwMCkgKiAxMDAwMDAwXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldENoYW5uZWxNZXNzYWdlKGNoYW5uZWxFbnRyeSkge1xuICAgIGNvbnN0IHJlc29sdmVkSW5mbyA9IGNoYW5uZWxFbnRyeS5nZXRJbmZvKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVmOiBjaGFubmVsUmVmVG9NZXNzYWdlKGNoYW5uZWxFbnRyeS5yZWYpLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IHJlc29sdmVkSW5mby50YXJnZXQsXG4gICAgICAgICAgICBzdGF0ZTogY29ubmVjdGl2aXR5U3RhdGVUb01lc3NhZ2UocmVzb2x2ZWRJbmZvLnN0YXRlKSxcbiAgICAgICAgICAgIGNhbGxzX3N0YXJ0ZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc1N0YXJ0ZWQsXG4gICAgICAgICAgICBjYWxsc19zdWNjZWVkZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc1N1Y2NlZWRlZCxcbiAgICAgICAgICAgIGNhbGxzX2ZhaWxlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzRmFpbGVkLFxuICAgICAgICAgICAgbGFzdF9jYWxsX3N0YXJ0ZWRfdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChyZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIubGFzdENhbGxTdGFydGVkVGltZXN0YW1wKSxcbiAgICAgICAgICAgIHRyYWNlOiByZXNvbHZlZEluZm8udHJhY2UuZ2V0VHJhY2VNZXNzYWdlKClcbiAgICAgICAgfSxcbiAgICAgICAgY2hhbm5lbF9yZWY6IHJlc29sdmVkSW5mby5jaGlsZHJlbi5jaGFubmVscy5tYXAocmVmID0+IGNoYW5uZWxSZWZUb01lc3NhZ2UocmVmKSksXG4gICAgICAgIHN1YmNoYW5uZWxfcmVmOiByZXNvbHZlZEluZm8uY2hpbGRyZW4uc3ViY2hhbm5lbHMubWFwKHJlZiA9PiBzdWJjaGFubmVsUmVmVG9NZXNzYWdlKHJlZikpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIEdldENoYW5uZWwoY2FsbCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBjaGFubmVsSWQgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LmNoYW5uZWxfaWQpO1xuICAgIGNvbnN0IGNoYW5uZWxFbnRyeSA9IGNoYW5uZWxzW2NoYW5uZWxJZF07XG4gICAgaWYgKGNoYW5uZWxFbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICdjb2RlJzogY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcbiAgICAgICAgICAgICdkZXRhaWxzJzogJ05vIGNoYW5uZWwgZGF0YSBmb3VuZCBmb3IgaWQgJyArIGNoYW5uZWxJZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB7IGNoYW5uZWw6IGdldENoYW5uZWxNZXNzYWdlKGNoYW5uZWxFbnRyeSkgfSk7XG59XG5mdW5jdGlvbiBHZXRUb3BDaGFubmVscyhjYWxsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IG1heFJlc3VsdHMgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0Lm1heF9yZXN1bHRzKTtcbiAgICBjb25zdCByZXN1bHRMaXN0ID0gW107XG4gICAgbGV0IGkgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnN0YXJ0X2NoYW5uZWxfaWQpO1xuICAgIGZvciAoOyBpIDwgY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbEVudHJ5ID0gY2hhbm5lbHNbaV07XG4gICAgICAgIGlmIChjaGFubmVsRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0TGlzdC5wdXNoKGdldENoYW5uZWxNZXNzYWdlKGNoYW5uZWxFbnRyeSkpO1xuICAgICAgICBpZiAocmVzdWx0TGlzdC5sZW5ndGggPj0gbWF4UmVzdWx0cykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICBjaGFubmVsOiByZXN1bHRMaXN0LFxuICAgICAgICBlbmQ6IGkgPj0gc2VydmVycy5sZW5ndGhcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFNlcnZlck1lc3NhZ2Uoc2VydmVyRW50cnkpIHtcbiAgICBjb25zdCByZXNvbHZlZEluZm8gPSBzZXJ2ZXJFbnRyeS5nZXRJbmZvKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVmOiBzZXJ2ZXJSZWZUb01lc3NhZ2Uoc2VydmVyRW50cnkucmVmKSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgY2FsbHNfc3RhcnRlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzU3RhcnRlZCxcbiAgICAgICAgICAgIGNhbGxzX3N1Y2NlZWRlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzU3VjY2VlZGVkLFxuICAgICAgICAgICAgY2FsbHNfZmFpbGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNGYWlsZWQsXG4gICAgICAgICAgICBsYXN0X2NhbGxfc3RhcnRlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5sYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXApLFxuICAgICAgICAgICAgdHJhY2U6IHJlc29sdmVkSW5mby50cmFjZS5nZXRUcmFjZU1lc3NhZ2UoKVxuICAgICAgICB9LFxuICAgICAgICBsaXN0ZW5fc29ja2V0OiByZXNvbHZlZEluZm8ubGlzdGVuZXJDaGlsZHJlbi5zb2NrZXRzLm1hcChyZWYgPT4gc29ja2V0UmVmVG9NZXNzYWdlKHJlZikpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIEdldFNlcnZlcihjYWxsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlcnZlcklkID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5zZXJ2ZXJfaWQpO1xuICAgIGNvbnN0IHNlcnZlckVudHJ5ID0gc2VydmVyc1tzZXJ2ZXJJZF07XG4gICAgaWYgKHNlcnZlckVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgJ2NvZGUnOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgICAgICAgICAgJ2RldGFpbHMnOiAnTm8gc2VydmVyIGRhdGEgZm91bmQgZm9yIGlkICcgKyBzZXJ2ZXJJZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB7IHNlcnZlcjogZ2V0U2VydmVyTWVzc2FnZShzZXJ2ZXJFbnRyeSkgfSk7XG59XG5mdW5jdGlvbiBHZXRTZXJ2ZXJzKGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgbWF4UmVzdWx0cyA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3QubWF4X3Jlc3VsdHMpO1xuICAgIGNvbnN0IHJlc3VsdExpc3QgPSBbXTtcbiAgICBsZXQgaSA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3Quc3RhcnRfc2VydmVyX2lkKTtcbiAgICBmb3IgKDsgaSA8IHNlcnZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2VydmVyRW50cnkgPSBzZXJ2ZXJzW2ldO1xuICAgICAgICBpZiAoc2VydmVyRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0TGlzdC5wdXNoKGdldFNlcnZlck1lc3NhZ2Uoc2VydmVyRW50cnkpKTtcbiAgICAgICAgaWYgKHJlc3VsdExpc3QubGVuZ3RoID49IG1heFJlc3VsdHMpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgc2VydmVyOiByZXN1bHRMaXN0LFxuICAgICAgICBlbmQ6IGkgPj0gc2VydmVycy5sZW5ndGhcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIEdldFN1YmNoYW5uZWwoY2FsbCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzdWJjaGFubmVsSWQgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnN1YmNoYW5uZWxfaWQpO1xuICAgIGNvbnN0IHN1YmNoYW5uZWxFbnRyeSA9IHN1YmNoYW5uZWxzW3N1YmNoYW5uZWxJZF07XG4gICAgaWYgKHN1YmNoYW5uZWxFbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICdjb2RlJzogY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcbiAgICAgICAgICAgICdkZXRhaWxzJzogJ05vIHN1YmNoYW5uZWwgZGF0YSBmb3VuZCBmb3IgaWQgJyArIHN1YmNoYW5uZWxJZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZEluZm8gPSBzdWJjaGFubmVsRW50cnkuZ2V0SW5mbygpO1xuICAgIGNvbnN0IHN1YmNoYW5uZWxNZXNzYWdlID0ge1xuICAgICAgICByZWY6IHN1YmNoYW5uZWxSZWZUb01lc3NhZ2Uoc3ViY2hhbm5lbEVudHJ5LnJlZiksXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHRhcmdldDogcmVzb2x2ZWRJbmZvLnRhcmdldCxcbiAgICAgICAgICAgIHN0YXRlOiBjb25uZWN0aXZpdHlTdGF0ZVRvTWVzc2FnZShyZXNvbHZlZEluZm8uc3RhdGUpLFxuICAgICAgICAgICAgY2FsbHNfc3RhcnRlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzU3RhcnRlZCxcbiAgICAgICAgICAgIGNhbGxzX3N1Y2NlZWRlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzU3VjY2VlZGVkLFxuICAgICAgICAgICAgY2FsbHNfZmFpbGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNGYWlsZWQsXG4gICAgICAgICAgICBsYXN0X2NhbGxfc3RhcnRlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5sYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXApLFxuICAgICAgICAgICAgdHJhY2U6IHJlc29sdmVkSW5mby50cmFjZS5nZXRUcmFjZU1lc3NhZ2UoKVxuICAgICAgICB9LFxuICAgICAgICBzb2NrZXRfcmVmOiByZXNvbHZlZEluZm8uY2hpbGRyZW4uc29ja2V0cy5tYXAocmVmID0+IHNvY2tldFJlZlRvTWVzc2FnZShyZWYpKVxuICAgIH07XG4gICAgY2FsbGJhY2sobnVsbCwgeyBzdWJjaGFubmVsOiBzdWJjaGFubmVsTWVzc2FnZSB9KTtcbn1cbmZ1bmN0aW9uIHN1YmNoYW5uZWxBZGRyZXNzVG9BZGRyZXNzTWVzc2FnZShzdWJjaGFubmVsQWRkcmVzcykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoc3ViY2hhbm5lbF9hZGRyZXNzXzEuaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhzdWJjaGFubmVsQWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZHJlc3M6ICd0Y3BpcF9hZGRyZXNzJyxcbiAgICAgICAgICAgIHRjcGlwX2FkZHJlc3M6IHtcbiAgICAgICAgICAgICAgICBpcF9hZGRyZXNzOiAoX2EgPSBpcEFkZHJlc3NTdHJpbmdUb0J1ZmZlcihzdWJjaGFubmVsQWRkcmVzcy5ob3N0KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHBvcnQ6IHN1YmNoYW5uZWxBZGRyZXNzLnBvcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzOiAndWRzX2FkZHJlc3MnLFxuICAgICAgICAgICAgdWRzX2FkZHJlc3M6IHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogc3ViY2hhbm5lbEFkZHJlc3MucGF0aFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIEdldFNvY2tldChjYWxsLCBjYWxsYmFjaykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgY29uc3Qgc29ja2V0SWQgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnNvY2tldF9pZCk7XG4gICAgY29uc3Qgc29ja2V0RW50cnkgPSBzb2NrZXRzW3NvY2tldElkXTtcbiAgICBpZiAoc29ja2V0RW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAnY29kZSc6IGNvbnN0YW50c18xLlN0YXR1cy5OT1RfRk9VTkQsXG4gICAgICAgICAgICAnZGV0YWlscyc6ICdObyBzb2NrZXQgZGF0YSBmb3VuZCBmb3IgaWQgJyArIHNvY2tldElkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkSW5mbyA9IHNvY2tldEVudHJ5LmdldEluZm8oKTtcbiAgICBjb25zdCBzZWN1cml0eU1lc3NhZ2UgPSByZXNvbHZlZEluZm8uc2VjdXJpdHkgPyB7XG4gICAgICAgIG1vZGVsOiAndGxzJyxcbiAgICAgICAgdGxzOiB7XG4gICAgICAgICAgICBjaXBoZXJfc3VpdGU6IHJlc29sdmVkSW5mby5zZWN1cml0eS5jaXBoZXJTdWl0ZVN0YW5kYXJkTmFtZSA/ICdzdGFuZGFyZF9uYW1lJyA6ICdvdGhlcl9uYW1lJyxcbiAgICAgICAgICAgIHN0YW5kYXJkX25hbWU6IChfYSA9IHJlc29sdmVkSW5mby5zZWN1cml0eS5jaXBoZXJTdWl0ZVN0YW5kYXJkTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3RoZXJfbmFtZTogKF9iID0gcmVzb2x2ZWRJbmZvLnNlY3VyaXR5LmNpcGhlclN1aXRlT3RoZXJOYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBsb2NhbF9jZXJ0aWZpY2F0ZTogKF9jID0gcmVzb2x2ZWRJbmZvLnNlY3VyaXR5LmxvY2FsQ2VydGlmaWNhdGUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlbW90ZV9jZXJ0aWZpY2F0ZTogKF9kID0gcmVzb2x2ZWRJbmZvLnNlY3VyaXR5LnJlbW90ZUNlcnRpZmljYXRlKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgIH0gOiBudWxsO1xuICAgIGNvbnN0IHNvY2tldE1lc3NhZ2UgPSB7XG4gICAgICAgIHJlZjogc29ja2V0UmVmVG9NZXNzYWdlKHNvY2tldEVudHJ5LnJlZiksXG4gICAgICAgIGxvY2FsOiByZXNvbHZlZEluZm8ubG9jYWxBZGRyZXNzID8gc3ViY2hhbm5lbEFkZHJlc3NUb0FkZHJlc3NNZXNzYWdlKHJlc29sdmVkSW5mby5sb2NhbEFkZHJlc3MpIDogbnVsbCxcbiAgICAgICAgcmVtb3RlOiByZXNvbHZlZEluZm8ucmVtb3RlQWRkcmVzcyA/IHN1YmNoYW5uZWxBZGRyZXNzVG9BZGRyZXNzTWVzc2FnZShyZXNvbHZlZEluZm8ucmVtb3RlQWRkcmVzcykgOiBudWxsLFxuICAgICAgICByZW1vdGVfbmFtZTogKF9lID0gcmVzb2x2ZWRJbmZvLnJlbW90ZU5hbWUpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc2VjdXJpdHk6IHNlY3VyaXR5TWVzc2FnZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAga2VlcF9hbGl2ZXNfc2VudDogcmVzb2x2ZWRJbmZvLmtlZXBBbGl2ZXNTZW50LFxuICAgICAgICAgICAgc3RyZWFtc19zdGFydGVkOiByZXNvbHZlZEluZm8uc3RyZWFtc1N0YXJ0ZWQsXG4gICAgICAgICAgICBzdHJlYW1zX3N1Y2NlZWRlZDogcmVzb2x2ZWRJbmZvLnN0cmVhbXNTdWNjZWVkZWQsXG4gICAgICAgICAgICBzdHJlYW1zX2ZhaWxlZDogcmVzb2x2ZWRJbmZvLnN0cmVhbXNGYWlsZWQsXG4gICAgICAgICAgICBsYXN0X2xvY2FsX3N0cmVhbV9jcmVhdGVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmxhc3RMb2NhbFN0cmVhbUNyZWF0ZWRUaW1lc3RhbXApLFxuICAgICAgICAgICAgbGFzdF9yZW1vdGVfc3RyZWFtX2NyZWF0ZWRfdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChyZXNvbHZlZEluZm8ubGFzdFJlbW90ZVN0cmVhbUNyZWF0ZWRUaW1lc3RhbXApLFxuICAgICAgICAgICAgbWVzc2FnZXNfcmVjZWl2ZWQ6IHJlc29sdmVkSW5mby5tZXNzYWdlc1JlY2VpdmVkLFxuICAgICAgICAgICAgbWVzc2FnZXNfc2VudDogcmVzb2x2ZWRJbmZvLm1lc3NhZ2VzU2VudCxcbiAgICAgICAgICAgIGxhc3RfbWVzc2FnZV9yZWNlaXZlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wKSxcbiAgICAgICAgICAgIGxhc3RfbWVzc2FnZV9zZW50X3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCksXG4gICAgICAgICAgICBsb2NhbF9mbG93X2NvbnRyb2xfd2luZG93OiByZXNvbHZlZEluZm8ubG9jYWxGbG93Q29udHJvbFdpbmRvdyA/IHsgdmFsdWU6IHJlc29sdmVkSW5mby5sb2NhbEZsb3dDb250cm9sV2luZG93IH0gOiBudWxsLFxuICAgICAgICAgICAgcmVtb3RlX2Zsb3dfY29udHJvbF93aW5kb3c6IHJlc29sdmVkSW5mby5yZW1vdGVGbG93Q29udHJvbFdpbmRvdyA/IHsgdmFsdWU6IHJlc29sdmVkSW5mby5yZW1vdGVGbG93Q29udHJvbFdpbmRvdyB9IDogbnVsbCxcbiAgICAgICAgfVxuICAgIH07XG4gICAgY2FsbGJhY2sobnVsbCwgeyBzb2NrZXQ6IHNvY2tldE1lc3NhZ2UgfSk7XG59XG5mdW5jdGlvbiBHZXRTZXJ2ZXJTb2NrZXRzKGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VydmVySWQgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnNlcnZlcl9pZCk7XG4gICAgY29uc3Qgc2VydmVyRW50cnkgPSBzZXJ2ZXJzW3NlcnZlcklkXTtcbiAgICBpZiAoc2VydmVyRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAnY29kZSc6IGNvbnN0YW50c18xLlN0YXR1cy5OT1RfRk9VTkQsXG4gICAgICAgICAgICAnZGV0YWlscyc6ICdObyBzZXJ2ZXIgZGF0YSBmb3VuZCBmb3IgaWQgJyArIHNlcnZlcklkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0SWQgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnN0YXJ0X3NvY2tldF9pZCk7XG4gICAgY29uc3QgbWF4UmVzdWx0cyA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3QubWF4X3Jlc3VsdHMpO1xuICAgIGNvbnN0IHJlc29sdmVkSW5mbyA9IHNlcnZlckVudHJ5LmdldEluZm8oKTtcbiAgICAvLyBJZiB3ZSB3YW50ZWQgdG8gaW5jbHVkZSBsaXN0ZW5lciBzb2NrZXRzIGluIHRoZSByZXN1bHQsIHRoaXMgbGluZSB3b3VsZFxuICAgIC8vIGluc3RlYWQgc2F5XG4gICAgLy8gY29uc3QgYWxsU29ja2V0cyA9IHJlc29sdmVkSW5mby5saXN0ZW5lckNoaWxkcmVuLnNvY2tldHMuY29uY2F0KHJlc29sdmVkSW5mby5zZXNzaW9uQ2hpbGRyZW4uc29ja2V0cykuc29ydCgocmVmMSwgcmVmMikgPT4gcmVmMS5pZCAtIHJlZjIuaWQpO1xuICAgIGNvbnN0IGFsbFNvY2tldHMgPSByZXNvbHZlZEluZm8uc2Vzc2lvbkNoaWxkcmVuLnNvY2tldHMuc29ydCgocmVmMSwgcmVmMikgPT4gcmVmMS5pZCAtIHJlZjIuaWQpO1xuICAgIGNvbnN0IHJlc3VsdExpc3QgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBhbGxTb2NrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhbGxTb2NrZXRzW2ldLmlkID49IHN0YXJ0SWQpIHtcbiAgICAgICAgICAgIHJlc3VsdExpc3QucHVzaChzb2NrZXRSZWZUb01lc3NhZ2UoYWxsU29ja2V0c1tpXSkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdExpc3QubGVuZ3RoID49IG1heFJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgIHNvY2tldF9yZWY6IHJlc3VsdExpc3QsXG4gICAgICAgIGVuZDogaSA+PSBhbGxTb2NrZXRzLmxlbmd0aFxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0Q2hhbm5lbHpIYW5kbGVycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBHZXRDaGFubmVsLFxuICAgICAgICBHZXRUb3BDaGFubmVscyxcbiAgICAgICAgR2V0U2VydmVyLFxuICAgICAgICBHZXRTZXJ2ZXJzLFxuICAgICAgICBHZXRTdWJjaGFubmVsLFxuICAgICAgICBHZXRTb2NrZXQsXG4gICAgICAgIEdldFNlcnZlclNvY2tldHNcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRDaGFubmVsekhhbmRsZXJzID0gZ2V0Q2hhbm5lbHpIYW5kbGVycztcbmxldCBsb2FkZWRDaGFubmVsekRlZmluaXRpb24gPSBudWxsO1xuZnVuY3Rpb24gZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvbigpIHtcbiAgICBpZiAobG9hZGVkQ2hhbm5lbHpEZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiBsb2FkZWRDaGFubmVsekRlZmluaXRpb247XG4gICAgfVxuICAgIC8qIFRoZSBwdXJwb3NlIG9mIHRoaXMgY29tcGxleGl0eSBpcyB0byBhdm9pZCBsb2FkaW5nIEBncnBjL3Byb3RvLWxvYWRlciBhdFxuICAgICAqIHJ1bnRpbWUgZm9yIHVzZXJzIHdobyB3aWxsIG5vdCB1c2UvZW5hYmxlIGNoYW5uZWx6LiAqL1xuICAgIGNvbnN0IGxvYWRlckxvYWRTeW5jID0gcmVxdWlyZSgnQGdycGMvcHJvdG8tbG9hZGVyJykubG9hZFN5bmM7XG4gICAgY29uc3QgbG9hZGVkUHJvdG8gPSBsb2FkZXJMb2FkU3luYygnY2hhbm5lbHoucHJvdG8nLCB7XG4gICAgICAgIGtlZXBDYXNlOiB0cnVlLFxuICAgICAgICBsb25nczogU3RyaW5nLFxuICAgICAgICBlbnVtczogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0czogdHJ1ZSxcbiAgICAgICAgb25lb2ZzOiB0cnVlLFxuICAgICAgICBpbmNsdWRlRGlyczogW1xuICAgICAgICAgICAgYCR7X19kaXJuYW1lfS8uLi8uLi9wcm90b2BcbiAgICAgICAgXVxuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5uZWx6R3JwY09iamVjdCA9IG1ha2VfY2xpZW50XzEubG9hZFBhY2thZ2VEZWZpbml0aW9uKGxvYWRlZFByb3RvKTtcbiAgICBsb2FkZWRDaGFubmVsekRlZmluaXRpb24gPSBjaGFubmVsekdycGNPYmplY3QuZ3JwYy5jaGFubmVsei52MS5DaGFubmVsei5zZXJ2aWNlO1xuICAgIHJldHVybiBsb2FkZWRDaGFubmVsekRlZmluaXRpb247XG59XG5leHBvcnRzLmdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24gPSBnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uO1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgYWRtaW5fMS5yZWdpc3RlckFkbWluU2VydmljZShnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uLCBnZXRDaGFubmVsekhhbmRsZXJzKTtcbn1cbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5uZWx6LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInNldHVwIiwiZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvbiIsImdldENoYW5uZWx6SGFuZGxlcnMiLCJ1bnJlZ2lzdGVyQ2hhbm5lbHpSZWYiLCJyZWdpc3RlckNoYW5uZWx6U29ja2V0IiwicmVnaXN0ZXJDaGFubmVselNlcnZlciIsInJlZ2lzdGVyQ2hhbm5lbHpTdWJjaGFubmVsIiwicmVnaXN0ZXJDaGFubmVsekNoYW5uZWwiLCJDaGFubmVsekNhbGxUcmFja2VyIiwiQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXIiLCJDaGFubmVselRyYWNlIiwibmV0XzEiLCJyZXF1aXJlIiwiY29ubmVjdGl2aXR5X3N0YXRlXzEiLCJjb25zdGFudHNfMSIsInN1YmNoYW5uZWxfYWRkcmVzc18xIiwiYWRtaW5fMSIsIm1ha2VfY2xpZW50XzEiLCJjaGFubmVsUmVmVG9NZXNzYWdlIiwicmVmIiwiY2hhbm5lbF9pZCIsImlkIiwibmFtZSIsInN1YmNoYW5uZWxSZWZUb01lc3NhZ2UiLCJzdWJjaGFubmVsX2lkIiwic2VydmVyUmVmVG9NZXNzYWdlIiwic2VydmVyX2lkIiwic29ja2V0UmVmVG9NZXNzYWdlIiwic29ja2V0X2lkIiwiVEFSR0VUX1JFVEFJTkVEX1RSQUNFUyIsImNvbnN0cnVjdG9yIiwiZXZlbnRzIiwiZXZlbnRzTG9nZ2VkIiwiY3JlYXRpb25UaW1lc3RhbXAiLCJEYXRlIiwiYWRkVHJhY2UiLCJzZXZlcml0eSIsImRlc2NyaXB0aW9uIiwiY2hpbGQiLCJ0aW1lc3RhbXAiLCJwdXNoIiwiY2hpbGRDaGFubmVsIiwia2luZCIsInVuZGVmaW5lZCIsImNoaWxkU3ViY2hhbm5lbCIsImxlbmd0aCIsInNsaWNlIiwiZ2V0VHJhY2VNZXNzYWdlIiwiY3JlYXRpb25fdGltZXN0YW1wIiwiZGF0ZVRvUHJvdG9UaW1lc3RhbXAiLCJudW1fZXZlbnRzX2xvZ2dlZCIsIm1hcCIsImV2ZW50IiwiY2hhbm5lbF9yZWYiLCJzdWJjaGFubmVsX3JlZiIsImNoYW5uZWxDaGlsZHJlbiIsIk1hcCIsInN1YmNoYW5uZWxDaGlsZHJlbiIsInNvY2tldENoaWxkcmVuIiwicmVmQ2hpbGQiLCJfYSIsIl9iIiwiX2MiLCJ0cmFja2VkQ2hpbGQiLCJnZXQiLCJjb3VudCIsInNldCIsInVucmVmQ2hpbGQiLCJkZWxldGUiLCJnZXRDaGlsZExpc3RzIiwiY2hhbm5lbHMiLCJ2YWx1ZXMiLCJzdWJjaGFubmVscyIsInNvY2tldHMiLCJjYWxsc1N0YXJ0ZWQiLCJjYWxsc1N1Y2NlZWRlZCIsImNhbGxzRmFpbGVkIiwibGFzdENhbGxTdGFydGVkVGltZXN0YW1wIiwiYWRkQ2FsbFN0YXJ0ZWQiLCJhZGRDYWxsU3VjY2VlZGVkIiwiYWRkQ2FsbEZhaWxlZCIsIm5leHRJZCIsImdldE5leHRJZCIsInNlcnZlcnMiLCJnZXRJbmZvIiwiY2hhbm5lbHpFbmFibGVkIiwicGFyc2VJUHY2U2VjdGlvbiIsImFkZHJlc3NTZWN0aW9uIiwibnVtYmVyVmFsdWUiLCJOdW1iZXIiLCJwYXJzZUludCIsInBhcnNlSVB2NkNodW5rIiwiYWRkcmVzc0NodW5rIiwiYnl0ZVBhaXJzIiwic3BsaXQiLCJzZWN0aW9uIiwicmVzdWx0IiwiY29uY2F0IiwiaXBBZGRyZXNzU3RyaW5nVG9CdWZmZXIiLCJpcEFkZHJlc3MiLCJpc0lQdjQiLCJCdWZmZXIiLCJmcm9tIiwiVWludDhBcnJheSIsInNlZ21lbnQiLCJpc0lQdjYiLCJsZWZ0U2VjdGlvbiIsInJpZ2h0U2VjdGlvbiIsImRvdWJsZUNvbG9uSW5kZXgiLCJpbmRleE9mIiwic3Vic3RyaW5nIiwibGVmdEJ1ZmZlciIsInJpZ2h0QnVmZmVyIiwibWlkZGxlQnVmZmVyIiwiYWxsb2MiLCJjb25uZWN0aXZpdHlTdGF0ZVRvTWVzc2FnZSIsInN0YXRlIiwiQ29ubmVjdGl2aXR5U3RhdGUiLCJDT05ORUNUSU5HIiwiSURMRSIsIlJFQURZIiwiU0hVVERPV04iLCJUUkFOU0lFTlRfRkFJTFVSRSIsImRhdGUiLCJtaWxsaXNTaW5jZUVwb2NoIiwiZ2V0VGltZSIsInNlY29uZHMiLCJuYW5vcyIsImdldENoYW5uZWxNZXNzYWdlIiwiY2hhbm5lbEVudHJ5IiwicmVzb2x2ZWRJbmZvIiwiZGF0YSIsInRhcmdldCIsImNhbGxzX3N0YXJ0ZWQiLCJjYWxsVHJhY2tlciIsImNhbGxzX3N1Y2NlZWRlZCIsImNhbGxzX2ZhaWxlZCIsImxhc3RfY2FsbF9zdGFydGVkX3RpbWVzdGFtcCIsInRyYWNlIiwiY2hpbGRyZW4iLCJHZXRDaGFubmVsIiwiY2FsbCIsImNhbGxiYWNrIiwiY2hhbm5lbElkIiwicmVxdWVzdCIsIlN0YXR1cyIsIk5PVF9GT1VORCIsImNoYW5uZWwiLCJHZXRUb3BDaGFubmVscyIsIm1heFJlc3VsdHMiLCJtYXhfcmVzdWx0cyIsInJlc3VsdExpc3QiLCJpIiwic3RhcnRfY2hhbm5lbF9pZCIsImVuZCIsImdldFNlcnZlck1lc3NhZ2UiLCJzZXJ2ZXJFbnRyeSIsImxpc3Rlbl9zb2NrZXQiLCJsaXN0ZW5lckNoaWxkcmVuIiwiR2V0U2VydmVyIiwic2VydmVySWQiLCJzZXJ2ZXIiLCJHZXRTZXJ2ZXJzIiwic3RhcnRfc2VydmVyX2lkIiwiR2V0U3ViY2hhbm5lbCIsInN1YmNoYW5uZWxJZCIsInN1YmNoYW5uZWxFbnRyeSIsInN1YmNoYW5uZWxNZXNzYWdlIiwic29ja2V0X3JlZiIsInN1YmNoYW5uZWwiLCJzdWJjaGFubmVsQWRkcmVzc1RvQWRkcmVzc01lc3NhZ2UiLCJzdWJjaGFubmVsQWRkcmVzcyIsImlzVGNwU3ViY2hhbm5lbEFkZHJlc3MiLCJhZGRyZXNzIiwidGNwaXBfYWRkcmVzcyIsImlwX2FkZHJlc3MiLCJob3N0IiwicG9ydCIsInVkc19hZGRyZXNzIiwiZmlsZW5hbWUiLCJwYXRoIiwiR2V0U29ja2V0IiwiX2QiLCJfZSIsInNvY2tldElkIiwic29ja2V0RW50cnkiLCJzZWN1cml0eU1lc3NhZ2UiLCJzZWN1cml0eSIsIm1vZGVsIiwidGxzIiwiY2lwaGVyX3N1aXRlIiwiY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWUiLCJzdGFuZGFyZF9uYW1lIiwib3RoZXJfbmFtZSIsImNpcGhlclN1aXRlT3RoZXJOYW1lIiwibG9jYWxfY2VydGlmaWNhdGUiLCJsb2NhbENlcnRpZmljYXRlIiwicmVtb3RlX2NlcnRpZmljYXRlIiwicmVtb3RlQ2VydGlmaWNhdGUiLCJzb2NrZXRNZXNzYWdlIiwibG9jYWwiLCJsb2NhbEFkZHJlc3MiLCJyZW1vdGUiLCJyZW1vdGVBZGRyZXNzIiwicmVtb3RlX25hbWUiLCJyZW1vdGVOYW1lIiwia2VlcF9hbGl2ZXNfc2VudCIsImtlZXBBbGl2ZXNTZW50Iiwic3RyZWFtc19zdGFydGVkIiwic3RyZWFtc1N0YXJ0ZWQiLCJzdHJlYW1zX3N1Y2NlZWRlZCIsInN0cmVhbXNTdWNjZWVkZWQiLCJzdHJlYW1zX2ZhaWxlZCIsInN0cmVhbXNGYWlsZWQiLCJsYXN0X2xvY2FsX3N0cmVhbV9jcmVhdGVkX3RpbWVzdGFtcCIsImxhc3RMb2NhbFN0cmVhbUNyZWF0ZWRUaW1lc3RhbXAiLCJsYXN0X3JlbW90ZV9zdHJlYW1fY3JlYXRlZF90aW1lc3RhbXAiLCJsYXN0UmVtb3RlU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcCIsIm1lc3NhZ2VzX3JlY2VpdmVkIiwibWVzc2FnZXNSZWNlaXZlZCIsIm1lc3NhZ2VzX3NlbnQiLCJtZXNzYWdlc1NlbnQiLCJsYXN0X21lc3NhZ2VfcmVjZWl2ZWRfdGltZXN0YW1wIiwibGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCIsImxhc3RfbWVzc2FnZV9zZW50X3RpbWVzdGFtcCIsImxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCIsImxvY2FsX2Zsb3dfY29udHJvbF93aW5kb3ciLCJsb2NhbEZsb3dDb250cm9sV2luZG93IiwicmVtb3RlX2Zsb3dfY29udHJvbF93aW5kb3ciLCJyZW1vdGVGbG93Q29udHJvbFdpbmRvdyIsInNvY2tldCIsIkdldFNlcnZlclNvY2tldHMiLCJzdGFydElkIiwic3RhcnRfc29ja2V0X2lkIiwiYWxsU29ja2V0cyIsInNlc3Npb25DaGlsZHJlbiIsInNvcnQiLCJyZWYxIiwicmVmMiIsImxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbiIsImxvYWRlckxvYWRTeW5jIiwibG9hZFN5bmMiLCJsb2FkZWRQcm90byIsImtlZXBDYXNlIiwibG9uZ3MiLCJTdHJpbmciLCJlbnVtcyIsImRlZmF1bHRzIiwib25lb2ZzIiwiaW5jbHVkZURpcnMiLCJfX2Rpcm5hbWUiLCJjaGFubmVsekdycGNPYmplY3QiLCJsb2FkUGFja2FnZURlZmluaXRpb24iLCJncnBjIiwiY2hhbm5lbHoiLCJ2MSIsIkNoYW5uZWx6Iiwic2VydmljZSIsInJlZ2lzdGVyQWRtaW5TZXJ2aWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client-interceptors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getInterceptingCall = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst call_stream_1 = __webpack_require__(/*! ./call-stream */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-stream.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */ class InterceptorConfigurationError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"InterceptorConfigurationError\";\n        Error.captureStackTrace(this, InterceptorConfigurationError);\n    }\n}\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\nclass ListenerBuilder {\n    constructor(){\n        this.metadata = undefined;\n        this.message = undefined;\n        this.status = undefined;\n    }\n    withOnReceiveMetadata(onReceiveMetadata) {\n        this.metadata = onReceiveMetadata;\n        return this;\n    }\n    withOnReceiveMessage(onReceiveMessage) {\n        this.message = onReceiveMessage;\n        return this;\n    }\n    withOnReceiveStatus(onReceiveStatus) {\n        this.status = onReceiveStatus;\n        return this;\n    }\n    build() {\n        return {\n            onReceiveMetadata: this.metadata,\n            onReceiveMessage: this.message,\n            onReceiveStatus: this.status\n        };\n    }\n}\nexports.ListenerBuilder = ListenerBuilder;\nclass RequesterBuilder {\n    constructor(){\n        this.start = undefined;\n        this.message = undefined;\n        this.halfClose = undefined;\n        this.cancel = undefined;\n    }\n    withStart(start) {\n        this.start = start;\n        return this;\n    }\n    withSendMessage(sendMessage) {\n        this.message = sendMessage;\n        return this;\n    }\n    withHalfClose(halfClose) {\n        this.halfClose = halfClose;\n        return this;\n    }\n    withCancel(cancel) {\n        this.cancel = cancel;\n        return this;\n    }\n    build() {\n        return {\n            start: this.start,\n            sendMessage: this.message,\n            halfClose: this.halfClose,\n            cancel: this.cancel\n        };\n    }\n}\nexports.RequesterBuilder = RequesterBuilder;\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */ const defaultListener = {\n    onReceiveMetadata: (metadata, next)=>{\n        next(metadata);\n    },\n    onReceiveMessage: (message, next)=>{\n        next(message);\n    },\n    onReceiveStatus: (status, next)=>{\n        next(status);\n    }\n};\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */ const defaultRequester = {\n    start: (metadata, listener, next)=>{\n        next(metadata, listener);\n    },\n    sendMessage: (message, next)=>{\n        next(message);\n    },\n    halfClose: (next)=>{\n        next();\n    },\n    cancel: (next)=>{\n        next();\n    }\n};\nclass InterceptingCall {\n    constructor(nextCall, requester){\n        var _a, _b, _c, _d;\n        this.nextCall = nextCall;\n        /**\n         * Indicates that metadata has been passed to the requester's start\n         * method but it has not been passed to the corresponding next callback\n         */ this.processingMetadata = false;\n        /**\n         * Message context for a pending message that is waiting for\n         */ this.pendingMessageContext = null;\n        /**\n         * Indicates that a message has been passed to the requester's sendMessage\n         * method but it has not been passed to the corresponding next callback\n         */ this.processingMessage = false;\n        /**\n         * Indicates that a status was received but could not be propagated because\n         * a message was still being processed.\n         */ this.pendingHalfClose = false;\n        if (requester) {\n            this.requester = {\n                start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\n                sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\n                halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\n                cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel\n            };\n        } else {\n            this.requester = defaultRequester;\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.requester.cancel(()=>{\n            this.nextCall.cancelWithStatus(status, details);\n        });\n    }\n    getPeer() {\n        return this.nextCall.getPeer();\n    }\n    processPendingMessage() {\n        if (this.pendingMessageContext) {\n            this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\n            this.pendingMessageContext = null;\n            this.pendingMessage = null;\n        }\n    }\n    processPendingHalfClose() {\n        if (this.pendingHalfClose) {\n            this.nextCall.halfClose();\n        }\n    }\n    start(metadata, interceptingListener) {\n        var _a, _b, _c, _d, _e, _f;\n        const fullInterceptingListener = {\n            onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : (metadata)=>{},\n            onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : (message)=>{},\n            onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : (status)=>{}\n        };\n        this.processingMetadata = true;\n        this.requester.start(metadata, fullInterceptingListener, (md, listener)=>{\n            var _a, _b, _c;\n            this.processingMetadata = false;\n            let finalInterceptingListener;\n            if (call_stream_1.isInterceptingListener(listener)) {\n                finalInterceptingListener = listener;\n            } else {\n                const fullListener = {\n                    onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\n                    onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\n                    onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus\n                };\n                finalInterceptingListener = new call_stream_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\n            }\n            this.nextCall.start(md, finalInterceptingListener);\n            this.processPendingMessage();\n            this.processPendingHalfClose();\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessageWithContext(context, message) {\n        this.processingMessage = true;\n        this.requester.sendMessage(message, (finalMessage)=>{\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessageContext = context;\n                this.pendingMessage = message;\n            } else {\n                this.nextCall.sendMessageWithContext(context, finalMessage);\n                this.processPendingHalfClose();\n            }\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    startRead() {\n        this.nextCall.startRead();\n    }\n    halfClose() {\n        this.requester.halfClose(()=>{\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingHalfClose = true;\n            } else {\n                this.nextCall.halfClose();\n            }\n        });\n    }\n    setCredentials(credentials) {\n        this.nextCall.setCredentials(credentials);\n    }\n}\nexports.InterceptingCall = InterceptingCall;\nfunction getCall(channel, path, options) {\n    var _a, _b;\n    const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;\n    const host = options.host;\n    const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;\n    const propagateFlags = options.propagate_flags;\n    const credentials = options.credentials;\n    const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n    if (credentials) {\n        call.setCredentials(credentials);\n    }\n    return call;\n}\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */ class BaseInterceptingCall {\n    constructor(call, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    methodDefinition){\n        this.call = call;\n        this.methodDefinition = methodDefinition;\n    }\n    cancelWithStatus(status, details) {\n        this.call.cancelWithStatus(status, details);\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    setCredentials(credentials) {\n        this.call.setCredentials(credentials);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessageWithContext(context, message) {\n        let serialized;\n        try {\n            serialized = this.methodDefinition.requestSerialize(message);\n        } catch (e) {\n            this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${e.message}`);\n            return;\n        }\n        this.call.sendMessageWithContext(context, serialized);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    start(metadata, interceptingListener) {\n        let readError = null;\n        this.call.start(metadata, {\n            onReceiveMetadata: (metadata)=>{\n                var _a;\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\n            },\n            onReceiveMessage: (message)=>{\n                var _a;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                let deserialized;\n                try {\n                    deserialized = this.methodDefinition.responseDeserialize(message);\n                } catch (e) {\n                    readError = {\n                        code: constants_1.Status.INTERNAL,\n                        details: `Response message parsing error: ${e.message}`,\n                        metadata: new metadata_1.Metadata()\n                    };\n                    this.call.cancelWithStatus(readError.code, readError.details);\n                    return;\n                }\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\n            },\n            onReceiveStatus: (status)=>{\n                var _a, _b;\n                if (readError) {\n                    (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\n                } else {\n                    (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\n                }\n            }\n        });\n    }\n    startRead() {\n        this.call.startRead();\n    }\n    halfClose() {\n        this.call.halfClose();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */ class BaseUnaryInterceptingCall extends BaseInterceptingCall {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(call, methodDefinition){\n        super(call, methodDefinition);\n    }\n    start(metadata, listener) {\n        var _a, _b;\n        let receivedMessage = false;\n        const wrapperListener = {\n            onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : (metadata)=>{},\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage: (message)=>{\n                var _a;\n                receivedMessage = true;\n                (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\n            },\n            onReceiveStatus: (status)=>{\n                var _a, _b;\n                if (!receivedMessage) {\n                    (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\n                }\n                (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\n            }\n        };\n        super.start(metadata, wrapperListener);\n        this.call.startRead();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */ class BaseStreamingInterceptingCall extends BaseInterceptingCall {\n}\nfunction getBottomInterceptingCall(channel, options, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition) {\n    const call = getCall(channel, methodDefinition.path, options);\n    if (methodDefinition.responseStream) {\n        return new BaseStreamingInterceptingCall(call, methodDefinition);\n    } else {\n        return new BaseUnaryInterceptingCall(call, methodDefinition);\n    }\n}\nfunction getInterceptingCall(interceptorArgs, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition, options, channel) {\n    if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError(\"Both interceptors and interceptor_providers were passed as options \" + \"to the client constructor. Only one of these is allowed.\");\n    }\n    if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError(\"Both interceptors and interceptor_providers were passed as call \" + \"options. Only one of these is allowed.\");\n    }\n    let interceptors = [];\n    // Interceptors passed to the call override interceptors passed to the client constructor\n    if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {\n        interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map((provider)=>provider(methodDefinition))).filter((interceptor)=>interceptor);\n    // Filter out falsy values when providers return nothing\n    } else {\n        interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map((provider)=>provider(methodDefinition))).filter((interceptor)=>interceptor);\n    // Filter out falsy values when providers return nothing\n    }\n    const interceptorOptions = Object.assign({}, options, {\n        method_definition: methodDefinition\n    });\n    /* For each interceptor in the list, the nextCall function passed to it is\n     * based on the next interceptor in the list, using a nextCall function\n     * constructed with the following interceptor in the list, and so on. The\n     * initialValue, which is effectively at the end of the list, is a nextCall\n     * function that invokes getBottomInterceptingCall, the result of which\n     * handles (de)serialization and also gets the underlying call from the\n     * channel. */ const getCall = interceptors.reduceRight((nextCall, nextInterceptor)=>{\n        return (currentOptions)=>nextInterceptor(currentOptions, nextCall);\n    }, (finalOptions)=>getBottomInterceptingCall(channel, finalOptions, methodDefinition));\n    return getCall(interceptorOptions);\n}\nexports.getInterceptingCall = getInterceptingCall; //# sourceMappingURL=client-interceptors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LWludGVyY2VwdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMkJBQTJCLEdBQUdBLHdCQUF3QixHQUFHQSx3QkFBd0IsR0FBR0EsdUJBQXVCLEdBQUdBLHFDQUFxQyxHQUFHLEtBQUs7QUFDM0osTUFBTU8sYUFBYUMsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQyxrRkFBZTtBQUM3QyxNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6Qzs7O0NBR0MsR0FDRCxNQUFNRixzQ0FBc0NLO0lBQ3hDQyxZQUFZQyxPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1pILE1BQU1JLGlCQUFpQixDQUFDLElBQUksRUFBRVQ7SUFDbEM7QUFDSjtBQUNBTixxQ0FBcUMsR0FBR007QUFDeEMsTUFBTUQ7SUFDRk8sYUFBYztRQUNWLElBQUksQ0FBQ0ksUUFBUSxHQUFHQztRQUNoQixJQUFJLENBQUNKLE9BQU8sR0FBR0k7UUFDZixJQUFJLENBQUNDLE1BQU0sR0FBR0Q7SUFDbEI7SUFDQUUsc0JBQXNCQyxpQkFBaUIsRUFBRTtRQUNyQyxJQUFJLENBQUNKLFFBQVEsR0FBR0k7UUFDaEIsT0FBTyxJQUFJO0lBQ2Y7SUFDQUMscUJBQXFCQyxnQkFBZ0IsRUFBRTtRQUNuQyxJQUFJLENBQUNULE9BQU8sR0FBR1M7UUFDZixPQUFPLElBQUk7SUFDZjtJQUNBQyxvQkFBb0JDLGVBQWUsRUFBRTtRQUNqQyxJQUFJLENBQUNOLE1BQU0sR0FBR007UUFDZCxPQUFPLElBQUk7SUFDZjtJQUNBQyxRQUFRO1FBQ0osT0FBTztZQUNITCxtQkFBbUIsSUFBSSxDQUFDSixRQUFRO1lBQ2hDTSxrQkFBa0IsSUFBSSxDQUFDVCxPQUFPO1lBQzlCVyxpQkFBaUIsSUFBSSxDQUFDTixNQUFNO1FBQ2hDO0lBQ0o7QUFDSjtBQUNBbEIsdUJBQXVCLEdBQUdLO0FBQzFCLE1BQU1EO0lBQ0ZRLGFBQWM7UUFDVixJQUFJLENBQUNjLEtBQUssR0FBR1Q7UUFDYixJQUFJLENBQUNKLE9BQU8sR0FBR0k7UUFDZixJQUFJLENBQUNVLFNBQVMsR0FBR1Y7UUFDakIsSUFBSSxDQUFDVyxNQUFNLEdBQUdYO0lBQ2xCO0lBQ0FZLFVBQVVILEtBQUssRUFBRTtRQUNiLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtRQUNiLE9BQU8sSUFBSTtJQUNmO0lBQ0FJLGdCQUFnQkMsV0FBVyxFQUFFO1FBQ3pCLElBQUksQ0FBQ2xCLE9BQU8sR0FBR2tCO1FBQ2YsT0FBTyxJQUFJO0lBQ2Y7SUFDQUMsY0FBY0wsU0FBUyxFQUFFO1FBQ3JCLElBQUksQ0FBQ0EsU0FBUyxHQUFHQTtRQUNqQixPQUFPLElBQUk7SUFDZjtJQUNBTSxXQUFXTCxNQUFNLEVBQUU7UUFDZixJQUFJLENBQUNBLE1BQU0sR0FBR0E7UUFDZCxPQUFPLElBQUk7SUFDZjtJQUNBSCxRQUFRO1FBQ0osT0FBTztZQUNIQyxPQUFPLElBQUksQ0FBQ0EsS0FBSztZQUNqQkssYUFBYSxJQUFJLENBQUNsQixPQUFPO1lBQ3pCYyxXQUFXLElBQUksQ0FBQ0EsU0FBUztZQUN6QkMsUUFBUSxJQUFJLENBQUNBLE1BQU07UUFDdkI7SUFDSjtBQUNKO0FBQ0E1Qix3QkFBd0IsR0FBR0k7QUFDM0I7OztDQUdDLEdBQ0QsTUFBTThCLGtCQUFrQjtJQUNwQmQsbUJBQW1CLENBQUNKLFVBQVVtQjtRQUMxQkEsS0FBS25CO0lBQ1Q7SUFDQU0sa0JBQWtCLENBQUNULFNBQVNzQjtRQUN4QkEsS0FBS3RCO0lBQ1Q7SUFDQVcsaUJBQWlCLENBQUNOLFFBQVFpQjtRQUN0QkEsS0FBS2pCO0lBQ1Q7QUFDSjtBQUNBOzs7Q0FHQyxHQUNELE1BQU1rQixtQkFBbUI7SUFDckJWLE9BQU8sQ0FBQ1YsVUFBVXFCLFVBQVVGO1FBQ3hCQSxLQUFLbkIsVUFBVXFCO0lBQ25CO0lBQ0FOLGFBQWEsQ0FBQ2xCLFNBQVNzQjtRQUNuQkEsS0FBS3RCO0lBQ1Q7SUFDQWMsV0FBVyxDQUFDUTtRQUNSQTtJQUNKO0lBQ0FQLFFBQVEsQ0FBQ087UUFDTEE7SUFDSjtBQUNKO0FBQ0EsTUFBTWhDO0lBQ0ZTLFlBQVkwQixRQUFRLEVBQUVDLFNBQVMsQ0FBRTtRQUM3QixJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQztRQUNoQixJQUFJLENBQUNMLFFBQVEsR0FBR0E7UUFDaEI7OztTQUdDLEdBQ0QsSUFBSSxDQUFDTSxrQkFBa0IsR0FBRztRQUMxQjs7U0FFQyxHQUNELElBQUksQ0FBQ0MscUJBQXFCLEdBQUc7UUFDN0I7OztTQUdDLEdBQ0QsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztRQUN6Qjs7O1NBR0MsR0FDRCxJQUFJLENBQUNDLGdCQUFnQixHQUFHO1FBQ3hCLElBQUlSLFdBQVc7WUFDWCxJQUFJLENBQUNBLFNBQVMsR0FBRztnQkFDYmIsT0FBTyxDQUFDYyxLQUFLRCxVQUFVYixLQUFLLE1BQU0sUUFBUWMsT0FBTyxLQUFLLElBQUlBLEtBQUtKLGlCQUFpQlYsS0FBSztnQkFDckZLLGFBQWEsQ0FBQ1UsS0FBS0YsVUFBVVIsV0FBVyxNQUFNLFFBQVFVLE9BQU8sS0FBSyxJQUFJQSxLQUFLTCxpQkFBaUJMLFdBQVc7Z0JBQ3ZHSixXQUFXLENBQUNlLEtBQUtILFVBQVVaLFNBQVMsTUFBTSxRQUFRZSxPQUFPLEtBQUssSUFBSUEsS0FBS04saUJBQWlCVCxTQUFTO2dCQUNqR0MsUUFBUSxDQUFDZSxLQUFLSixVQUFVWCxNQUFNLE1BQU0sUUFBUWUsT0FBTyxLQUFLLElBQUlBLEtBQUtQLGlCQUFpQlIsTUFBTTtZQUM1RjtRQUNKLE9BQ0s7WUFDRCxJQUFJLENBQUNXLFNBQVMsR0FBR0g7UUFDckI7SUFDSjtJQUNBWSxpQkFBaUI5QixNQUFNLEVBQUUrQixPQUFPLEVBQUU7UUFDOUIsSUFBSSxDQUFDVixTQUFTLENBQUNYLE1BQU0sQ0FBQztZQUNsQixJQUFJLENBQUNVLFFBQVEsQ0FBQ1UsZ0JBQWdCLENBQUM5QixRQUFRK0I7UUFDM0M7SUFDSjtJQUNBQyxVQUFVO1FBQ04sT0FBTyxJQUFJLENBQUNaLFFBQVEsQ0FBQ1ksT0FBTztJQUNoQztJQUNBQyx3QkFBd0I7UUFDcEIsSUFBSSxJQUFJLENBQUNOLHFCQUFxQixFQUFFO1lBQzVCLElBQUksQ0FBQ1AsUUFBUSxDQUFDYyxzQkFBc0IsQ0FBQyxJQUFJLENBQUNQLHFCQUFxQixFQUFFLElBQUksQ0FBQ1EsY0FBYztZQUNwRixJQUFJLENBQUNSLHFCQUFxQixHQUFHO1lBQzdCLElBQUksQ0FBQ1EsY0FBYyxHQUFHO1FBQzFCO0lBQ0o7SUFDQUMsMEJBQTBCO1FBQ3RCLElBQUksSUFBSSxDQUFDUCxnQkFBZ0IsRUFBRTtZQUN2QixJQUFJLENBQUNULFFBQVEsQ0FBQ1gsU0FBUztRQUMzQjtJQUNKO0lBQ0FELE1BQU1WLFFBQVEsRUFBRXVDLG9CQUFvQixFQUFFO1FBQ2xDLElBQUlmLElBQUlDLElBQUlDLElBQUlDLElBQUlhLElBQUlDO1FBQ3hCLE1BQU1DLDJCQUEyQjtZQUM3QnRDLG1CQUFtQixDQUFDcUIsS0FBSyxDQUFDRCxLQUFLZSx5QkFBeUIsUUFBUUEseUJBQXlCLEtBQUssSUFBSSxLQUFLLElBQUlBLHFCQUFxQm5DLGlCQUFpQixNQUFNLFFBQVFvQixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdtQixJQUFJLENBQUNKLHFCQUFvQixNQUFPLFFBQVFkLE9BQU8sS0FBSyxJQUFJQSxLQUFNLENBQUN6QixZQUFlO1lBQ3pRTSxrQkFBa0IsQ0FBQ3FCLEtBQUssQ0FBQ0QsS0FBS2EseUJBQXlCLFFBQVFBLHlCQUF5QixLQUFLLElBQUksS0FBSyxJQUFJQSxxQkFBcUJqQyxnQkFBZ0IsTUFBTSxRQUFRb0IsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaUIsSUFBSSxDQUFDSixxQkFBb0IsTUFBTyxRQUFRWixPQUFPLEtBQUssSUFBSUEsS0FBTSxDQUFDOUIsV0FBYztZQUN0UVcsaUJBQWlCLENBQUNpQyxLQUFLLENBQUNELEtBQUtELHlCQUF5QixRQUFRQSx5QkFBeUIsS0FBSyxJQUFJLEtBQUssSUFBSUEscUJBQXFCL0IsZUFBZSxNQUFNLFFBQVFnQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdHLElBQUksQ0FBQ0oscUJBQW9CLE1BQU8sUUFBUUUsT0FBTyxLQUFLLElBQUlBLEtBQU0sQ0FBQ3ZDLFVBQWE7UUFDdlE7UUFDQSxJQUFJLENBQUMwQixrQkFBa0IsR0FBRztRQUMxQixJQUFJLENBQUNMLFNBQVMsQ0FBQ2IsS0FBSyxDQUFDVixVQUFVMEMsMEJBQTBCLENBQUNFLElBQUl2QjtZQUMxRCxJQUFJRyxJQUFJQyxJQUFJQztZQUNaLElBQUksQ0FBQ0Usa0JBQWtCLEdBQUc7WUFDMUIsSUFBSWlCO1lBQ0osSUFBSXBELGNBQWNxRCxzQkFBc0IsQ0FBQ3pCLFdBQVc7Z0JBQ2hEd0IsNEJBQTRCeEI7WUFDaEMsT0FDSztnQkFDRCxNQUFNMEIsZUFBZTtvQkFDakIzQyxtQkFBbUIsQ0FBQ29CLEtBQUtILFNBQVNqQixpQkFBaUIsTUFBTSxRQUFRb0IsT0FBTyxLQUFLLElBQUlBLEtBQUtOLGdCQUFnQmQsaUJBQWlCO29CQUN2SEUsa0JBQWtCLENBQUNtQixLQUFLSixTQUFTZixnQkFBZ0IsTUFBTSxRQUFRbUIsT0FBTyxLQUFLLElBQUlBLEtBQUtQLGdCQUFnQlosZ0JBQWdCO29CQUNwSEUsaUJBQWlCLENBQUNrQixLQUFLTCxTQUFTYixlQUFlLE1BQU0sUUFBUWtCLE9BQU8sS0FBSyxJQUFJQSxLQUFLUixnQkFBZ0JWLGVBQWU7Z0JBQ3JIO2dCQUNBcUMsNEJBQTRCLElBQUlwRCxjQUFjdUQsd0JBQXdCLENBQUNELGNBQWNMO1lBQ3pGO1lBQ0EsSUFBSSxDQUFDcEIsUUFBUSxDQUFDWixLQUFLLENBQUNrQyxJQUFJQztZQUN4QixJQUFJLENBQUNWLHFCQUFxQjtZQUMxQixJQUFJLENBQUNHLHVCQUF1QjtRQUNoQztJQUNKO0lBQ0EsOERBQThEO0lBQzlERix1QkFBdUJhLE9BQU8sRUFBRXBELE9BQU8sRUFBRTtRQUNyQyxJQUFJLENBQUNpQyxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNQLFNBQVMsQ0FBQ1IsV0FBVyxDQUFDbEIsU0FBUyxDQUFDcUQ7WUFDakMsSUFBSSxDQUFDcEIsaUJBQWlCLEdBQUc7WUFDekIsSUFBSSxJQUFJLENBQUNGLGtCQUFrQixFQUFFO2dCQUN6QixJQUFJLENBQUNDLHFCQUFxQixHQUFHb0I7Z0JBQzdCLElBQUksQ0FBQ1osY0FBYyxHQUFHeEM7WUFDMUIsT0FDSztnQkFDRCxJQUFJLENBQUN5QixRQUFRLENBQUNjLHNCQUFzQixDQUFDYSxTQUFTQztnQkFDOUMsSUFBSSxDQUFDWix1QkFBdUI7WUFDaEM7UUFDSjtJQUNKO0lBQ0EsOERBQThEO0lBQzlEdkIsWUFBWWxCLE9BQU8sRUFBRTtRQUNqQixJQUFJLENBQUN1QyxzQkFBc0IsQ0FBQyxDQUFDLEdBQUd2QztJQUNwQztJQUNBc0QsWUFBWTtRQUNSLElBQUksQ0FBQzdCLFFBQVEsQ0FBQzZCLFNBQVM7SUFDM0I7SUFDQXhDLFlBQVk7UUFDUixJQUFJLENBQUNZLFNBQVMsQ0FBQ1osU0FBUyxDQUFDO1lBQ3JCLElBQUksSUFBSSxDQUFDaUIsa0JBQWtCLElBQUksSUFBSSxDQUFDRSxpQkFBaUIsRUFBRTtnQkFDbkQsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztZQUM1QixPQUNLO2dCQUNELElBQUksQ0FBQ1QsUUFBUSxDQUFDWCxTQUFTO1lBQzNCO1FBQ0o7SUFDSjtJQUNBeUMsZUFBZUMsV0FBVyxFQUFFO1FBQ3hCLElBQUksQ0FBQy9CLFFBQVEsQ0FBQzhCLGNBQWMsQ0FBQ0M7SUFDakM7QUFDSjtBQUNBckUsd0JBQXdCLEdBQUdHO0FBQzNCLFNBQVNtRSxRQUFRQyxPQUFPLEVBQUVDLElBQUksRUFBRUMsT0FBTztJQUNuQyxJQUFJakMsSUFBSUM7SUFDUixNQUFNaUMsV0FBVyxDQUFDbEMsS0FBS2lDLFFBQVFDLFFBQVEsTUFBTSxRQUFRbEMsT0FBTyxLQUFLLElBQUlBLEtBQUttQztJQUMxRSxNQUFNQyxPQUFPSCxRQUFRRyxJQUFJO0lBQ3pCLE1BQU1DLFNBQVMsQ0FBQ3BDLEtBQUtnQyxRQUFRSSxNQUFNLE1BQU0sUUFBUXBDLE9BQU8sS0FBSyxJQUFJQSxLQUFLO0lBQ3RFLE1BQU1xQyxpQkFBaUJMLFFBQVFNLGVBQWU7SUFDOUMsTUFBTVYsY0FBY0ksUUFBUUosV0FBVztJQUN2QyxNQUFNVyxPQUFPVCxRQUFRVSxVQUFVLENBQUNULE1BQU1FLFVBQVVFLE1BQU1DLFFBQVFDO0lBQzlELElBQUlULGFBQWE7UUFDYlcsS0FBS1osY0FBYyxDQUFDQztJQUN4QjtJQUNBLE9BQU9XO0FBQ1g7QUFDQTs7O0NBR0MsR0FDRCxNQUFNRTtJQUNGdEUsWUFBWW9FLElBQUksRUFDaEIsOERBQThEO0lBQzlERyxnQkFBZ0IsQ0FBRTtRQUNkLElBQUksQ0FBQ0gsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0csZ0JBQWdCLEdBQUdBO0lBQzVCO0lBQ0FuQyxpQkFBaUI5QixNQUFNLEVBQUUrQixPQUFPLEVBQUU7UUFDOUIsSUFBSSxDQUFDK0IsSUFBSSxDQUFDaEMsZ0JBQWdCLENBQUM5QixRQUFRK0I7SUFDdkM7SUFDQUMsVUFBVTtRQUNOLE9BQU8sSUFBSSxDQUFDOEIsSUFBSSxDQUFDOUIsT0FBTztJQUM1QjtJQUNBa0IsZUFBZUMsV0FBVyxFQUFFO1FBQ3hCLElBQUksQ0FBQ1csSUFBSSxDQUFDWixjQUFjLENBQUNDO0lBQzdCO0lBQ0EsOERBQThEO0lBQzlEakIsdUJBQXVCYSxPQUFPLEVBQUVwRCxPQUFPLEVBQUU7UUFDckMsSUFBSXVFO1FBQ0osSUFBSTtZQUNBQSxhQUFhLElBQUksQ0FBQ0QsZ0JBQWdCLENBQUNFLGdCQUFnQixDQUFDeEU7UUFDeEQsRUFDQSxPQUFPeUUsR0FBRztZQUNOLElBQUksQ0FBQ04sSUFBSSxDQUFDaEMsZ0JBQWdCLENBQUN0QyxZQUFZNkUsTUFBTSxDQUFDQyxRQUFRLEVBQUUsQ0FBQyx1Q0FBdUMsRUFBRUYsRUFBRXpFLE9BQU8sQ0FBQyxDQUFDO1lBQzdHO1FBQ0o7UUFDQSxJQUFJLENBQUNtRSxJQUFJLENBQUM1QixzQkFBc0IsQ0FBQ2EsU0FBU21CO0lBQzlDO0lBQ0EsOERBQThEO0lBQzlEckQsWUFBWWxCLE9BQU8sRUFBRTtRQUNqQixJQUFJLENBQUN1QyxzQkFBc0IsQ0FBQyxDQUFDLEdBQUd2QztJQUNwQztJQUNBYSxNQUFNVixRQUFRLEVBQUV1QyxvQkFBb0IsRUFBRTtRQUNsQyxJQUFJa0MsWUFBWTtRQUNoQixJQUFJLENBQUNULElBQUksQ0FBQ3RELEtBQUssQ0FBQ1YsVUFBVTtZQUN0QkksbUJBQW1CLENBQUNKO2dCQUNoQixJQUFJd0I7Z0JBQ0hBLENBQUFBLEtBQUtlLHlCQUF5QixRQUFRQSx5QkFBeUIsS0FBSyxJQUFJLEtBQUssSUFBSUEscUJBQXFCbkMsaUJBQWlCLE1BQU0sUUFBUW9CLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3dDLElBQUksQ0FBQ3pCLHNCQUFzQnZDO1lBQ2pNO1lBQ0FNLGtCQUFrQixDQUFDVDtnQkFDZixJQUFJMkI7Z0JBQ0osOERBQThEO2dCQUM5RCxJQUFJa0Q7Z0JBQ0osSUFBSTtvQkFDQUEsZUFBZSxJQUFJLENBQUNQLGdCQUFnQixDQUFDUSxtQkFBbUIsQ0FBQzlFO2dCQUM3RCxFQUNBLE9BQU95RSxHQUFHO29CQUNORyxZQUFZO3dCQUNSRyxNQUFNbEYsWUFBWTZFLE1BQU0sQ0FBQ0MsUUFBUTt3QkFDakN2QyxTQUFTLENBQUMsZ0NBQWdDLEVBQUVxQyxFQUFFekUsT0FBTyxDQUFDLENBQUM7d0JBQ3ZERyxVQUFVLElBQUlULFdBQVdzRixRQUFRO29CQUNyQztvQkFDQSxJQUFJLENBQUNiLElBQUksQ0FBQ2hDLGdCQUFnQixDQUFDeUMsVUFBVUcsSUFBSSxFQUFFSCxVQUFVeEMsT0FBTztvQkFDNUQ7Z0JBQ0o7Z0JBQ0NULENBQUFBLEtBQUtlLHlCQUF5QixRQUFRQSx5QkFBeUIsS0FBSyxJQUFJLEtBQUssSUFBSUEscUJBQXFCakMsZ0JBQWdCLE1BQU0sUUFBUWtCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3dDLElBQUksQ0FBQ3pCLHNCQUFzQm1DO1lBQ2hNO1lBQ0FsRSxpQkFBaUIsQ0FBQ047Z0JBQ2QsSUFBSXNCLElBQUlDO2dCQUNSLElBQUlnRCxXQUFXO29CQUNWakQsQ0FBQUEsS0FBS2UseUJBQXlCLFFBQVFBLHlCQUF5QixLQUFLLElBQUksS0FBSyxJQUFJQSxxQkFBcUIvQixlQUFlLE1BQU0sUUFBUWdCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3dDLElBQUksQ0FBQ3pCLHNCQUFzQmtDO2dCQUMvTCxPQUNLO29CQUNBaEQsQ0FBQUEsS0FBS2MseUJBQXlCLFFBQVFBLHlCQUF5QixLQUFLLElBQUksS0FBSyxJQUFJQSxxQkFBcUIvQixlQUFlLE1BQU0sUUFBUWlCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3VDLElBQUksQ0FBQ3pCLHNCQUFzQnJDO2dCQUMvTDtZQUNKO1FBQ0o7SUFDSjtJQUNBaUQsWUFBWTtRQUNSLElBQUksQ0FBQ2EsSUFBSSxDQUFDYixTQUFTO0lBQ3ZCO0lBQ0F4QyxZQUFZO1FBQ1IsSUFBSSxDQUFDcUQsSUFBSSxDQUFDckQsU0FBUztJQUN2QjtBQUNKO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTW1FLGtDQUFrQ1o7SUFDcEMsOERBQThEO0lBQzlEdEUsWUFBWW9FLElBQUksRUFBRUcsZ0JBQWdCLENBQUU7UUFDaEMsS0FBSyxDQUFDSCxNQUFNRztJQUNoQjtJQUNBekQsTUFBTVYsUUFBUSxFQUFFcUIsUUFBUSxFQUFFO1FBQ3RCLElBQUlHLElBQUlDO1FBQ1IsSUFBSXNELGtCQUFrQjtRQUN0QixNQUFNQyxrQkFBa0I7WUFDcEI1RSxtQkFBbUIsQ0FBQ3FCLEtBQUssQ0FBQ0QsS0FBS0gsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVNqQixpQkFBaUIsTUFBTSxRQUFRb0IsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHbUIsSUFBSSxDQUFDdEIsU0FBUSxNQUFPLFFBQVFJLE9BQU8sS0FBSyxJQUFJQSxLQUFNLENBQUN6QixZQUFlO1lBQ3pOLDhEQUE4RDtZQUM5RE0sa0JBQWtCLENBQUNUO2dCQUNmLElBQUkyQjtnQkFDSnVELGtCQUFrQjtnQkFDakJ2RCxDQUFBQSxLQUFLSCxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBU2YsZ0JBQWdCLE1BQU0sUUFBUWtCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3dDLElBQUksQ0FBQzNDLFVBQVV4QjtZQUNoSjtZQUNBVyxpQkFBaUIsQ0FBQ047Z0JBQ2QsSUFBSXNCLElBQUlDO2dCQUNSLElBQUksQ0FBQ3NELGlCQUFpQjtvQkFDakJ2RCxDQUFBQSxLQUFLSCxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBU2YsZ0JBQWdCLE1BQU0sUUFBUWtCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3dDLElBQUksQ0FBQzNDLFVBQVU7Z0JBQ2hKO2dCQUNDSSxDQUFBQSxLQUFLSixhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBU2IsZUFBZSxNQUFNLFFBQVFpQixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd1QyxJQUFJLENBQUMzQyxVQUFVbkI7WUFDL0k7UUFDSjtRQUNBLEtBQUssQ0FBQ1EsTUFBTVYsVUFBVWdGO1FBQ3RCLElBQUksQ0FBQ2hCLElBQUksQ0FBQ2IsU0FBUztJQUN2QjtBQUNKO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTThCLHNDQUFzQ2Y7QUFDNUM7QUFDQSxTQUFTZ0IsMEJBQTBCM0IsT0FBTyxFQUFFRSxPQUFPLEVBQ25ELDhEQUE4RDtBQUM5RFUsZ0JBQWdCO0lBQ1osTUFBTUgsT0FBT1YsUUFBUUMsU0FBU1ksaUJBQWlCWCxJQUFJLEVBQUVDO0lBQ3JELElBQUlVLGlCQUFpQmdCLGNBQWMsRUFBRTtRQUNqQyxPQUFPLElBQUlGLDhCQUE4QmpCLE1BQU1HO0lBQ25ELE9BQ0s7UUFDRCxPQUFPLElBQUlXLDBCQUEwQmQsTUFBTUc7SUFDL0M7QUFDSjtBQUNBLFNBQVNqRixvQkFBb0JrRyxlQUFlLEVBQzVDLDhEQUE4RDtBQUM5RGpCLGdCQUFnQixFQUFFVixPQUFPLEVBQUVGLE9BQU87SUFDOUIsSUFBSTZCLGdCQUFnQkMsa0JBQWtCLENBQUNDLE1BQU0sR0FBRyxLQUM1Q0YsZ0JBQWdCRywwQkFBMEIsQ0FBQ0QsTUFBTSxHQUFHLEdBQUc7UUFDdkQsTUFBTSxJQUFJaEcsOEJBQThCLHdFQUNwQztJQUNSO0lBQ0EsSUFBSThGLGdCQUFnQkksZ0JBQWdCLENBQUNGLE1BQU0sR0FBRyxLQUMxQ0YsZ0JBQWdCSyx3QkFBd0IsQ0FBQ0gsTUFBTSxHQUFHLEdBQUc7UUFDckQsTUFBTSxJQUFJaEcsOEJBQThCLHFFQUNwQztJQUNSO0lBQ0EsSUFBSW9HLGVBQWUsRUFBRTtJQUNyQix5RkFBeUY7SUFDekYsSUFBSU4sZ0JBQWdCSSxnQkFBZ0IsQ0FBQ0YsTUFBTSxHQUFHLEtBQzFDRixnQkFBZ0JLLHdCQUF3QixDQUFDSCxNQUFNLEdBQUcsR0FBRztRQUNyREksZUFBZSxFQUFFLENBQ1pDLE1BQU0sQ0FBQ1AsZ0JBQWdCSSxnQkFBZ0IsRUFBRUosZ0JBQWdCSyx3QkFBd0IsQ0FBQ0csR0FBRyxDQUFDLENBQUNDLFdBQWFBLFNBQVMxQixvQkFDN0cyQixNQUFNLENBQUMsQ0FBQ0MsY0FBZ0JBO0lBQzdCLHdEQUF3RDtJQUM1RCxPQUNLO1FBQ0RMLGVBQWUsRUFBRSxDQUNaQyxNQUFNLENBQUNQLGdCQUFnQkMsa0JBQWtCLEVBQUVELGdCQUFnQkcsMEJBQTBCLENBQUNLLEdBQUcsQ0FBQyxDQUFDQyxXQUFhQSxTQUFTMUIsb0JBQ2pIMkIsTUFBTSxDQUFDLENBQUNDLGNBQWdCQTtJQUM3Qix3REFBd0Q7SUFDNUQ7SUFDQSxNQUFNQyxxQkFBcUJsSCxPQUFPbUgsTUFBTSxDQUFDLENBQUMsR0FBR3hDLFNBQVM7UUFDbER5QyxtQkFBbUIvQjtJQUN2QjtJQUNBOzs7Ozs7Z0JBTVksR0FDWixNQUFNYixVQUFVb0MsYUFBYVMsV0FBVyxDQUFDLENBQUM3RSxVQUFVOEU7UUFDaEQsT0FBTyxDQUFDQyxpQkFBbUJELGdCQUFnQkMsZ0JBQWdCL0U7SUFDL0QsR0FBRyxDQUFDZ0YsZUFBaUJwQiwwQkFBMEIzQixTQUFTK0MsY0FBY25DO0lBQ3RFLE9BQU9iLFFBQVEwQztBQUNuQjtBQUNBaEgsMkJBQTJCLEdBQUdFLHFCQUM5QiwrQ0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc2htaXR0LWd1cHRhLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NsaWVudC1pbnRlcmNlcHRvcnMuanM/MTMwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRJbnRlcmNlcHRpbmdDYWxsID0gZXhwb3J0cy5JbnRlcmNlcHRpbmdDYWxsID0gZXhwb3J0cy5SZXF1ZXN0ZXJCdWlsZGVyID0gZXhwb3J0cy5MaXN0ZW5lckJ1aWxkZXIgPSBleHBvcnRzLkludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yID0gdm9pZCAwO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgY2FsbF9zdHJlYW1fMSA9IHJlcXVpcmUoXCIuL2NhbGwtc3RyZWFtXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG4vKipcbiAqIEVycm9yIGNsYXNzIGFzc29jaWF0ZWQgd2l0aCBwYXNzaW5nIGJvdGggaW50ZXJjZXB0b3JzIGFuZCBpbnRlcmNlcHRvclxuICogcHJvdmlkZXJzIHRvIGEgY2xpZW50IGNvbnN0cnVjdG9yIG9yIGFzIGNhbGwgb3B0aW9ucy5cbiAqL1xuY2xhc3MgSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yJztcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IpO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IgPSBJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcjtcbmNsYXNzIExpc3RlbmVyQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHdpdGhPblJlY2VpdmVNZXRhZGF0YShvblJlY2VpdmVNZXRhZGF0YSkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gb25SZWNlaXZlTWV0YWRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoT25SZWNlaXZlTWVzc2FnZShvblJlY2VpdmVNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG9uUmVjZWl2ZU1lc3NhZ2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoT25SZWNlaXZlU3RhdHVzKG9uUmVjZWl2ZVN0YXR1cykge1xuICAgICAgICB0aGlzLnN0YXR1cyA9IG9uUmVjZWl2ZVN0YXR1cztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJ1aWxkKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IHRoaXMubWV0YWRhdGEsXG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTGlzdGVuZXJCdWlsZGVyID0gTGlzdGVuZXJCdWlsZGVyO1xuY2xhc3MgUmVxdWVzdGVyQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5oYWxmQ2xvc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2FuY2VsID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB3aXRoU3RhcnQoc3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2l0aFNlbmRNZXNzYWdlKHNlbmRNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHNlbmRNZXNzYWdlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2l0aEhhbGZDbG9zZShoYWxmQ2xvc2UpIHtcbiAgICAgICAgdGhpcy5oYWxmQ2xvc2UgPSBoYWxmQ2xvc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoQ2FuY2VsKGNhbmNlbCkge1xuICAgICAgICB0aGlzLmNhbmNlbCA9IGNhbmNlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJ1aWxkKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQsXG4gICAgICAgICAgICBzZW5kTWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgaGFsZkNsb3NlOiB0aGlzLmhhbGZDbG9zZSxcbiAgICAgICAgICAgIGNhbmNlbDogdGhpcy5jYW5jZWwsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0ZXJCdWlsZGVyID0gUmVxdWVzdGVyQnVpbGRlcjtcbi8qKlxuICogQSBMaXN0ZW5lciB3aXRoIGEgZGVmYXVsdCBwYXNzLXRocm91Z2ggaW1wbGVtZW50YXRpb24gb2YgZWFjaCBtZXRob2QuIFVzZWRcbiAqIGZvciBmaWxsaW5nIG91dCBMaXN0ZW5lcnMgd2l0aCBzb21lIG1ldGhvZHMgb21pdHRlZC5cbiAqL1xuY29uc3QgZGVmYXVsdExpc3RlbmVyID0ge1xuICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiAobWV0YWRhdGEsIG5leHQpID0+IHtcbiAgICAgICAgbmV4dChtZXRhZGF0YSk7XG4gICAgfSxcbiAgICBvblJlY2VpdmVNZXNzYWdlOiAobWVzc2FnZSwgbmV4dCkgPT4ge1xuICAgICAgICBuZXh0KG1lc3NhZ2UpO1xuICAgIH0sXG4gICAgb25SZWNlaXZlU3RhdHVzOiAoc3RhdHVzLCBuZXh0KSA9PiB7XG4gICAgICAgIG5leHQoc3RhdHVzKTtcbiAgICB9LFxufTtcbi8qKlxuICogQSBSZXF1ZXN0ZXIgd2l0aCBhIGRlZmF1bHQgcGFzcy10aHJvdWdoIGltcGxlbWVudGF0aW9uIG9mIGVhY2ggbWV0aG9kLiBVc2VkXG4gKiBmb3IgZmlsbGluZyBvdXQgUmVxdWVzdGVycyB3aXRoIHNvbWUgbWV0aG9kcyBvbWl0dGVkLlxuICovXG5jb25zdCBkZWZhdWx0UmVxdWVzdGVyID0ge1xuICAgIHN0YXJ0OiAobWV0YWRhdGEsIGxpc3RlbmVyLCBuZXh0KSA9PiB7XG4gICAgICAgIG5leHQobWV0YWRhdGEsIGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIHNlbmRNZXNzYWdlOiAobWVzc2FnZSwgbmV4dCkgPT4ge1xuICAgICAgICBuZXh0KG1lc3NhZ2UpO1xuICAgIH0sXG4gICAgaGFsZkNsb3NlOiAobmV4dCkgPT4ge1xuICAgICAgICBuZXh0KCk7XG4gICAgfSxcbiAgICBjYW5jZWw6IChuZXh0KSA9PiB7XG4gICAgICAgIG5leHQoKTtcbiAgICB9LFxufTtcbmNsYXNzIEludGVyY2VwdGluZ0NhbGwge1xuICAgIGNvbnN0cnVjdG9yKG5leHRDYWxsLCByZXF1ZXN0ZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICB0aGlzLm5leHRDYWxsID0gbmV4dENhbGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCBtZXRhZGF0YSBoYXMgYmVlbiBwYXNzZWQgdG8gdGhlIHJlcXVlc3RlcidzIHN0YXJ0XG4gICAgICAgICAqIG1ldGhvZCBidXQgaXQgaGFzIG5vdCBiZWVuIHBhc3NlZCB0byB0aGUgY29ycmVzcG9uZGluZyBuZXh0IGNhbGxiYWNrXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWVzc2FnZSBjb250ZXh0IGZvciBhIHBlbmRpbmcgbWVzc2FnZSB0aGF0IGlzIHdhaXRpbmcgZm9yXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlQ29udGV4dCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIG1lc3NhZ2UgaGFzIGJlZW4gcGFzc2VkIHRvIHRoZSByZXF1ZXN0ZXIncyBzZW5kTWVzc2FnZVxuICAgICAgICAgKiBtZXRob2QgYnV0IGl0IGhhcyBub3QgYmVlbiBwYXNzZWQgdG8gdGhlIGNvcnJlc3BvbmRpbmcgbmV4dCBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgYSBzdGF0dXMgd2FzIHJlY2VpdmVkIGJ1dCBjb3VsZCBub3QgYmUgcHJvcGFnYXRlZCBiZWNhdXNlXG4gICAgICAgICAqIGEgbWVzc2FnZSB3YXMgc3RpbGwgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nSGFsZkNsb3NlID0gZmFsc2U7XG4gICAgICAgIGlmIChyZXF1ZXN0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdGVyID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiAoX2EgPSByZXF1ZXN0ZXIuc3RhcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZmF1bHRSZXF1ZXN0ZXIuc3RhcnQsXG4gICAgICAgICAgICAgICAgc2VuZE1lc3NhZ2U6IChfYiA9IHJlcXVlc3Rlci5zZW5kTWVzc2FnZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVmYXVsdFJlcXVlc3Rlci5zZW5kTWVzc2FnZSxcbiAgICAgICAgICAgICAgICBoYWxmQ2xvc2U6IChfYyA9IHJlcXVlc3Rlci5oYWxmQ2xvc2UpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGRlZmF1bHRSZXF1ZXN0ZXIuaGFsZkNsb3NlLFxuICAgICAgICAgICAgICAgIGNhbmNlbDogKF9kID0gcmVxdWVzdGVyLmNhbmNlbCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZGVmYXVsdFJlcXVlc3Rlci5jYW5jZWwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ZXIgPSBkZWZhdWx0UmVxdWVzdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdGVyLmNhbmNlbCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5leHRDYWxsLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDYWxsLmdldFBlZXIoKTtcbiAgICB9XG4gICAgcHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nTWVzc2FnZUNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dENhbGwuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dCh0aGlzLnBlbmRpbmdNZXNzYWdlQ29udGV4dCwgdGhpcy5wZW5kaW5nTWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzUGVuZGluZ0hhbGZDbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0hhbGZDbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydChtZXRhZGF0YSwgaW50ZXJjZXB0aW5nTGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIGNvbnN0IGZ1bGxJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiAoX2IgPSAoX2EgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iaW5kKGludGVyY2VwdGluZ0xpc3RlbmVyKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKChtZXRhZGF0YSkgPT4geyB9KSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IChfZCA9IChfYyA9IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRpbmdMaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYmluZChpbnRlcmNlcHRpbmdMaXN0ZW5lcikpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICgobWVzc2FnZSkgPT4geyB9KSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogKF9mID0gKF9lID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmJpbmQoaW50ZXJjZXB0aW5nTGlzdGVuZXIpKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiAoKHN0YXR1cykgPT4geyB9KSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlcXVlc3Rlci5zdGFydChtZXRhZGF0YSwgZnVsbEludGVyY2VwdGluZ0xpc3RlbmVyLCAobWQsIGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lcjtcbiAgICAgICAgICAgIGlmIChjYWxsX3N0cmVhbV8xLmlzSW50ZXJjZXB0aW5nTGlzdGVuZXIobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgICAgZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVsbExpc3RlbmVyID0ge1xuICAgICAgICAgICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogKF9hID0gbGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZmF1bHRMaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogKF9iID0gbGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVmYXVsdExpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogKF9jID0gbGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0TGlzdGVuZXIub25SZWNlaXZlU3RhdHVzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IG5ldyBjYWxsX3N0cmVhbV8xLkludGVyY2VwdGluZ0xpc3RlbmVySW1wbChmdWxsTGlzdGVuZXIsIGZ1bGxJbnRlcmNlcHRpbmdMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5leHRDYWxsLnN0YXJ0KG1kLCBmaW5hbEludGVyY2VwdGluZ0xpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nSGFsZkNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZXIuc2VuZE1lc3NhZ2UobWVzc2FnZSwgKGZpbmFsTWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZUNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIGZpbmFsTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ0hhbGZDbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dCh7fSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIHN0YXJ0UmVhZCgpIHtcbiAgICAgICAgdGhpcy5uZXh0Q2FsbC5zdGFydFJlYWQoKTtcbiAgICB9XG4gICAgaGFsZkNsb3NlKCkge1xuICAgICAgICB0aGlzLnJlcXVlc3Rlci5oYWxmQ2xvc2UoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhIHx8IHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdIYWxmQ2xvc2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRoaXMubmV4dENhbGwuc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50ZXJjZXB0aW5nQ2FsbCA9IEludGVyY2VwdGluZ0NhbGw7XG5mdW5jdGlvbiBnZXRDYWxsKGNoYW5uZWwsIHBhdGgsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGRlYWRsaW5lID0gKF9hID0gb3B0aW9ucy5kZWFkbGluZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogSW5maW5pdHk7XG4gICAgY29uc3QgaG9zdCA9IG9wdGlvbnMuaG9zdDtcbiAgICBjb25zdCBwYXJlbnQgPSAoX2IgPSBvcHRpb25zLnBhcmVudCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcbiAgICBjb25zdCBwcm9wYWdhdGVGbGFncyA9IG9wdGlvbnMucHJvcGFnYXRlX2ZsYWdzO1xuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscztcbiAgICBjb25zdCBjYWxsID0gY2hhbm5lbC5jcmVhdGVDYWxsKHBhdGgsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnQsIHByb3BhZ2F0ZUZsYWdzKTtcbiAgICBpZiAoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY2FsbC5zZXRDcmVkZW50aWFscyhjcmVkZW50aWFscyk7XG4gICAgfVxuICAgIHJldHVybiBjYWxsO1xufVxuLyoqXG4gKiBJbnRlcmNlcHRpbmdDYWxsIGltcGxlbWVudGF0aW9uIHRoYXQgZGlyZWN0bHkgb3ducyB0aGUgdW5kZXJseWluZyBDYWxsXG4gKiBvYmplY3QgYW5kIGhhbmRsZXMgc2VyaWFsaXphdGlvbiBhbmQgZGVzZXJhaXpsaWF0aW9uLlxuICovXG5jbGFzcyBCYXNlSW50ZXJjZXB0aW5nQ2FsbCB7XG4gICAgY29uc3RydWN0b3IoY2FsbCwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBtZXRob2REZWZpbml0aW9uKSB7XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgICAgIHRoaXMubWV0aG9kRGVmaW5pdGlvbiA9IG1ldGhvZERlZmluaXRpb247XG4gICAgfVxuICAgIGNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuY2FsbC5jYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscyk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGVlcigpO1xuICAgIH1cbiAgICBzZXRDcmVkZW50aWFscyhjcmVkZW50aWFscykge1xuICAgICAgICB0aGlzLmNhbGwuc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgbWVzc2FnZSkge1xuICAgICAgICBsZXQgc2VyaWFsaXplZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQgPSB0aGlzLm1ldGhvZERlZmluaXRpb24ucmVxdWVzdFNlcmlhbGl6ZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCBgUmVxdWVzdCBtZXNzYWdlIHNlcmlhbGl6YXRpb24gZmFpbHVyZTogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgc2VyaWFsaXplZCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoe30sIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBzdGFydChtZXRhZGF0YSwgaW50ZXJjZXB0aW5nTGlzdGVuZXIpIHtcbiAgICAgICAgbGV0IHJlYWRFcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuY2FsbC5zdGFydChtZXRhZGF0YSwge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IChtZXRhZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGludGVyY2VwdGluZ0xpc3RlbmVyLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBsZXQgZGVzZXJpYWxpemVkO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2VyaWFsaXplZCA9IHRoaXMubWV0aG9kRGVmaW5pdGlvbi5yZXNwb25zZURlc2VyaWFsaXplKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkRXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVzcG9uc2UgbWVzc2FnZSBwYXJzaW5nIGVycm9yOiAke2UubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbC5jYW5jZWxXaXRoU3RhdHVzKHJlYWRFcnJvci5jb2RlLCByZWFkRXJyb3IuZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKF9hID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGludGVyY2VwdGluZ0xpc3RlbmVyLCBkZXNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChpbnRlcmNlcHRpbmdMaXN0ZW5lciwgcmVhZEVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIChfYiA9IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRpbmdMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGludGVyY2VwdGluZ0xpc3RlbmVyLCBzdGF0dXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGFydFJlYWQoKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zdGFydFJlYWQoKTtcbiAgICB9XG4gICAgaGFsZkNsb3NlKCkge1xuICAgICAgICB0aGlzLmNhbGwuaGFsZkNsb3NlKCk7XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlSW50ZXJjZXB0aW5nQ2FsbCB3aXRoIHNwZWNpYWwtY2FzZWQgYmVoYXZpb3IgZm9yIG1ldGhvZHMgd2l0aCB1bmFyeVxuICogcmVzcG9uc2VzLlxuICovXG5jbGFzcyBCYXNlVW5hcnlJbnRlcmNlcHRpbmdDYWxsIGV4dGVuZHMgQmFzZUludGVyY2VwdGluZ0NhbGwge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3RydWN0b3IoY2FsbCwgbWV0aG9kRGVmaW5pdGlvbikge1xuICAgICAgICBzdXBlcihjYWxsLCBtZXRob2REZWZpbml0aW9uKTtcbiAgICB9XG4gICAgc3RhcnQobWV0YWRhdGEsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZWNlaXZlZE1lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgd3JhcHBlckxpc3RlbmVyID0ge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IChfYiA9IChfYSA9IGxpc3RlbmVyID09PSBudWxsIHx8IGxpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJpbmQobGlzdGVuZXIpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAoKG1ldGFkYXRhKSA9PiB7IH0pLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkTWVzc2FnZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgKF9hID0gbGlzdGVuZXIgPT09IG51bGwgfHwgbGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGxpc3RlbmVyLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGlmICghcmVjZWl2ZWRNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGxpc3RlbmVyID09PSBudWxsIHx8IGxpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChsaXN0ZW5lciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYiA9IGxpc3RlbmVyID09PSBudWxsIHx8IGxpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGxpc3RlbmVyLCBzdGF0dXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIuc3RhcnQobWV0YWRhdGEsIHdyYXBwZXJMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuY2FsbC5zdGFydFJlYWQoKTtcbiAgICB9XG59XG4vKipcbiAqIEJhc2VJbnRlcmNlcHRpbmdDYWxsIHdpdGggc3BlY2lhbC1jYXNlZCBiZWhhdmlvciBmb3IgbWV0aG9kcyB3aXRoIHN0cmVhbWluZ1xuICogcmVzcG9uc2VzLlxuICovXG5jbGFzcyBCYXNlU3RyZWFtaW5nSW50ZXJjZXB0aW5nQ2FsbCBleHRlbmRzIEJhc2VJbnRlcmNlcHRpbmdDYWxsIHtcbn1cbmZ1bmN0aW9uIGdldEJvdHRvbUludGVyY2VwdGluZ0NhbGwoY2hhbm5lbCwgb3B0aW9ucywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxubWV0aG9kRGVmaW5pdGlvbikge1xuICAgIGNvbnN0IGNhbGwgPSBnZXRDYWxsKGNoYW5uZWwsIG1ldGhvZERlZmluaXRpb24ucGF0aCwgb3B0aW9ucyk7XG4gICAgaWYgKG1ldGhvZERlZmluaXRpb24ucmVzcG9uc2VTdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlU3RyZWFtaW5nSW50ZXJjZXB0aW5nQ2FsbChjYWxsLCBtZXRob2REZWZpbml0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZVVuYXJ5SW50ZXJjZXB0aW5nQ2FsbChjYWxsLCBtZXRob2REZWZpbml0aW9uKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRJbnRlcmNlcHRpbmdDYWxsKGludGVyY2VwdG9yQXJncywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxubWV0aG9kRGVmaW5pdGlvbiwgb3B0aW9ucywgY2hhbm5lbCkge1xuICAgIGlmIChpbnRlcmNlcHRvckFyZ3MuY2xpZW50SW50ZXJjZXB0b3JzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgaW50ZXJjZXB0b3JBcmdzLmNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yKCdCb3RoIGludGVyY2VwdG9ycyBhbmQgaW50ZXJjZXB0b3JfcHJvdmlkZXJzIHdlcmUgcGFzc2VkIGFzIG9wdGlvbnMgJyArXG4gICAgICAgICAgICAndG8gdGhlIGNsaWVudCBjb25zdHJ1Y3Rvci4gT25seSBvbmUgb2YgdGhlc2UgaXMgYWxsb3dlZC4nKTtcbiAgICB9XG4gICAgaWYgKGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgaW50ZXJjZXB0b3JBcmdzLmNhbGxJbnRlcmNlcHRvclByb3ZpZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcignQm90aCBpbnRlcmNlcHRvcnMgYW5kIGludGVyY2VwdG9yX3Byb3ZpZGVycyB3ZXJlIHBhc3NlZCBhcyBjYWxsICcgK1xuICAgICAgICAgICAgJ29wdGlvbnMuIE9ubHkgb25lIG9mIHRoZXNlIGlzIGFsbG93ZWQuJyk7XG4gICAgfVxuICAgIGxldCBpbnRlcmNlcHRvcnMgPSBbXTtcbiAgICAvLyBJbnRlcmNlcHRvcnMgcGFzc2VkIHRvIHRoZSBjYWxsIG92ZXJyaWRlIGludGVyY2VwdG9ycyBwYXNzZWQgdG8gdGhlIGNsaWVudCBjb25zdHJ1Y3RvclxuICAgIGlmIChpbnRlcmNlcHRvckFyZ3MuY2FsbEludGVyY2VwdG9ycy5sZW5ndGggPiAwIHx8XG4gICAgICAgIGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JQcm92aWRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBpbnRlcmNlcHRvcnMgPSBbXVxuICAgICAgICAgICAgLmNvbmNhdChpbnRlcmNlcHRvckFyZ3MuY2FsbEludGVyY2VwdG9ycywgaW50ZXJjZXB0b3JBcmdzLmNhbGxJbnRlcmNlcHRvclByb3ZpZGVycy5tYXAoKHByb3ZpZGVyKSA9PiBwcm92aWRlcihtZXRob2REZWZpbml0aW9uKSkpXG4gICAgICAgICAgICAuZmlsdGVyKChpbnRlcmNlcHRvcikgPT4gaW50ZXJjZXB0b3IpO1xuICAgICAgICAvLyBGaWx0ZXIgb3V0IGZhbHN5IHZhbHVlcyB3aGVuIHByb3ZpZGVycyByZXR1cm4gbm90aGluZ1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaW50ZXJjZXB0b3JzID0gW11cbiAgICAgICAgICAgIC5jb25jYXQoaW50ZXJjZXB0b3JBcmdzLmNsaWVudEludGVyY2VwdG9ycywgaW50ZXJjZXB0b3JBcmdzLmNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzLm1hcCgocHJvdmlkZXIpID0+IHByb3ZpZGVyKG1ldGhvZERlZmluaXRpb24pKSlcbiAgICAgICAgICAgIC5maWx0ZXIoKGludGVyY2VwdG9yKSA9PiBpbnRlcmNlcHRvcik7XG4gICAgICAgIC8vIEZpbHRlciBvdXQgZmFsc3kgdmFsdWVzIHdoZW4gcHJvdmlkZXJzIHJldHVybiBub3RoaW5nXG4gICAgfVxuICAgIGNvbnN0IGludGVyY2VwdG9yT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgbWV0aG9kX2RlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXG4gICAgfSk7XG4gICAgLyogRm9yIGVhY2ggaW50ZXJjZXB0b3IgaW4gdGhlIGxpc3QsIHRoZSBuZXh0Q2FsbCBmdW5jdGlvbiBwYXNzZWQgdG8gaXQgaXNcbiAgICAgKiBiYXNlZCBvbiB0aGUgbmV4dCBpbnRlcmNlcHRvciBpbiB0aGUgbGlzdCwgdXNpbmcgYSBuZXh0Q2FsbCBmdW5jdGlvblxuICAgICAqIGNvbnN0cnVjdGVkIHdpdGggdGhlIGZvbGxvd2luZyBpbnRlcmNlcHRvciBpbiB0aGUgbGlzdCwgYW5kIHNvIG9uLiBUaGVcbiAgICAgKiBpbml0aWFsVmFsdWUsIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QsIGlzIGEgbmV4dENhbGxcbiAgICAgKiBmdW5jdGlvbiB0aGF0IGludm9rZXMgZ2V0Qm90dG9tSW50ZXJjZXB0aW5nQ2FsbCwgdGhlIHJlc3VsdCBvZiB3aGljaFxuICAgICAqIGhhbmRsZXMgKGRlKXNlcmlhbGl6YXRpb24gYW5kIGFsc28gZ2V0cyB0aGUgdW5kZXJseWluZyBjYWxsIGZyb20gdGhlXG4gICAgICogY2hhbm5lbC4gKi9cbiAgICBjb25zdCBnZXRDYWxsID0gaW50ZXJjZXB0b3JzLnJlZHVjZVJpZ2h0KChuZXh0Q2FsbCwgbmV4dEludGVyY2VwdG9yKSA9PiB7XG4gICAgICAgIHJldHVybiAoY3VycmVudE9wdGlvbnMpID0+IG5leHRJbnRlcmNlcHRvcihjdXJyZW50T3B0aW9ucywgbmV4dENhbGwpO1xuICAgIH0sIChmaW5hbE9wdGlvbnMpID0+IGdldEJvdHRvbUludGVyY2VwdGluZ0NhbGwoY2hhbm5lbCwgZmluYWxPcHRpb25zLCBtZXRob2REZWZpbml0aW9uKSk7XG4gICAgcmV0dXJuIGdldENhbGwoaW50ZXJjZXB0b3JPcHRpb25zKTtcbn1cbmV4cG9ydHMuZ2V0SW50ZXJjZXB0aW5nQ2FsbCA9IGdldEludGVyY2VwdGluZ0NhbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnQtaW50ZXJjZXB0b3JzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldEludGVyY2VwdGluZ0NhbGwiLCJJbnRlcmNlcHRpbmdDYWxsIiwiUmVxdWVzdGVyQnVpbGRlciIsIkxpc3RlbmVyQnVpbGRlciIsIkludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yIiwibWV0YWRhdGFfMSIsInJlcXVpcmUiLCJjYWxsX3N0cmVhbV8xIiwiY29uc3RhbnRzXzEiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsIm5hbWUiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIm1ldGFkYXRhIiwidW5kZWZpbmVkIiwic3RhdHVzIiwid2l0aE9uUmVjZWl2ZU1ldGFkYXRhIiwib25SZWNlaXZlTWV0YWRhdGEiLCJ3aXRoT25SZWNlaXZlTWVzc2FnZSIsIm9uUmVjZWl2ZU1lc3NhZ2UiLCJ3aXRoT25SZWNlaXZlU3RhdHVzIiwib25SZWNlaXZlU3RhdHVzIiwiYnVpbGQiLCJzdGFydCIsImhhbGZDbG9zZSIsImNhbmNlbCIsIndpdGhTdGFydCIsIndpdGhTZW5kTWVzc2FnZSIsInNlbmRNZXNzYWdlIiwid2l0aEhhbGZDbG9zZSIsIndpdGhDYW5jZWwiLCJkZWZhdWx0TGlzdGVuZXIiLCJuZXh0IiwiZGVmYXVsdFJlcXVlc3RlciIsImxpc3RlbmVyIiwibmV4dENhbGwiLCJyZXF1ZXN0ZXIiLCJfYSIsIl9iIiwiX2MiLCJfZCIsInByb2Nlc3NpbmdNZXRhZGF0YSIsInBlbmRpbmdNZXNzYWdlQ29udGV4dCIsInByb2Nlc3NpbmdNZXNzYWdlIiwicGVuZGluZ0hhbGZDbG9zZSIsImNhbmNlbFdpdGhTdGF0dXMiLCJkZXRhaWxzIiwiZ2V0UGVlciIsInByb2Nlc3NQZW5kaW5nTWVzc2FnZSIsInNlbmRNZXNzYWdlV2l0aENvbnRleHQiLCJwZW5kaW5nTWVzc2FnZSIsInByb2Nlc3NQZW5kaW5nSGFsZkNsb3NlIiwiaW50ZXJjZXB0aW5nTGlzdGVuZXIiLCJfZSIsIl9mIiwiZnVsbEludGVyY2VwdGluZ0xpc3RlbmVyIiwiYmluZCIsIm1kIiwiZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lciIsImlzSW50ZXJjZXB0aW5nTGlzdGVuZXIiLCJmdWxsTGlzdGVuZXIiLCJJbnRlcmNlcHRpbmdMaXN0ZW5lckltcGwiLCJjb250ZXh0IiwiZmluYWxNZXNzYWdlIiwic3RhcnRSZWFkIiwic2V0Q3JlZGVudGlhbHMiLCJjcmVkZW50aWFscyIsImdldENhbGwiLCJjaGFubmVsIiwicGF0aCIsIm9wdGlvbnMiLCJkZWFkbGluZSIsIkluZmluaXR5IiwiaG9zdCIsInBhcmVudCIsInByb3BhZ2F0ZUZsYWdzIiwicHJvcGFnYXRlX2ZsYWdzIiwiY2FsbCIsImNyZWF0ZUNhbGwiLCJCYXNlSW50ZXJjZXB0aW5nQ2FsbCIsIm1ldGhvZERlZmluaXRpb24iLCJzZXJpYWxpemVkIiwicmVxdWVzdFNlcmlhbGl6ZSIsImUiLCJTdGF0dXMiLCJJTlRFUk5BTCIsInJlYWRFcnJvciIsImRlc2VyaWFsaXplZCIsInJlc3BvbnNlRGVzZXJpYWxpemUiLCJjb2RlIiwiTWV0YWRhdGEiLCJCYXNlVW5hcnlJbnRlcmNlcHRpbmdDYWxsIiwicmVjZWl2ZWRNZXNzYWdlIiwid3JhcHBlckxpc3RlbmVyIiwiQmFzZVN0cmVhbWluZ0ludGVyY2VwdGluZ0NhbGwiLCJnZXRCb3R0b21JbnRlcmNlcHRpbmdDYWxsIiwicmVzcG9uc2VTdHJlYW0iLCJpbnRlcmNlcHRvckFyZ3MiLCJjbGllbnRJbnRlcmNlcHRvcnMiLCJsZW5ndGgiLCJjbGllbnRJbnRlcmNlcHRvclByb3ZpZGVycyIsImNhbGxJbnRlcmNlcHRvcnMiLCJjYWxsSW50ZXJjZXB0b3JQcm92aWRlcnMiLCJpbnRlcmNlcHRvcnMiLCJjb25jYXQiLCJtYXAiLCJwcm92aWRlciIsImZpbHRlciIsImludGVyY2VwdG9yIiwiaW50ZXJjZXB0b3JPcHRpb25zIiwiYXNzaWduIiwibWV0aG9kX2RlZmluaXRpb24iLCJyZWR1Y2VSaWdodCIsIm5leHRJbnRlcmNlcHRvciIsImN1cnJlbnRPcHRpb25zIiwiZmluYWxPcHRpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/client.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Client = void 0;\nconst call_1 = __webpack_require__(/*! ./call */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call.js\");\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\nconst CHANNEL_SYMBOL = Symbol();\nconst INTERCEPTOR_SYMBOL = Symbol();\nconst INTERCEPTOR_PROVIDER_SYMBOL = Symbol();\nconst CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();\nfunction isFunction(arg) {\n    return typeof arg === \"function\";\n}\nfunction getErrorStackString(error) {\n    return error.stack.split(\"\\n\").slice(1).join(\"\\n\");\n}\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */ class Client {\n    constructor(address, credentials, options = {}){\n        var _a, _b;\n        options = Object.assign({}, options);\n        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];\n        delete options.interceptors;\n        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];\n        delete options.interceptor_providers;\n        if (this[INTERCEPTOR_SYMBOL].length > 0 && this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {\n            throw new Error(\"Both interceptors and interceptor_providers were passed as options \" + \"to the client constructor. Only one of these is allowed.\");\n        }\n        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] = options.callInvocationTransformer;\n        delete options.callInvocationTransformer;\n        if (options.channelOverride) {\n            this[CHANNEL_SYMBOL] = options.channelOverride;\n        } else if (options.channelFactoryOverride) {\n            const channelFactoryOverride = options.channelFactoryOverride;\n            delete options.channelFactoryOverride;\n            this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);\n        } else {\n            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);\n        }\n    }\n    close() {\n        this[CHANNEL_SYMBOL].close();\n    }\n    getChannel() {\n        return this[CHANNEL_SYMBOL];\n    }\n    waitForReady(deadline, callback) {\n        const checkState = (err)=>{\n            if (err) {\n                callback(new Error(\"Failed to connect before the deadline\"));\n                return;\n            }\n            let newState;\n            try {\n                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\n            } catch (e) {\n                callback(new Error(\"The channel has been closed\"));\n                return;\n            }\n            if (newState === connectivity_state_1.ConnectivityState.READY) {\n                callback();\n            } else {\n                try {\n                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\n                } catch (e) {\n                    callback(new Error(\"The channel has been closed\"));\n                }\n            }\n        };\n        setImmediate(checkState);\n    }\n    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n        if (isFunction(arg1)) {\n            return {\n                metadata: new metadata_1.Metadata(),\n                options: {},\n                callback: arg1\n            };\n        } else if (isFunction(arg2)) {\n            if (arg1 instanceof metadata_1.Metadata) {\n                return {\n                    metadata: arg1,\n                    options: {},\n                    callback: arg2\n                };\n            } else {\n                return {\n                    metadata: new metadata_1.Metadata(),\n                    options: arg1,\n                    callback: arg2\n                };\n            }\n        } else {\n            if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && isFunction(arg3))) {\n                throw new Error(\"Incorrect arguments passed\");\n            }\n            return {\n                metadata: arg1,\n                options: arg2,\n                callback: arg3\n            };\n        }\n    }\n    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientUnaryCallImpl(),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n        };\n        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */ emitter.call = call;\n        if (callProperties.callOptions.credentials) {\n            call.setCredentials(callProperties.callOptions.credentials);\n        }\n        let responseMessage = null;\n        let receivedStatus = false;\n        const callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: (metadata)=>{\n                emitter.emit(\"metadata\", metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage (message) {\n                if (responseMessage !== null) {\n                    call.cancelWithStatus(constants_1.Status.INTERNAL, \"Too many responses received\");\n                }\n                responseMessage = message;\n            },\n            onReceiveStatus (status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    if (responseMessage === null) {\n                        const callerStack = getErrorStackString(callerStackError);\n                        callProperties.callback(call_1.callErrorFromStatus({\n                            code: constants_1.Status.INTERNAL,\n                            details: \"No message received\",\n                            metadata: status.metadata\n                        }, callerStack));\n                    } else {\n                        callProperties.callback(null, responseMessage);\n                    }\n                } else {\n                    const callerStack = getErrorStackString(callerStackError);\n                    callProperties.callback(call_1.callErrorFromStatus(status, callerStack));\n                }\n                emitter.emit(\"status\", status);\n            }\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return emitter;\n    }\n    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientWritableStreamImpl(serialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n        };\n        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */ emitter.call = call;\n        if (callProperties.callOptions.credentials) {\n            call.setCredentials(callProperties.callOptions.credentials);\n        }\n        let responseMessage = null;\n        let receivedStatus = false;\n        const callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: (metadata)=>{\n                emitter.emit(\"metadata\", metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage (message) {\n                if (responseMessage !== null) {\n                    call.cancelWithStatus(constants_1.Status.INTERNAL, \"Too many responses received\");\n                }\n                responseMessage = message;\n            },\n            onReceiveStatus (status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    if (responseMessage === null) {\n                        const callerStack = getErrorStackString(callerStackError);\n                        callProperties.callback(call_1.callErrorFromStatus({\n                            code: constants_1.Status.INTERNAL,\n                            details: \"No message received\",\n                            metadata: status.metadata\n                        }, callerStack));\n                    } else {\n                        callProperties.callback(null, responseMessage);\n                    }\n                } else {\n                    const callerStack = getErrorStackString(callerStackError);\n                    callProperties.callback(call_1.callErrorFromStatus(status, callerStack));\n                }\n                emitter.emit(\"status\", status);\n            }\n        });\n        return emitter;\n    }\n    checkMetadataAndOptions(arg1, arg2) {\n        let metadata;\n        let options;\n        if (arg1 instanceof metadata_1.Metadata) {\n            metadata = arg1;\n            if (arg2) {\n                options = arg2;\n            } else {\n                options = {};\n            }\n        } else {\n            if (arg1) {\n                options = arg1;\n            } else {\n                options = {};\n            }\n            metadata = new metadata_1.Metadata();\n        }\n        return {\n            metadata,\n            options\n        };\n    }\n    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientReadableStreamImpl(deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n        };\n        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */ stream.call = call;\n        if (callProperties.callOptions.credentials) {\n            call.setCredentials(callProperties.callOptions.credentials);\n        }\n        let receivedStatus = false;\n        const callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata (metadata) {\n                stream.emit(\"metadata\", metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage (message) {\n                stream.push(message);\n            },\n            onReceiveStatus (status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    const callerStack = getErrorStackString(callerStackError);\n                    stream.emit(\"error\", call_1.callErrorFromStatus(status, callerStack));\n                }\n                stream.emit(\"status\", status);\n            }\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return stream;\n    }\n    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n        };\n        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */ stream.call = call;\n        if (callProperties.callOptions.credentials) {\n            call.setCredentials(callProperties.callOptions.credentials);\n        }\n        let receivedStatus = false;\n        const callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata (metadata) {\n                stream.emit(\"metadata\", metadata);\n            },\n            onReceiveMessage (message) {\n                stream.push(message);\n            },\n            onReceiveStatus (status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    const callerStack = getErrorStackString(callerStackError);\n                    stream.emit(\"error\", call_1.callErrorFromStatus(status, callerStack));\n                }\n                stream.emit(\"status\", status);\n            }\n        });\n        return stream;\n    }\n}\nexports.Client = Client; //# sourceMappingURL=client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixNQUFNRyxTQUFTQyxtQkFBT0EsQ0FBQyxvRUFBUTtBQUMvQixNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQywwRUFBVztBQUNyQyxNQUFNRSx1QkFBdUJGLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNRyxjQUFjSCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNSSxhQUFhSixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNSyx3QkFBd0JMLG1CQUFPQSxDQUFDLGtHQUF1QjtBQUM3RCxNQUFNTSxpQkFBaUJDO0FBQ3ZCLE1BQU1DLHFCQUFxQkQ7QUFDM0IsTUFBTUUsOEJBQThCRjtBQUNwQyxNQUFNRyxxQ0FBcUNIO0FBQzNDLFNBQVNJLFdBQVdDLEdBQUc7SUFDbkIsT0FBTyxPQUFPQSxRQUFRO0FBQzFCO0FBQ0EsU0FBU0Msb0JBQW9CQyxLQUFLO0lBQzlCLE9BQU9BLE1BQU1DLEtBQUssQ0FBQ0MsS0FBSyxDQUFDLE1BQU1DLEtBQUssQ0FBQyxHQUFHQyxJQUFJLENBQUM7QUFDakQ7QUFDQTs7O0NBR0MsR0FDRCxNQUFNcEI7SUFDRnFCLFlBQVlDLE9BQU8sRUFBRUMsV0FBVyxFQUFFQyxVQUFVLENBQUMsQ0FBQyxDQUFFO1FBQzVDLElBQUlDLElBQUlDO1FBQ1JGLFVBQVU1QixPQUFPK0IsTUFBTSxDQUFDLENBQUMsR0FBR0g7UUFDNUIsSUFBSSxDQUFDZCxtQkFBbUIsR0FBRyxDQUFDZSxLQUFLRCxRQUFRSSxZQUFZLE1BQU0sUUFBUUgsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRTtRQUMxRixPQUFPRCxRQUFRSSxZQUFZO1FBQzNCLElBQUksQ0FBQ2pC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c291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNobWl0dC1ndXB0YS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jbGllbnQuanM/ODI2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DbGllbnQgPSB2b2lkIDA7XG5jb25zdCBjYWxsXzEgPSByZXF1aXJlKFwiLi9jYWxsXCIpO1xuY29uc3QgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vY2hhbm5lbFwiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBjbGllbnRfaW50ZXJjZXB0b3JzXzEgPSByZXF1aXJlKFwiLi9jbGllbnQtaW50ZXJjZXB0b3JzXCIpO1xuY29uc3QgQ0hBTk5FTF9TWU1CT0wgPSBTeW1ib2woKTtcbmNvbnN0IElOVEVSQ0VQVE9SX1NZTUJPTCA9IFN5bWJvbCgpO1xuY29uc3QgSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MID0gU3ltYm9sKCk7XG5jb25zdCBDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MID0gU3ltYm9sKCk7XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gZ2V0RXJyb3JTdGFja1N0cmluZyhlcnJvcikge1xuICAgIHJldHVybiBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuc2xpY2UoMSkuam9pbignXFxuJyk7XG59XG4vKipcbiAqIEEgZ2VuZXJpYyBnUlBDIGNsaWVudC4gUHJpbWFyaWx5IHVzZWZ1bCBhcyBhIGJhc2UgY2xhc3MgZm9yIGFsbCBnZW5lcmF0ZWRcbiAqIGNsaWVudHMuXG4gKi9cbmNsYXNzIENsaWVudCB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgY3JlZGVudGlhbHMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXSA9IChfYSA9IG9wdGlvbnMuaW50ZXJjZXB0b3JzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuaW50ZXJjZXB0b3JzO1xuICAgICAgICB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0gPSAoX2IgPSBvcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycztcbiAgICAgICAgaWYgKHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXS5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIGludGVyY2VwdG9ycyBhbmQgaW50ZXJjZXB0b3JfcHJvdmlkZXJzIHdlcmUgcGFzc2VkIGFzIG9wdGlvbnMgJyArXG4gICAgICAgICAgICAgICAgJ3RvIHRoZSBjbGllbnQgY29uc3RydWN0b3IuIE9ubHkgb25lIG9mIHRoZXNlIGlzIGFsbG93ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXSA9XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXI7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmNhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXI7XG4gICAgICAgIGlmIChvcHRpb25zLmNoYW5uZWxPdmVycmlkZSkge1xuICAgICAgICAgICAgdGhpc1tDSEFOTkVMX1NZTUJPTF0gPSBvcHRpb25zLmNoYW5uZWxPdmVycmlkZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmNoYW5uZWxGYWN0b3J5T3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxGYWN0b3J5T3ZlcnJpZGUgPSBvcHRpb25zLmNoYW5uZWxGYWN0b3J5T3ZlcnJpZGU7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5jaGFubmVsRmFjdG9yeU92ZXJyaWRlO1xuICAgICAgICAgICAgdGhpc1tDSEFOTkVMX1NZTUJPTF0gPSBjaGFubmVsRmFjdG9yeU92ZXJyaWRlKGFkZHJlc3MsIGNyZWRlbnRpYWxzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbQ0hBTk5FTF9TWU1CT0xdID0gbmV3IGNoYW5uZWxfMS5DaGFubmVsSW1wbGVtZW50YXRpb24oYWRkcmVzcywgY3JlZGVudGlhbHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzW0NIQU5ORUxfU1lNQk9MXS5jbG9zZSgpO1xuICAgIH1cbiAgICBnZXRDaGFubmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tDSEFOTkVMX1NZTUJPTF07XG4gICAgfVxuICAgIHdhaXRGb3JSZWFkeShkZWFkbGluZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgY2hlY2tTdGF0ZSA9IChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb25uZWN0IGJlZm9yZSB0aGUgZGVhZGxpbmUnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5ld1N0YXRlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRoaXNbQ0hBTk5FTF9TWU1CT0xdLmdldENvbm5lY3Rpdml0eVN0YXRlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ1RoZSBjaGFubmVsIGhhcyBiZWVuIGNsb3NlZCcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbQ0hBTk5FTF9TWU1CT0xdLndhdGNoQ29ubmVjdGl2aXR5U3RhdGUobmV3U3RhdGUsIGRlYWRsaW5lLCBjaGVja1N0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdUaGUgY2hhbm5lbCBoYXMgYmVlbiBjbG9zZWQnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzZXRJbW1lZGlhdGUoY2hlY2tTdGF0ZSk7XG4gICAgfVxuICAgIGNoZWNrT3B0aW9uYWxVbmFyeVJlc3BvbnNlQXJndW1lbnRzKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oYXJnMSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLCBvcHRpb25zOiB7fSwgY2FsbGJhY2s6IGFyZzEgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGFyZzIpKSB7XG4gICAgICAgICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRhZGF0YTogYXJnMSwgb3B0aW9uczoge30sIGNhbGxiYWNrOiBhcmcyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSwgb3B0aW9uczogYXJnMSwgY2FsbGJhY2s6IGFyZzIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghKGFyZzEgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLk1ldGFkYXRhICYmXG4gICAgICAgICAgICAgICAgYXJnMiBpbnN0YW5jZW9mIE9iamVjdCAmJlxuICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24oYXJnMykpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgYXJndW1lbnRzIHBhc3NlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgbWV0YWRhdGE6IGFyZzEsIG9wdGlvbnM6IGFyZzIsIGNhbGxiYWNrOiBhcmczIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWFrZVVuYXJ5UmVxdWVzdChtZXRob2QsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIGFyZ3VtZW50LCBtZXRhZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgY2hlY2tlZEFyZ3VtZW50cyA9IHRoaXMuY2hlY2tPcHRpb25hbFVuYXJ5UmVzcG9uc2VBcmd1bWVudHMobWV0YWRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgY29uc3QgbWV0aG9kRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIHBhdGg6IG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW06IGZhbHNlLFxuICAgICAgICAgICAgcmVzcG9uc2VTdHJlYW06IGZhbHNlLFxuICAgICAgICAgICAgcmVxdWVzdFNlcmlhbGl6ZTogc2VyaWFsaXplLFxuICAgICAgICAgICAgcmVzcG9uc2VEZXNlcmlhbGl6ZTogZGVzZXJpYWxpemUsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjYWxsUHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIGFyZ3VtZW50OiBhcmd1bWVudCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjaGVja2VkQXJndW1lbnRzLm1ldGFkYXRhLFxuICAgICAgICAgICAgY2FsbDogbmV3IGNhbGxfMS5DbGllbnRVbmFyeUNhbGxJbXBsKCksXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzW0NIQU5ORUxfU1lNQk9MXSxcbiAgICAgICAgICAgIG1ldGhvZERlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXG4gICAgICAgICAgICBjYWxsT3B0aW9uczogY2hlY2tlZEFyZ3VtZW50cy5vcHRpb25zLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNoZWNrZWRBcmd1bWVudHMuY2FsbGJhY2ssXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKSB7XG4gICAgICAgICAgICBjYWxsUHJvcGVydGllcyA9IHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0oY2FsbFByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBjYWxsUHJvcGVydGllcy5jYWxsO1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvckFyZ3MgPSB7XG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvcnM6IHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXSxcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzOiB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JzOiAoX2EgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzOiAoX2IgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYWxsID0gY2xpZW50X2ludGVyY2VwdG9yc18xLmdldEludGVyY2VwdGluZ0NhbGwoaW50ZXJjZXB0b3JBcmdzLCBjYWxsUHJvcGVydGllcy5tZXRob2REZWZpbml0aW9uLCBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucywgY2FsbFByb3BlcnRpZXMuY2hhbm5lbCk7XG4gICAgICAgIC8qIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB0aGUgZW1pdHRlciBpcyB1c2VkLiBVbmZvcnR1bmF0ZWx5IHdlIGNhbid0XG4gICAgICAgICAqIGVuZm9yY2UgdGhpcyB3aXRoIHRoZSB0eXBlIHN5c3RlbS4gV2UgbmVlZCB0byBjb25zdHJ1Y3QgdGhpcyBlbWl0dGVyXG4gICAgICAgICAqIGJlZm9yZSBjYWxsaW5nIHRoZSBDYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyLCBhbmQgd2UgbmVlZCB0byBjcmVhdGUgdGhlXG4gICAgICAgICAqIGNhbGwgYWZ0ZXIgdGhhdC4gKi9cbiAgICAgICAgZW1pdHRlci5jYWxsID0gY2FsbDtcbiAgICAgICAgaWYgKGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICBjYWxsLnNldENyZWRlbnRpYWxzKGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmNyZWRlbnRpYWxzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2VNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgbGV0IHJlY2VpdmVkU3RhdHVzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNhbGxlclN0YWNrRXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgY2FsbC5zdGFydChjYWxsUHJvcGVydGllcy5tZXRhZGF0YSwge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IChtZXRhZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnbWV0YWRhdGEnLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCwgJ1RvbyBtYW55IHJlc3BvbnNlcyByZWNlaXZlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNwb25zZU1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWNlaXZlZFN0YXR1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2soY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAnTm8gbWVzc2FnZSByZWNlaXZlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHN0YXR1cy5tZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2FsbGVyU3RhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzLmNhbGxiYWNrKG51bGwsIHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlclN0YWNrID0gZ2V0RXJyb3JTdGFja1N0cmluZyhjYWxsZXJTdGFja0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2soY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMoc3RhdHVzLCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY2FsbC5zZW5kTWVzc2FnZShhcmd1bWVudCk7XG4gICAgICAgIGNhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgIHJldHVybiBlbWl0dGVyO1xuICAgIH1cbiAgICBtYWtlQ2xpZW50U3RyZWFtUmVxdWVzdChtZXRob2QsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIG1ldGFkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjaGVja2VkQXJndW1lbnRzID0gdGhpcy5jaGVja09wdGlvbmFsVW5hcnlSZXNwb25zZUFyZ3VtZW50cyhtZXRhZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICBjb25zdCBtZXRob2REZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgcGF0aDogbWV0aG9kLFxuICAgICAgICAgICAgcmVxdWVzdFN0cmVhbTogdHJ1ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtOiBmYWxzZSxcbiAgICAgICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IHNlcmlhbGl6ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY2FsbFByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBtZXRhZGF0YTogY2hlY2tlZEFyZ3VtZW50cy5tZXRhZGF0YSxcbiAgICAgICAgICAgIGNhbGw6IG5ldyBjYWxsXzEuQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsKHNlcmlhbGl6ZSksXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzW0NIQU5ORUxfU1lNQk9MXSxcbiAgICAgICAgICAgIG1ldGhvZERlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXG4gICAgICAgICAgICBjYWxsT3B0aW9uczogY2hlY2tlZEFyZ3VtZW50cy5vcHRpb25zLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNoZWNrZWRBcmd1bWVudHMuY2FsbGJhY2ssXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKSB7XG4gICAgICAgICAgICBjYWxsUHJvcGVydGllcyA9IHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0oY2FsbFByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBjYWxsUHJvcGVydGllcy5jYWxsO1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvckFyZ3MgPSB7XG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvcnM6IHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXSxcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzOiB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JzOiAoX2EgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzOiAoX2IgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYWxsID0gY2xpZW50X2ludGVyY2VwdG9yc18xLmdldEludGVyY2VwdGluZ0NhbGwoaW50ZXJjZXB0b3JBcmdzLCBjYWxsUHJvcGVydGllcy5tZXRob2REZWZpbml0aW9uLCBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucywgY2FsbFByb3BlcnRpZXMuY2hhbm5lbCk7XG4gICAgICAgIC8qIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB0aGUgZW1pdHRlciBpcyB1c2VkLiBVbmZvcnR1bmF0ZWx5IHdlIGNhbid0XG4gICAgICAgICAqIGVuZm9yY2UgdGhpcyB3aXRoIHRoZSB0eXBlIHN5c3RlbS4gV2UgbmVlZCB0byBjb25zdHJ1Y3QgdGhpcyBlbWl0dGVyXG4gICAgICAgICAqIGJlZm9yZSBjYWxsaW5nIHRoZSBDYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyLCBhbmQgd2UgbmVlZCB0byBjcmVhdGUgdGhlXG4gICAgICAgICAqIGNhbGwgYWZ0ZXIgdGhhdC4gKi9cbiAgICAgICAgZW1pdHRlci5jYWxsID0gY2FsbDtcbiAgICAgICAgaWYgKGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICBjYWxsLnNldENyZWRlbnRpYWxzKGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmNyZWRlbnRpYWxzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2VNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgbGV0IHJlY2VpdmVkU3RhdHVzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNhbGxlclN0YWNrRXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgY2FsbC5zdGFydChjYWxsUHJvcGVydGllcy5tZXRhZGF0YSwge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IChtZXRhZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnbWV0YWRhdGEnLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCwgJ1RvbyBtYW55IHJlc3BvbnNlcyByZWNlaXZlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNwb25zZU1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWNlaXZlZFN0YXR1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2soY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAnTm8gbWVzc2FnZSByZWNlaXZlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHN0YXR1cy5tZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2FsbGVyU3RhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzLmNhbGxiYWNrKG51bGwsIHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlclN0YWNrID0gZ2V0RXJyb3JTdGFja1N0cmluZyhjYWxsZXJTdGFja0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2soY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMoc3RhdHVzLCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXI7XG4gICAgfVxuICAgIGNoZWNrTWV0YWRhdGFBbmRPcHRpb25zKGFyZzEsIGFyZzIpIHtcbiAgICAgICAgbGV0IG1ldGFkYXRhO1xuICAgICAgICBsZXQgb3B0aW9ucztcbiAgICAgICAgaWYgKGFyZzEgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLk1ldGFkYXRhKSB7XG4gICAgICAgICAgICBtZXRhZGF0YSA9IGFyZzE7XG4gICAgICAgICAgICBpZiAoYXJnMikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFyZzEpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ldGFkYXRhID0gbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtZXRhZGF0YSwgb3B0aW9ucyB9O1xuICAgIH1cbiAgICBtYWtlU2VydmVyU3RyZWFtUmVxdWVzdChtZXRob2QsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIGFyZ3VtZW50LCBtZXRhZGF0YSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjaGVja2VkQXJndW1lbnRzID0gdGhpcy5jaGVja01ldGFkYXRhQW5kT3B0aW9ucyhtZXRhZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG1ldGhvZERlZmluaXRpb24gPSB7XG4gICAgICAgICAgICBwYXRoOiBtZXRob2QsXG4gICAgICAgICAgICByZXF1ZXN0U3RyZWFtOiBmYWxzZSxcbiAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtOiB0cnVlLFxuICAgICAgICAgICAgcmVxdWVzdFNlcmlhbGl6ZTogc2VyaWFsaXplLFxuICAgICAgICAgICAgcmVzcG9uc2VEZXNlcmlhbGl6ZTogZGVzZXJpYWxpemUsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjYWxsUHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIGFyZ3VtZW50OiBhcmd1bWVudCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjaGVja2VkQXJndW1lbnRzLm1ldGFkYXRhLFxuICAgICAgICAgICAgY2FsbDogbmV3IGNhbGxfMS5DbGllbnRSZWFkYWJsZVN0cmVhbUltcGwoZGVzZXJpYWxpemUpLFxuICAgICAgICAgICAgY2hhbm5lbDogdGhpc1tDSEFOTkVMX1NZTUJPTF0sXG4gICAgICAgICAgICBtZXRob2REZWZpbml0aW9uOiBtZXRob2REZWZpbml0aW9uLFxuICAgICAgICAgICAgY2FsbE9wdGlvbnM6IGNoZWNrZWRBcmd1bWVudHMub3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0pIHtcbiAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzID0gdGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXShjYWxsUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY2FsbFByb3BlcnRpZXMuY2FsbDtcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0b3JBcmdzID0ge1xuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JzOiB0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0sXG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvclByb3ZpZGVyczogdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yczogKF9hID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSxcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvclByb3ZpZGVyczogKF9iID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JfcHJvdmlkZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2FsbCA9IGNsaWVudF9pbnRlcmNlcHRvcnNfMS5nZXRJbnRlcmNlcHRpbmdDYWxsKGludGVyY2VwdG9yQXJncywgY2FsbFByb3BlcnRpZXMubWV0aG9kRGVmaW5pdGlvbiwgY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMsIGNhbGxQcm9wZXJ0aWVzLmNoYW5uZWwpO1xuICAgICAgICAvKiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgdGhlIGVtaXR0ZXIgaXMgdXNlZC4gVW5mb3J0dW5hdGVseSB3ZSBjYW4ndFxuICAgICAgICAgKiBlbmZvcmNlIHRoaXMgd2l0aCB0aGUgdHlwZSBzeXN0ZW0uIFdlIG5lZWQgdG8gY29uc3RydWN0IHRoaXMgZW1pdHRlclxuICAgICAgICAgKiBiZWZvcmUgY2FsbGluZyB0aGUgQ2FsbEludm9jYXRpb25UcmFuc2Zvcm1lciwgYW5kIHdlIG5lZWQgdG8gY3JlYXRlIHRoZVxuICAgICAgICAgKiBjYWxsIGFmdGVyIHRoYXQuICovXG4gICAgICAgIHN0cmVhbS5jYWxsID0gY2FsbDtcbiAgICAgICAgaWYgKGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICBjYWxsLnNldENyZWRlbnRpYWxzKGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmNyZWRlbnRpYWxzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVjZWl2ZWRTdGF0dXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2FsbGVyU3RhY2tFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBjYWxsLnN0YXJ0KGNhbGxQcm9wZXJ0aWVzLm1ldGFkYXRhLCB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVkU3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZXJTdGFjayA9IGdldEVycm9yU3RhY2tTdHJpbmcoY2FsbGVyU3RhY2tFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGNhbGxfMS5jYWxsRXJyb3JGcm9tU3RhdHVzKHN0YXR1cywgY2FsbGVyU3RhY2spKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY2FsbC5zZW5kTWVzc2FnZShhcmd1bWVudCk7XG4gICAgICAgIGNhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxuICAgIG1ha2VCaWRpU3RyZWFtUmVxdWVzdChtZXRob2QsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIG1ldGFkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRBcmd1bWVudHMgPSB0aGlzLmNoZWNrTWV0YWRhdGFBbmRPcHRpb25zKG1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbWV0aG9kRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIHBhdGg6IG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW06IHRydWUsXG4gICAgICAgICAgICByZXNwb25zZVN0cmVhbTogdHJ1ZSxcbiAgICAgICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IHNlcmlhbGl6ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY2FsbFByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBtZXRhZGF0YTogY2hlY2tlZEFyZ3VtZW50cy5tZXRhZGF0YSxcbiAgICAgICAgICAgIGNhbGw6IG5ldyBjYWxsXzEuQ2xpZW50RHVwbGV4U3RyZWFtSW1wbChzZXJpYWxpemUsIGRlc2VyaWFsaXplKSxcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXNbQ0hBTk5FTF9TWU1CT0xdLFxuICAgICAgICAgICAgbWV0aG9kRGVmaW5pdGlvbjogbWV0aG9kRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGNhbGxPcHRpb25zOiBjaGVja2VkQXJndW1lbnRzLm9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKSB7XG4gICAgICAgICAgICBjYWxsUHJvcGVydGllcyA9IHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0oY2FsbFByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNhbGxQcm9wZXJ0aWVzLmNhbGw7XG4gICAgICAgIGNvbnN0IGludGVyY2VwdG9yQXJncyA9IHtcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yczogdGhpc1tJTlRFUkNFUFRPUl9TWU1CT0xdLFxuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JQcm92aWRlcnM6IHRoaXNbSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MXSxcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvcnM6IChfYSA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JQcm92aWRlcnM6IChfYiA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbGwgPSBjbGllbnRfaW50ZXJjZXB0b3JzXzEuZ2V0SW50ZXJjZXB0aW5nQ2FsbChpbnRlcmNlcHRvckFyZ3MsIGNhbGxQcm9wZXJ0aWVzLm1ldGhvZERlZmluaXRpb24sIGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLCBjYWxsUHJvcGVydGllcy5jaGFubmVsKTtcbiAgICAgICAgLyogVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBlbWl0dGVyIGlzIHVzZWQuIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3RcbiAgICAgICAgICogZW5mb3JjZSB0aGlzIHdpdGggdGhlIHR5cGUgc3lzdGVtLiBXZSBuZWVkIHRvIGNvbnN0cnVjdCB0aGlzIGVtaXR0ZXJcbiAgICAgICAgICogYmVmb3JlIGNhbGxpbmcgdGhlIENhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXIsIGFuZCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGVcbiAgICAgICAgICogY2FsbCBhZnRlciB0aGF0LiAqL1xuICAgICAgICBzdHJlYW0uY2FsbCA9IGNhbGw7XG4gICAgICAgIGlmIChjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgY2FsbC5zZXRDcmVkZW50aWFscyhjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5jcmVkZW50aWFscyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlY2VpdmVkU3RhdHVzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNhbGxlclN0YWNrRXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgY2FsbC5zdGFydChjYWxsUHJvcGVydGllcy5tZXRhZGF0YSwge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnbWV0YWRhdGEnLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVkU3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZXJTdGFjayA9IGdldEVycm9yU3RhY2tTdHJpbmcoY2FsbGVyU3RhY2tFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGNhbGxfMS5jYWxsRXJyb3JGcm9tU3RhdHVzKHN0YXR1cywgY2FsbGVyU3RhY2spKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG59XG5leHBvcnRzLkNsaWVudCA9IENsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDbGllbnQiLCJjYWxsXzEiLCJyZXF1aXJlIiwiY2hhbm5lbF8xIiwiY29ubmVjdGl2aXR5X3N0YXRlXzEiLCJjb25zdGFudHNfMSIsIm1ldGFkYXRhXzEiLCJjbGllbnRfaW50ZXJjZXB0b3JzXzEiLCJDSEFOTkVMX1NZTUJPTCIsIlN5bWJvbCIsIklOVEVSQ0VQVE9SX1NZTUJPTCIsIklOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTCIsIkNBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0wiLCJpc0Z1bmN0aW9uIiwiYXJnIiwiZ2V0RXJyb3JTdGFja1N0cmluZyIsImVycm9yIiwic3RhY2siLCJzcGxpdCIsInNsaWNlIiwiam9pbiIsImNvbnN0cnVjdG9yIiwiYWRkcmVzcyIsImNyZWRlbnRpYWxzIiwib3B0aW9ucyIsIl9hIiwiX2IiLCJhc3NpZ24iLCJpbnRlcmNlcHRvcnMiLCJpbnRlcmNlcHRvcl9wcm92aWRlcnMiLCJsZW5ndGgiLCJFcnJvciIsImNhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXIiLCJjaGFubmVsT3ZlcnJpZGUiLCJjaGFubmVsRmFjdG9yeU92ZXJyaWRlIiwiQ2hhbm5lbEltcGxlbWVudGF0aW9uIiwiY2xvc2UiLCJnZXRDaGFubmVsIiwid2FpdEZvclJlYWR5IiwiZGVhZGxpbmUiLCJjYWxsYmFjayIsImNoZWNrU3RhdGUiLCJlcnIiLCJuZXdTdGF0ZSIsImdldENvbm5lY3Rpdml0eVN0YXRlIiwiZSIsIkNvbm5lY3Rpdml0eVN0YXRlIiwiUkVBRFkiLCJ3YXRjaENvbm5lY3Rpdml0eVN0YXRlIiwic2V0SW1tZWRpYXRlIiwiY2hlY2tPcHRpb25hbFVuYXJ5UmVzcG9uc2VBcmd1bWVudHMiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJtZXRhZGF0YSIsIk1ldGFkYXRhIiwibWFrZVVuYXJ5UmVxdWVzdCIsIm1ldGhvZCIsInNlcmlhbGl6ZSIsImRlc2VyaWFsaXplIiwiYXJndW1lbnQiLCJjaGVja2VkQXJndW1lbnRzIiwibWV0aG9kRGVmaW5pdGlvbiIsInBhdGgiLCJyZXF1ZXN0U3RyZWFtIiwicmVzcG9uc2VTdHJlYW0iLCJyZXF1ZXN0U2VyaWFsaXplIiwicmVzcG9uc2VEZXNlcmlhbGl6ZSIsImNhbGxQcm9wZXJ0aWVzIiwiY2FsbCIsIkNsaWVudFVuYXJ5Q2FsbEltcGwiLCJjaGFubmVsIiwiY2FsbE9wdGlvbnMiLCJlbWl0dGVyIiwiaW50ZXJjZXB0b3JBcmdzIiwiY2xpZW50SW50ZXJjZXB0b3JzIiwiY2xpZW50SW50ZXJjZXB0b3JQcm92aWRlcnMiLCJjYWxsSW50ZXJjZXB0b3JzIiwiY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzIiwiZ2V0SW50ZXJjZXB0aW5nQ2FsbCIsInNldENyZWRlbnRpYWxzIiwicmVzcG9uc2VNZXNzYWdlIiwicmVjZWl2ZWRTdGF0dXMiLCJjYWxsZXJTdGFja0Vycm9yIiwic3RhcnQiLCJvblJlY2VpdmVNZXRhZGF0YSIsImVtaXQiLCJvblJlY2VpdmVNZXNzYWdlIiwibWVzc2FnZSIsImNhbmNlbFdpdGhTdGF0dXMiLCJTdGF0dXMiLCJJTlRFUk5BTCIsIm9uUmVjZWl2ZVN0YXR1cyIsInN0YXR1cyIsImNvZGUiLCJPSyIsImNhbGxlclN0YWNrIiwiY2FsbEVycm9yRnJvbVN0YXR1cyIsImRldGFpbHMiLCJzZW5kTWVzc2FnZSIsImhhbGZDbG9zZSIsIm1ha2VDbGllbnRTdHJlYW1SZXF1ZXN0IiwiQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsIiwiY2hlY2tNZXRhZGF0YUFuZE9wdGlvbnMiLCJtYWtlU2VydmVyU3RyZWFtUmVxdWVzdCIsIkNsaWVudFJlYWRhYmxlU3RyZWFtSW1wbCIsInN0cmVhbSIsInB1c2giLCJtYWtlQmlkaVN0cmVhbVJlcXVlc3QiLCJDbGllbnREdXBsZXhTdHJlYW1JbXBsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js":
/*!************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CompressionAlgorithms = void 0;\nvar CompressionAlgorithms;\n(function(CompressionAlgorithms) {\n    CompressionAlgorithms[CompressionAlgorithms[\"identity\"] = 0] = \"identity\";\n    CompressionAlgorithms[CompressionAlgorithms[\"deflate\"] = 1] = \"deflate\";\n    CompressionAlgorithms[CompressionAlgorithms[\"gzip\"] = 2] = \"gzip\";\n})(CompressionAlgorithms = exports.CompressionAlgorithms || (exports.CompressionAlgorithms = {}));\n; //# sourceMappingURL=compression-algorithms.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tYWxnb3JpdGhtcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNkJBQTZCLEdBQUcsS0FBSztBQUNyQyxJQUFJRTtBQUNILFVBQVVBLHFCQUFxQjtJQUM1QkEscUJBQXFCLENBQUNBLHFCQUFxQixDQUFDLFdBQVcsR0FBRyxFQUFFLEdBQUc7SUFDL0RBLHFCQUFxQixDQUFDQSxxQkFBcUIsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQzlEQSxxQkFBcUIsQ0FBQ0EscUJBQXFCLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztBQUMvRCxHQUFHQSx3QkFBd0JGLFFBQVFFLHFCQUFxQixJQUFLRixDQUFBQSw2QkFBNkIsR0FBRyxDQUFDO0VBRTlGLGtEQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL2FzaG1pdHQtZ3VwdGEvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tYWxnb3JpdGhtcy5qcz8yOTI5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIxIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbXByZXNzaW9uQWxnb3JpdGhtcyA9IHZvaWQgMDtcbnZhciBDb21wcmVzc2lvbkFsZ29yaXRobXM7XG4oZnVuY3Rpb24gKENvbXByZXNzaW9uQWxnb3JpdGhtcykge1xuICAgIENvbXByZXNzaW9uQWxnb3JpdGhtc1tDb21wcmVzc2lvbkFsZ29yaXRobXNbXCJpZGVudGl0eVwiXSA9IDBdID0gXCJpZGVudGl0eVwiO1xuICAgIENvbXByZXNzaW9uQWxnb3JpdGhtc1tDb21wcmVzc2lvbkFsZ29yaXRobXNbXCJkZWZsYXRlXCJdID0gMV0gPSBcImRlZmxhdGVcIjtcbiAgICBDb21wcmVzc2lvbkFsZ29yaXRobXNbQ29tcHJlc3Npb25BbGdvcml0aG1zW1wiZ3ppcFwiXSA9IDJdID0gXCJnemlwXCI7XG59KShDb21wcmVzc2lvbkFsZ29yaXRobXMgPSBleHBvcnRzLkNvbXByZXNzaW9uQWxnb3JpdGhtcyB8fCAoZXhwb3J0cy5Db21wcmVzc2lvbkFsZ29yaXRobXMgPSB7fSkpO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcHJlc3Npb24tYWxnb3JpdGhtcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDb21wcmVzc2lvbkFsZ29yaXRobXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-filter.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CompressionFilterFactory = exports.CompressionFilter = void 0;\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst isCompressionAlgorithmKey = (key)=>{\n    return typeof key === \"number\" && typeof compression_algorithms_1.CompressionAlgorithms[key] === \"string\";\n};\nclass CompressionHandler {\n    /**\n     * @param message Raw uncompressed message bytes\n     * @param compress Indicates whether the message should be compressed\n     * @return Framed message, compressed if applicable\n     */ async writeMessage(message, compress) {\n        let messageBuffer = message;\n        if (compress) {\n            messageBuffer = await this.compressMessage(messageBuffer);\n        }\n        const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n        output.writeUInt8(compress ? 1 : 0, 0);\n        output.writeUInt32BE(messageBuffer.length, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    /**\n     * @param data Framed message, possibly compressed\n     * @return Uncompressed message\n     */ async readMessage(data) {\n        const compressed = data.readUInt8(0) === 1;\n        let messageBuffer = data.slice(5);\n        if (compressed) {\n            messageBuffer = await this.decompressMessage(messageBuffer);\n        }\n        return messageBuffer;\n    }\n}\nclass IdentityHandler extends CompressionHandler {\n    async compressMessage(message) {\n        return message;\n    }\n    async writeMessage(message, compress) {\n        const output = Buffer.allocUnsafe(message.length + 5);\n        /* With \"identity\" compression, messages should always be marked as\n         * uncompressed */ output.writeUInt8(0, 0);\n        output.writeUInt32BE(message.length, 1);\n        message.copy(output, 5);\n        return output;\n    }\n    decompressMessage(message) {\n        return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n    }\n}\nclass DeflateHandler extends CompressionHandler {\n    compressMessage(message) {\n        return new Promise((resolve, reject)=>{\n            zlib.deflate(message, (err, output)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject)=>{\n            zlib.inflate(message, (err, output)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n}\nclass GzipHandler extends CompressionHandler {\n    compressMessage(message) {\n        return new Promise((resolve, reject)=>{\n            zlib.gzip(message, (err, output)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject)=>{\n            zlib.unzip(message, (err, output)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n}\nclass UnknownHandler extends CompressionHandler {\n    constructor(compressionName){\n        super();\n        this.compressionName = compressionName;\n    }\n    compressMessage(message) {\n        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));\n    }\n    decompressMessage(message) {\n        // This should be unreachable\n        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\n    }\n}\nfunction getCompressionHandler(compressionName) {\n    switch(compressionName){\n        case \"identity\":\n            return new IdentityHandler();\n        case \"deflate\":\n            return new DeflateHandler();\n        case \"gzip\":\n            return new GzipHandler();\n        default:\n            return new UnknownHandler(compressionName);\n    }\n}\nclass CompressionFilter extends filter_1.BaseFilter {\n    constructor(channelOptions, sharedFilterConfig){\n        var _a;\n        super();\n        this.sharedFilterConfig = sharedFilterConfig;\n        this.sendCompression = new IdentityHandler();\n        this.receiveCompression = new IdentityHandler();\n        this.currentCompressionAlgorithm = \"identity\";\n        const compressionAlgorithmKey = channelOptions[\"grpc.default_compression_algorithm\"];\n        if (compressionAlgorithmKey !== undefined) {\n            if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {\n                const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];\n                const serverSupportedEncodings = (_a = sharedFilterConfig.serverSupportedEncodingHeader) === null || _a === void 0 ? void 0 : _a.split(\",\");\n                /**\n                 * There are two possible situations here:\n                 * 1) We don't have any info yet from the server about what compression it supports\n                 *    In that case we should just use what the client tells us to use\n                 * 2) We've previously received a response from the server including a grpc-accept-encoding header\n                 *    In that case we only want to use the encoding chosen by the client if the server supports it\n                 */ if (!serverSupportedEncodings || serverSupportedEncodings.includes(clientSelectedEncoding)) {\n                    this.currentCompressionAlgorithm = clientSelectedEncoding;\n                    this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm);\n                }\n            } else {\n                logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);\n            }\n        }\n    }\n    async sendMetadata(metadata) {\n        const headers = await metadata;\n        headers.set(\"grpc-accept-encoding\", \"identity,deflate,gzip\");\n        headers.set(\"accept-encoding\", \"identity\");\n        // No need to send the header if it's \"identity\" -  behavior is identical; save the bandwidth\n        if (this.currentCompressionAlgorithm === \"identity\") {\n            headers.remove(\"grpc-encoding\");\n        } else {\n            headers.set(\"grpc-encoding\", this.currentCompressionAlgorithm);\n        }\n        return headers;\n    }\n    receiveMetadata(metadata) {\n        const receiveEncoding = metadata.get(\"grpc-encoding\");\n        if (receiveEncoding.length > 0) {\n            const encoding = receiveEncoding[0];\n            if (typeof encoding === \"string\") {\n                this.receiveCompression = getCompressionHandler(encoding);\n            }\n        }\n        metadata.remove(\"grpc-encoding\");\n        /* Check to see if the compression we're using to send messages is supported by the server\n         * If not, reset the sendCompression filter and have it use the default IdentityHandler */ const serverSupportedEncodingsHeader = metadata.get(\"grpc-accept-encoding\")[0];\n        if (serverSupportedEncodingsHeader) {\n            this.sharedFilterConfig.serverSupportedEncodingHeader = serverSupportedEncodingsHeader;\n            const serverSupportedEncodings = serverSupportedEncodingsHeader.split(\",\");\n            if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {\n                this.sendCompression = new IdentityHandler();\n                this.currentCompressionAlgorithm = \"identity\";\n            }\n        }\n        metadata.remove(\"grpc-accept-encoding\");\n        return metadata;\n    }\n    async sendMessage(message) {\n        var _a;\n        /* This filter is special. The input message is the bare message bytes,\n         * and the output is a framed and possibly compressed message. For this\n         * reason, this filter should be at the bottom of the filter stack */ const resolvedMessage = await message;\n        let compress;\n        if (this.sendCompression instanceof IdentityHandler) {\n            compress = false;\n        } else {\n            compress = (((_a = resolvedMessage.flags) !== null && _a !== void 0 ? _a : 0) & 2 /* NoCompress */ ) === 0;\n        }\n        return {\n            message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),\n            flags: resolvedMessage.flags\n        };\n    }\n    async receiveMessage(message) {\n        /* This filter is also special. The input message is framed and possibly\n         * compressed, and the output message is deframed and uncompressed. So\n         * this is another reason that this filter should be at the bottom of the\n         * filter stack. */ return this.receiveCompression.readMessage(await message);\n    }\n}\nexports.CompressionFilter = CompressionFilter;\nclass CompressionFilterFactory {\n    constructor(channel, options){\n        this.channel = channel;\n        this.options = options;\n        this.sharedFilterConfig = {};\n    }\n    createFilter(callStream) {\n        return new CompressionFilter(this.options, this.sharedFilterConfig);\n    }\n}\nexports.CompressionFilterFactory = CompressionFilterFactory; //# sourceMappingURL=compression-filter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tZmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQ0FBZ0MsR0FBR0EseUJBQXlCLEdBQUcsS0FBSztBQUNwRSxNQUFNSSxPQUFPQyxtQkFBT0EsQ0FBQyxrQkFBTTtBQUMzQixNQUFNQywyQkFBMkJELG1CQUFPQSxDQUFDLHdHQUEwQjtBQUNuRSxNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRyxXQUFXSCxtQkFBT0EsQ0FBQyx3RUFBVTtBQUNuQyxNQUFNSSxVQUFVSixtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNSyw0QkFBNEIsQ0FBQ0M7SUFDL0IsT0FBTyxPQUFPQSxRQUFRLFlBQVksT0FBT0wseUJBQXlCTSxxQkFBcUIsQ0FBQ0QsSUFBSSxLQUFLO0FBQ3JHO0FBQ0EsTUFBTUU7SUFDRjs7OztLQUlDLEdBQ0QsTUFBTUMsYUFBYUMsT0FBTyxFQUFFQyxRQUFRLEVBQUU7UUFDbEMsSUFBSUMsZ0JBQWdCRjtRQUNwQixJQUFJQyxVQUFVO1lBQ1ZDLGdCQUFnQixNQUFNLElBQUksQ0FBQ0MsZUFBZSxDQUFDRDtRQUMvQztRQUNBLE1BQU1FLFNBQVNDLE9BQU9DLFdBQVcsQ0FBQ0osY0FBY0ssTUFBTSxHQUFHO1FBQ3pESCxPQUFPSSxVQUFVLENBQUNQLFdBQVcsSUFBSSxHQUFHO1FBQ3BDRyxPQUFPSyxhQUFhLENBQUNQLGNBQWNLLE1BQU0sRUFBRTtRQUMzQ0wsY0FBY1EsSUFBSSxDQUFDTixRQUFRO1FBQzNCLE9BQU9BO0lBQ1g7SUFDQTs7O0tBR0MsR0FDRCxNQUFNTyxZQUFZQyxJQUFJLEVBQUU7UUFDcEIsTUFBTUMsYUFBYUQsS0FBS0UsU0FBUyxDQUFDLE9BQU87UUFDekMsSUFBSVosZ0JBQWdC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UyxNQUFNLElBQUksQ0FBQ3FDLGVBQWUsQ0FBQ3RDLFlBQVksQ0FBQzhELGdCQUFnQjdELE9BQU8sRUFBRUM7WUFDMUU2RCxPQUFPRCxnQkFBZ0JDLEtBQUs7UUFDaEM7SUFDSjtJQUNBLE1BQU1DLGVBQWUvRCxPQUFPLEVBQUU7UUFDMUI7Ozt5QkFHaUIsR0FDakIsT0FBTyxJQUFJLENBQUNzQyxrQkFBa0IsQ0FBQzNCLFdBQVcsQ0FBQyxNQUFNWDtJQUNyRDtBQUNKO0FBQ0FmLHlCQUF5QixHQUFHRztBQUM1QixNQUFNRDtJQUNGMkMsWUFBWWtDLE9BQU8sRUFBRUMsT0FBTyxDQUFFO1FBQzFCLElBQUksQ0FBQ0QsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQzlCLGtCQUFrQixHQUFHLENBQUM7SUFDL0I7SUFDQStCLGFBQWFDLFVBQVUsRUFBRTtRQUNyQixPQUFPLElBQUkvRSxrQkFBa0IsSUFBSSxDQUFDNkUsT0FBTyxFQUFFLElBQUksQ0FBQzlCLGtCQUFrQjtJQUN0RTtBQUNKO0FBQ0FsRCxnQ0FBZ0MsR0FBR0UsMEJBQ25DLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL2FzaG1pdHQtZ3VwdGEvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tZmlsdGVyLmpzPzc1ZTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tcHJlc3Npb25GaWx0ZXJGYWN0b3J5ID0gZXhwb3J0cy5Db21wcmVzc2lvbkZpbHRlciA9IHZvaWQgMDtcbmNvbnN0IHpsaWIgPSByZXF1aXJlKFwiemxpYlwiKTtcbmNvbnN0IGNvbXByZXNzaW9uX2FsZ29yaXRobXNfMSA9IHJlcXVpcmUoXCIuL2NvbXByZXNzaW9uLWFsZ29yaXRobXNcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGZpbHRlcl8xID0gcmVxdWlyZShcIi4vZmlsdGVyXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBpc0NvbXByZXNzaW9uQWxnb3JpdGhtS2V5ID0gKGtleSkgPT4ge1xuICAgIHJldHVybiB0eXBlb2Yga2V5ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29tcHJlc3Npb25fYWxnb3JpdGhtc18xLkNvbXByZXNzaW9uQWxnb3JpdGhtc1trZXldID09PSAnc3RyaW5nJztcbn07XG5jbGFzcyBDb21wcmVzc2lvbkhhbmRsZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFJhdyB1bmNvbXByZXNzZWQgbWVzc2FnZSBieXRlc1xuICAgICAqIEBwYXJhbSBjb21wcmVzcyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbWVzc2FnZSBzaG91bGQgYmUgY29tcHJlc3NlZFxuICAgICAqIEByZXR1cm4gRnJhbWVkIG1lc3NhZ2UsIGNvbXByZXNzZWQgaWYgYXBwbGljYWJsZVxuICAgICAqL1xuICAgIGFzeW5jIHdyaXRlTWVzc2FnZShtZXNzYWdlLCBjb21wcmVzcykge1xuICAgICAgICBsZXQgbWVzc2FnZUJ1ZmZlciA9IG1lc3NhZ2U7XG4gICAgICAgIGlmIChjb21wcmVzcykge1xuICAgICAgICAgICAgbWVzc2FnZUJ1ZmZlciA9IGF3YWl0IHRoaXMuY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2VCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShtZXNzYWdlQnVmZmVyLmxlbmd0aCArIDUpO1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50OChjb21wcmVzcyA/IDEgOiAwLCAwKTtcbiAgICAgICAgb3V0cHV0LndyaXRlVUludDMyQkUobWVzc2FnZUJ1ZmZlci5sZW5ndGgsIDEpO1xuICAgICAgICBtZXNzYWdlQnVmZmVyLmNvcHkob3V0cHV0LCA1KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRhdGEgRnJhbWVkIG1lc3NhZ2UsIHBvc3NpYmx5IGNvbXByZXNzZWRcbiAgICAgKiBAcmV0dXJuIFVuY29tcHJlc3NlZCBtZXNzYWdlXG4gICAgICovXG4gICAgYXN5bmMgcmVhZE1lc3NhZ2UoZGF0YSkge1xuICAgICAgICBjb25zdCBjb21wcmVzc2VkID0gZGF0YS5yZWFkVUludDgoMCkgPT09IDE7XG4gICAgICAgIGxldCBtZXNzYWdlQnVmZmVyID0gZGF0YS5zbGljZSg1KTtcbiAgICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VCdWZmZXIgPSBhd2FpdCB0aGlzLmRlY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2VCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlQnVmZmVyO1xuICAgIH1cbn1cbmNsYXNzIElkZW50aXR5SGFuZGxlciBleHRlbmRzIENvbXByZXNzaW9uSGFuZGxlciB7XG4gICAgYXN5bmMgY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGFzeW5jIHdyaXRlTWVzc2FnZShtZXNzYWdlLCBjb21wcmVzcykge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobWVzc2FnZS5sZW5ndGggKyA1KTtcbiAgICAgICAgLyogV2l0aCBcImlkZW50aXR5XCIgY29tcHJlc3Npb24sIG1lc3NhZ2VzIHNob3VsZCBhbHdheXMgYmUgbWFya2VkIGFzXG4gICAgICAgICAqIHVuY29tcHJlc3NlZCAqL1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50OCgwLCAwKTtcbiAgICAgICAgb3V0cHV0LndyaXRlVUludDMyQkUobWVzc2FnZS5sZW5ndGgsIDEpO1xuICAgICAgICBtZXNzYWdlLmNvcHkob3V0cHV0LCA1KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgZGVjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdSZWNlaXZlZCBjb21wcmVzc2VkIG1lc3NhZ2UgYnV0IFwiZ3JwYy1lbmNvZGluZ1wiIGhlYWRlciB3YXMgaWRlbnRpdHknKSk7XG4gICAgfVxufVxuY2xhc3MgRGVmbGF0ZUhhbmRsZXIgZXh0ZW5kcyBDb21wcmVzc2lvbkhhbmRsZXIge1xuICAgIGNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB6bGliLmRlZmxhdGUobWVzc2FnZSwgKGVyciwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHpsaWIuaW5mbGF0ZShtZXNzYWdlLCAoZXJyLCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBHemlwSGFuZGxlciBleHRlbmRzIENvbXByZXNzaW9uSGFuZGxlciB7XG4gICAgY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHpsaWIuZ3ppcChtZXNzYWdlLCAoZXJyLCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgemxpYi51bnppcChtZXNzYWdlLCAoZXJyLCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBVbmtub3duSGFuZGxlciBleHRlbmRzIENvbXByZXNzaW9uSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoY29tcHJlc3Npb25OYW1lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb25OYW1lID0gY29tcHJlc3Npb25OYW1lO1xuICAgIH1cbiAgICBjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBSZWNlaXZlZCBtZXNzYWdlIGNvbXByZXNzZWQgd2l0aCB1bnN1cHBvcnRlZCBjb21wcmVzc2lvbiBtZXRob2QgJHt0aGlzLmNvbXByZXNzaW9uTmFtZX1gKSk7XG4gICAgfVxuICAgIGRlY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgdW5yZWFjaGFibGVcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgQ29tcHJlc3Npb24gbWV0aG9kIG5vdCBzdXBwb3J0ZWQ6ICR7dGhpcy5jb21wcmVzc2lvbk5hbWV9YCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENvbXByZXNzaW9uSGFuZGxlcihjb21wcmVzc2lvbk5hbWUpIHtcbiAgICBzd2l0Y2ggKGNvbXByZXNzaW9uTmFtZSkge1xuICAgICAgICBjYXNlICdpZGVudGl0eSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IElkZW50aXR5SGFuZGxlcigpO1xuICAgICAgICBjYXNlICdkZWZsYXRlJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVmbGF0ZUhhbmRsZXIoKTtcbiAgICAgICAgY2FzZSAnZ3ppcCc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEd6aXBIYW5kbGVyKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVua25vd25IYW5kbGVyKGNvbXByZXNzaW9uTmFtZSk7XG4gICAgfVxufVxuY2xhc3MgQ29tcHJlc3Npb25GaWx0ZXIgZXh0ZW5kcyBmaWx0ZXJfMS5CYXNlRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsT3B0aW9ucywgc2hhcmVkRmlsdGVyQ29uZmlnKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zaGFyZWRGaWx0ZXJDb25maWcgPSBzaGFyZWRGaWx0ZXJDb25maWc7XG4gICAgICAgIHRoaXMuc2VuZENvbXByZXNzaW9uID0gbmV3IElkZW50aXR5SGFuZGxlcigpO1xuICAgICAgICB0aGlzLnJlY2VpdmVDb21wcmVzc2lvbiA9IG5ldyBJZGVudGl0eUhhbmRsZXIoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0gPSAnaWRlbnRpdHknO1xuICAgICAgICBjb25zdCBjb21wcmVzc2lvbkFsZ29yaXRobUtleSA9IGNoYW5uZWxPcHRpb25zWydncnBjLmRlZmF1bHRfY29tcHJlc3Npb25fYWxnb3JpdGhtJ107XG4gICAgICAgIGlmIChjb21wcmVzc2lvbkFsZ29yaXRobUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2lvbkFsZ29yaXRobUtleShjb21wcmVzc2lvbkFsZ29yaXRobUtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRTZWxlY3RlZEVuY29kaW5nID0gY29tcHJlc3Npb25fYWxnb3JpdGhtc18xLkNvbXByZXNzaW9uQWxnb3JpdGhtc1tjb21wcmVzc2lvbkFsZ29yaXRobUtleV07XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzID0gKF9hID0gc2hhcmVkRmlsdGVyQ29uZmlnLnNlcnZlclN1cHBvcnRlZEVuY29kaW5nSGVhZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGVyZSBhcmUgdHdvIHBvc3NpYmxlIHNpdHVhdGlvbnMgaGVyZTpcbiAgICAgICAgICAgICAgICAgKiAxKSBXZSBkb24ndCBoYXZlIGFueSBpbmZvIHlldCBmcm9tIHRoZSBzZXJ2ZXIgYWJvdXQgd2hhdCBjb21wcmVzc2lvbiBpdCBzdXBwb3J0c1xuICAgICAgICAgICAgICAgICAqICAgIEluIHRoYXQgY2FzZSB3ZSBzaG91bGQganVzdCB1c2Ugd2hhdCB0aGUgY2xpZW50IHRlbGxzIHVzIHRvIHVzZVxuICAgICAgICAgICAgICAgICAqIDIpIFdlJ3ZlIHByZXZpb3VzbHkgcmVjZWl2ZWQgYSByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIgaW5jbHVkaW5nIGEgZ3JwYy1hY2NlcHQtZW5jb2RpbmcgaGVhZGVyXG4gICAgICAgICAgICAgICAgICogICAgSW4gdGhhdCBjYXNlIHdlIG9ubHkgd2FudCB0byB1c2UgdGhlIGVuY29kaW5nIGNob3NlbiBieSB0aGUgY2xpZW50IGlmIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgaXRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoIXNlcnZlclN1cHBvcnRlZEVuY29kaW5ncyB8fCBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3MuaW5jbHVkZXMoY2xpZW50U2VsZWN0ZWRFbmNvZGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0gPSBjbGllbnRTZWxlY3RlZEVuY29kaW5nO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRDb21wcmVzc2lvbiA9IGdldENvbXByZXNzaW9uSGFuZGxlcih0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2luZy5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCBgSW52YWxpZCB2YWx1ZSBwcm92aWRlZCBmb3IgZ3JwYy5kZWZhdWx0X2NvbXByZXNzaW9uX2FsZ29yaXRobSBvcHRpb246ICR7Y29tcHJlc3Npb25BbGdvcml0aG1LZXl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2VuZE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCBtZXRhZGF0YTtcbiAgICAgICAgaGVhZGVycy5zZXQoJ2dycGMtYWNjZXB0LWVuY29kaW5nJywgJ2lkZW50aXR5LGRlZmxhdGUsZ3ppcCcpO1xuICAgICAgICBoZWFkZXJzLnNldCgnYWNjZXB0LWVuY29kaW5nJywgJ2lkZW50aXR5Jyk7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gc2VuZCB0aGUgaGVhZGVyIGlmIGl0J3MgXCJpZGVudGl0eVwiIC0gIGJlaGF2aW9yIGlzIGlkZW50aWNhbDsgc2F2ZSB0aGUgYmFuZHdpZHRoXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAgICAgaGVhZGVycy5yZW1vdmUoJ2dycGMtZW5jb2RpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdncnBjLWVuY29kaW5nJywgdGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICByZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgcmVjZWl2ZUVuY29kaW5nID0gbWV0YWRhdGEuZ2V0KCdncnBjLWVuY29kaW5nJyk7XG4gICAgICAgIGlmIChyZWNlaXZlRW5jb2RpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RpbmcgPSByZWNlaXZlRW5jb2RpbmdbMF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVjZWl2ZUNvbXByZXNzaW9uID0gZ2V0Q29tcHJlc3Npb25IYW5kbGVyKGVuY29kaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoJ2dycGMtZW5jb2RpbmcnKTtcbiAgICAgICAgLyogQ2hlY2sgdG8gc2VlIGlmIHRoZSBjb21wcmVzc2lvbiB3ZSdyZSB1c2luZyB0byBzZW5kIG1lc3NhZ2VzIGlzIHN1cHBvcnRlZCBieSB0aGUgc2VydmVyXG4gICAgICAgICAqIElmIG5vdCwgcmVzZXQgdGhlIHNlbmRDb21wcmVzc2lvbiBmaWx0ZXIgYW5kIGhhdmUgaXQgdXNlIHRoZSBkZWZhdWx0IElkZW50aXR5SGFuZGxlciAqL1xuICAgICAgICBjb25zdCBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3NIZWFkZXIgPSBtZXRhZGF0YS5nZXQoJ2dycGMtYWNjZXB0LWVuY29kaW5nJylbMF07XG4gICAgICAgIGlmIChzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3NIZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkRmlsdGVyQ29uZmlnLnNlcnZlclN1cHBvcnRlZEVuY29kaW5nSGVhZGVyID0gc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzSGVhZGVyO1xuICAgICAgICAgICAgY29uc3Qgc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzID0gc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzSGVhZGVyLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBpZiAoIXNlcnZlclN1cHBvcnRlZEVuY29kaW5ncy5pbmNsdWRlcyh0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRDb21wcmVzc2lvbiA9IG5ldyBJZGVudGl0eUhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSA9ICdpZGVudGl0eSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWV0YWRhdGEucmVtb3ZlKCdncnBjLWFjY2VwdC1lbmNvZGluZycpO1xuICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvKiBUaGlzIGZpbHRlciBpcyBzcGVjaWFsLiBUaGUgaW5wdXQgbWVzc2FnZSBpcyB0aGUgYmFyZSBtZXNzYWdlIGJ5dGVzLFxuICAgICAgICAgKiBhbmQgdGhlIG91dHB1dCBpcyBhIGZyYW1lZCBhbmQgcG9zc2libHkgY29tcHJlc3NlZCBtZXNzYWdlLiBGb3IgdGhpc1xuICAgICAgICAgKiByZWFzb24sIHRoaXMgZmlsdGVyIHNob3VsZCBiZSBhdCB0aGUgYm90dG9tIG9mIHRoZSBmaWx0ZXIgc3RhY2sgKi9cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRNZXNzYWdlID0gYXdhaXQgbWVzc2FnZTtcbiAgICAgICAgbGV0IGNvbXByZXNzO1xuICAgICAgICBpZiAodGhpcy5zZW5kQ29tcHJlc3Npb24gaW5zdGFuY2VvZiBJZGVudGl0eUhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNvbXByZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb21wcmVzcyA9ICgoKF9hID0gcmVzb2x2ZWRNZXNzYWdlLmZsYWdzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSAmIDIgLyogTm9Db21wcmVzcyAqLykgPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGF3YWl0IHRoaXMuc2VuZENvbXByZXNzaW9uLndyaXRlTWVzc2FnZShyZXNvbHZlZE1lc3NhZ2UubWVzc2FnZSwgY29tcHJlc3MpLFxuICAgICAgICAgICAgZmxhZ3M6IHJlc29sdmVkTWVzc2FnZS5mbGFncyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAvKiBUaGlzIGZpbHRlciBpcyBhbHNvIHNwZWNpYWwuIFRoZSBpbnB1dCBtZXNzYWdlIGlzIGZyYW1lZCBhbmQgcG9zc2libHlcbiAgICAgICAgICogY29tcHJlc3NlZCwgYW5kIHRoZSBvdXRwdXQgbWVzc2FnZSBpcyBkZWZyYW1lZCBhbmQgdW5jb21wcmVzc2VkLiBTb1xuICAgICAgICAgKiB0aGlzIGlzIGFub3RoZXIgcmVhc29uIHRoYXQgdGhpcyBmaWx0ZXIgc2hvdWxkIGJlIGF0IHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAgICAqIGZpbHRlciBzdGFjay4gKi9cbiAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZUNvbXByZXNzaW9uLnJlYWRNZXNzYWdlKGF3YWl0IG1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29tcHJlc3Npb25GaWx0ZXIgPSBDb21wcmVzc2lvbkZpbHRlcjtcbmNsYXNzIENvbXByZXNzaW9uRmlsdGVyRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnNoYXJlZEZpbHRlckNvbmZpZyA9IHt9O1xuICAgIH1cbiAgICBjcmVhdGVGaWx0ZXIoY2FsbFN0cmVhbSkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXByZXNzaW9uRmlsdGVyKHRoaXMub3B0aW9ucywgdGhpcy5zaGFyZWRGaWx0ZXJDb25maWcpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29tcHJlc3Npb25GaWx0ZXJGYWN0b3J5ID0gQ29tcHJlc3Npb25GaWx0ZXJGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcHJlc3Npb24tZmlsdGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkNvbXByZXNzaW9uRmlsdGVyRmFjdG9yeSIsIkNvbXByZXNzaW9uRmlsdGVyIiwiemxpYiIsInJlcXVpcmUiLCJjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEiLCJjb25zdGFudHNfMSIsImZpbHRlcl8xIiwibG9nZ2luZyIsImlzQ29tcHJlc3Npb25BbGdvcml0aG1LZXkiLCJrZXkiLCJDb21wcmVzc2lvbkFsZ29yaXRobXMiLCJDb21wcmVzc2lvbkhhbmRsZXIiLCJ3cml0ZU1lc3NhZ2UiLCJtZXNzYWdlIiwiY29tcHJlc3MiLCJtZXNzYWdlQnVmZmVyIiwiY29tcHJlc3NNZXNzYWdlIiwib3V0cHV0IiwiQnVmZmVyIiwiYWxsb2NVbnNhZmUiLCJsZW5ndGgiLCJ3cml0ZVVJbnQ4Iiwid3JpdGVVSW50MzJCRSIsImNvcHkiLCJyZWFkTWVzc2FnZSIsImRhdGEiLCJjb21wcmVzc2VkIiwicmVhZFVJbnQ4Iiwic2xpY2UiLCJkZWNvbXByZXNzTWVzc2FnZSIsIklkZW50aXR5SGFuZGxlciIsIlByb21pc2UiLCJyZWplY3QiLCJFcnJvciIsIkRlZmxhdGVIYW5kbGVyIiwicmVzb2x2ZSIsImRlZmxhdGUiLCJlcnIiLCJpbmZsYXRlIiwiR3ppcEhhbmRsZXIiLCJnemlwIiwidW56aXAiLCJVbmtub3duSGFuZGxlciIsImNvbnN0cnVjdG9yIiwiY29tcHJlc3Npb25OYW1lIiwiZ2V0Q29tcHJlc3Npb25IYW5kbGVyIiwiQmFzZUZpbHRlciIsImNoYW5uZWxPcHRpb25zIiwic2hhcmVkRmlsdGVyQ29uZmlnIiwiX2EiLCJzZW5kQ29tcHJlc3Npb24iLCJyZWNlaXZlQ29tcHJlc3Npb24iLCJjdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0iLCJjb21wcmVzc2lvbkFsZ29yaXRobUtleSIsInVuZGVmaW5lZCIsImNsaWVudFNlbGVjdGVkRW5jb2RpbmciLCJzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3MiLCJzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ0hlYWRlciIsInNwbGl0IiwiaW5jbHVkZXMiLCJsb2ciLCJMb2dWZXJib3NpdHkiLCJFUlJPUiIsInNlbmRNZXRhZGF0YSIsIm1ldGFkYXRhIiwiaGVhZGVycyIsInNldCIsInJlbW92ZSIsInJlY2VpdmVNZXRhZGF0YSIsInJlY2VpdmVFbmNvZGluZyIsImdldCIsImVuY29kaW5nIiwic2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzSGVhZGVyIiwic2VuZE1lc3NhZ2UiLCJyZXNvbHZlZE1lc3NhZ2UiLCJmbGFncyIsInJlY2VpdmVNZXNzYWdlIiwiY2hhbm5lbCIsIm9wdGlvbnMiLCJjcmVhdGVGaWx0ZXIiLCJjYWxsU3RyZWFtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/connectivity-state.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ConnectivityState = void 0;\nvar ConnectivityState;\n(function(ConnectivityState) {\n    ConnectivityState[ConnectivityState[\"IDLE\"] = 0] = \"IDLE\";\n    ConnectivityState[ConnectivityState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    ConnectivityState[ConnectivityState[\"READY\"] = 2] = \"READY\";\n    ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 3] = \"TRANSIENT_FAILURE\";\n    ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState = exports.ConnectivityState || (exports.ConnectivityState = {})); //# sourceMappingURL=connectivity-state.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29ubmVjdGl2aXR5LXN0YXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx5QkFBeUIsR0FBRyxLQUFLO0FBQ2pDLElBQUlFO0FBQ0gsVUFBVUEsaUJBQWlCO0lBQ3hCQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUNuREEsaUJBQWlCLENBQUNBLGlCQUFpQixDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7SUFDekRBLGlCQUFpQixDQUFDQSxpQkFBaUIsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ3BEQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsb0JBQW9CLEdBQUcsRUFBRSxHQUFHO0lBQ2hFQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsV0FBVyxHQUFHLEVBQUUsR0FBRztBQUMzRCxHQUFHQSxvQkFBb0JGLFFBQVFFLGlCQUFpQixJQUFLRixDQUFBQSx5QkFBeUIsR0FBRyxDQUFDLEtBQ2xGLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL2FzaG1pdHQtZ3VwdGEvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29ubmVjdGl2aXR5LXN0YXRlLmpzPzRlZTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29ubmVjdGl2aXR5U3RhdGUgPSB2b2lkIDA7XG52YXIgQ29ubmVjdGl2aXR5U3RhdGU7XG4oZnVuY3Rpb24gKENvbm5lY3Rpdml0eVN0YXRlKSB7XG4gICAgQ29ubmVjdGl2aXR5U3RhdGVbQ29ubmVjdGl2aXR5U3RhdGVbXCJJRExFXCJdID0gMF0gPSBcIklETEVcIjtcbiAgICBDb25uZWN0aXZpdHlTdGF0ZVtDb25uZWN0aXZpdHlTdGF0ZVtcIkNPTk5FQ1RJTkdcIl0gPSAxXSA9IFwiQ09OTkVDVElOR1wiO1xuICAgIENvbm5lY3Rpdml0eVN0YXRlW0Nvbm5lY3Rpdml0eVN0YXRlW1wiUkVBRFlcIl0gPSAyXSA9IFwiUkVBRFlcIjtcbiAgICBDb25uZWN0aXZpdHlTdGF0ZVtDb25uZWN0aXZpdHlTdGF0ZVtcIlRSQU5TSUVOVF9GQUlMVVJFXCJdID0gM10gPSBcIlRSQU5TSUVOVF9GQUlMVVJFXCI7XG4gICAgQ29ubmVjdGl2aXR5U3RhdGVbQ29ubmVjdGl2aXR5U3RhdGVbXCJTSFVURE9XTlwiXSA9IDRdID0gXCJTSFVURE9XTlwiO1xufSkoQ29ubmVjdGl2aXR5U3RhdGUgPSBleHBvcnRzLkNvbm5lY3Rpdml0eVN0YXRlIHx8IChleHBvcnRzLkNvbm5lY3Rpdml0eVN0YXRlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpdml0eS1zdGF0ZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDb25uZWN0aXZpdHlTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/constants.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = exports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = exports.Propagate = exports.LogVerbosity = exports.Status = void 0;\nvar Status;\n(function(Status) {\n    Status[Status[\"OK\"] = 0] = \"OK\";\n    Status[Status[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    Status[Status[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    Status[Status[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n    Status[Status[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n    Status[Status[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n    Status[Status[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n    Status[Status[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n    Status[Status[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n    Status[Status[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n    Status[Status[\"ABORTED\"] = 10] = \"ABORTED\";\n    Status[Status[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n    Status[Status[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n    Status[Status[\"INTERNAL\"] = 13] = \"INTERNAL\";\n    Status[Status[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n    Status[Status[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n    Status[Status[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n})(Status = exports.Status || (exports.Status = {}));\nvar LogVerbosity;\n(function(LogVerbosity) {\n    LogVerbosity[LogVerbosity[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogVerbosity[LogVerbosity[\"INFO\"] = 1] = \"INFO\";\n    LogVerbosity[LogVerbosity[\"ERROR\"] = 2] = \"ERROR\";\n    LogVerbosity[LogVerbosity[\"NONE\"] = 3] = \"NONE\";\n})(LogVerbosity = exports.LogVerbosity || (exports.LogVerbosity = {}));\n/**\n * NOTE: This enum is not currently used in any implemented API in this\n * library. It is included only for type parity with the other implementation.\n */ var Propagate;\n(function(Propagate) {\n    Propagate[Propagate[\"DEADLINE\"] = 1] = \"DEADLINE\";\n    Propagate[Propagate[\"CENSUS_STATS_CONTEXT\"] = 2] = \"CENSUS_STATS_CONTEXT\";\n    Propagate[Propagate[\"CENSUS_TRACING_CONTEXT\"] = 4] = \"CENSUS_TRACING_CONTEXT\";\n    Propagate[Propagate[\"CANCELLATION\"] = 8] = \"CANCELLATION\";\n    // https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/propagation_bits.h#L43\n    Propagate[Propagate[\"DEFAULTS\"] = 65535] = \"DEFAULTS\";\n})(Propagate = exports.Propagate || (exports.Propagate = {}));\n// -1 means unlimited\nexports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;\n// 4 MB default\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQ0FBMEMsR0FBR0EsdUNBQXVDLEdBQUdBLGlCQUFpQixHQUFHQSxvQkFBb0IsR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDeEosSUFBSU07QUFDSCxVQUFVQSxNQUFNO0lBQ2JBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLEtBQUssR0FBRyxFQUFFLEdBQUc7SUFDM0JBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLFlBQVksR0FBRyxFQUFFLEdBQUc7SUFDbENBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDaENBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLG1CQUFtQixHQUFHLEVBQUUsR0FBRztJQUN6Q0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsb0JBQW9CLEdBQUcsRUFBRSxHQUFHO0lBQzFDQSxNQUFNLENBQUNBLE1BQU0sQ0FBQyxZQUFZLEdBQUcsRUFBRSxHQUFHO0lBQ2xDQSxNQUFNLENBQUNBLE1BQU0sQ0FBQyxpQkFBaUIsR0FBRyxFQUFFLEdBQUc7SUFDdkNBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLG9CQUFvQixHQUFHLEVBQUUsR0FBRztJQUMxQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMscUJBQXFCLEdBQUcsRUFBRSxHQUFHO0lBQzNDQSxNQUFNLENBQUNBLE1BQU0sQ0FBQyxzQkFBc0IsR0FBRyxFQUFFLEdBQUc7SUFDNUNBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLFVBQVUsR0FBRyxHQUFHLEdBQUc7SUFDakNBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLGVBQWUsR0FBRyxHQUFHLEdBQUc7SUFDdENBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLGdCQUFnQixHQUFHLEdBQUcsR0FBRztJQUN2Q0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsV0FBVyxHQUFHLEdBQUcsR0FBRztJQUNsQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsY0FBYyxHQUFHLEdBQUcsR0FBRztJQUNyQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsWUFBWSxHQUFHLEdBQUcsR0FBRztJQUNuQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsa0JBQWtCLEdBQUcsR0FBRyxHQUFHO0FBQzdDLEdBQUdBLFNBQVNOLFFBQVFNLE1BQU0sSUFBS04sQ0FBQUEsY0FBYyxHQUFHLENBQUM7QUFDakQsSUFBSUs7QUFDSCxVQUFVQSxZQUFZO0lBQ25CQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQzFDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQ3pDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQzFDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0FBQzdDLEdBQUdBLGVBQWVMLFFBQVFLLFlBQVksSUFBS0wsQ0FBQUEsb0JBQW9CLEdBQUcsQ0FBQztBQUNuRTs7O0NBR0MsR0FDRCxJQUFJSTtBQUNILFVBQVVBLFNBQVM7SUFDaEJBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLFdBQVcsR0FBRyxFQUFFLEdBQUc7SUFDdkNBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLHVCQUF1QixHQUFHLEVBQUUsR0FBRztJQUNuREEsU0FBUyxDQUFDQSxTQUFTLENBQUMseUJBQXlCLEdBQUcsRUFBRSxHQUFHO0lBQ3JEQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxlQUFlLEdBQUcsRUFBRSxHQUFHO0lBQzNDLDRGQUE0RjtJQUM1RkEsU0FBUyxDQUFDQSxTQUFTLENBQUMsV0FBVyxHQUFHLE1BQU0sR0FBRztBQUMvQyxHQUFHQSxZQUFZSixRQUFRSSxTQUFTLElBQUtKLENBQUFBLGlCQUFpQixHQUFHLENBQUM7QUFDMUQscUJBQXFCO0FBQ3JCQSx1Q0FBdUMsR0FBRyxDQUFDO0FBQzNDLGVBQWU7QUFDZkEsMENBQTBDLEdBQUcsSUFBSSxPQUFPLE1BQ3hELHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FzaG1pdHQtZ3VwdGEvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29uc3RhbnRzLmpzPzFjMmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSCA9IGV4cG9ydHMuREVGQVVMVF9NQVhfU0VORF9NRVNTQUdFX0xFTkdUSCA9IGV4cG9ydHMuUHJvcGFnYXRlID0gZXhwb3J0cy5Mb2dWZXJib3NpdHkgPSBleHBvcnRzLlN0YXR1cyA9IHZvaWQgMDtcbnZhciBTdGF0dXM7XG4oZnVuY3Rpb24gKFN0YXR1cykge1xuICAgIFN0YXR1c1tTdGF0dXNbXCJPS1wiXSA9IDBdID0gXCJPS1wiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJDQU5DRUxMRURcIl0gPSAxXSA9IFwiQ0FOQ0VMTEVEXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlVOS05PV05cIl0gPSAyXSA9IFwiVU5LTk9XTlwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJJTlZBTElEX0FSR1VNRU5UXCJdID0gM10gPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiREVBRExJTkVfRVhDRUVERURcIl0gPSA0XSA9IFwiREVBRExJTkVfRVhDRUVERURcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiTk9UX0ZPVU5EXCJdID0gNV0gPSBcIk5PVF9GT1VORFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJBTFJFQURZX0VYSVNUU1wiXSA9IDZdID0gXCJBTFJFQURZX0VYSVNUU1wiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJQRVJNSVNTSU9OX0RFTklFRFwiXSA9IDddID0gXCJQRVJNSVNTSU9OX0RFTklFRFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJSRVNPVVJDRV9FWEhBVVNURURcIl0gPSA4XSA9IFwiUkVTT1VSQ0VfRVhIQVVTVEVEXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIkZBSUxFRF9QUkVDT05ESVRJT05cIl0gPSA5XSA9IFwiRkFJTEVEX1BSRUNPTkRJVElPTlwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJBQk9SVEVEXCJdID0gMTBdID0gXCJBQk9SVEVEXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIk9VVF9PRl9SQU5HRVwiXSA9IDExXSA9IFwiT1VUX09GX1JBTkdFXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlVOSU1QTEVNRU5URURcIl0gPSAxMl0gPSBcIlVOSU1QTEVNRU5URURcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiSU5URVJOQUxcIl0gPSAxM10gPSBcIklOVEVSTkFMXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlVOQVZBSUxBQkxFXCJdID0gMTRdID0gXCJVTkFWQUlMQUJMRVwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJEQVRBX0xPU1NcIl0gPSAxNV0gPSBcIkRBVEFfTE9TU1wiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJVTkFVVEhFTlRJQ0FURURcIl0gPSAxNl0gPSBcIlVOQVVUSEVOVElDQVRFRFwiO1xufSkoU3RhdHVzID0gZXhwb3J0cy5TdGF0dXMgfHwgKGV4cG9ydHMuU3RhdHVzID0ge30pKTtcbnZhciBMb2dWZXJib3NpdHk7XG4oZnVuY3Rpb24gKExvZ1ZlcmJvc2l0eSkge1xuICAgIExvZ1ZlcmJvc2l0eVtMb2dWZXJib3NpdHlbXCJERUJVR1wiXSA9IDBdID0gXCJERUJVR1wiO1xuICAgIExvZ1ZlcmJvc2l0eVtMb2dWZXJib3NpdHlbXCJJTkZPXCJdID0gMV0gPSBcIklORk9cIjtcbiAgICBMb2dWZXJib3NpdHlbTG9nVmVyYm9zaXR5W1wiRVJST1JcIl0gPSAyXSA9IFwiRVJST1JcIjtcbiAgICBMb2dWZXJib3NpdHlbTG9nVmVyYm9zaXR5W1wiTk9ORVwiXSA9IDNdID0gXCJOT05FXCI7XG59KShMb2dWZXJib3NpdHkgPSBleHBvcnRzLkxvZ1ZlcmJvc2l0eSB8fCAoZXhwb3J0cy5Mb2dWZXJib3NpdHkgPSB7fSkpO1xuLyoqXG4gKiBOT1RFOiBUaGlzIGVudW0gaXMgbm90IGN1cnJlbnRseSB1c2VkIGluIGFueSBpbXBsZW1lbnRlZCBBUEkgaW4gdGhpc1xuICogbGlicmFyeS4gSXQgaXMgaW5jbHVkZWQgb25seSBmb3IgdHlwZSBwYXJpdHkgd2l0aCB0aGUgb3RoZXIgaW1wbGVtZW50YXRpb24uXG4gKi9cbnZhciBQcm9wYWdhdGU7XG4oZnVuY3Rpb24gKFByb3BhZ2F0ZSkge1xuICAgIFByb3BhZ2F0ZVtQcm9wYWdhdGVbXCJERUFETElORVwiXSA9IDFdID0gXCJERUFETElORVwiO1xuICAgIFByb3BhZ2F0ZVtQcm9wYWdhdGVbXCJDRU5TVVNfU1RBVFNfQ09OVEVYVFwiXSA9IDJdID0gXCJDRU5TVVNfU1RBVFNfQ09OVEVYVFwiO1xuICAgIFByb3BhZ2F0ZVtQcm9wYWdhdGVbXCJDRU5TVVNfVFJBQ0lOR19DT05URVhUXCJdID0gNF0gPSBcIkNFTlNVU19UUkFDSU5HX0NPTlRFWFRcIjtcbiAgICBQcm9wYWdhdGVbUHJvcGFnYXRlW1wiQ0FOQ0VMTEFUSU9OXCJdID0gOF0gPSBcIkNBTkNFTExBVElPTlwiO1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMvYmxvYi9tYXN0ZXIvaW5jbHVkZS9ncnBjL2ltcGwvY29kZWdlbi9wcm9wYWdhdGlvbl9iaXRzLmgjTDQzXG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkRFRkFVTFRTXCJdID0gNjU1MzVdID0gXCJERUZBVUxUU1wiO1xufSkoUHJvcGFnYXRlID0gZXhwb3J0cy5Qcm9wYWdhdGUgfHwgKGV4cG9ydHMuUHJvcGFnYXRlID0ge30pKTtcbi8vIC0xIG1lYW5zIHVubGltaXRlZFxuZXhwb3J0cy5ERUZBVUxUX01BWF9TRU5EX01FU1NBR0VfTEVOR1RIID0gLTE7XG4vLyA0IE1CIGRlZmF1bHRcbmV4cG9ydHMuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSCA9IDQgKiAxMDI0ICogMTAyNDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJERUZBVUxUX01BWF9SRUNFSVZFX01FU1NBR0VfTEVOR1RIIiwiREVGQVVMVF9NQVhfU0VORF9NRVNTQUdFX0xFTkdUSCIsIlByb3BhZ2F0ZSIsIkxvZ1ZlcmJvc2l0eSIsIlN0YXR1cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/deadline-filter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/deadline-filter.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DeadlineFilterFactory = exports.DeadlineFilter = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst units = [\n    [\n        \"m\",\n        1\n    ],\n    [\n        \"S\",\n        1000\n    ],\n    [\n        \"M\",\n        60 * 1000\n    ],\n    [\n        \"H\",\n        60 * 60 * 1000\n    ]\n];\nfunction getDeadline(deadline) {\n    const now = new Date().getTime();\n    const timeoutMs = Math.max(deadline - now, 0);\n    for (const [unit, factor] of units){\n        const amount = timeoutMs / factor;\n        if (amount < 1e8) {\n            return String(Math.ceil(amount)) + unit;\n        }\n    }\n    throw new Error(\"Deadline is too far in the future\");\n}\nclass DeadlineFilter extends filter_1.BaseFilter {\n    constructor(channel, callStream){\n        super();\n        this.channel = channel;\n        this.callStream = callStream;\n        this.timer = null;\n        this.deadline = Infinity;\n        this.retreiveDeadline();\n        this.runTimer();\n    }\n    retreiveDeadline() {\n        const callDeadline = this.callStream.getDeadline();\n        if (callDeadline instanceof Date) {\n            this.deadline = callDeadline.getTime();\n        } else {\n            this.deadline = callDeadline;\n        }\n    }\n    runTimer() {\n        var _a, _b;\n        if (this.timer) {\n            clearTimeout(this.timer);\n        }\n        const now = new Date().getTime();\n        const timeout = this.deadline - now;\n        if (timeout <= 0) {\n            process.nextTick(()=>{\n                this.callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, \"Deadline exceeded\");\n            });\n        } else if (this.deadline !== Infinity) {\n            this.timer = setTimeout(()=>{\n                this.callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, \"Deadline exceeded\");\n            }, timeout);\n            (_b = (_a = this.timer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    refresh() {\n        this.retreiveDeadline();\n        this.runTimer();\n    }\n    async sendMetadata(metadata) {\n        if (this.deadline === Infinity) {\n            return metadata;\n        }\n        /* The input metadata promise depends on the original channel.connect()\n         * promise, so when it is complete that implies that the channel is\n         * connected */ const finalMetadata = await metadata;\n        const timeoutString = getDeadline(this.deadline);\n        finalMetadata.set(\"grpc-timeout\", timeoutString);\n        return finalMetadata;\n    }\n    receiveTrailers(status) {\n        if (this.timer) {\n            clearTimeout(this.timer);\n        }\n        return status;\n    }\n}\nexports.DeadlineFilter = DeadlineFilter;\nclass DeadlineFilterFactory {\n    constructor(channel){\n        this.channel = channel;\n    }\n    createFilter(callStream) {\n        return new DeadlineFilter(this.channel, callStream);\n    }\n}\nexports.DeadlineFilterFactory = DeadlineFilterFactory; //# sourceMappingURL=deadline-filter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZGVhZGxpbmUtZmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw2QkFBNkIsR0FBR0Esc0JBQXNCLEdBQUcsS0FBSztBQUM5RCxNQUFNSSxjQUFjQyxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyx3RUFBVTtBQUNuQyxNQUFNRSxRQUFRO0lBQ1Y7UUFBQztRQUFLO0tBQUU7SUFDUjtRQUFDO1FBQUs7S0FBSztJQUNYO1FBQUM7UUFBSyxLQUFLO0tBQUs7SUFDaEI7UUFBQztRQUFLLEtBQUssS0FBSztLQUFLO0NBQ3hCO0FBQ0QsU0FBU0MsWUFBWUMsUUFBUTtJQUN6QixNQUFNQyxNQUFNLElBQUlDLE9BQU9DLE9BQU87SUFDOUIsTUFBTUMsWUFBWUMsS0FBS0MsR0FBRyxDQUFDTixXQUFXQyxLQUFLO0lBQzNDLEtBQUssTUFBTSxDQUFDTSxNQUFNQyxPQUFPLElBQUlWLE1BQU87UUFDaEMsTUFBTVcsU0FBU0wsWUFBWUk7UUFDM0IsSUFBSUMsU0FBUyxLQUFLO1lBQ2QsT0FBT0MsT0FBT0wsS0FBS00sSUFBSSxDQUFDRixXQUFXRjtRQUN2QztJQUNKO0lBQ0EsTUFBTSxJQUFJSyxNQUFNO0FBQ3BCO0FBQ0EsTUFBTWxCLHVCQUF1QkcsU0FBU2dCLFVBQVU7SUFDNUNDLFlBQVlDLE9BQU8sRUFBRUMsVUFBVSxDQUFFO1FBQzdCLEtBQUs7UUFDTCxJQUFJLENBQUNELE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNqQixRQUFRLEdBQUdrQjtRQUNoQixJQUFJLENBQUNDLGdCQUFnQjtRQUNyQixJQUFJLENBQUNDLFFBQVE7SUFDakI7SUFDQUQsbUJBQW1CO1FBQ2YsTUFBTUUsZUFBZSxJQUFJLENBQUNMLFVBQVUsQ0FBQ2pCLFdBQVc7UUFDaEQsSUFBSXNCLHdCQUF3Qm5CLE1BQU07WUFDOUIsSUFBSSxDQUFDRixRQUFRLEdBQUdxQixhQUFhbEIsT0FBTztRQUN4QyxPQUNLO1lBQ0QsSUFBSSxDQUFDSCxRQUFRLEdBQUdxQjtRQUNwQjtJQUNKO0lBQ0FELFdBQVc7UUFDUCxJQUFJRSxJQUFJQztRQUNSLElBQUksSUFBSSxDQUFDTixLQUFLLEVBQUU7WUFDWk8sYUFBYSxJQUFJLENBQUNQLEtBQUs7UUFDM0I7UUFDQSxNQUFNaEIsTUFBTSxJQUFJQyxPQUFPQyxPQUFPO1FBQzlCLE1BQU1zQixVQUFVLElBQUksQ0FBQ3pCLFFBQVEsR0FBR0M7UUFDaEMsSUFBSXdCLFdBQVcsR0FBRztZQUNkQyxRQUFRQyxRQUFRLENBQUM7Z0JBQ2IsSUFBSSxDQUFDWCxVQUFVLENBQUNZLGdCQUFnQixDQUFDakMsWUFBWWtDLE1BQU0sQ0FBQ0MsaUJBQWlCLEVBQUU7WUFDM0U7UUFDSixPQUNLLElBQUksSUFBSSxDQUFDOUIsUUFBUSxLQUFLa0IsVUFBVTtZQUNqQyxJQUFJLENBQUNELEtBQUssR0FBR2MsV0FBVztnQkFDcEIsSUFBSSxDQUFDZixVQUFVLENBQUNZLGdCQUFnQixDQUFDakMsWUFBWWtDLE1BQU0sQ0FBQ0MsaUJBQWlCLEVBQUU7WUFDM0UsR0FBR0w7WUFDRkYsQ0FBQUEsS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQ0wsS0FBSyxFQUFFZSxLQUFLLE1BQU0sUUFBUVQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHVSxJQUFJLENBQUNYO1FBQ2hGO0lBQ0o7SUFDQVksVUFBVTtRQUNOLElBQUksQ0FBQ2YsZ0JBQWdCO1FBQ3JCLElBQUksQ0FBQ0MsUUFBUTtJQUNqQjtJQUNBLE1BQU1lLGFBQWFDLFFBQVEsRUFBRTtRQUN6QixJQUFJLElBQUksQ0FBQ3BDLFFBQVEsS0FBS2tCLFVBQVU7WUFDNUIsT0FBT2tCO1FBQ1g7UUFDQTs7cUJBRWEsR0FDYixNQUFNQyxnQkFBZ0IsTUFBTUQ7UUFDNUIsTUFBTUUsZ0JBQWdCdkMsWUFBWSxJQUFJLENBQUNDLFFBQVE7UUFDL0NxQyxjQUFjRSxHQUFHLENBQUMsZ0JBQWdCRDtRQUNsQyxPQUFPRDtJQUNYO0lBQ0FHLGdCQUFnQkMsTUFBTSxFQUFFO1FBQ3BCLElBQUksSUFBSSxDQUFDeEIsS0FBSyxFQUFFO1lBQ1pPLGFBQWEsSUFBSSxDQUFDUCxLQUFLO1FBQzNCO1FBQ0EsT0FBT3dCO0lBQ1g7QUFDSjtBQUNBbEQsc0JBQXNCLEdBQUdHO0FBQ3pCLE1BQU1EO0lBQ0ZxQixZQUFZQyxPQUFPLENBQUU7UUFDakIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ25CO0lBQ0EyQixhQUFhMUIsVUFBVSxFQUFFO1FBQ3JCLE9BQU8sSUFBSXRCLGVBQWUsSUFBSSxDQUFDcUIsT0FBTyxFQUFFQztJQUM1QztBQUNKO0FBQ0F6Qiw2QkFBNkIsR0FBR0UsdUJBQ2hDLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FzaG1pdHQtZ3VwdGEvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZGVhZGxpbmUtZmlsdGVyLmpzPzlkODkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVhZGxpbmVGaWx0ZXJGYWN0b3J5ID0gZXhwb3J0cy5EZWFkbGluZUZpbHRlciA9IHZvaWQgMDtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9maWx0ZXJcIik7XG5jb25zdCB1bml0cyA9IFtcbiAgICBbJ20nLCAxXSxcbiAgICBbJ1MnLCAxMDAwXSxcbiAgICBbJ00nLCA2MCAqIDEwMDBdLFxuICAgIFsnSCcsIDYwICogNjAgKiAxMDAwXSxcbl07XG5mdW5jdGlvbiBnZXREZWFkbGluZShkZWFkbGluZSkge1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGNvbnN0IHRpbWVvdXRNcyA9IE1hdGgubWF4KGRlYWRsaW5lIC0gbm93LCAwKTtcbiAgICBmb3IgKGNvbnN0IFt1bml0LCBmYWN0b3JdIG9mIHVuaXRzKSB7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IHRpbWVvdXRNcyAvIGZhY3RvcjtcbiAgICAgICAgaWYgKGFtb3VudCA8IDFlOCkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhNYXRoLmNlaWwoYW1vdW50KSkgKyB1bml0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignRGVhZGxpbmUgaXMgdG9vIGZhciBpbiB0aGUgZnV0dXJlJyk7XG59XG5jbGFzcyBEZWFkbGluZUZpbHRlciBleHRlbmRzIGZpbHRlcl8xLkJhc2VGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwsIGNhbGxTdHJlYW0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5jYWxsU3RyZWFtID0gY2FsbFN0cmVhbTtcbiAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVhZGxpbmUgPSBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5yZXRyZWl2ZURlYWRsaW5lKCk7XG4gICAgICAgIHRoaXMucnVuVGltZXIoKTtcbiAgICB9XG4gICAgcmV0cmVpdmVEZWFkbGluZSgpIHtcbiAgICAgICAgY29uc3QgY2FsbERlYWRsaW5lID0gdGhpcy5jYWxsU3RyZWFtLmdldERlYWRsaW5lKCk7XG4gICAgICAgIGlmIChjYWxsRGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmRlYWRsaW5lID0gY2FsbERlYWRsaW5lLmdldFRpbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVhZGxpbmUgPSBjYWxsRGVhZGxpbmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnVuVGltZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLmRlYWRsaW5lIC0gbm93O1xuICAgICAgICBpZiAodGltZW91dCA8PSAwKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxTdHJlYW0uY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuREVBRExJTkVfRVhDRUVERUQsICdEZWFkbGluZSBleGNlZWRlZCcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZWFkbGluZSAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxTdHJlYW0uY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuREVBRExJTkVfRVhDRUVERUQsICdEZWFkbGluZSBleGNlZWRlZCcpO1xuICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnRpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMucmV0cmVpdmVEZWFkbGluZSgpO1xuICAgICAgICB0aGlzLnJ1blRpbWVyKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5kZWFkbGluZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvKiBUaGUgaW5wdXQgbWV0YWRhdGEgcHJvbWlzZSBkZXBlbmRzIG9uIHRoZSBvcmlnaW5hbCBjaGFubmVsLmNvbm5lY3QoKVxuICAgICAgICAgKiBwcm9taXNlLCBzbyB3aGVuIGl0IGlzIGNvbXBsZXRlIHRoYXQgaW1wbGllcyB0aGF0IHRoZSBjaGFubmVsIGlzXG4gICAgICAgICAqIGNvbm5lY3RlZCAqL1xuICAgICAgICBjb25zdCBmaW5hbE1ldGFkYXRhID0gYXdhaXQgbWV0YWRhdGE7XG4gICAgICAgIGNvbnN0IHRpbWVvdXRTdHJpbmcgPSBnZXREZWFkbGluZSh0aGlzLmRlYWRsaW5lKTtcbiAgICAgICAgZmluYWxNZXRhZGF0YS5zZXQoJ2dycGMtdGltZW91dCcsIHRpbWVvdXRTdHJpbmcpO1xuICAgICAgICByZXR1cm4gZmluYWxNZXRhZGF0YTtcbiAgICB9XG4gICAgcmVjZWl2ZVRyYWlsZXJzKHN0YXR1cykge1xuICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxufVxuZXhwb3J0cy5EZWFkbGluZUZpbHRlciA9IERlYWRsaW5lRmlsdGVyO1xuY2xhc3MgRGVhZGxpbmVGaWx0ZXJGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgfVxuICAgIGNyZWF0ZUZpbHRlcihjYWxsU3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVhZGxpbmVGaWx0ZXIodGhpcy5jaGFubmVsLCBjYWxsU3RyZWFtKTtcbiAgICB9XG59XG5leHBvcnRzLkRlYWRsaW5lRmlsdGVyRmFjdG9yeSA9IERlYWRsaW5lRmlsdGVyRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYWRsaW5lLWZpbHRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJEZWFkbGluZUZpbHRlckZhY3RvcnkiLCJEZWFkbGluZUZpbHRlciIsImNvbnN0YW50c18xIiwicmVxdWlyZSIsImZpbHRlcl8xIiwidW5pdHMiLCJnZXREZWFkbGluZSIsImRlYWRsaW5lIiwibm93IiwiRGF0ZSIsImdldFRpbWUiLCJ0aW1lb3V0TXMiLCJNYXRoIiwibWF4IiwidW5pdCIsImZhY3RvciIsImFtb3VudCIsIlN0cmluZyIsImNlaWwiLCJFcnJvciIsIkJhc2VGaWx0ZXIiLCJjb25zdHJ1Y3RvciIsImNoYW5uZWwiLCJjYWxsU3RyZWFtIiwidGltZXIiLCJJbmZpbml0eSIsInJldHJlaXZlRGVhZGxpbmUiLCJydW5UaW1lciIsImNhbGxEZWFkbGluZSIsIl9hIiwiX2IiLCJjbGVhclRpbWVvdXQiLCJ0aW1lb3V0IiwicHJvY2VzcyIsIm5leHRUaWNrIiwiY2FuY2VsV2l0aFN0YXR1cyIsIlN0YXR1cyIsIkRFQURMSU5FX0VYQ0VFREVEIiwic2V0VGltZW91dCIsInVucmVmIiwiY2FsbCIsInJlZnJlc2giLCJzZW5kTWV0YWRhdGEiLCJtZXRhZGF0YSIsImZpbmFsTWV0YWRhdGEiLCJ0aW1lb3V0U3RyaW5nIiwic2V0IiwicmVjZWl2ZVRyYWlsZXJzIiwic3RhdHVzIiwiY3JlYXRlRmlsdGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/deadline-filter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/duration.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/duration.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isDuration = exports.durationToMs = exports.msToDuration = void 0;\nfunction msToDuration(millis) {\n    return {\n        seconds: millis / 1000 | 0,\n        nanos: millis % 1000 * 1000000 | 0\n    };\n}\nexports.msToDuration = msToDuration;\nfunction durationToMs(duration) {\n    return duration.seconds * 1000 + duration.nanos / 1000000 | 0;\n}\nexports.durationToMs = durationToMs;\nfunction isDuration(value) {\n    return typeof value.seconds === \"number\" && typeof value.nanos === \"number\";\n}\nexports.isDuration = isDuration; //# sourceMappingURL=duration.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZHVyYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtCQUFrQixHQUFHQSxvQkFBb0IsR0FBR0Esb0JBQW9CLEdBQUcsS0FBSztBQUN4RSxTQUFTSSxhQUFhQyxNQUFNO0lBQ3hCLE9BQU87UUFDSEMsU0FBUyxTQUFVLE9BQVE7UUFDM0JDLE9BQU8sU0FBVSxPQUFRLFVBQVU7SUFDdkM7QUFDSjtBQUNBUCxvQkFBb0IsR0FBR0k7QUFDdkIsU0FBU0QsYUFBYUssUUFBUTtJQUMxQixPQUFPLFNBQVVGLE9BQU8sR0FBRyxPQUFPRSxTQUFTRCxLQUFLLEdBQUcsVUFBVztBQUNsRTtBQUNBUCxvQkFBb0IsR0FBR0c7QUFDdkIsU0FBU0QsV0FBV0QsS0FBSztJQUNyQixPQUFPLE9BQVFBLE1BQU1LLE9BQU8sS0FBSyxZQUFjLE9BQU9MLE1BQU1NLEtBQUssS0FBSztBQUMxRTtBQUNBUCxrQkFBa0IsR0FBR0UsWUFDckIsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNobWl0dC1ndXB0YS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9kdXJhdGlvbi5qcz9kMTEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzRHVyYXRpb24gPSBleHBvcnRzLmR1cmF0aW9uVG9NcyA9IGV4cG9ydHMubXNUb0R1cmF0aW9uID0gdm9pZCAwO1xuZnVuY3Rpb24gbXNUb0R1cmF0aW9uKG1pbGxpcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlY29uZHM6IChtaWxsaXMgLyAxMDAwKSB8IDAsXG4gICAgICAgIG5hbm9zOiAobWlsbGlzICUgMTAwMCkgKiAxMDAwMDAwIHwgMFxuICAgIH07XG59XG5leHBvcnRzLm1zVG9EdXJhdGlvbiA9IG1zVG9EdXJhdGlvbjtcbmZ1bmN0aW9uIGR1cmF0aW9uVG9NcyhkdXJhdGlvbikge1xuICAgIHJldHVybiAoZHVyYXRpb24uc2Vjb25kcyAqIDEwMDAgKyBkdXJhdGlvbi5uYW5vcyAvIDEwMDAwMDApIHwgMDtcbn1cbmV4cG9ydHMuZHVyYXRpb25Ub01zID0gZHVyYXRpb25Ub01zO1xuZnVuY3Rpb24gaXNEdXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbHVlLnNlY29uZHMgPT09ICdudW1iZXInKSAmJiAodHlwZW9mIHZhbHVlLm5hbm9zID09PSAnbnVtYmVyJyk7XG59XG5leHBvcnRzLmlzRHVyYXRpb24gPSBpc0R1cmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHVyYXRpb24uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaXNEdXJhdGlvbiIsImR1cmF0aW9uVG9NcyIsIm1zVG9EdXJhdGlvbiIsIm1pbGxpcyIsInNlY29uZHMiLCJuYW5vcyIsImR1cmF0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/duration.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/experimental.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/experimental.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar logging_1 = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nObject.defineProperty(exports, \"trace\", ({\n    enumerable: true,\n    get: function() {\n        return logging_1.trace;\n    }\n}));\nObject.defineProperty(exports, \"log\", ({\n    enumerable: true,\n    get: function() {\n        return logging_1.log;\n    }\n}));\nvar resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nObject.defineProperty(exports, \"registerResolver\", ({\n    enumerable: true,\n    get: function() {\n        return resolver_1.registerResolver;\n    }\n}));\nvar uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nObject.defineProperty(exports, \"uriToString\", ({\n    enumerable: true,\n    get: function() {\n        return uri_parser_1.uriToString;\n    }\n}));\nvar duration_1 = __webpack_require__(/*! ./duration */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\nObject.defineProperty(exports, \"durationToMs\", ({\n    enumerable: true,\n    get: function() {\n        return duration_1.durationToMs;\n    }\n}));\nvar backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nObject.defineProperty(exports, \"BackoffTimeout\", ({\n    enumerable: true,\n    get: function() {\n        return backoff_timeout_1.BackoffTimeout;\n    }\n}));\nvar load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nObject.defineProperty(exports, \"createChildChannelControlHelper\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_1.createChildChannelControlHelper;\n    }\n}));\nObject.defineProperty(exports, \"registerLoadBalancerType\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_1.registerLoadBalancerType;\n    }\n}));\nObject.defineProperty(exports, \"getFirstUsableConfig\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_1.getFirstUsableConfig;\n    }\n}));\nObject.defineProperty(exports, \"validateLoadBalancingConfig\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_1.validateLoadBalancingConfig;\n    }\n}));\nvar subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nObject.defineProperty(exports, \"subchannelAddressToString\", ({\n    enumerable: true,\n    get: function() {\n        return subchannel_address_1.subchannelAddressToString;\n    }\n}));\nvar load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nObject.defineProperty(exports, \"ChildLoadBalancerHandler\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_child_handler_1.ChildLoadBalancerHandler;\n    }\n}));\nvar picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nObject.defineProperty(exports, \"UnavailablePicker\", ({\n    enumerable: true,\n    get: function() {\n        return picker_1.UnavailablePicker;\n    }\n}));\nObject.defineProperty(exports, \"QueuePicker\", ({\n    enumerable: true,\n    get: function() {\n        return picker_1.QueuePicker;\n    }\n}));\nObject.defineProperty(exports, \"PickResultType\", ({\n    enumerable: true,\n    get: function() {\n        return picker_1.PickResultType;\n    }\n}));\nvar filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nObject.defineProperty(exports, \"BaseFilter\", ({\n    enumerable: true,\n    get: function() {\n        return filter_1.BaseFilter;\n    }\n}));\nvar filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\nObject.defineProperty(exports, \"FilterStackFactory\", ({\n    enumerable: true,\n    get: function() {\n        return filter_stack_1.FilterStackFactory;\n    }\n}));\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nObject.defineProperty(exports, \"registerAdminService\", ({\n    enumerable: true,\n    get: function() {\n        return admin_1.registerAdminService;\n    }\n}));\nvar subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\nObject.defineProperty(exports, \"BaseSubchannelWrapper\", ({\n    enumerable: true,\n    get: function() {\n        return subchannel_interface_1.BaseSubchannelWrapper;\n    }\n}));\nvar load_balancer_outlier_detection_1 = __webpack_require__(/*! ./load-balancer-outlier-detection */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\");\nObject.defineProperty(exports, \"OutlierDetectionLoadBalancingConfig\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_outlier_detection_1.OutlierDetectionLoadBalancingConfig;\n    }\n})); //# sourceMappingURL=experimental.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZXhwZXJpbWVudGFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELElBQUlDLFlBQVlDLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DTCx5Q0FBd0M7SUFBRU0sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsVUFBVUksS0FBSztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzNHUix1Q0FBc0M7SUFBRU0sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsVUFBVUssR0FBRztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3ZHLElBQUlDLGFBQWFMLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3JDTCxvREFBbUQ7SUFBRU0sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0csV0FBV0MsZ0JBQWdCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDbEksSUFBSUMsZUFBZVAsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDekNMLCtDQUE4QztJQUFFTSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSyxhQUFhQyxXQUFXO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDMUgsSUFBSUMsYUFBYVQsbUJBQU9BLENBQUMsNEVBQVk7QUFDckNMLGdEQUErQztJQUFFTSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPTyxXQUFXQyxZQUFZO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDMUgsSUFBSUMsb0JBQW9CWCxtQkFBT0EsQ0FBQywwRkFBbUI7QUFDbkRMLGtEQUFpRDtJQUFFTSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPUyxrQkFBa0JDLGNBQWM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNySSxJQUFJQyxrQkFBa0JiLG1CQUFPQSxDQUFDLHNGQUFpQjtBQUMvQ0wsbUVBQWtFO0lBQUVNLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9XLGdCQUFnQkMsK0JBQStCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDcktuQiw0REFBMkQ7SUFBRU0sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT1csZ0JBQWdCRSx3QkFBd0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN2SnBCLHdEQUF1RDtJQUFFTSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPVyxnQkFBZ0JHLG9CQUFvQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQy9JckIsK0RBQThEO0lBQUVNLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9XLGdCQUFnQkksMkJBQTJCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDN0osSUFBSUMsdUJBQXVCbEIsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQ3pETCw2REFBNEQ7SUFBRU0sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT2dCLHFCQUFxQkMseUJBQXlCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDOUosSUFBSUMsZ0NBQWdDcEIsbUJBQU9BLENBQUMsa0hBQStCO0FBQzNFTCw0REFBMkQ7SUFBRU0sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT2tCLDhCQUE4QkMsd0JBQXdCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDckssSUFBSUMsV0FBV3RCLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ2pDTCxxREFBb0Q7SUFBRU0sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFNBQVNDLGlCQUFpQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2xJNUIsK0NBQThDO0lBQUVNLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixTQUFTRSxXQUFXO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDdEg3QixrREFBaUQ7SUFBRU0sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFNBQVNHLGNBQWM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM1SCxJQUFJQyxXQUFXMUIsbUJBQU9BLENBQUMsd0VBQVU7QUFDakNMLDhDQUE2QztJQUFFTSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPd0IsU0FBU0MsVUFBVTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3BILElBQUlDLGlCQUFpQjVCLG1CQUFPQSxDQUFDLG9GQUFnQjtBQUM3Q0wsc0RBQXFEO0lBQUVNLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU8wQixlQUFlQyxrQkFBa0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMxSSxJQUFJQyxVQUFVOUIsbUJBQU9BLENBQUMsc0VBQVM7QUFDL0JMLHdEQUF1RDtJQUFFTSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPNEIsUUFBUUMsb0JBQW9CO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDdkksSUFBSUMseUJBQXlCaEMsbUJBQU9BLENBQUMsb0dBQXdCO0FBQzdETCx5REFBd0Q7SUFBRU0sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBTzhCLHVCQUF1QkMscUJBQXFCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDeEosSUFBSUMsb0NBQW9DbEMsbUJBQU9BLENBQUMsMEhBQW1DO0FBQ25GTCx1RUFBc0U7SUFBRU0sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT2dDLGtDQUFrQ0MsbUNBQW1DO0lBQUU7QUFBRSxDQUFDLEVBQUMsRUFDL0wsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNobWl0dC1ndXB0YS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9leHBlcmltZW50YWwuanM/NGFkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidHJhY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvZ2dpbmdfMS50cmFjZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9nZ2luZ18xLmxvZzsgfSB9KTtcbnZhciByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWdpc3RlclJlc29sdmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXI7IH0gfSk7XG52YXIgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVyaVRvU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmc7IH0gfSk7XG52YXIgZHVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL2R1cmF0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZHVyYXRpb25Ub01zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkdXJhdGlvbl8xLmR1cmF0aW9uVG9NczsgfSB9KTtcbnZhciBiYWNrb2ZmX3RpbWVvdXRfMSA9IHJlcXVpcmUoXCIuL2JhY2tvZmYtdGltZW91dFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhY2tvZmZUaW1lb3V0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYWNrb2ZmX3RpbWVvdXRfMS5CYWNrb2ZmVGltZW91dDsgfSB9KTtcbnZhciBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl8xLmNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWdpc3RlckxvYWRCYWxhbmNlclR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvYWRfYmFsYW5jZXJfMS5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRGaXJzdFVzYWJsZUNvbmZpZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl8xLmdldEZpcnN0VXNhYmxlQ29uZmlnOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyXzEudmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnOyB9IH0pO1xudmFyIHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZzsgfSB9KTtcbnZhciBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItY2hpbGQtaGFuZGxlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNoaWxkTG9hZEJhbGFuY2VySGFuZGxlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyOyB9IH0pO1xudmFyIHBpY2tlcl8xID0gcmVxdWlyZShcIi4vcGlja2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVW5hdmFpbGFibGVQaWNrZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUXVldWVQaWNrZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBpY2tlcl8xLlF1ZXVlUGlja2VyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGlja1Jlc3VsdFR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlOyB9IH0pO1xudmFyIGZpbHRlcl8xID0gcmVxdWlyZShcIi4vZmlsdGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFzZUZpbHRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmlsdGVyXzEuQmFzZUZpbHRlcjsgfSB9KTtcbnZhciBmaWx0ZXJfc3RhY2tfMSA9IHJlcXVpcmUoXCIuL2ZpbHRlci1zdGFja1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZpbHRlclN0YWNrRmFjdG9yeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmlsdGVyX3N0YWNrXzEuRmlsdGVyU3RhY2tGYWN0b3J5OyB9IH0pO1xudmFyIGFkbWluXzEgPSByZXF1aXJlKFwiLi9hZG1pblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZ2lzdGVyQWRtaW5TZXJ2aWNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhZG1pbl8xLnJlZ2lzdGVyQWRtaW5TZXJ2aWNlOyB9IH0pO1xudmFyIHN1YmNoYW5uZWxfaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWludGVyZmFjZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhc2VTdWJjaGFubmVsV3JhcHBlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3ViY2hhbm5lbF9pbnRlcmZhY2VfMS5CYXNlU3ViY2hhbm5lbFdyYXBwZXI7IH0gfSk7XG52YXIgbG9hZF9iYWxhbmNlcl9vdXRsaWVyX2RldGVjdGlvbl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1vdXRsaWVyLWRldGVjdGlvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyX291dGxpZXJfZGV0ZWN0aW9uXzEuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWc7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHBlcmltZW50YWwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibG9nZ2luZ18xIiwicmVxdWlyZSIsImVudW1lcmFibGUiLCJnZXQiLCJ0cmFjZSIsImxvZyIsInJlc29sdmVyXzEiLCJyZWdpc3RlclJlc29sdmVyIiwidXJpX3BhcnNlcl8xIiwidXJpVG9TdHJpbmciLCJkdXJhdGlvbl8xIiwiZHVyYXRpb25Ub01zIiwiYmFja29mZl90aW1lb3V0XzEiLCJCYWNrb2ZmVGltZW91dCIsImxvYWRfYmFsYW5jZXJfMSIsImNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIiLCJyZWdpc3RlckxvYWRCYWxhbmNlclR5cGUiLCJnZXRGaXJzdFVzYWJsZUNvbmZpZyIsInZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZyIsInN1YmNoYW5uZWxfYWRkcmVzc18xIiwic3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyIsImxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xIiwiQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyIiwicGlja2VyXzEiLCJVbmF2YWlsYWJsZVBpY2tlciIsIlF1ZXVlUGlja2VyIiwiUGlja1Jlc3VsdFR5cGUiLCJmaWx0ZXJfMSIsIkJhc2VGaWx0ZXIiLCJmaWx0ZXJfc3RhY2tfMSIsIkZpbHRlclN0YWNrRmFjdG9yeSIsImFkbWluXzEiLCJyZWdpc3RlckFkbWluU2VydmljZSIsInN1YmNoYW5uZWxfaW50ZXJmYWNlXzEiLCJCYXNlU3ViY2hhbm5lbFdyYXBwZXIiLCJsb2FkX2JhbGFuY2VyX291dGxpZXJfZGV0ZWN0aW9uXzEiLCJPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/experimental.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter-stack.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FilterStackFactory = exports.FilterStack = void 0;\nclass FilterStack {\n    constructor(filters){\n        this.filters = filters;\n    }\n    sendMetadata(metadata) {\n        let result = metadata;\n        for(let i = 0; i < this.filters.length; i++){\n            result = this.filters[i].sendMetadata(result);\n        }\n        return result;\n    }\n    receiveMetadata(metadata) {\n        let result = metadata;\n        for(let i = this.filters.length - 1; i >= 0; i--){\n            result = this.filters[i].receiveMetadata(result);\n        }\n        return result;\n    }\n    sendMessage(message) {\n        let result = message;\n        for(let i = 0; i < this.filters.length; i++){\n            result = this.filters[i].sendMessage(result);\n        }\n        return result;\n    }\n    receiveMessage(message) {\n        let result = message;\n        for(let i = this.filters.length - 1; i >= 0; i--){\n            result = this.filters[i].receiveMessage(result);\n        }\n        return result;\n    }\n    receiveTrailers(status) {\n        let result = status;\n        for(let i = this.filters.length - 1; i >= 0; i--){\n            result = this.filters[i].receiveTrailers(result);\n        }\n        return result;\n    }\n    refresh() {\n        for (const filter of this.filters){\n            filter.refresh();\n        }\n    }\n    push(filters) {\n        this.filters.unshift(...filters);\n    }\n    getFilters() {\n        return this.filters;\n    }\n}\nexports.FilterStack = FilterStack;\nclass FilterStackFactory {\n    constructor(factories){\n        this.factories = factories;\n    }\n    push(filterFactories) {\n        this.factories.unshift(...filterFactories);\n    }\n    createFilter(callStream) {\n        return new FilterStack(this.factories.map((factory)=>factory.createFilter(callStream)));\n    }\n}\nexports.FilterStackFactory = FilterStackFactory; //# sourceMappingURL=filter-stack.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLXN0YWNrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQkFBMEIsR0FBR0EsbUJBQW1CLEdBQUcsS0FBSztBQUN4RCxNQUFNRztJQUNGQyxZQUFZQyxPQUFPLENBQUU7UUFDakIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ25CO0lBQ0FDLGFBQWFDLFFBQVEsRUFBRTtRQUNuQixJQUFJQyxTQUFTRDtRQUNiLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ0osT0FBTyxDQUFDSyxNQUFNLEVBQUVELElBQUs7WUFDMUNELFNBQVMsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEVBQUUsQ0FBQ0gsWUFBWSxDQUFDRTtRQUMxQztRQUNBLE9BQU9BO0lBQ1g7SUFDQUcsZ0JBQWdCSixRQUFRLEVBQUU7UUFDdEIsSUFBSUMsU0FBU0Q7UUFDYixJQUFLLElBQUlFLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLE1BQU0sR0FBRyxHQUFHRCxLQUFLLEdBQUdBLElBQUs7WUFDL0NELFNBQVMsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEVBQUUsQ0FBQ0UsZUFBZSxDQUFDSDtRQUM3QztRQUNBLE9BQU9BO0lBQ1g7SUFDQUksWUFBWUMsT0FBTyxFQUFFO1FBQ2pCLElBQUlMLFNBQVNLO1FBQ2IsSUFBSyxJQUFJSixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLE1BQU0sRUFBRUQsSUFBSztZQUMxQ0QsU0FBUyxJQUFJLENBQUNILE9BQU8sQ0FBQ0ksRUFBRSxDQUFDRyxXQUFXLENBQUNKO1FBQ3pDO1FBQ0EsT0FBT0E7SUFDWDtJQUNBTSxlQUFlRCxPQUFPLEVBQUU7UUFDcEIsSUFBSUwsU0FBU0s7UUFDYixJQUFLLElBQUlKLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLE1BQU0sR0FBRyxHQUFHRCxLQUFLLEdBQUdBLElBQUs7WUFDL0NELFNBQVMsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEVBQUUsQ0FBQ0ssY0FBYyxDQUFDTjtRQUM1QztRQUNBLE9BQU9BO0lBQ1g7SUFDQU8sZ0JBQWdCQyxNQUFNLEVBQUU7UUFDcEIsSUFBSVIsU0FBU1E7UUFDYixJQUFLLElBQUlQLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLE1BQU0sR0FBRyxHQUFHRCxLQUFLLEdBQUdBLElBQUs7WUFDL0NELFNBQVMsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEVBQUUsQ0FBQ00sZUFBZSxDQUFDUDtRQUM3QztRQUNBLE9BQU9BO0lBQ1g7SUFDQVMsVUFBVTtRQUNOLEtBQUssTUFBTUMsVUFBVSxJQUFJLENBQUNiLE9BQU8sQ0FBRTtZQUMvQmEsT0FBT0QsT0FBTztRQUNsQjtJQUNKO0lBQ0FFLEtBQUtkLE9BQU8sRUFBRTtRQUNWLElBQUksQ0FBQ0EsT0FBTyxDQUFDZSxPQUFPLElBQUlmO0lBQzVCO0lBQ0FnQixhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUNoQixPQUFPO0lBQ3ZCO0FBQ0o7QUFDQUwsbUJBQW1CLEdBQUdHO0FBQ3RCLE1BQU1EO0lBQ0ZFLFlBQVlrQixTQUFTLENBQUU7UUFDbkIsSUFBSSxDQUFDQSxTQUFTLEdBQUdBO0lBQ3JCO0lBQ0FILEtBQUtJLGVBQWUsRUFBRTtRQUNsQixJQUFJLENBQUNELFNBQVMsQ0FBQ0YsT0FBTyxJQUFJRztJQUM5QjtJQUNBQyxhQUFhQyxVQUFVLEVBQUU7UUFDckIsT0FBTyxJQUFJdEIsWUFBWSxJQUFJLENBQUNtQixTQUFTLENBQUNJLEdBQUcsQ0FBQyxDQUFDQyxVQUFZQSxRQUFRSCxZQUFZLENBQUNDO0lBQ2hGO0FBQ0o7QUFDQXpCLDBCQUEwQixHQUFHRSxvQkFDN0Isd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNobWl0dC1ndXB0YS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9maWx0ZXItc3RhY2suanM/NzUzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GaWx0ZXJTdGFja0ZhY3RvcnkgPSBleHBvcnRzLkZpbHRlclN0YWNrID0gdm9pZCAwO1xuY2xhc3MgRmlsdGVyU3RhY2sge1xuICAgIGNvbnN0cnVjdG9yKGZpbHRlcnMpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcbiAgICB9XG4gICAgc2VuZE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBtZXRhZGF0YTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyc1tpXS5zZW5kTWV0YWRhdGEocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG1ldGFkYXRhO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmZpbHRlcnNbaV0ucmVjZWl2ZU1ldGFkYXRhKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbWVzc2FnZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyc1tpXS5zZW5kTWVzc2FnZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG1lc3NhZ2U7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZpbHRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyc1tpXS5yZWNlaXZlTWVzc2FnZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlY2VpdmVUcmFpbGVycyhzdGF0dXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHN0YXR1cztcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZmlsdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXJzW2ldLnJlY2VpdmVUcmFpbGVycyhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHRoaXMuZmlsdGVycykge1xuICAgICAgICAgICAgZmlsdGVyLnJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXNoKGZpbHRlcnMpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJzLnVuc2hpZnQoLi4uZmlsdGVycyk7XG4gICAgfVxuICAgIGdldEZpbHRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcnM7XG4gICAgfVxufVxuZXhwb3J0cy5GaWx0ZXJTdGFjayA9IEZpbHRlclN0YWNrO1xuY2xhc3MgRmlsdGVyU3RhY2tGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3JpZXMpIHtcbiAgICAgICAgdGhpcy5mYWN0b3JpZXMgPSBmYWN0b3JpZXM7XG4gICAgfVxuICAgIHB1c2goZmlsdGVyRmFjdG9yaWVzKSB7XG4gICAgICAgIHRoaXMuZmFjdG9yaWVzLnVuc2hpZnQoLi4uZmlsdGVyRmFjdG9yaWVzKTtcbiAgICB9XG4gICAgY3JlYXRlRmlsdGVyKGNhbGxTdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJTdGFjayh0aGlzLmZhY3Rvcmllcy5tYXAoKGZhY3RvcnkpID0+IGZhY3RvcnkuY3JlYXRlRmlsdGVyKGNhbGxTdHJlYW0pKSk7XG4gICAgfVxufVxuZXhwb3J0cy5GaWx0ZXJTdGFja0ZhY3RvcnkgPSBGaWx0ZXJTdGFja0ZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXItc3RhY2suanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRmlsdGVyU3RhY2tGYWN0b3J5IiwiRmlsdGVyU3RhY2siLCJjb25zdHJ1Y3RvciIsImZpbHRlcnMiLCJzZW5kTWV0YWRhdGEiLCJtZXRhZGF0YSIsInJlc3VsdCIsImkiLCJsZW5ndGgiLCJyZWNlaXZlTWV0YWRhdGEiLCJzZW5kTWVzc2FnZSIsIm1lc3NhZ2UiLCJyZWNlaXZlTWVzc2FnZSIsInJlY2VpdmVUcmFpbGVycyIsInN0YXR1cyIsInJlZnJlc2giLCJmaWx0ZXIiLCJwdXNoIiwidW5zaGlmdCIsImdldEZpbHRlcnMiLCJmYWN0b3JpZXMiLCJmaWx0ZXJGYWN0b3JpZXMiLCJjcmVhdGVGaWx0ZXIiLCJjYWxsU3RyZWFtIiwibWFwIiwiZmFjdG9yeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BaseFilter = void 0;\nclass BaseFilter {\n    async sendMetadata(metadata) {\n        return metadata;\n    }\n    receiveMetadata(metadata) {\n        return metadata;\n    }\n    async sendMessage(message) {\n        return message;\n    }\n    async receiveMessage(message) {\n        return message;\n    }\n    receiveTrailers(status) {\n        return status;\n    }\n    refresh() {}\n}\nexports.BaseFilter = BaseFilter; //# sourceMappingURL=filter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBa0IsR0FBRyxLQUFLO0FBQzFCLE1BQU1FO0lBQ0YsTUFBTUMsYUFBYUMsUUFBUSxFQUFFO1FBQ3pCLE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCRCxRQUFRLEVBQUU7UUFDdEIsT0FBT0E7SUFDWDtJQUNBLE1BQU1FLFlBQVlDLE9BQU8sRUFBRTtRQUN2QixPQUFPQTtJQUNYO0lBQ0EsTUFBTUMsZUFBZUQsT0FBTyxFQUFFO1FBQzFCLE9BQU9BO0lBQ1g7SUFDQUUsZ0JBQWdCQyxNQUFNLEVBQUU7UUFDcEIsT0FBT0E7SUFDWDtJQUNBQyxVQUFVLENBQUU7QUFDaEI7QUFDQVgsa0JBQWtCLEdBQUdFLFlBQ3JCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FzaG1pdHQtZ3VwdGEvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLmpzPzBmMzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZUZpbHRlciA9IHZvaWQgMDtcbmNsYXNzIEJhc2VGaWx0ZXIge1xuICAgIGFzeW5jIHNlbmRNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgfVxuICAgIHJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIHJlY2VpdmVUcmFpbGVycyhzdGF0dXMpIHtcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG4gICAgcmVmcmVzaCgpIHsgfVxufVxuZXhwb3J0cy5CYXNlRmlsdGVyID0gQmFzZUZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJCYXNlRmlsdGVyIiwic2VuZE1ldGFkYXRhIiwibWV0YWRhdGEiLCJyZWNlaXZlTWV0YWRhdGEiLCJzZW5kTWVzc2FnZSIsIm1lc3NhZ2UiLCJyZWNlaXZlTWVzc2FnZSIsInJlY2VpdmVUcmFpbGVycyIsInN0YXR1cyIsInJlZnJlc2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/http_proxy.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getProxiedConnection = exports.mapProxyName = void 0;\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst TRACER_NAME = \"proxy\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nfunction getProxyInfo() {\n    let proxyEnv = \"\";\n    let envVar = \"\";\n    /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n     * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n     * fallback behavior can be removed if there's a demand for it.\n     */ if (process.env.grpc_proxy) {\n        envVar = \"grpc_proxy\";\n        proxyEnv = process.env.grpc_proxy;\n    } else if (process.env.https_proxy) {\n        envVar = \"https_proxy\";\n        proxyEnv = process.env.https_proxy;\n    } else if (process.env.http_proxy) {\n        envVar = \"http_proxy\";\n        proxyEnv = process.env.http_proxy;\n    } else {\n        return {};\n    }\n    let proxyUrl;\n    try {\n        proxyUrl = new url_1.URL(proxyEnv);\n    } catch (e) {\n        logging_1.log(constants_1.LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n        return {};\n    }\n    if (proxyUrl.protocol !== \"http:\") {\n        logging_1.log(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\n        return {};\n    }\n    let userCred = null;\n    if (proxyUrl.username) {\n        if (proxyUrl.password) {\n            logging_1.log(constants_1.LogVerbosity.INFO, \"userinfo found in proxy URI\");\n            userCred = `${proxyUrl.username}:${proxyUrl.password}`;\n        } else {\n            userCred = proxyUrl.username;\n        }\n    }\n    const hostname = proxyUrl.hostname;\n    let port = proxyUrl.port;\n    /* The proxy URL uses the scheme \"http:\", which has a default port number of\n     * 80. We need to set that explicitly here if it is omitted because otherwise\n     * it will use gRPC's default port 443. */ if (port === \"\") {\n        port = \"80\";\n    }\n    const result = {\n        address: `${hostname}:${port}`\n    };\n    if (userCred) {\n        result.creds = userCred;\n    }\n    trace(\"Proxy server \" + result.address + \" set by environment variable \" + envVar);\n    return result;\n}\nfunction getNoProxyHostList() {\n    /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */ let noProxyStr = process.env.no_grpc_proxy;\n    let envVar = \"no_grpc_proxy\";\n    if (!noProxyStr) {\n        noProxyStr = process.env.no_proxy;\n        envVar = \"no_proxy\";\n    }\n    if (noProxyStr) {\n        trace(\"No proxy server list set by environment variable \" + envVar);\n        return noProxyStr.split(\",\");\n    } else {\n        return [];\n    }\n}\nfunction mapProxyName(target, options) {\n    var _a;\n    const noProxyResult = {\n        target: target,\n        extraOptions: {}\n    };\n    if (((_a = options[\"grpc.enable_http_proxy\"]) !== null && _a !== void 0 ? _a : 1) === 0) {\n        return noProxyResult;\n    }\n    if (target.scheme === \"unix\") {\n        return noProxyResult;\n    }\n    const proxyInfo = getProxyInfo();\n    if (!proxyInfo.address) {\n        return noProxyResult;\n    }\n    const hostPort = uri_parser_1.splitHostPort(target.path);\n    if (!hostPort) {\n        return noProxyResult;\n    }\n    const serverHost = hostPort.host;\n    for (const host of getNoProxyHostList()){\n        if (host === serverHost) {\n            trace(\"Not using proxy for target in no_proxy list: \" + uri_parser_1.uriToString(target));\n            return noProxyResult;\n        }\n    }\n    const extraOptions = {\n        \"grpc.http_connect_target\": uri_parser_1.uriToString(target)\n    };\n    if (proxyInfo.creds) {\n        extraOptions[\"grpc.http_connect_creds\"] = proxyInfo.creds;\n    }\n    return {\n        target: {\n            scheme: \"dns\",\n            path: proxyInfo.address\n        },\n        extraOptions: extraOptions\n    };\n}\nexports.mapProxyName = mapProxyName;\nfunction getProxiedConnection(address, channelOptions, connectionOptions) {\n    if (!(\"grpc.http_connect_target\" in channelOptions)) {\n        return Promise.resolve({});\n    }\n    const realTarget = channelOptions[\"grpc.http_connect_target\"];\n    const parsedTarget = uri_parser_1.parseUri(realTarget);\n    if (parsedTarget === null) {\n        return Promise.resolve({});\n    }\n    const options = {\n        method: \"CONNECT\",\n        path: parsedTarget.path\n    };\n    const headers = {\n        Host: parsedTarget.path\n    };\n    // Connect to the subchannel address as a proxy\n    if (subchannel_address_1.isTcpSubchannelAddress(address)) {\n        options.host = address.host;\n        options.port = address.port;\n    } else {\n        options.socketPath = address.path;\n    }\n    if (\"grpc.http_connect_creds\" in channelOptions) {\n        headers[\"Proxy-Authorization\"] = \"Basic \" + Buffer.from(channelOptions[\"grpc.http_connect_creds\"]).toString(\"base64\");\n    }\n    options.headers = headers;\n    const proxyAddressString = subchannel_address_1.subchannelAddressToString(address);\n    trace(\"Using proxy \" + proxyAddressString + \" to connect to \" + options.path);\n    return new Promise((resolve, reject)=>{\n        const request = http.request(options);\n        request.once(\"connect\", (res, socket, head)=>{\n            var _a;\n            request.removeAllListeners();\n            socket.removeAllListeners();\n            if (res.statusCode === 200) {\n                trace(\"Successfully connected to \" + options.path + \" through proxy \" + proxyAddressString);\n                if (\"secureContext\" in connectionOptions) {\n                    /* The proxy is connecting to a TLS server, so upgrade this socket\n                     * connection to a TLS connection.\n                     * This is a workaround for https://github.com/nodejs/node/issues/32922\n                     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */ const targetPath = resolver_1.getDefaultAuthority(parsedTarget);\n                    const hostPort = uri_parser_1.splitHostPort(targetPath);\n                    const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;\n                    const cts = tls.connect(Object.assign({\n                        host: remoteHost,\n                        servername: remoteHost,\n                        socket: socket\n                    }, connectionOptions), ()=>{\n                        trace(\"Successfully established a TLS connection to \" + options.path + \" through proxy \" + proxyAddressString);\n                        resolve({\n                            socket: cts,\n                            realTarget: parsedTarget\n                        });\n                    });\n                    cts.on(\"error\", (error)=>{\n                        trace(\"Failed to establish a TLS connection to \" + options.path + \" through proxy \" + proxyAddressString + \" with error \" + error.message);\n                        reject();\n                    });\n                } else {\n                    trace(\"Successfully established a plaintext connection to \" + options.path + \" through proxy \" + proxyAddressString);\n                    resolve({\n                        socket,\n                        realTarget: parsedTarget\n                    });\n                }\n            } else {\n                logging_1.log(constants_1.LogVerbosity.ERROR, \"Failed to connect to \" + options.path + \" through proxy \" + proxyAddressString + \" with status \" + res.statusCode);\n                reject();\n            }\n        });\n        request.once(\"error\", (err)=>{\n            request.removeAllListeners();\n            logging_1.log(constants_1.LogVerbosity.ERROR, \"Failed to connect to proxy \" + proxyAddressString + \" with error \" + err.message);\n            reject();\n        });\n        request.end();\n    });\n}\nexports.getProxiedConnection = getProxiedConnection; //# sourceMappingURL=http_proxy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaHR0cF9wcm94eS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNEJBQTRCLEdBQUdBLG9CQUFvQixHQUFHLEtBQUs7QUFDM0QsTUFBTUksWUFBWUMsbUJBQU9BLENBQUMsMEVBQVc7QUFDckMsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUUsYUFBYUYsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUcsT0FBT0gsbUJBQU9BLENBQUMsa0JBQU07QUFDM0IsTUFBTUksTUFBTUosbUJBQU9BLENBQUMsZ0JBQUs7QUFDekIsTUFBTUssVUFBVUwsbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTU0sdUJBQXVCTixtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTU8sZUFBZVAsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTVEsUUFBUVIsbUJBQU9BLENBQUMsZ0JBQUs7QUFDM0IsTUFBTVMsY0FBYztBQUNwQixTQUFTQyxNQUFNQyxJQUFJO0lBQ2ZOLFFBQVFLLEtBQUssQ0FBQ1QsWUFBWVcsWUFBWSxDQUFDQyxLQUFLLEVBQUVKLGFBQWFFO0FBQy9EO0FBQ0EsU0FBU0c7SUFDTCxJQUFJQyxXQUFXO0lBQ2YsSUFBSUMsU0FBUztJQUNiOzs7S0FHQyxHQUNELElBQUlDLFFBQVFDLEdBQUcsQ0FBQ0MsVUFBVSxFQUFFO1FBQ3hCSCxTQUFTO1FBQ1RELFdBQVdFLFFBQVFDLEdBQUcsQ0FBQ0MsVUFBVTtJQUNyQyxPQUNLLElBQUlGLFFBQVFDLEdBQUcsQ0FBQ0UsV0FBVyxFQUFFO1FBQzlCSixTQUFTO1FBQ1RELFdBQVdFLFFBQVFDLEdBQUcsQ0FBQ0UsV0FBVztJQUN0QyxPQUNLLElBQUlILFFBQVFDLEdBQUcsQ0FBQ0csVUFBVSxFQUFF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RCxNQUFNLHdEQUNGaUMsUUFBUVEsSUFBSSxHQUNaLG9CQUNBbUI7b0JBQ0paLFFBQVE7d0JBQ0prQjt3QkFDQWpCLFlBQVlDO29CQUNoQjtnQkFDSjtZQUNKLE9BQ0s7Z0JBQ0Q3RCxVQUFVMEIsR0FBRyxDQUFDeEIsWUFBWVcsWUFBWSxDQUFDYyxLQUFLLEVBQUUsMEJBQzFDaUIsUUFBUVEsSUFBSSxHQUNaLG9CQUNBbUIscUJBQ0Esa0JBQ0FLLElBQUlJLFVBQVU7Z0JBQ2xCUDtZQUNKO1FBQ0o7UUFDQUMsUUFBUUMsSUFBSSxDQUFDLFNBQVMsQ0FBQ2dCO1lBQ25CakIsUUFBUUssa0JBQWtCO1lBQzFCL0UsVUFBVTBCLEdBQUcsQ0FBQ3hCLFlBQVlXLFlBQVksQ0FBQ2MsS0FBSyxFQUFFLGdDQUMxQzRDLHFCQUNBLGlCQUNBb0IsSUFBSUQsT0FBTztZQUNmakI7UUFDSjtRQUNBQyxRQUFRa0IsR0FBRztJQUNmO0FBQ0o7QUFDQWhHLDRCQUE0QixHQUFHRSxzQkFDL0Isc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNobWl0dC1ndXB0YS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9odHRwX3Byb3h5LmpzPzI4ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0UHJveGllZENvbm5lY3Rpb24gPSBleHBvcnRzLm1hcFByb3h5TmFtZSA9IHZvaWQgMDtcbmNvbnN0IGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKFwiaHR0cFwiKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoXCJ0bHNcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3Byb3h5JztcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xufVxuZnVuY3Rpb24gZ2V0UHJveHlJbmZvKCkge1xuICAgIGxldCBwcm94eUVudiA9ICcnO1xuICAgIGxldCBlbnZWYXIgPSAnJztcbiAgICAvKiBQcmVmZXIgdXNpbmcgJ2dycGNfcHJveHknLiBGYWxsYmFjayBvbiAnaHR0cF9wcm94eScgaWYgaXQgaXMgbm90IHNldC5cbiAgICAgKiBBbHNvIHByZWZlciB1c2luZyAnaHR0cHNfcHJveHknIHdpdGggZmFsbGJhY2sgb24gJ2h0dHBfcHJveHknLiBUaGVcbiAgICAgKiBmYWxsYmFjayBiZWhhdmlvciBjYW4gYmUgcmVtb3ZlZCBpZiB0aGVyZSdzIGEgZGVtYW5kIGZvciBpdC5cbiAgICAgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuZ3JwY19wcm94eSkge1xuICAgICAgICBlbnZWYXIgPSAnZ3JwY19wcm94eSc7XG4gICAgICAgIHByb3h5RW52ID0gcHJvY2Vzcy5lbnYuZ3JwY19wcm94eTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuaHR0cHNfcHJveHkpIHtcbiAgICAgICAgZW52VmFyID0gJ2h0dHBzX3Byb3h5JztcbiAgICAgICAgcHJveHlFbnYgPSBwcm9jZXNzLmVudi5odHRwc19wcm94eTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuaHR0cF9wcm94eSkge1xuICAgICAgICBlbnZWYXIgPSAnaHR0cF9wcm94eSc7XG4gICAgICAgIHByb3h5RW52ID0gcHJvY2Vzcy5lbnYuaHR0cF9wcm94eTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgbGV0IHByb3h5VXJsO1xuICAgIHRyeSB7XG4gICAgICAgIHByb3h5VXJsID0gbmV3IHVybF8xLlVSTChwcm94eUVudik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCBgY2Fubm90IHBhcnNlIHZhbHVlIG9mIFwiJHtlbnZWYXJ9XCIgZW52IHZhcmApO1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChwcm94eVVybC5wcm90b2NvbCAhPT0gJ2h0dHA6Jykge1xuICAgICAgICBsb2dnaW5nXzEubG9nKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgYFwiJHtwcm94eVVybC5wcm90b2NvbH1cIiBzY2hlbWUgbm90IHN1cHBvcnRlZCBpbiBwcm94eSBVUklgKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBsZXQgdXNlckNyZWQgPSBudWxsO1xuICAgIGlmIChwcm94eVVybC51c2VybmFtZSkge1xuICAgICAgICBpZiAocHJveHlVcmwucGFzc3dvcmQpIHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LklORk8sICd1c2VyaW5mbyBmb3VuZCBpbiBwcm94eSBVUkknKTtcbiAgICAgICAgICAgIHVzZXJDcmVkID0gYCR7cHJveHlVcmwudXNlcm5hbWV9OiR7cHJveHlVcmwucGFzc3dvcmR9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVzZXJDcmVkID0gcHJveHlVcmwudXNlcm5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaG9zdG5hbWUgPSBwcm94eVVybC5ob3N0bmFtZTtcbiAgICBsZXQgcG9ydCA9IHByb3h5VXJsLnBvcnQ7XG4gICAgLyogVGhlIHByb3h5IFVSTCB1c2VzIHRoZSBzY2hlbWUgXCJodHRwOlwiLCB3aGljaCBoYXMgYSBkZWZhdWx0IHBvcnQgbnVtYmVyIG9mXG4gICAgICogODAuIFdlIG5lZWQgdG8gc2V0IHRoYXQgZXhwbGljaXRseSBoZXJlIGlmIGl0IGlzIG9taXR0ZWQgYmVjYXVzZSBvdGhlcndpc2VcbiAgICAgKiBpdCB3aWxsIHVzZSBnUlBDJ3MgZGVmYXVsdCBwb3J0IDQ0My4gKi9cbiAgICBpZiAocG9ydCA9PT0gJycpIHtcbiAgICAgICAgcG9ydCA9ICc4MCc7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgYWRkcmVzczogYCR7aG9zdG5hbWV9OiR7cG9ydH1gLFxuICAgIH07XG4gICAgaWYgKHVzZXJDcmVkKSB7XG4gICAgICAgIHJlc3VsdC5jcmVkcyA9IHVzZXJDcmVkO1xuICAgIH1cbiAgICB0cmFjZSgnUHJveHkgc2VydmVyICcgKyByZXN1bHQuYWRkcmVzcyArICcgc2V0IGJ5IGVudmlyb25tZW50IHZhcmlhYmxlICcgKyBlbnZWYXIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXROb1Byb3h5SG9zdExpc3QoKSB7XG4gICAgLyogUHJlZmVyIHVzaW5nICdub19ncnBjX3Byb3h5Jy4gRmFsbGJhY2sgb24gJ25vX3Byb3h5JyBpZiBpdCBpcyBub3Qgc2V0LiAqL1xuICAgIGxldCBub1Byb3h5U3RyID0gcHJvY2Vzcy5lbnYubm9fZ3JwY19wcm94eTtcbiAgICBsZXQgZW52VmFyID0gJ25vX2dycGNfcHJveHknO1xuICAgIGlmICghbm9Qcm94eVN0cikge1xuICAgICAgICBub1Byb3h5U3RyID0gcHJvY2Vzcy5lbnYubm9fcHJveHk7XG4gICAgICAgIGVudlZhciA9ICdub19wcm94eSc7XG4gICAgfVxuICAgIGlmIChub1Byb3h5U3RyKSB7XG4gICAgICAgIHRyYWNlKCdObyBwcm94eSBzZXJ2ZXIgbGlzdCBzZXQgYnkgZW52aXJvbm1lbnQgdmFyaWFibGUgJyArIGVudlZhcik7XG4gICAgICAgIHJldHVybiBub1Byb3h5U3RyLnNwbGl0KCcsJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwUHJveHlOYW1lKHRhcmdldCwgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBub1Byb3h5UmVzdWx0ID0ge1xuICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgZXh0cmFPcHRpb25zOiB7fSxcbiAgICB9O1xuICAgIGlmICgoKF9hID0gb3B0aW9uc1snZ3JwYy5lbmFibGVfaHR0cF9wcm94eSddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbm9Qcm94eVJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRhcmdldC5zY2hlbWUgPT09ICd1bml4Jykge1xuICAgICAgICByZXR1cm4gbm9Qcm94eVJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgcHJveHlJbmZvID0gZ2V0UHJveHlJbmZvKCk7XG4gICAgaWYgKCFwcm94eUluZm8uYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gbm9Qcm94eVJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgaG9zdFBvcnQgPSB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCh0YXJnZXQucGF0aCk7XG4gICAgaWYgKCFob3N0UG9ydCkge1xuICAgICAgICByZXR1cm4gbm9Qcm94eVJlc3VsdDtcbiAgICB9XG4gICAgY29uc3Qgc2VydmVySG9zdCA9IGhvc3RQb3J0Lmhvc3Q7XG4gICAgZm9yIChjb25zdCBob3N0IG9mIGdldE5vUHJveHlIb3N0TGlzdCgpKSB7XG4gICAgICAgIGlmIChob3N0ID09PSBzZXJ2ZXJIb3N0KSB7XG4gICAgICAgICAgICB0cmFjZSgnTm90IHVzaW5nIHByb3h5IGZvciB0YXJnZXQgaW4gbm9fcHJveHkgbGlzdDogJyArIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZyh0YXJnZXQpKTtcbiAgICAgICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV4dHJhT3B0aW9ucyA9IHtcbiAgICAgICAgJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCc6IHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZyh0YXJnZXQpLFxuICAgIH07XG4gICAgaWYgKHByb3h5SW5mby5jcmVkcykge1xuICAgICAgICBleHRyYU9wdGlvbnNbJ2dycGMuaHR0cF9jb25uZWN0X2NyZWRzJ10gPSBwcm94eUluZm8uY3JlZHM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgc2NoZW1lOiAnZG5zJyxcbiAgICAgICAgICAgIHBhdGg6IHByb3h5SW5mby5hZGRyZXNzLFxuICAgICAgICB9LFxuICAgICAgICBleHRyYU9wdGlvbnM6IGV4dHJhT3B0aW9ucyxcbiAgICB9O1xufVxuZXhwb3J0cy5tYXBQcm94eU5hbWUgPSBtYXBQcm94eU5hbWU7XG5mdW5jdGlvbiBnZXRQcm94aWVkQ29ubmVjdGlvbihhZGRyZXNzLCBjaGFubmVsT3B0aW9ucywgY29ubmVjdGlvbk9wdGlvbnMpIHtcbiAgICBpZiAoISgnZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0JyBpbiBjaGFubmVsT3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWxUYXJnZXQgPSBjaGFubmVsT3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0J107XG4gICAgY29uc3QgcGFyc2VkVGFyZ2V0ID0gdXJpX3BhcnNlcl8xLnBhcnNlVXJpKHJlYWxUYXJnZXQpO1xuICAgIGlmIChwYXJzZWRUYXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSk7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogJ0NPTk5FQ1QnLFxuICAgICAgICBwYXRoOiBwYXJzZWRUYXJnZXQucGF0aCxcbiAgICB9O1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgIEhvc3Q6IHBhcnNlZFRhcmdldC5wYXRoLFxuICAgIH07XG4gICAgLy8gQ29ubmVjdCB0byB0aGUgc3ViY2hhbm5lbCBhZGRyZXNzIGFzIGEgcHJveHlcbiAgICBpZiAoc3ViY2hhbm5lbF9hZGRyZXNzXzEuaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgICBvcHRpb25zLmhvc3QgPSBhZGRyZXNzLmhvc3Q7XG4gICAgICAgIG9wdGlvbnMucG9ydCA9IGFkZHJlc3MucG9ydDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuc29ja2V0UGF0aCA9IGFkZHJlc3MucGF0aDtcbiAgICB9XG4gICAgaWYgKCdncnBjLmh0dHBfY29ubmVjdF9jcmVkcycgaW4gY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgaGVhZGVyc1snUHJveHktQXV0aG9yaXphdGlvbiddID1cbiAgICAgICAgICAgICdCYXNpYyAnICtcbiAgICAgICAgICAgICAgICBCdWZmZXIuZnJvbShjaGFubmVsT3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfY3JlZHMnXSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH1cbiAgICBvcHRpb25zLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIGNvbnN0IHByb3h5QWRkcmVzc1N0cmluZyA9IHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcoYWRkcmVzcyk7XG4gICAgdHJhY2UoJ1VzaW5nIHByb3h5ICcgKyBwcm94eUFkZHJlc3NTdHJpbmcgKyAnIHRvIGNvbm5lY3QgdG8gJyArIG9wdGlvbnMucGF0aCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGh0dHAucmVxdWVzdChvcHRpb25zKTtcbiAgICAgICAgcmVxdWVzdC5vbmNlKCdjb25uZWN0JywgKHJlcywgc29ja2V0LCBoZWFkKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICB0cmFjZSgnU3VjY2Vzc2Z1bGx5IGNvbm5lY3RlZCB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXRoICtcbiAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgICAgICBwcm94eUFkZHJlc3NTdHJpbmcpO1xuICAgICAgICAgICAgICAgIGlmICgnc2VjdXJlQ29udGV4dCcgaW4gY29ubmVjdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogVGhlIHByb3h5IGlzIGNvbm5lY3RpbmcgdG8gYSBUTFMgc2VydmVyLCBzbyB1cGdyYWRlIHRoaXMgc29ja2V0XG4gICAgICAgICAgICAgICAgICAgICAqIGNvbm5lY3Rpb24gdG8gYSBUTFMgY29ubmVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICogVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzI5MjJcbiAgICAgICAgICAgICAgICAgICAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMtbm9kZS9wdWxsLzEzNjkgZm9yIG1vcmUgaW5mby4gKi9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0UGF0aCA9IHJlc29sdmVyXzEuZ2V0RGVmYXVsdEF1dGhvcml0eShwYXJzZWRUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBob3N0UG9ydCA9IHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KHRhcmdldFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1vdGVIb3N0ID0gKF9hID0gaG9zdFBvcnQgPT09IG51bGwgfHwgaG9zdFBvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhvc3RQb3J0Lmhvc3QpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRhcmdldFBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN0cyA9IHRscy5jb25uZWN0KE9iamVjdC5hc3NpZ24oeyBob3N0OiByZW1vdGVIb3N0LCBzZXJ2ZXJuYW1lOiByZW1vdGVIb3N0LCBzb2NrZXQ6IHNvY2tldCB9LCBjb25uZWN0aW9uT3B0aW9ucyksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlKCdTdWNjZXNzZnVsbHkgZXN0YWJsaXNoZWQgYSBUTFMgY29ubmVjdGlvbiB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhdGggK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgdGhyb3VnaCBwcm94eSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eUFkZHJlc3NTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHNvY2tldDogY3RzLCByZWFsVGFyZ2V0OiBwYXJzZWRUYXJnZXQgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjdHMub24oJ2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZSgnRmFpbGVkIHRvIGVzdGFibGlzaCBhIFRMUyBjb25uZWN0aW9uIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGF0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5QWRkcmVzc1N0cmluZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB3aXRoIGVycm9yICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ1N1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlZCBhIHBsYWludGV4dCBjb25uZWN0aW9uIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXRoICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgdGhyb3VnaCBwcm94eSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5QWRkcmVzc1N0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhbFRhcmdldDogcGFyc2VkVGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnaW5nXzEubG9nKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgJ0ZhaWxlZCB0byBjb25uZWN0IHRvICcgK1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhdGggK1xuICAgICAgICAgICAgICAgICAgICAnIHRocm91Z2ggcHJveHkgJyArXG4gICAgICAgICAgICAgICAgICAgIHByb3h5QWRkcmVzc1N0cmluZyArXG4gICAgICAgICAgICAgICAgICAgICcgd2l0aCBzdGF0dXMgJyArXG4gICAgICAgICAgICAgICAgICAgIHJlcy5zdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3Qub25jZSgnZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsICdGYWlsZWQgdG8gY29ubmVjdCB0byBwcm94eSAnICtcbiAgICAgICAgICAgICAgICBwcm94eUFkZHJlc3NTdHJpbmcgK1xuICAgICAgICAgICAgICAgICcgd2l0aCBlcnJvciAnICtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3QuZW5kKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmdldFByb3hpZWRDb25uZWN0aW9uID0gZ2V0UHJveGllZENvbm5lY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odHRwX3Byb3h5LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldFByb3hpZWRDb25uZWN0aW9uIiwibWFwUHJveHlOYW1lIiwibG9nZ2luZ18xIiwicmVxdWlyZSIsImNvbnN0YW50c18xIiwicmVzb2x2ZXJfMSIsImh0dHAiLCJ0bHMiLCJsb2dnaW5nIiwic3ViY2hhbm5lbF9hZGRyZXNzXzEiLCJ1cmlfcGFyc2VyXzEiLCJ1cmxfMSIsIlRSQUNFUl9OQU1FIiwidHJhY2UiLCJ0ZXh0IiwiTG9nVmVyYm9zaXR5IiwiREVCVUciLCJnZXRQcm94eUluZm8iLCJwcm94eUVudiIsImVudlZhciIsInByb2Nlc3MiLCJlbnYiLCJncnBjX3Byb3h5IiwiaHR0cHNfcHJveHkiLCJodHRwX3Byb3h5IiwicHJveHlVcmwiLCJVUkwiLCJlIiwibG9nIiwiRVJST1IiLCJwcm90b2NvbCIsInVzZXJDcmVkIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsIklORk8iLCJob3N0bmFtZSIsInBvcnQiLCJyZXN1bHQiLCJhZGRyZXNzIiwiY3JlZHMiLCJnZXROb1Byb3h5SG9zdExpc3QiLCJub1Byb3h5U3RyIiwibm9fZ3JwY19wcm94eSIsIm5vX3Byb3h5Iiwic3BsaXQiLCJ0YXJnZXQiLCJvcHRpb25zIiwiX2EiLCJub1Byb3h5UmVzdWx0IiwiZXh0cmFPcHRpb25zIiwic2NoZW1lIiwicHJveHlJbmZvIiwiaG9zdFBvcnQiLCJzcGxpdEhvc3RQb3J0IiwicGF0aCIsInNlcnZlckhvc3QiLCJob3N0IiwidXJpVG9TdHJpbmciLCJjaGFubmVsT3B0aW9ucyIsImNvbm5lY3Rpb25PcHRpb25zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWFsVGFyZ2V0IiwicGFyc2VkVGFyZ2V0IiwicGFyc2VVcmkiLCJtZXRob2QiLCJoZWFkZXJzIiwiSG9zdCIsImlzVGNwU3ViY2hhbm5lbEFkZHJlc3MiLCJzb2NrZXRQYXRoIiwiQnVmZmVyIiwiZnJvbSIsInRvU3RyaW5nIiwicHJveHlBZGRyZXNzU3RyaW5nIiwic3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyIsInJlamVjdCIsInJlcXVlc3QiLCJvbmNlIiwicmVzIiwic29ja2V0IiwiaGVhZCIsInJlbW92ZUFsbExpc3RlbmVycyIsInN0YXR1c0NvZGUiLCJ0YXJnZXRQYXRoIiwiZ2V0RGVmYXVsdEF1dGhvcml0eSIsInJlbW90ZUhvc3QiLCJjdHMiLCJjb25uZWN0IiwiYXNzaWduIiwic2VydmVybmFtZSIsIm9uIiwiZXJyb3IiLCJtZXNzYWdlIiwiZXJyIiwiZW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.experimental = exports.StatusBuilder = exports.getClientChannel = exports.ServerCredentials = exports.Server = exports.setLogVerbosity = exports.setLogger = exports.load = exports.loadObject = exports.CallCredentials = exports.ChannelCredentials = exports.waitForClientReady = exports.closeClient = exports.Channel = exports.makeGenericClientConstructor = exports.makeClientConstructor = exports.loadPackageDefinition = exports.Client = exports.compressionAlgorithms = exports.propagate = exports.connectivityState = exports.status = exports.logVerbosity = exports.Metadata = exports.credentials = void 0;\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\nObject.defineProperty(exports, \"CallCredentials\", ({\n    enumerable: true,\n    get: function() {\n        return call_credentials_1.CallCredentials;\n    }\n}));\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\nObject.defineProperty(exports, \"Channel\", ({\n    enumerable: true,\n    get: function() {\n        return channel_1.ChannelImplementation;\n    }\n}));\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\nObject.defineProperty(exports, \"compressionAlgorithms\", ({\n    enumerable: true,\n    get: function() {\n        return compression_algorithms_1.CompressionAlgorithms;\n    }\n}));\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nObject.defineProperty(exports, \"connectivityState\", ({\n    enumerable: true,\n    get: function() {\n        return connectivity_state_1.ConnectivityState;\n    }\n}));\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nObject.defineProperty(exports, \"ChannelCredentials\", ({\n    enumerable: true,\n    get: function() {\n        return channel_credentials_1.ChannelCredentials;\n    }\n}));\nconst client_1 = __webpack_require__(/*! ./client */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/client.js\");\nObject.defineProperty(exports, \"Client\", ({\n    enumerable: true,\n    get: function() {\n        return client_1.Client;\n    }\n}));\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nObject.defineProperty(exports, \"logVerbosity\", ({\n    enumerable: true,\n    get: function() {\n        return constants_1.LogVerbosity;\n    }\n}));\nObject.defineProperty(exports, \"status\", ({\n    enumerable: true,\n    get: function() {\n        return constants_1.Status;\n    }\n}));\nObject.defineProperty(exports, \"propagate\", ({\n    enumerable: true,\n    get: function() {\n        return constants_1.Propagate;\n    }\n}));\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\nObject.defineProperty(exports, \"loadPackageDefinition\", ({\n    enumerable: true,\n    get: function() {\n        return make_client_1.loadPackageDefinition;\n    }\n}));\nObject.defineProperty(exports, \"makeClientConstructor\", ({\n    enumerable: true,\n    get: function() {\n        return make_client_1.makeClientConstructor;\n    }\n}));\nObject.defineProperty(exports, \"makeGenericClientConstructor\", ({\n    enumerable: true,\n    get: function() {\n        return make_client_1.makeClientConstructor;\n    }\n}));\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nObject.defineProperty(exports, \"Metadata\", ({\n    enumerable: true,\n    get: function() {\n        return metadata_1.Metadata;\n    }\n}));\nconst server_1 = __webpack_require__(/*! ./server */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/server.js\");\nObject.defineProperty(exports, \"Server\", ({\n    enumerable: true,\n    get: function() {\n        return server_1.Server;\n    }\n}));\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\nObject.defineProperty(exports, \"ServerCredentials\", ({\n    enumerable: true,\n    get: function() {\n        return server_credentials_1.ServerCredentials;\n    }\n}));\nconst status_builder_1 = __webpack_require__(/*! ./status-builder */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\");\nObject.defineProperty(exports, \"StatusBuilder\", ({\n    enumerable: true,\n    get: function() {\n        return status_builder_1.StatusBuilder;\n    }\n}));\n/**** Client Credentials ****/ // Using assign only copies enumerable properties, which is what we want\nexports.credentials = {\n    /**\n     * Combine a ChannelCredentials with any number of CallCredentials into a\n     * single ChannelCredentials object.\n     * @param channelCredentials The ChannelCredentials object.\n     * @param callCredentials Any number of CallCredentials objects.\n     * @return The resulting ChannelCredentials object.\n     */ combineChannelCredentials: (channelCredentials, ...callCredentials)=>{\n        return callCredentials.reduce((acc, other)=>acc.compose(other), channelCredentials);\n    },\n    /**\n     * Combine any number of CallCredentials into a single CallCredentials\n     * object.\n     * @param first The first CallCredentials object.\n     * @param additional Any number of additional CallCredentials objects.\n     * @return The resulting CallCredentials object.\n     */ combineCallCredentials: (first, ...additional)=>{\n        return additional.reduce((acc, other)=>acc.compose(other), first);\n    },\n    // from channel-credentials.ts\n    createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,\n    createSsl: channel_credentials_1.ChannelCredentials.createSsl,\n    createFromSecureContext: channel_credentials_1.ChannelCredentials.createFromSecureContext,\n    // from call-credentials.ts\n    createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,\n    createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,\n    createEmpty: call_credentials_1.CallCredentials.createEmpty\n};\n/**\n * Close a Client object.\n * @param client The client to close.\n */ exports.closeClient = (client)=>client.close();\nexports.waitForClientReady = (client, deadline, callback)=>client.waitForReady(deadline, callback);\n/* eslint-enable @typescript-eslint/no-explicit-any */ /**** Unimplemented function stubs ****/ /* eslint-disable @typescript-eslint/no-explicit-any */ exports.loadObject = (value, options)=>{\n    throw new Error(\"Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead\");\n};\nexports.load = (filename, format, options)=>{\n    throw new Error(\"Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead\");\n};\nexports.setLogger = (logger)=>{\n    logging.setLogger(logger);\n};\nexports.setLogVerbosity = (verbosity)=>{\n    logging.setLoggerVerbosity(verbosity);\n};\nexports.getClientChannel = (client)=>{\n    return client_1.Client.prototype.getChannel.call(client);\n};\nvar client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\nObject.defineProperty(exports, \"ListenerBuilder\", ({\n    enumerable: true,\n    get: function() {\n        return client_interceptors_1.ListenerBuilder;\n    }\n}));\nObject.defineProperty(exports, \"RequesterBuilder\", ({\n    enumerable: true,\n    get: function() {\n        return client_interceptors_1.RequesterBuilder;\n    }\n}));\nObject.defineProperty(exports, \"InterceptingCall\", ({\n    enumerable: true,\n    get: function() {\n        return client_interceptors_1.InterceptingCall;\n    }\n}));\nObject.defineProperty(exports, \"InterceptorConfigurationError\", ({\n    enumerable: true,\n    get: function() {\n        return client_interceptors_1.InterceptorConfigurationError;\n    }\n}));\nvar channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nObject.defineProperty(exports, \"getChannelzServiceDefinition\", ({\n    enumerable: true,\n    get: function() {\n        return channelz_1.getChannelzServiceDefinition;\n    }\n}));\nObject.defineProperty(exports, \"getChannelzHandlers\", ({\n    enumerable: true,\n    get: function() {\n        return channelz_1.getChannelzHandlers;\n    }\n}));\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nObject.defineProperty(exports, \"addAdminServicesToServer\", ({\n    enumerable: true,\n    get: function() {\n        return admin_1.addAdminServicesToServer;\n    }\n}));\nconst experimental = __webpack_require__(/*! ./experimental */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\nexports.experimental = experimental;\nconst resolver_dns = __webpack_require__(/*! ./resolver-dns */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\");\nconst resolver_uds = __webpack_require__(/*! ./resolver-uds */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\");\nconst resolver_ip = __webpack_require__(/*! ./resolver-ip */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\");\nconst load_balancer_pick_first = __webpack_require__(/*! ./load-balancer-pick-first */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\");\nconst load_balancer_round_robin = __webpack_require__(/*! ./load-balancer-round-robin */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\");\nconst load_balancer_outlier_detection = __webpack_require__(/*! ./load-balancer-outlier-detection */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\");\nconst channelz = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(ssr)/./node_modules/@grpc/grpc-js/package.json\").version);\n(()=>{\n    logging.trace(constants_1.LogVerbosity.DEBUG, \"index\", \"Loading @grpc/grpc-js version \" + clientVersion);\n    resolver_dns.setup();\n    resolver_uds.setup();\n    resolver_ip.setup();\n    load_balancer_pick_first.setup();\n    load_balancer_round_robin.setup();\n    load_balancer_outlier_detection.setup();\n    channelz.setup();\n})(); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHQSxxQkFBcUIsR0FBR0Esd0JBQXdCLEdBQUdBLHlCQUF5QixHQUFHQSxjQUFjLEdBQUdBLHVCQUF1QixHQUFHQSxpQkFBaUIsR0FBR0EsWUFBWSxHQUFHQSxrQkFBa0IsR0FBR0EsdUJBQXVCLEdBQUdBLDBCQUEwQixHQUFHQSwwQkFBMEIsR0FBR0EsbUJBQW1CLEdBQUdBLGVBQWUsR0FBR0Esb0NBQW9DLEdBQUdBLDZCQUE2QixHQUFHQSw2QkFBNkIsR0FBR0EsY0FBYyxHQUFHQSw2QkFBNkIsR0FBR0EsaUJBQWlCLEdBQUdBLHlCQUF5QixHQUFHQSxjQUFjLEdBQUdBLG9CQUFvQixHQUFHQSxnQkFBZ0IsR0FBR0EsbUJBQW1CLEdBQUcsS0FBSztBQUNubUIsTUFBTTJCLHFCQUFxQkMsbUJBQU9BLENBQUMsNEZBQW9CO0FBQ3ZEOUIsbURBQWtEO0lBQUUrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSCxtQkFBbUJoQixlQUFlO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDeEksTUFBTW9CLFlBQVlILG1CQUFPQSxDQUFDLDBFQUFXO0FBQ3JDOUIsMkNBQTBDO0lBQUUrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPQyxVQUFVQyxxQkFBcUI7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM3SCxNQUFNQywyQkFBMkJMLG1CQUFPQSxDQUFDLHdHQUEwQjtBQUNuRTlCLHlEQUF3RDtJQUFFK0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0cseUJBQXlCQyxxQkFBcUI7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMxSixNQUFNQyx1QkFBdUJQLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRDlCLHFEQUFvRDtJQUFFK0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0sscUJBQXFCQyxpQkFBaUI7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM5SSxNQUFNQyx3QkFBd0JULG1CQUFPQSxDQUFDLGtHQUF1QjtBQUM3RDlCLHNEQUFxRDtJQUFFK0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT08sc0JBQXNCekIsa0JBQWtCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDakosTUFBTTBCLFdBQVdWLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DOUIsMENBQXlDO0lBQUUrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPUSxTQUFTbkIsTUFBTTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzVHLE1BQU1vQixjQUFjWCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QzlCLGdEQUErQztJQUFFK0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT1MsWUFBWUMsWUFBWTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzNIMUMsMENBQXlDO0lBQUUrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPUyxZQUFZRSxNQUFNO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDL0czQyw2Q0FBNEM7SUFBRStCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9TLFlBQVlHLFNBQVM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNySCxNQUFNQyxVQUFVZixtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNZ0IsZ0JBQWdCaEIsbUJBQU9BLENBQUMsa0ZBQWU7QUFDN0M5Qix5REFBd0Q7SUFBRStCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9jLGNBQWMxQixxQkFBcUI7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMvSXBCLHlEQUF3RDtJQUFFK0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT2MsY0FBYzNCLHFCQUFxQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQy9JbkIsZ0VBQStEO0lBQUUrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPYyxjQUFjM0IscUJBQXFCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDdEosTUFBTTRCLGFBQWFqQixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QzlCLDRDQUEyQztJQUFFK0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT2UsV0FBV3BCLFFBQVE7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNsSCxNQUFNcUIsV0FBV2xCLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DOUIsMENBQXlDO0lBQUUrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPZ0IsU0FBU3hDLE1BQU07SUFBRTtBQUFFLENBQUMsRUFBQztBQUM1RyxNQUFNeUMsdUJBQXVCbkIsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNEOUIscURBQW9EO0lBQUUrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPaUIscUJBQXFCMUMsaUJBQWlCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDOUksTUFBTTJDLG1CQUFtQnBCLG1CQUFPQSxDQUFDLHdGQUFrQjtBQUNuRDlCLGlEQUFnRDtJQUFFK0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT2tCLGlCQUFpQjdDLGFBQWE7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNsSSw0QkFBNEIsR0FDNUIsd0VBQXdFO0FBQ3hFSCxtQkFBbUIsR0FBRztJQUNsQjs7Ozs7O0tBTUMsR0FDRGlELDJCQUEyQixDQUFDQyxvQkFBb0IsR0FBR0M7UUFDL0MsT0FBT0EsZ0JBQWdCQyxNQUFNLENBQUMsQ0FBQ0MsS0FBS0MsUUFBVUQsSUFBSUUsT0FBTyxDQUFDRCxRQUFRSjtJQUN0RTtJQUNBOzs7Ozs7S0FNQyxHQUNETSx3QkFBd0IsQ0FBQ0MsT0FBTyxHQUFHQztRQUMvQixPQUFPQSxXQUFXTixNQUFNLENBQUMsQ0FBQ0MsS0FBS0MsUUFBVUQsSUFBSUUsT0FBTyxDQUFDRCxRQUFRRztJQUNqRTtJQUNBLDhCQUE4QjtJQUM5QkUsZ0JBQWdCdEIsc0JBQXNCekIsa0JBQWtCLENBQUMrQyxjQUFjO0lBQ3ZFQyxXQUFXdkIsc0JBQXNCekIsa0JBQWtCLENBQUNnRCxTQUFTO0lBQzdEQyx5QkFBeUJ4QixzQkFBc0J6QixrQkFBa0IsQ0FBQ2lELHVCQUF1QjtJQUN6RiwyQkFBMkI7SUFDM0JDLDZCQUE2Qm5DLG1CQUFtQmhCLGVBQWUsQ0FBQ21ELDJCQUEyQjtJQUMzRkMsNEJBQTRCcEMsbUJBQW1CaEIsZUFBZSxDQUFDb0QsMEJBQTBCO0lBQ3pGQyxhQUFhckMsbUJBQW1CaEIsZUFBZSxDQUFDcUQsV0FBVztBQUMvRDtBQUNBOzs7Q0FHQyxHQUNEaEUsbUJBQW1CLEdBQUcsQ0FBQ2lFLFNBQVdBLE9BQU9DLEtBQUs7QUFDOUNsRSwwQkFBMEIsR0FBRyxDQUFDaUUsUUFBUUUsVUFBVUMsV0FBYUgsT0FBT0ksWUFBWSxDQUFDRixVQUFVQztBQUMzRixvREFBb0QsR0FDcEQsc0NBQXNDLEdBQ3RDLHFEQUFxRCxHQUNyRHBFLGtCQUFrQixHQUFHLENBQUNDLE9BQU9xRTtJQUN6QixNQUFNLElBQUlDLE1BQU07QUFDcEI7QUFDQXZFLFlBQVksR0FBRyxDQUFDd0UsVUFBVUMsUUFBUUg7SUFDOUIsTUFBTSxJQUFJQyxNQUFNO0FBQ3BCO0FBQ0F2RSxpQkFBaUIsR0FBRyxDQUFDMEU7SUFDakIvQixRQUFRbkMsU0FBUyxDQUFDa0U7QUFDdEI7QUFDQTFFLHVCQUF1QixHQUFHLENBQUMyRTtJQUN2QmhDLFFBQVFpQyxrQkFBa0IsQ0FBQ0Q7QUFDL0I7QUFDQTNFLHdCQUF3QixHQUFHLENBQUNpRTtJQUN4QixPQUFPM0IsU0FBU25CLE1BQU0sQ0FBQzBELFNBQVMsQ0FBQ0MsVUFBVSxDQUFDQyxJQUFJLENBQUNkO0FBQ3JEO0FBQ0EsSUFBSWUsd0JBQXdCcEQsbUJBQU9BLENBQUMsa0dBQXVCO0FBQzNEOUIsbURBQWtEO0lBQUUrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPa0Qsc0JBQXNCQyxlQUFlO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDM0luRixvREFBbUQ7SUFBRStCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9rRCxzQkFBc0JFLGdCQUFnQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzdJcEYsb0RBQW1EO0lBQUUrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPa0Qsc0JBQXNCRyxnQkFBZ0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM3SXJGLGlFQUFnRTtJQUFFK0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT2tELHNCQUFzQkksNkJBQTZCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDdkssSUFBSUMsYUFBYXpELG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3JDOUIsZ0VBQStEO0lBQUUrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPdUQsV0FBV0MsNEJBQTRCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDMUp4Rix1REFBc0Q7SUFBRStCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU91RCxXQUFXRSxtQkFBbUI7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN4SSxJQUFJQyxVQUFVNUQsbUJBQU9BLENBQUMsc0VBQVM7QUFDL0I5Qiw0REFBMkQ7SUFBRStCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU8wRCxRQUFRQyx3QkFBd0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMvSSxNQUFNdkYsZUFBZTBCLG1CQUFPQSxDQUFDLG9GQUFnQjtBQUM3QzVCLG9CQUFvQixHQUFHRTtBQUN2QixNQUFNd0YsZUFBZTlELG1CQUFPQSxDQUFDLG9GQUFnQjtBQUM3QyxNQUFNK0QsZUFBZS9ELG1CQUFPQSxDQUFDLG9GQUFnQjtBQUM3QyxNQUFNZ0UsY0FBY2hFLG1CQUFPQSxDQUFDLGtGQUFlO0FBQzNDLE1BQU1pRSwyQkFBMkJqRSxtQkFBT0EsQ0FBQyw0R0FBNEI7QUFDckUsTUFBTWtFLDRCQUE0QmxFLG1CQUFPQSxDQUFDLDhHQUE2QjtBQUN2RSxNQUFNbUUsa0NBQWtDbkUsbUJBQU9BLENBQUMsMEhBQW1DO0FBQ25GLE1BQU1vRSxXQUFXcEUsbUJBQU9BLENBQUMsNEVBQVk7QUFDckMsTUFBTXFFLGdCQUFnQnJFLDBHQUFxQztBQUMxRDtJQUNHZSxRQUFRd0QsS0FBSyxDQUFDNUQsWUFBWUMsWUFBWSxDQUFDNEQsS0FBSyxFQUFFLFNBQVMsbUNBQW1DSDtJQUMxRlAsYUFBYVcsS0FBSztJQUNsQlYsYUFBYVUsS0FBSztJQUNsQlQsWUFBWVMsS0FBSztJQUNqQlIseUJBQXlCUSxLQUFLO0lBQzlCUCwwQkFBMEJPLEtBQUs7SUFDL0JOLGdDQUFnQ00sS0FBSztJQUNyQ0wsU0FBU0ssS0FBSztBQUNsQixNQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FzaG1pdHQtZ3VwdGEvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW5kZXguanM/Mzk1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHBlcmltZW50YWwgPSBleHBvcnRzLlN0YXR1c0J1aWxkZXIgPSBleHBvcnRzLmdldENsaWVudENoYW5uZWwgPSBleHBvcnRzLlNlcnZlckNyZWRlbnRpYWxzID0gZXhwb3J0cy5TZXJ2ZXIgPSBleHBvcnRzLnNldExvZ1ZlcmJvc2l0eSA9IGV4cG9ydHMuc2V0TG9nZ2VyID0gZXhwb3J0cy5sb2FkID0gZXhwb3J0cy5sb2FkT2JqZWN0ID0gZXhwb3J0cy5DYWxsQ3JlZGVudGlhbHMgPSBleHBvcnRzLkNoYW5uZWxDcmVkZW50aWFscyA9IGV4cG9ydHMud2FpdEZvckNsaWVudFJlYWR5ID0gZXhwb3J0cy5jbG9zZUNsaWVudCA9IGV4cG9ydHMuQ2hhbm5lbCA9IGV4cG9ydHMubWFrZUdlbmVyaWNDbGllbnRDb25zdHJ1Y3RvciA9IGV4cG9ydHMubWFrZUNsaWVudENvbnN0cnVjdG9yID0gZXhwb3J0cy5sb2FkUGFja2FnZURlZmluaXRpb24gPSBleHBvcnRzLkNsaWVudCA9IGV4cG9ydHMuY29tcHJlc3Npb25BbGdvcml0aG1zID0gZXhwb3J0cy5wcm9wYWdhdGUgPSBleHBvcnRzLmNvbm5lY3Rpdml0eVN0YXRlID0gZXhwb3J0cy5zdGF0dXMgPSBleHBvcnRzLmxvZ1ZlcmJvc2l0eSA9IGV4cG9ydHMuTWV0YWRhdGEgPSBleHBvcnRzLmNyZWRlbnRpYWxzID0gdm9pZCAwO1xuY29uc3QgY2FsbF9jcmVkZW50aWFsc18xID0gcmVxdWlyZShcIi4vY2FsbC1jcmVkZW50aWFsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbGxDcmVkZW50aWFsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFsczsgfSB9KTtcbmNvbnN0IGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWxcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDaGFubmVsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFubmVsXzEuQ2hhbm5lbEltcGxlbWVudGF0aW9uOyB9IH0pO1xuY29uc3QgY29tcHJlc3Npb25fYWxnb3JpdGhtc18xID0gcmVxdWlyZShcIi4vY29tcHJlc3Npb24tYWxnb3JpdGhtc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbXByZXNzaW9uQWxnb3JpdGhtc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcHJlc3Npb25fYWxnb3JpdGhtc18xLkNvbXByZXNzaW9uQWxnb3JpdGhtczsgfSB9KTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29ubmVjdGl2aXR5U3RhdGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlOyB9IH0pO1xuY29uc3QgY2hhbm5lbF9jcmVkZW50aWFsc18xID0gcmVxdWlyZShcIi4vY2hhbm5lbC1jcmVkZW50aWFsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNoYW5uZWxDcmVkZW50aWFsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hhbm5lbF9jcmVkZW50aWFsc18xLkNoYW5uZWxDcmVkZW50aWFsczsgfSB9KTtcbmNvbnN0IGNsaWVudF8xID0gcmVxdWlyZShcIi4vY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfMS5DbGllbnQ7IH0gfSk7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvZ1ZlcmJvc2l0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RhdHVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudHNfMS5TdGF0dXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwcm9wYWdhdGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLlByb3BhZ2F0ZTsgfSB9KTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgbWFrZV9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL21ha2UtY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9hZFBhY2thZ2VEZWZpbml0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYWtlX2NsaWVudF8xLmxvYWRQYWNrYWdlRGVmaW5pdGlvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VDbGllbnRDb25zdHJ1Y3RvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFrZV9jbGllbnRfMS5tYWtlQ2xpZW50Q29uc3RydWN0b3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlR2VuZXJpY0NsaWVudENvbnN0cnVjdG9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYWtlX2NsaWVudF8xLm1ha2VDbGllbnRDb25zdHJ1Y3RvcjsgfSB9KTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1ldGFkYXRhXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXRhZGF0YV8xLk1ldGFkYXRhOyB9IH0pO1xuY29uc3Qgc2VydmVyXzEgPSByZXF1aXJlKFwiLi9zZXJ2ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXJ2ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcnZlcl8xLlNlcnZlcjsgfSB9KTtcbmNvbnN0IHNlcnZlcl9jcmVkZW50aWFsc18xID0gcmVxdWlyZShcIi4vc2VydmVyLWNyZWRlbnRpYWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VydmVyQ3JlZGVudGlhbHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcnZlcl9jcmVkZW50aWFsc18xLlNlcnZlckNyZWRlbnRpYWxzOyB9IH0pO1xuY29uc3Qgc3RhdHVzX2J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL3N0YXR1cy1idWlsZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RhdHVzQnVpbGRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RhdHVzX2J1aWxkZXJfMS5TdGF0dXNCdWlsZGVyOyB9IH0pO1xuLyoqKiogQ2xpZW50IENyZWRlbnRpYWxzICoqKiovXG4vLyBVc2luZyBhc3NpZ24gb25seSBjb3BpZXMgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLCB3aGljaCBpcyB3aGF0IHdlIHdhbnRcbmV4cG9ydHMuY3JlZGVudGlhbHMgPSB7XG4gICAgLyoqXG4gICAgICogQ29tYmluZSBhIENoYW5uZWxDcmVkZW50aWFscyB3aXRoIGFueSBudW1iZXIgb2YgQ2FsbENyZWRlbnRpYWxzIGludG8gYVxuICAgICAqIHNpbmdsZSBDaGFubmVsQ3JlZGVudGlhbHMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBjaGFubmVsQ3JlZGVudGlhbHMgVGhlIENoYW5uZWxDcmVkZW50aWFscyBvYmplY3QuXG4gICAgICogQHBhcmFtIGNhbGxDcmVkZW50aWFscyBBbnkgbnVtYmVyIG9mIENhbGxDcmVkZW50aWFscyBvYmplY3RzLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3VsdGluZyBDaGFubmVsQ3JlZGVudGlhbHMgb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbWJpbmVDaGFubmVsQ3JlZGVudGlhbHM6IChjaGFubmVsQ3JlZGVudGlhbHMsIC4uLmNhbGxDcmVkZW50aWFscykgPT4ge1xuICAgICAgICByZXR1cm4gY2FsbENyZWRlbnRpYWxzLnJlZHVjZSgoYWNjLCBvdGhlcikgPT4gYWNjLmNvbXBvc2Uob3RoZXIpLCBjaGFubmVsQ3JlZGVudGlhbHMpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ29tYmluZSBhbnkgbnVtYmVyIG9mIENhbGxDcmVkZW50aWFscyBpbnRvIGEgc2luZ2xlIENhbGxDcmVkZW50aWFsc1xuICAgICAqIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gZmlyc3QgVGhlIGZpcnN0IENhbGxDcmVkZW50aWFscyBvYmplY3QuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWwgQW55IG51bWJlciBvZiBhZGRpdGlvbmFsIENhbGxDcmVkZW50aWFscyBvYmplY3RzLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3VsdGluZyBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbWJpbmVDYWxsQ3JlZGVudGlhbHM6IChmaXJzdCwgLi4uYWRkaXRpb25hbCkgPT4ge1xuICAgICAgICByZXR1cm4gYWRkaXRpb25hbC5yZWR1Y2UoKGFjYywgb3RoZXIpID0+IGFjYy5jb21wb3NlKG90aGVyKSwgZmlyc3QpO1xuICAgIH0sXG4gICAgLy8gZnJvbSBjaGFubmVsLWNyZWRlbnRpYWxzLnRzXG4gICAgY3JlYXRlSW5zZWN1cmU6IGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHMuY3JlYXRlSW5zZWN1cmUsXG4gICAgY3JlYXRlU3NsOiBjaGFubmVsX2NyZWRlbnRpYWxzXzEuQ2hhbm5lbENyZWRlbnRpYWxzLmNyZWF0ZVNzbCxcbiAgICBjcmVhdGVGcm9tU2VjdXJlQ29udGV4dDogY2hhbm5lbF9jcmVkZW50aWFsc18xLkNoYW5uZWxDcmVkZW50aWFscy5jcmVhdGVGcm9tU2VjdXJlQ29udGV4dCxcbiAgICAvLyBmcm9tIGNhbGwtY3JlZGVudGlhbHMudHNcbiAgICBjcmVhdGVGcm9tTWV0YWRhdGFHZW5lcmF0b3I6IGNhbGxfY3JlZGVudGlhbHNfMS5DYWxsQ3JlZGVudGlhbHMuY3JlYXRlRnJvbU1ldGFkYXRhR2VuZXJhdG9yLFxuICAgIGNyZWF0ZUZyb21Hb29nbGVDcmVkZW50aWFsOiBjYWxsX2NyZWRlbnRpYWxzXzEuQ2FsbENyZWRlbnRpYWxzLmNyZWF0ZUZyb21Hb29nbGVDcmVkZW50aWFsLFxuICAgIGNyZWF0ZUVtcHR5OiBjYWxsX2NyZWRlbnRpYWxzXzEuQ2FsbENyZWRlbnRpYWxzLmNyZWF0ZUVtcHR5LFxufTtcbi8qKlxuICogQ2xvc2UgYSBDbGllbnQgb2JqZWN0LlxuICogQHBhcmFtIGNsaWVudCBUaGUgY2xpZW50IHRvIGNsb3NlLlxuICovXG5leHBvcnRzLmNsb3NlQ2xpZW50ID0gKGNsaWVudCkgPT4gY2xpZW50LmNsb3NlKCk7XG5leHBvcnRzLndhaXRGb3JDbGllbnRSZWFkeSA9IChjbGllbnQsIGRlYWRsaW5lLCBjYWxsYmFjaykgPT4gY2xpZW50LndhaXRGb3JSZWFkeShkZWFkbGluZSwgY2FsbGJhY2spO1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKioqKiBVbmltcGxlbWVudGVkIGZ1bmN0aW9uIHN0dWJzICoqKiovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5leHBvcnRzLmxvYWRPYmplY3QgPSAodmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdmFpbGFibGUgaW4gdGhpcyBsaWJyYXJ5LiBVc2UgQGdycGMvcHJvdG8tbG9hZGVyIGFuZCBsb2FkUGFja2FnZURlZmluaXRpb24gaW5zdGVhZCcpO1xufTtcbmV4cG9ydHMubG9hZCA9IChmaWxlbmFtZSwgZm9ybWF0LCBvcHRpb25zKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXZhaWxhYmxlIGluIHRoaXMgbGlicmFyeS4gVXNlIEBncnBjL3Byb3RvLWxvYWRlciBhbmQgbG9hZFBhY2thZ2VEZWZpbml0aW9uIGluc3RlYWQnKTtcbn07XG5leHBvcnRzLnNldExvZ2dlciA9IChsb2dnZXIpID0+IHtcbiAgICBsb2dnaW5nLnNldExvZ2dlcihsb2dnZXIpO1xufTtcbmV4cG9ydHMuc2V0TG9nVmVyYm9zaXR5ID0gKHZlcmJvc2l0eSkgPT4ge1xuICAgIGxvZ2dpbmcuc2V0TG9nZ2VyVmVyYm9zaXR5KHZlcmJvc2l0eSk7XG59O1xuZXhwb3J0cy5nZXRDbGllbnRDaGFubmVsID0gKGNsaWVudCkgPT4ge1xuICAgIHJldHVybiBjbGllbnRfMS5DbGllbnQucHJvdG90eXBlLmdldENoYW5uZWwuY2FsbChjbGllbnQpO1xufTtcbnZhciBjbGllbnRfaW50ZXJjZXB0b3JzXzEgPSByZXF1aXJlKFwiLi9jbGllbnQtaW50ZXJjZXB0b3JzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGlzdGVuZXJCdWlsZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfaW50ZXJjZXB0b3JzXzEuTGlzdGVuZXJCdWlsZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdGVyQnVpbGRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xpZW50X2ludGVyY2VwdG9yc18xLlJlcXVlc3RlckJ1aWxkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnRlcmNlcHRpbmdDYWxsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfaW50ZXJjZXB0b3JzXzEuSW50ZXJjZXB0aW5nQ2FsbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfaW50ZXJjZXB0b3JzXzEuSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3I7IH0gfSk7XG52YXIgY2hhbm5lbHpfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hhbm5lbHpfMS5nZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Q2hhbm5lbHpIYW5kbGVyc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hhbm5lbHpfMS5nZXRDaGFubmVsekhhbmRsZXJzOyB9IH0pO1xudmFyIGFkbWluXzEgPSByZXF1aXJlKFwiLi9hZG1pblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZEFkbWluU2VydmljZXNUb1NlcnZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRtaW5fMS5hZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXI7IH0gfSk7XG5jb25zdCBleHBlcmltZW50YWwgPSByZXF1aXJlKFwiLi9leHBlcmltZW50YWxcIik7XG5leHBvcnRzLmV4cGVyaW1lbnRhbCA9IGV4cGVyaW1lbnRhbDtcbmNvbnN0IHJlc29sdmVyX2RucyA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyLWRuc1wiKTtcbmNvbnN0IHJlc29sdmVyX3VkcyA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyLXVkc1wiKTtcbmNvbnN0IHJlc29sdmVyX2lwID0gcmVxdWlyZShcIi4vcmVzb2x2ZXItaXBcIik7XG5jb25zdCBsb2FkX2JhbGFuY2VyX3BpY2tfZmlyc3QgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLXBpY2stZmlyc3RcIik7XG5jb25zdCBsb2FkX2JhbGFuY2VyX3JvdW5kX3JvYmluID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1yb3VuZC1yb2JpblwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfb3V0bGllcl9kZXRlY3Rpb24gPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLW91dGxpZXItZGV0ZWN0aW9uXCIpO1xuY29uc3QgY2hhbm5lbHogPSByZXF1aXJlKFwiLi9jaGFubmVselwiKTtcbmNvbnN0IGNsaWVudFZlcnNpb24gPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuKCgpID0+IHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ2luZGV4JywgJ0xvYWRpbmcgQGdycGMvZ3JwYy1qcyB2ZXJzaW9uICcgKyBjbGllbnRWZXJzaW9uKTtcbiAgICByZXNvbHZlcl9kbnMuc2V0dXAoKTtcbiAgICByZXNvbHZlcl91ZHMuc2V0dXAoKTtcbiAgICByZXNvbHZlcl9pcC5zZXR1cCgpO1xuICAgIGxvYWRfYmFsYW5jZXJfcGlja19maXJzdC5zZXR1cCgpO1xuICAgIGxvYWRfYmFsYW5jZXJfcm91bmRfcm9iaW4uc2V0dXAoKTtcbiAgICBsb2FkX2JhbGFuY2VyX291dGxpZXJfZGV0ZWN0aW9uLnNldHVwKCk7XG4gICAgY2hhbm5lbHouc2V0dXAoKTtcbn0pKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJleHBlcmltZW50YWwiLCJTdGF0dXNCdWlsZGVyIiwiZ2V0Q2xpZW50Q2hhbm5lbCIsIlNlcnZlckNyZWRlbnRpYWxzIiwiU2VydmVyIiwic2V0TG9nVmVyYm9zaXR5Iiwic2V0TG9nZ2VyIiwibG9hZCIsImxvYWRPYmplY3QiLCJDYWxsQ3JlZGVudGlhbHMiLCJDaGFubmVsQ3JlZGVudGlhbHMiLCJ3YWl0Rm9yQ2xpZW50UmVhZHkiLCJjbG9zZUNsaWVudCIsIkNoYW5uZWwiLCJtYWtlR2VuZXJpY0NsaWVudENvbnN0cnVjdG9yIiwibWFrZUNsaWVudENvbnN0cnVjdG9yIiwibG9hZFBhY2thZ2VEZWZpbml0aW9uIiwiQ2xpZW50IiwiY29tcHJlc3Npb25BbGdvcml0aG1zIiwicHJvcGFnYXRlIiwiY29ubmVjdGl2aXR5U3RhdGUiLCJzdGF0dXMiLCJsb2dWZXJib3NpdHkiLCJNZXRhZGF0YSIsImNyZWRlbnRpYWxzIiwiY2FsbF9jcmVkZW50aWFsc18xIiwicmVxdWlyZSIsImVudW1lcmFibGUiLCJnZXQiLCJjaGFubmVsXzEiLCJDaGFubmVsSW1wbGVtZW50YXRpb24iLCJjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEiLCJDb21wcmVzc2lvbkFsZ29yaXRobXMiLCJjb25uZWN0aXZpdHlfc3RhdGVfMSIsIkNvbm5lY3Rpdml0eVN0YXRlIiwiY2hhbm5lbF9jcmVkZW50aWFsc18xIiwiY2xpZW50XzEiLCJjb25zdGFudHNfMSIsIkxvZ1ZlcmJvc2l0eSIsIlN0YXR1cyIsIlByb3BhZ2F0ZSIsImxvZ2dpbmciLCJtYWtlX2NsaWVudF8xIiwibWV0YWRhdGFfMSIsInNlcnZlcl8xIiwic2VydmVyX2NyZWRlbnRpYWxzXzEiLCJzdGF0dXNfYnVpbGRlcl8xIiwiY29tYmluZUNoYW5uZWxDcmVkZW50aWFscyIsImNoYW5uZWxDcmVkZW50aWFscyIsImNhbGxDcmVkZW50aWFscyIsInJlZHVjZSIsImFjYyIsIm90aGVyIiwiY29tcG9zZSIsImNvbWJpbmVDYWxsQ3JlZGVudGlhbHMiLCJmaXJzdCIsImFkZGl0aW9uYWwiLCJjcmVhdGVJbnNlY3VyZSIsImNyZWF0ZVNzbCIsImNyZWF0ZUZyb21TZWN1cmVDb250ZXh0IiwiY3JlYXRlRnJvbU1ldGFkYXRhR2VuZXJhdG9yIiwiY3JlYXRlRnJvbUdvb2dsZUNyZWRlbnRpYWwiLCJjcmVhdGVFbXB0eSIsImNsaWVudCIsImNsb3NlIiwiZGVhZGxpbmUiLCJjYWxsYmFjayIsIndhaXRGb3JSZWFkeSIsIm9wdGlvbnMiLCJFcnJvciIsImZpbGVuYW1lIiwiZm9ybWF0IiwibG9nZ2VyIiwidmVyYm9zaXR5Iiwic2V0TG9nZ2VyVmVyYm9zaXR5IiwicHJvdG90eXBlIiwiZ2V0Q2hhbm5lbCIsImNhbGwiLCJjbGllbnRfaW50ZXJjZXB0b3JzXzEiLCJMaXN0ZW5lckJ1aWxkZXIiLCJSZXF1ZXN0ZXJCdWlsZGVyIiwiSW50ZXJjZXB0aW5nQ2FsbCIsIkludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yIiwiY2hhbm5lbHpfMSIsImdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24iLCJnZXRDaGFubmVsekhhbmRsZXJzIiwiYWRtaW5fMSIsImFkZEFkbWluU2VydmljZXNUb1NlcnZlciIsInJlc29sdmVyX2RucyIsInJlc29sdmVyX3VkcyIsInJlc29sdmVyX2lwIiwibG9hZF9iYWxhbmNlcl9waWNrX2ZpcnN0IiwibG9hZF9iYWxhbmNlcl9yb3VuZF9yb2JpbiIsImxvYWRfYmFsYW5jZXJfb3V0bGllcl9kZXRlY3Rpb24iLCJjaGFubmVseiIsImNsaWVudFZlcnNpb24iLCJ2ZXJzaW9uIiwidHJhY2UiLCJERUJVRyIsInNldHVwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ChildLoadBalancerHandler = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst TYPE_NAME = \"child_load_balancer_helper\";\nclass ChildLoadBalancerHandler {\n    constructor(channelControlHelper){\n        this.channelControlHelper = channelControlHelper;\n        this.currentChild = null;\n        this.pendingChild = null;\n        this.ChildPolicyHelper = class {\n            constructor(parent){\n                this.parent = parent;\n                this.child = null;\n            }\n            createSubchannel(subchannelAddress, subchannelArgs) {\n                return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n            }\n            updateState(connectivityState, picker) {\n                var _a;\n                if (this.calledByPendingChild()) {\n                    if (connectivityState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                        return;\n                    }\n                    (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();\n                    this.parent.currentChild = this.parent.pendingChild;\n                    this.parent.pendingChild = null;\n                } else if (!this.calledByCurrentChild()) {\n                    return;\n                }\n                this.parent.channelControlHelper.updateState(connectivityState, picker);\n            }\n            requestReresolution() {\n                var _a;\n                const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;\n                if (this.child === latestChild) {\n                    this.parent.channelControlHelper.requestReresolution();\n                }\n            }\n            setChild(newChild) {\n                this.child = newChild;\n            }\n            addChannelzChild(child) {\n                this.parent.channelControlHelper.addChannelzChild(child);\n            }\n            removeChannelzChild(child) {\n                this.parent.channelControlHelper.removeChannelzChild(child);\n            }\n            calledByPendingChild() {\n                return this.child === this.parent.pendingChild;\n            }\n            calledByCurrentChild() {\n                return this.child === this.parent.currentChild;\n            }\n        };\n    }\n    /**\n     * Prerequisites: lbConfig !== null and lbConfig.name is registered\n     * @param addressList\n     * @param lbConfig\n     * @param attributes\n     */ updateAddressList(addressList, lbConfig, attributes) {\n        let childToUpdate;\n        if (this.currentChild === null || this.currentChild.getTypeName() !== lbConfig.getLoadBalancerName()) {\n            const newHelper = new this.ChildPolicyHelper(this);\n            const newChild = load_balancer_1.createLoadBalancer(lbConfig, newHelper);\n            newHelper.setChild(newChild);\n            if (this.currentChild === null) {\n                this.currentChild = newChild;\n                childToUpdate = this.currentChild;\n            } else {\n                if (this.pendingChild) {\n                    this.pendingChild.destroy();\n                }\n                this.pendingChild = newChild;\n                childToUpdate = this.pendingChild;\n            }\n        } else {\n            if (this.pendingChild === null) {\n                childToUpdate = this.currentChild;\n            } else {\n                childToUpdate = this.pendingChild;\n            }\n        }\n        childToUpdate.updateAddressList(addressList, lbConfig, attributes);\n    }\n    exitIdle() {\n        if (this.currentChild) {\n            this.currentChild.exitIdle();\n            if (this.pendingChild) {\n                this.pendingChild.exitIdle();\n            }\n        }\n    }\n    resetBackoff() {\n        if (this.currentChild) {\n            this.currentChild.resetBackoff();\n            if (this.pendingChild) {\n                this.pendingChild.resetBackoff();\n            }\n        }\n    }\n    destroy() {\n        if (this.currentChild) {\n            this.currentChild.destroy();\n            this.currentChild = null;\n        }\n        if (this.pendingChild) {\n            this.pendingChild.destroy();\n            this.pendingChild = null;\n        }\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.ChildLoadBalancerHandler = ChildLoadBalancerHandler; //# sourceMappingURL=load-balancer-child-handler.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQ0FBZ0MsR0FBRyxLQUFLO0FBQ3hDLE1BQU1HLGtCQUFrQkMsbUJBQU9BLENBQUMsc0ZBQWlCO0FBQ2pELE1BQU1DLHVCQUF1QkQsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1FLFlBQVk7QUFDbEIsTUFBTUo7SUFDRkssWUFBWUMsb0JBQW9CLENBQUU7UUFDOUIsSUFBSSxDQUFDQSxvQkFBb0IsR0FBR0E7UUFDNUIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztZQUNyQkosWUFBWUssTUFBTSxDQUFFO2dCQUNoQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7Z0JBQ2QsSUFBSSxDQUFDQyxLQUFLLEdBQUc7WUFDakI7WUFDQUMsaUJBQWlCQyxpQkFBaUIsRUFBRUMsY0FBYyxFQUFFO2dCQUNoRCxPQUFPLElBQUksQ0FBQ0osTUFBTSxDQUFDSixvQkFBb0IsQ0FBQ00sZ0JBQWdCLENBQUNDLG1CQUFtQkM7WUFDaEY7WUFDQUMsWUFBWUMsaUJBQWlCLEVBQUVDLE1BQU0sRUFBRTtnQkFDbkMsSUFBSUM7Z0JBQ0osSUFBSSxJQUFJLENBQUNDLG9CQUFvQixJQUFJO29CQUM3QixJQUFJSCxzQkFBc0JiLHFCQUFxQmlCLGlCQUFpQixDQUFDQyxVQUFVLEVBQUU7d0JBQ3pFO29CQUNKO29CQUNDSCxDQUFBQSxLQUFLLElBQUksQ0FBQ1IsTUFBTSxDQUFDSCxZQUFZLE1BQU0sUUFBUVcsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSSxPQUFPO29CQUMvRSxJQUFJLENBQUNa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aUMsWUFBWTtZQUM5QixJQUFJLElBQUksQ0FBQ2hDLFlBQVksRUFBRTtnQkFDbkIsSUFBSSxDQUFDQSxZQUFZLENBQUNnQyxZQUFZO1lBQ2xDO1FBQ0o7SUFDSjtJQUNBbEIsVUFBVTtRQUNOLElBQUksSUFBSSxDQUFDZixZQUFZLEVBQUU7WUFDbkIsSUFBSSxDQUFDQSxZQUFZLENBQUNlLE9BQU87WUFDekIsSUFBSSxDQUFDZixZQUFZLEdBQUc7UUFDeEI7UUFDQSxJQUFJLElBQUksQ0FBQ0MsWUFBWSxFQUFFO1lBQ25CLElBQUksQ0FBQ0EsWUFBWSxDQUFDYyxPQUFPO1lBQ3pCLElBQUksQ0FBQ2QsWUFBWSxHQUFHO1FBQ3hCO0lBQ0o7SUFDQTJCLGNBQWM7UUFDVixPQUFPL0I7SUFDWDtBQUNKO0FBQ0FOLGdDQUFnQyxHQUFHRSwwQkFDbkMsdURBQXVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNobWl0dC1ndXB0YS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLWNoaWxkLWhhbmRsZXIuanM/N2UxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBUWVBFX05BTUUgPSAnY2hpbGRfbG9hZF9iYWxhbmNlcl9oZWxwZXInO1xuY2xhc3MgQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsQ29udHJvbEhlbHBlcikge1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyID0gY2hhbm5lbENvbnRyb2xIZWxwZXI7XG4gICAgICAgIHRoaXMuY3VycmVudENoaWxkID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGQgPSBudWxsO1xuICAgICAgICB0aGlzLkNoaWxkUG9saWN5SGVscGVyID0gY2xhc3Mge1xuICAgICAgICAgICAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjcmVhdGVTdWJjaGFubmVsKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci5jcmVhdGVTdWJjaGFubmVsKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbGxlZEJ5UGVuZGluZ0NoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5wYXJlbnQuY3VycmVudENoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jdXJyZW50Q2hpbGQgPSB0aGlzLnBhcmVudC5wZW5kaW5nQ2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnBlbmRpbmdDaGlsZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmNhbGxlZEJ5Q3VycmVudENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3RSZXJlc29sdXRpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhdGVzdENoaWxkID0gKF9hID0gdGhpcy5wYXJlbnQucGVuZGluZ0NoaWxkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnBhcmVudC5jdXJyZW50Q2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGQgPT09IGxhdGVzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoYW5uZWxDb250cm9sSGVscGVyLnJlcXVlc3RSZXJlc29sdXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDaGlsZChuZXdDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQgPSBuZXdDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZENoYW5uZWx6Q2hpbGQoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW92ZUNoYW5uZWx6Q2hpbGQoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxlZEJ5UGVuZGluZ0NoaWxkKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkID09PSB0aGlzLnBhcmVudC5wZW5kaW5nQ2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsZWRCeUN1cnJlbnRDaGlsZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZCA9PT0gdGhpcy5wYXJlbnQuY3VycmVudENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVyZXF1aXNpdGVzOiBsYkNvbmZpZyAhPT0gbnVsbCBhbmQgbGJDb25maWcubmFtZSBpcyByZWdpc3RlcmVkXG4gICAgICogQHBhcmFtIGFkZHJlc3NMaXN0XG4gICAgICogQHBhcmFtIGxiQ29uZmlnXG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICB1cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgbGV0IGNoaWxkVG9VcGRhdGU7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGlsZCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQuZ2V0VHlwZU5hbWUoKSAhPT0gbGJDb25maWcuZ2V0TG9hZEJhbGFuY2VyTmFtZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdIZWxwZXIgPSBuZXcgdGhpcy5DaGlsZFBvbGljeUhlbHBlcih0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0gbG9hZF9iYWxhbmNlcl8xLmNyZWF0ZUxvYWRCYWxhbmNlcihsYkNvbmZpZywgbmV3SGVscGVyKTtcbiAgICAgICAgICAgIG5ld0hlbHBlci5zZXRDaGlsZChuZXdDaGlsZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Q2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZCA9IG5ld0NoaWxkO1xuICAgICAgICAgICAgICAgIGNoaWxkVG9VcGRhdGUgPSB0aGlzLmN1cnJlbnRDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkID0gbmV3Q2hpbGQ7XG4gICAgICAgICAgICAgICAgY2hpbGRUb1VwZGF0ZSA9IHRoaXMucGVuZGluZ0NoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRUb1VwZGF0ZSA9IHRoaXMuY3VycmVudENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGRUb1VwZGF0ZSA9IHRoaXMucGVuZGluZ0NoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoaWxkVG9VcGRhdGUudXBkYXRlQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGxiQ29uZmlnLCBhdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgZXhpdElkbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQuZXhpdElkbGUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkLmV4aXRJZGxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzZXRCYWNrb2ZmKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENoaWxkLnJlc2V0QmFja29mZigpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGQucmVzZXRCYWNrb2ZmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxufVxuZXhwb3J0cy5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXIgPSBDaGlsZExvYWRCYWxhbmNlckhhbmRsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLWNoaWxkLWhhbmRsZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyIiwibG9hZF9iYWxhbmNlcl8xIiwicmVxdWlyZSIsImNvbm5lY3Rpdml0eV9zdGF0ZV8xIiwiVFlQRV9OQU1FIiwiY29uc3RydWN0b3IiLCJjaGFubmVsQ29udHJvbEhlbHBlciIsImN1cnJlbnRDaGlsZCIsInBlbmRpbmdDaGlsZCIsIkNoaWxkUG9saWN5SGVscGVyIiwicGFyZW50IiwiY2hpbGQiLCJjcmVhdGVTdWJjaGFubmVsIiwic3ViY2hhbm5lbEFkZHJlc3MiLCJzdWJjaGFubmVsQXJncyIsInVwZGF0ZVN0YXRlIiwiY29ubmVjdGl2aXR5U3RhdGUiLCJwaWNrZXIiLCJfYSIsImNhbGxlZEJ5UGVuZGluZ0NoaWxkIiwiQ29ubmVjdGl2aXR5U3RhdGUiLCJDT05ORUNUSU5HIiwiZGVzdHJveSIsImNhbGxlZEJ5Q3VycmVudENoaWxkIiwicmVxdWVzdFJlcmVzb2x1dGlvbiIsImxhdGVzdENoaWxkIiwic2V0Q2hpbGQiLCJuZXdDaGlsZCIsImFkZENoYW5uZWx6Q2hpbGQiLCJyZW1vdmVDaGFubmVsekNoaWxkIiwidXBkYXRlQWRkcmVzc0xpc3QiLCJhZGRyZXNzTGlzdCIsImxiQ29uZmlnIiwiYXR0cmlidXRlcyIsImNoaWxkVG9VcGRhdGUiLCJnZXRUeXBlTmFtZSIsImdldExvYWRCYWxhbmNlck5hbWUiLCJuZXdIZWxwZXIiLCJjcmVhdGVMb2FkQmFsYW5jZXIiLCJleGl0SWRsZSIsInJlc2V0QmFja29mZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ var _a;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = exports.OutlierDetectionLoadBalancer = exports.OutlierDetectionLoadBalancingConfig = void 0;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst duration_1 = __webpack_require__(/*! ./duration */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\nconst experimental_1 = __webpack_require__(/*! ./experimental */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = \"outlier_detection\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = \"outlier_detection\";\nconst OUTLIER_DETECTION_ENABLED = ((_a = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a !== void 0 ? _a : \"true\") === \"true\";\nconst defaultSuccessRateEjectionConfig = {\n    stdev_factor: 1900,\n    enforcement_percentage: 100,\n    minimum_hosts: 5,\n    request_volume: 100\n};\nconst defaultFailurePercentageEjectionConfig = {\n    threshold: 85,\n    enforcement_percentage: 100,\n    minimum_hosts: 5,\n    request_volume: 50\n};\nfunction validateFieldType(obj, fieldName, expectedType, objectName) {\n    if (fieldName in obj && typeof obj[fieldName] !== expectedType) {\n        const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n        throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);\n    }\n}\nfunction validatePositiveDuration(obj, fieldName, objectName) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    if (fieldName in obj) {\n        if (!duration_1.isDuration(obj[fieldName])) {\n            throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);\n        }\n        if (!(obj[fieldName].seconds >= 0 && obj[fieldName].seconds <= 315576000000 && obj[fieldName].nanos >= 0 && obj[fieldName].nanos <= 999999999)) {\n            throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);\n        }\n    }\n}\nfunction validatePercentage(obj, fieldName, objectName) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    validateFieldType(obj, fieldName, \"number\", objectName);\n    if (fieldName in obj && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {\n        throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);\n    }\n}\nclass OutlierDetectionLoadBalancingConfig {\n    constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy){\n        this.childPolicy = childPolicy;\n        this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 10000;\n        this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 30000;\n        this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 300000;\n        this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;\n        this.successRateEjection = successRateEjection ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;\n        this.failurePercentageEjection = failurePercentageEjection ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;\n    }\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    toJsonObject() {\n        return {\n            interval: duration_1.msToDuration(this.intervalMs),\n            base_ejection_time: duration_1.msToDuration(this.baseEjectionTimeMs),\n            max_ejection_time: duration_1.msToDuration(this.maxEjectionTimeMs),\n            max_ejection_percent: this.maxEjectionPercent,\n            success_rate_ejection: this.successRateEjection,\n            failure_percentage_ejection: this.failurePercentageEjection,\n            child_policy: this.childPolicy.map((policy)=>policy.toJsonObject())\n        };\n    }\n    getIntervalMs() {\n        return this.intervalMs;\n    }\n    getBaseEjectionTimeMs() {\n        return this.baseEjectionTimeMs;\n    }\n    getMaxEjectionTimeMs() {\n        return this.maxEjectionTimeMs;\n    }\n    getMaxEjectionPercent() {\n        return this.maxEjectionPercent;\n    }\n    getSuccessRateEjectionConfig() {\n        return this.successRateEjection;\n    }\n    getFailurePercentageEjectionConfig() {\n        return this.failurePercentageEjection;\n    }\n    getChildPolicy() {\n        return this.childPolicy;\n    }\n    copyWithChildPolicy(childPolicy) {\n        return new OutlierDetectionLoadBalancingConfig(this.intervalMs, this.baseEjectionTimeMs, this.maxEjectionTimeMs, this.maxEjectionPercent, this.successRateEjection, this.failurePercentageEjection, childPolicy);\n    }\n    static createFromJson(obj) {\n        var _a;\n        validatePositiveDuration(obj, \"interval\");\n        validatePositiveDuration(obj, \"base_ejection_time\");\n        validatePositiveDuration(obj, \"max_ejection_time\");\n        validatePercentage(obj, \"max_ejection_percent\");\n        if (\"success_rate_ejection\" in obj) {\n            if (typeof obj.success_rate_ejection !== \"object\") {\n                throw new Error(\"outlier detection config success_rate_ejection must be an object\");\n            }\n            validateFieldType(obj.success_rate_ejection, \"stdev_factor\", \"number\", \"success_rate_ejection\");\n            validatePercentage(obj.success_rate_ejection, \"enforcement_percentage\", \"success_rate_ejection\");\n            validateFieldType(obj.success_rate_ejection, \"minimum_hosts\", \"number\", \"success_rate_ejection\");\n            validateFieldType(obj.success_rate_ejection, \"request_volume\", \"number\", \"success_rate_ejection\");\n        }\n        if (\"failure_percentage_ejection\" in obj) {\n            if (typeof obj.failure_percentage_ejection !== \"object\") {\n                throw new Error(\"outlier detection config failure_percentage_ejection must be an object\");\n            }\n            validatePercentage(obj.failure_percentage_ejection, \"threshold\", \"failure_percentage_ejection\");\n            validatePercentage(obj.failure_percentage_ejection, \"enforcement_percentage\", \"failure_percentage_ejection\");\n            validateFieldType(obj.failure_percentage_ejection, \"minimum_hosts\", \"number\", \"failure_percentage_ejection\");\n            validateFieldType(obj.failure_percentage_ejection, \"request_volume\", \"number\", \"failure_percentage_ejection\");\n        }\n        return new OutlierDetectionLoadBalancingConfig(obj.interval ? duration_1.durationToMs(obj.interval) : null, obj.base_ejection_time ? duration_1.durationToMs(obj.base_ejection_time) : null, obj.max_ejection_time ? duration_1.durationToMs(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== void 0 ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, obj.child_policy.map(load_balancer_1.validateLoadBalancingConfig));\n    }\n}\nexports.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;\nclass OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n    constructor(childSubchannel, mapEntry){\n        super(childSubchannel);\n        this.mapEntry = mapEntry;\n        this.stateListeners = [];\n        this.ejected = false;\n        this.refCount = 0;\n        this.childSubchannelState = childSubchannel.getConnectivityState();\n        childSubchannel.addConnectivityStateListener((subchannel, previousState, newState)=>{\n            this.childSubchannelState = newState;\n            if (!this.ejected) {\n                for (const listener of this.stateListeners){\n                    listener(this, previousState, newState);\n                }\n            }\n        });\n    }\n    getConnectivityState() {\n        if (this.ejected) {\n            return connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n        } else {\n            return this.childSubchannelState;\n        }\n    }\n    /**\n     * Add a listener function to be called whenever the wrapper's\n     * connectivity state changes.\n     * @param listener\n     */ addConnectivityStateListener(listener) {\n        this.stateListeners.push(listener);\n    }\n    /**\n     * Remove a listener previously added with `addConnectivityStateListener`\n     * @param listener A reference to a function previously passed to\n     *     `addConnectivityStateListener`\n     */ removeConnectivityStateListener(listener) {\n        const listenerIndex = this.stateListeners.indexOf(listener);\n        if (listenerIndex > -1) {\n            this.stateListeners.splice(listenerIndex, 1);\n        }\n    }\n    ref() {\n        this.child.ref();\n        this.refCount += 1;\n    }\n    unref() {\n        this.child.unref();\n        this.refCount -= 1;\n        if (this.refCount <= 0) {\n            if (this.mapEntry) {\n                const index = this.mapEntry.subchannelWrappers.indexOf(this);\n                if (index >= 0) {\n                    this.mapEntry.subchannelWrappers.splice(index, 1);\n                }\n            }\n        }\n    }\n    eject() {\n        this.ejected = true;\n        for (const listener of this.stateListeners){\n            listener(this, this.childSubchannelState, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        }\n    }\n    uneject() {\n        this.ejected = false;\n        for (const listener of this.stateListeners){\n            listener(this, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, this.childSubchannelState);\n        }\n    }\n    getMapEntry() {\n        return this.mapEntry;\n    }\n    getWrappedSubchannel() {\n        return this.child;\n    }\n}\nfunction createEmptyBucket() {\n    return {\n        success: 0,\n        failure: 0\n    };\n}\nclass CallCounter {\n    constructor(){\n        this.activeBucket = createEmptyBucket();\n        this.inactiveBucket = createEmptyBucket();\n    }\n    addSuccess() {\n        this.activeBucket.success += 1;\n    }\n    addFailure() {\n        this.activeBucket.failure += 1;\n    }\n    switchBuckets() {\n        this.inactiveBucket = this.activeBucket;\n        this.activeBucket = createEmptyBucket();\n    }\n    getLastSuccesses() {\n        return this.inactiveBucket.success;\n    }\n    getLastFailures() {\n        return this.inactiveBucket.failure;\n    }\n}\nclass OutlierDetectionCounterFilter extends filter_1.BaseFilter {\n    constructor(callCounter){\n        super();\n        this.callCounter = callCounter;\n    }\n    receiveTrailers(status) {\n        if (status.code === constants_1.Status.OK) {\n            this.callCounter.addSuccess();\n        } else {\n            this.callCounter.addFailure();\n        }\n        return status;\n    }\n}\nclass OutlierDetectionCounterFilterFactory {\n    constructor(callCounter){\n        this.callCounter = callCounter;\n    }\n    createFilter(callStream) {\n        return new OutlierDetectionCounterFilter(this.callCounter);\n    }\n}\nclass OutlierDetectionPicker {\n    constructor(wrappedPicker, countCalls){\n        this.wrappedPicker = wrappedPicker;\n        this.countCalls = countCalls;\n    }\n    pick(pickArgs) {\n        const wrappedPick = this.wrappedPicker.pick(pickArgs);\n        if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {\n            const subchannelWrapper = wrappedPick.subchannel;\n            const mapEntry = subchannelWrapper.getMapEntry();\n            if (mapEntry) {\n                const extraFilterFactories = [\n                    ...wrappedPick.extraFilterFactories\n                ];\n                if (this.countCalls) {\n                    extraFilterFactories.push(new OutlierDetectionCounterFilterFactory(mapEntry.counter));\n                }\n                return Object.assign(Object.assign({}, wrappedPick), {\n                    subchannel: subchannelWrapper.getWrappedSubchannel(),\n                    extraFilterFactories: extraFilterFactories\n                });\n            } else {\n                return Object.assign(Object.assign({}, wrappedPick), {\n                    subchannel: subchannelWrapper.getWrappedSubchannel()\n                });\n            }\n        } else {\n            return wrappedPick;\n        }\n    }\n}\nclass OutlierDetectionLoadBalancer {\n    constructor(channelControlHelper){\n        this.addressMap = new Map();\n        this.latestConfig = null;\n        this.timerStartTime = null;\n        this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler(experimental_1.createChildChannelControlHelper(channelControlHelper, {\n            createSubchannel: (subchannelAddress, subchannelArgs)=>{\n                const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n                const mapEntry = this.addressMap.get(subchannel_address_1.subchannelAddressToString(subchannelAddress));\n                const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);\n                if ((mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.currentEjectionTimestamp) !== null) {\n                    // If the address is ejected, propagate that to the new subchannel wrapper\n                    subchannelWrapper.eject();\n                }\n                mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);\n                return subchannelWrapper;\n            },\n            updateState: (connectivityState, picker)=>{\n                if (connectivityState === connectivity_state_1.ConnectivityState.READY) {\n                    channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()));\n                } else {\n                    channelControlHelper.updateState(connectivityState, picker);\n                }\n            }\n        }));\n        this.ejectionTimer = setInterval(()=>{}, 0);\n        clearInterval(this.ejectionTimer);\n    }\n    isCountingEnabled() {\n        return this.latestConfig !== null && (this.latestConfig.getSuccessRateEjectionConfig() !== null || this.latestConfig.getFailurePercentageEjectionConfig() !== null);\n    }\n    getCurrentEjectionPercent() {\n        let ejectionCount = 0;\n        for (const mapEntry of this.addressMap.values()){\n            if (mapEntry.currentEjectionTimestamp !== null) {\n                ejectionCount += 1;\n            }\n        }\n        return ejectionCount * 100 / this.addressMap.size;\n    }\n    runSuccessRateCheck(ejectionTimestamp) {\n        if (!this.latestConfig) {\n            return;\n        }\n        const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();\n        if (!successRateConfig) {\n            return;\n        }\n        trace(\"Running success rate check\");\n        // Step 1\n        const targetRequestVolume = successRateConfig.request_volume;\n        let addresesWithTargetVolume = 0;\n        const successRates = [];\n        for (const mapEntry of this.addressMap.values()){\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures >= targetRequestVolume) {\n                addresesWithTargetVolume += 1;\n                successRates.push(successes / (successes + failures));\n            }\n        }\n        trace(\"Found \" + addresesWithTargetVolume + \" success rate candidates; currentEjectionPercent=\" + this.getCurrentEjectionPercent() + \" successRates=[\" + successRates + \"]\");\n        if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {\n            return;\n        }\n        // Step 2\n        const successRateMean = successRates.reduce((a, b)=>a + b) / successRates.length;\n        let successRateDeviationSum = 0;\n        for (const rate of successRates){\n            const deviation = rate - successRateMean;\n            successRateDeviationSum += deviation * deviation;\n        }\n        const successRateVariance = successRateDeviationSum / successRates.length;\n        const successRateStdev = Math.sqrt(successRateVariance);\n        const ejectionThreshold = successRateMean - successRateStdev * (successRateConfig.stdev_factor / 1000);\n        trace(\"stdev=\" + successRateStdev + \" ejectionThreshold=\" + ejectionThreshold);\n        // Step 3\n        for (const [address, mapEntry] of this.addressMap.entries()){\n            // Step 3.i\n            if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {\n                break;\n            }\n            // Step 3.ii\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures < targetRequestVolume) {\n                continue;\n            }\n            // Step 3.iii\n            const successRate = successes / (successes + failures);\n            trace(\"Checking candidate \" + address + \" successRate=\" + successRate);\n            if (successRate < ejectionThreshold) {\n                const randomNumber = Math.random() * 100;\n                trace(\"Candidate \" + address + \" randomNumber=\" + randomNumber + \" enforcement_percentage=\" + successRateConfig.enforcement_percentage);\n                if (randomNumber < successRateConfig.enforcement_percentage) {\n                    trace(\"Ejecting candidate \" + address);\n                    this.eject(mapEntry, ejectionTimestamp);\n                }\n            }\n        }\n    }\n    runFailurePercentageCheck(ejectionTimestamp) {\n        if (!this.latestConfig) {\n            return;\n        }\n        const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();\n        if (!failurePercentageConfig) {\n            return;\n        }\n        trace(\"Running failure percentage check. threshold=\" + failurePercentageConfig.threshold + \" request volume threshold=\" + failurePercentageConfig.request_volume);\n        // Step 1\n        let addressesWithTargetVolume = 0;\n        for (const mapEntry of this.addressMap.values()){\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures >= failurePercentageConfig.request_volume) {\n                addressesWithTargetVolume += 1;\n            }\n        }\n        if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {\n            return;\n        }\n        // Step 2\n        for (const [address, mapEntry] of this.addressMap.entries()){\n            // Step 2.i\n            if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {\n                break;\n            }\n            // Step 2.ii\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            trace(\"Candidate successes=\" + successes + \" failures=\" + failures);\n            if (successes + failures < failurePercentageConfig.request_volume) {\n                continue;\n            }\n            // Step 2.iii\n            const failurePercentage = failures * 100 / (failures + successes);\n            if (failurePercentage > failurePercentageConfig.threshold) {\n                const randomNumber = Math.random() * 100;\n                trace(\"Candidate \" + address + \" randomNumber=\" + randomNumber + \" enforcement_percentage=\" + failurePercentageConfig.enforcement_percentage);\n                if (randomNumber < failurePercentageConfig.enforcement_percentage) {\n                    trace(\"Ejecting candidate \" + address);\n                    this.eject(mapEntry, ejectionTimestamp);\n                }\n            }\n        }\n    }\n    eject(mapEntry, ejectionTimestamp) {\n        mapEntry.currentEjectionTimestamp = new Date();\n        mapEntry.ejectionTimeMultiplier += 1;\n        for (const subchannelWrapper of mapEntry.subchannelWrappers){\n            subchannelWrapper.eject();\n        }\n    }\n    uneject(mapEntry) {\n        mapEntry.currentEjectionTimestamp = null;\n        for (const subchannelWrapper of mapEntry.subchannelWrappers){\n            subchannelWrapper.uneject();\n        }\n    }\n    switchAllBuckets() {\n        for (const mapEntry of this.addressMap.values()){\n            mapEntry.counter.switchBuckets();\n        }\n    }\n    startTimer(delayMs) {\n        this.ejectionTimer = setTimeout(()=>this.runChecks(), delayMs);\n    }\n    runChecks() {\n        const ejectionTimestamp = new Date();\n        trace(\"Ejection timer running\");\n        this.switchAllBuckets();\n        if (!this.latestConfig) {\n            return;\n        }\n        this.timerStartTime = ejectionTimestamp;\n        this.startTimer(this.latestConfig.getIntervalMs());\n        this.runSuccessRateCheck(ejectionTimestamp);\n        this.runFailurePercentageCheck(ejectionTimestamp);\n        for (const [address, mapEntry] of this.addressMap.entries()){\n            if (mapEntry.currentEjectionTimestamp === null) {\n                if (mapEntry.ejectionTimeMultiplier > 0) {\n                    mapEntry.ejectionTimeMultiplier -= 1;\n                }\n            } else {\n                const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();\n                const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();\n                const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());\n                returnTime.setMilliseconds(returnTime.getMilliseconds() + Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));\n                if (returnTime < new Date()) {\n                    trace(\"Unejecting \" + address);\n                    this.uneject(mapEntry);\n                }\n            }\n        }\n    }\n    updateAddressList(addressList, lbConfig, attributes) {\n        if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {\n            return;\n        }\n        const subchannelAddresses = new Set();\n        for (const address of addressList){\n            subchannelAddresses.add(subchannel_address_1.subchannelAddressToString(address));\n        }\n        for (const address of subchannelAddresses){\n            if (!this.addressMap.has(address)) {\n                trace(\"Adding map entry for \" + address);\n                this.addressMap.set(address, {\n                    counter: new CallCounter(),\n                    currentEjectionTimestamp: null,\n                    ejectionTimeMultiplier: 0,\n                    subchannelWrappers: []\n                });\n            }\n        }\n        for (const key of this.addressMap.keys()){\n            if (!subchannelAddresses.has(key)) {\n                trace(\"Removing map entry for \" + key);\n                this.addressMap.delete(key);\n            }\n        }\n        const childPolicy = load_balancer_1.getFirstUsableConfig(lbConfig.getChildPolicy(), true);\n        this.childBalancer.updateAddressList(addressList, childPolicy, attributes);\n        if (lbConfig.getSuccessRateEjectionConfig() || lbConfig.getFailurePercentageEjectionConfig()) {\n            if (this.timerStartTime) {\n                trace(\"Previous timer existed. Replacing timer\");\n                clearTimeout(this.ejectionTimer);\n                const remainingDelay = lbConfig.getIntervalMs() - (new Date().getTime() - this.timerStartTime.getTime());\n                this.startTimer(remainingDelay);\n            } else {\n                trace(\"Starting new timer\");\n                this.timerStartTime = new Date();\n                this.startTimer(lbConfig.getIntervalMs());\n                this.switchAllBuckets();\n            }\n        } else {\n            trace(\"Counting disabled. Cancelling timer.\");\n            this.timerStartTime = null;\n            clearTimeout(this.ejectionTimer);\n            for (const mapEntry of this.addressMap.values()){\n                this.uneject(mapEntry);\n                mapEntry.ejectionTimeMultiplier = 0;\n            }\n        }\n        this.latestConfig = lbConfig;\n    }\n    exitIdle() {\n        this.childBalancer.exitIdle();\n    }\n    resetBackoff() {\n        this.childBalancer.resetBackoff();\n    }\n    destroy() {\n        clearTimeout(this.ejectionTimer);\n        this.childBalancer.destroy();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;\nfunction setup() {\n    if (OUTLIER_DETECTION_ENABLED) {\n        experimental_1.registerLoadBalancerType(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);\n    }\n}\nexports.setup = setup; //# sourceMappingURL=load-balancer-outlier-detection.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1vdXRsaWVyLWRldGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELElBQUlBO0FBQ0pDLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxhQUFhLEdBQUdBLG9DQUFvQyxHQUFHQSwyQ0FBMkMsR0FBRyxLQUFLO0FBQzFHLE1BQU1LLHVCQUF1QkMsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1HLGlCQUFpQkgsbUJBQU9BLENBQUMsb0ZBQWdCO0FBQy9DLE1BQU1JLFdBQVdKLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DLE1BQU1LLGtCQUFrQkwsbUJBQU9BLENBQUMsc0ZBQWlCO0FBQ2pELE1BQU1NLGdDQUFnQ04sbUJBQU9BLENBQUMsa0hBQStCO0FBQzdFLE1BQU1PLFdBQVdQLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DLE1BQU1RLHVCQUF1QlIsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1TLHlCQUF5QlQsbUJBQU9BLENBQUMsb0dBQXdCO0FBQy9ELE1BQU1VLFVBQVVWLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1XLGNBQWM7QUFDcEIsU0FBU0MsTUFBTUMsSUFBSTtJQUNmSCxRQUFRRSxLQUFLLENBQUNYLFlBQVlhLFlBQVksQ0FBQ0MsS0FBSyxFQUFFSixhQUFhRTtBQUMvRDtBQUNBLE1BQU1HLFlBQVk7QUFDbEIsTUFBTUMsNEJBQTRCLENBQUMsQ0FBQzFCLEtBQUsyQixRQUFRQyxHQUFHLENBQUNDLDBDQUEwQyxNQUFNLFFBQVE3QixPQUFPLEtBQUssSUFBSUEsS0FBSyxNQUFLLE1BQU87QUFDOUksTUFBTThCLG1DQUFtQztJ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azovL2FzaG1pdHQtZ3VwdGEvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1vdXRsaWVyLWRldGVjdGlvbi5qcz8wMDZhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldHVwID0gZXhwb3J0cy5PdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2VyID0gZXhwb3J0cy5PdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZyA9IHZvaWQgMDtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBkdXJhdGlvbl8xID0gcmVxdWlyZShcIi4vZHVyYXRpb25cIik7XG5jb25zdCBleHBlcmltZW50YWxfMSA9IHJlcXVpcmUoXCIuL2V4cGVyaW1lbnRhbFwiKTtcbmNvbnN0IGZpbHRlcl8xID0gcmVxdWlyZShcIi4vZmlsdGVyXCIpO1xuY29uc3QgbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlclwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyXCIpO1xuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IHN1YmNoYW5uZWxfaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWludGVyZmFjZVwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnb3V0bGllcl9kZXRlY3Rpb24nO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jb25zdCBUWVBFX05BTUUgPSAnb3V0bGllcl9kZXRlY3Rpb24nO1xuY29uc3QgT1VUTElFUl9ERVRFQ1RJT05fRU5BQkxFRCA9ICgoX2EgPSBwcm9jZXNzLmVudi5HUlBDX0VYUEVSSU1FTlRBTF9FTkFCTEVfT1VUTElFUl9ERVRFQ1RJT04pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd0cnVlJykgPT09ICd0cnVlJztcbmNvbnN0IGRlZmF1bHRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnID0ge1xuICAgIHN0ZGV2X2ZhY3RvcjogMTkwMCxcbiAgICBlbmZvcmNlbWVudF9wZXJjZW50YWdlOiAxMDAsXG4gICAgbWluaW11bV9ob3N0czogNSxcbiAgICByZXF1ZXN0X3ZvbHVtZTogMTAwXG59O1xuY29uc3QgZGVmYXVsdEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcgPSB7XG4gICAgdGhyZXNob2xkOiA4NSxcbiAgICBlbmZvcmNlbWVudF9wZXJjZW50YWdlOiAxMDAsXG4gICAgbWluaW11bV9ob3N0czogNSxcbiAgICByZXF1ZXN0X3ZvbHVtZTogNTBcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUZpZWxkVHlwZShvYmosIGZpZWxkTmFtZSwgZXhwZWN0ZWRUeXBlLCBvYmplY3ROYW1lKSB7XG4gICAgaWYgKGZpZWxkTmFtZSBpbiBvYmogJiYgdHlwZW9mIG9ialtmaWVsZE5hbWVdICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgY29uc3QgZnVsbEZpZWxkTmFtZSA9IG9iamVjdE5hbWUgPyBgJHtvYmplY3ROYW1lfS4ke2ZpZWxkTmFtZX1gIDogZmllbGROYW1lO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyAke2Z1bGxGaWVsZE5hbWV9IHBhcnNlIGVycm9yOiBleHBlY3RlZCAke2V4cGVjdGVkVHlwZX0sIGdvdCAke3R5cGVvZiBvYmpbZmllbGROYW1lXX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBvc2l0aXZlRHVyYXRpb24ob2JqLCBmaWVsZE5hbWUsIG9iamVjdE5hbWUpIHtcbiAgICBjb25zdCBmdWxsRmllbGROYW1lID0gb2JqZWN0TmFtZSA/IGAke29iamVjdE5hbWV9LiR7ZmllbGROYW1lfWAgOiBmaWVsZE5hbWU7XG4gICAgaWYgKGZpZWxkTmFtZSBpbiBvYmopIHtcbiAgICAgICAgaWYgKCFkdXJhdGlvbl8xLmlzRHVyYXRpb24ob2JqW2ZpZWxkTmFtZV0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyAke2Z1bGxGaWVsZE5hbWV9IHBhcnNlIGVycm9yOiBleHBlY3RlZCBEdXJhdGlvbiwgZ290ICR7dHlwZW9mIG9ialtmaWVsZE5hbWVdfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKG9ialtmaWVsZE5hbWVdLnNlY29uZHMgPj0gMCAmJiBvYmpbZmllbGROYW1lXS5zZWNvbmRzIDw9IDMxNTU3NjAwMDAwMCAmJiBvYmpbZmllbGROYW1lXS5uYW5vcyA+PSAwICYmIG9ialtmaWVsZE5hbWVdLm5hbm9zIDw9IDk5OTk5OTk5OSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb3V0bGllciBkZXRlY3Rpb24gY29uZmlnICR7ZnVsbEZpZWxkTmFtZX0gcGFyc2UgZXJyb3I6IHZhbHVlcyBvdXQgb2YgcmFuZ2UgZm9yIG5vbi1uZWdhdGl2ZSBEdWFyYXRpb25gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUGVyY2VudGFnZShvYmosIGZpZWxkTmFtZSwgb2JqZWN0TmFtZSkge1xuICAgIGNvbnN0IGZ1bGxGaWVsZE5hbWUgPSBvYmplY3ROYW1lID8gYCR7b2JqZWN0TmFtZX0uJHtmaWVsZE5hbWV9YCA6IGZpZWxkTmFtZTtcbiAgICB2YWxpZGF0ZUZpZWxkVHlwZShvYmosIGZpZWxkTmFtZSwgJ251bWJlcicsIG9iamVjdE5hbWUpO1xuICAgIGlmIChmaWVsZE5hbWUgaW4gb2JqICYmICEob2JqW2ZpZWxkTmFtZV0gPj0gMCAmJiBvYmpbZmllbGROYW1lXSA8PSAxMDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgb3V0bGllciBkZXRlY3Rpb24gY29uZmlnICR7ZnVsbEZpZWxkTmFtZX0gcGFyc2UgZXJyb3I6IHZhbHVlIG91dCBvZiByYW5nZSBmb3IgcGVyY2VudGFnZSAoMC0xMDApYCk7XG4gICAgfVxufVxuY2xhc3MgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcge1xuICAgIGNvbnN0cnVjdG9yKGludGVydmFsTXMsIGJhc2VFamVjdGlvblRpbWVNcywgbWF4RWplY3Rpb25UaW1lTXMsIG1heEVqZWN0aW9uUGVyY2VudCwgc3VjY2Vzc1JhdGVFamVjdGlvbiwgZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbiwgY2hpbGRQb2xpY3kpIHtcbiAgICAgICAgdGhpcy5jaGlsZFBvbGljeSA9IGNoaWxkUG9saWN5O1xuICAgICAgICB0aGlzLmludGVydmFsTXMgPSBpbnRlcnZhbE1zICE9PSBudWxsICYmIGludGVydmFsTXMgIT09IHZvaWQgMCA/IGludGVydmFsTXMgOiAxMDAwMDtcbiAgICAgICAgdGhpcy5iYXNlRWplY3Rpb25UaW1lTXMgPSBiYXNlRWplY3Rpb25UaW1lTXMgIT09IG51bGwgJiYgYmFzZUVqZWN0aW9uVGltZU1zICE9PSB2b2lkIDAgPyBiYXNlRWplY3Rpb25UaW1lTXMgOiAzMDAwMDtcbiAgICAgICAgdGhpcy5tYXhFamVjdGlvblRpbWVNcyA9IG1heEVqZWN0aW9uVGltZU1zICE9PSBudWxsICYmIG1heEVqZWN0aW9uVGltZU1zICE9PSB2b2lkIDAgPyBtYXhFamVjdGlvblRpbWVNcyA6IDMwMDAwMDtcbiAgICAgICAgdGhpcy5tYXhFamVjdGlvblBlcmNlbnQgPSBtYXhFamVjdGlvblBlcmNlbnQgIT09IG51bGwgJiYgbWF4RWplY3Rpb25QZXJjZW50ICE9PSB2b2lkIDAgPyBtYXhFamVjdGlvblBlcmNlbnQgOiAxMDtcbiAgICAgICAgdGhpcy5zdWNjZXNzUmF0ZUVqZWN0aW9uID0gc3VjY2Vzc1JhdGVFamVjdGlvbiA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcpLCBzdWNjZXNzUmF0ZUVqZWN0aW9uKSA6IG51bGw7XG4gICAgICAgIHRoaXMuZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbiA9IGZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb24gPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnKSwgZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbikgOiBudWxsO1xuICAgIH1cbiAgICBnZXRMb2FkQmFsYW5jZXJOYW1lKCkge1xuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xuICAgIH1cbiAgICB0b0pzb25PYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRlcnZhbDogZHVyYXRpb25fMS5tc1RvRHVyYXRpb24odGhpcy5pbnRlcnZhbE1zKSxcbiAgICAgICAgICAgIGJhc2VfZWplY3Rpb25fdGltZTogZHVyYXRpb25fMS5tc1RvRHVyYXRpb24odGhpcy5iYXNlRWplY3Rpb25UaW1lTXMpLFxuICAgICAgICAgICAgbWF4X2VqZWN0aW9uX3RpbWU6IGR1cmF0aW9uXzEubXNUb0R1cmF0aW9uKHRoaXMubWF4RWplY3Rpb25UaW1lTXMpLFxuICAgICAgICAgICAgbWF4X2VqZWN0aW9uX3BlcmNlbnQ6IHRoaXMubWF4RWplY3Rpb25QZXJjZW50LFxuICAgICAgICAgICAgc3VjY2Vzc19yYXRlX2VqZWN0aW9uOiB0aGlzLnN1Y2Nlc3NSYXRlRWplY3Rpb24sXG4gICAgICAgICAgICBmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb246IHRoaXMuZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbixcbiAgICAgICAgICAgIGNoaWxkX3BvbGljeTogdGhpcy5jaGlsZFBvbGljeS5tYXAocG9saWN5ID0+IHBvbGljeS50b0pzb25PYmplY3QoKSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0SW50ZXJ2YWxNcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJ2YWxNcztcbiAgICB9XG4gICAgZ2V0QmFzZUVqZWN0aW9uVGltZU1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlRWplY3Rpb25UaW1lTXM7XG4gICAgfVxuICAgIGdldE1heEVqZWN0aW9uVGltZU1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhFamVjdGlvblRpbWVNcztcbiAgICB9XG4gICAgZ2V0TWF4RWplY3Rpb25QZXJjZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhFamVjdGlvblBlcmNlbnQ7XG4gICAgfVxuICAgIGdldFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Y2Nlc3NSYXRlRWplY3Rpb247XG4gICAgfVxuICAgIGdldEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb247XG4gICAgfVxuICAgIGdldENoaWxkUG9saWN5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZFBvbGljeTtcbiAgICB9XG4gICAgY29weVdpdGhDaGlsZFBvbGljeShjaGlsZFBvbGljeSkge1xuICAgICAgICByZXR1cm4gbmV3IE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnKHRoaXMuaW50ZXJ2YWxNcywgdGhpcy5iYXNlRWplY3Rpb25UaW1lTXMsIHRoaXMubWF4RWplY3Rpb25UaW1lTXMsIHRoaXMubWF4RWplY3Rpb25QZXJjZW50LCB0aGlzLnN1Y2Nlc3NSYXRlRWplY3Rpb24sIHRoaXMuZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbiwgY2hpbGRQb2xpY3kpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRnJvbUpzb24ob2JqKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFsaWRhdGVQb3NpdGl2ZUR1cmF0aW9uKG9iaiwgJ2ludGVydmFsJyk7XG4gICAgICAgIHZhbGlkYXRlUG9zaXRpdmVEdXJhdGlvbihvYmosICdiYXNlX2VqZWN0aW9uX3RpbWUnKTtcbiAgICAgICAgdmFsaWRhdGVQb3NpdGl2ZUR1cmF0aW9uKG9iaiwgJ21heF9lamVjdGlvbl90aW1lJyk7XG4gICAgICAgIHZhbGlkYXRlUGVyY2VudGFnZShvYmosICdtYXhfZWplY3Rpb25fcGVyY2VudCcpO1xuICAgICAgICBpZiAoJ3N1Y2Nlc3NfcmF0ZV9lamVjdGlvbicgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRsaWVyIGRldGVjdGlvbiBjb25maWcgc3VjY2Vzc19yYXRlX2VqZWN0aW9uIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxpZGF0ZUZpZWxkVHlwZShvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uLCAnc3RkZXZfZmFjdG9yJywgJ251bWJlcicsICdzdWNjZXNzX3JhdGVfZWplY3Rpb24nKTtcbiAgICAgICAgICAgIHZhbGlkYXRlUGVyY2VudGFnZShvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uLCAnZW5mb3JjZW1lbnRfcGVyY2VudGFnZScsICdzdWNjZXNzX3JhdGVfZWplY3Rpb24nKTtcbiAgICAgICAgICAgIHZhbGlkYXRlRmllbGRUeXBlKG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24sICdtaW5pbXVtX2hvc3RzJywgJ251bWJlcicsICdzdWNjZXNzX3JhdGVfZWplY3Rpb24nKTtcbiAgICAgICAgICAgIHZhbGlkYXRlRmllbGRUeXBlKG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24sICdyZXF1ZXN0X3ZvbHVtZScsICdudW1iZXInLCAnc3VjY2Vzc19yYXRlX2VqZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24nIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmouZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0bGllciBkZXRlY3Rpb24gY29uZmlnIGZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsaWRhdGVQZXJjZW50YWdlKG9iai5mYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24sICd0aHJlc2hvbGQnLCAnZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uJyk7XG4gICAgICAgICAgICB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiwgJ2VuZm9yY2VtZW50X3BlcmNlbnRhZ2UnLCAnZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uJyk7XG4gICAgICAgICAgICB2YWxpZGF0ZUZpZWxkVHlwZShvYmouZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uLCAnbWluaW11bV9ob3N0cycsICdudW1iZXInLCAnZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uJyk7XG4gICAgICAgICAgICB2YWxpZGF0ZUZpZWxkVHlwZShvYmouZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uLCAncmVxdWVzdF92b2x1bWUnLCAnbnVtYmVyJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcob2JqLmludGVydmFsID8gZHVyYXRpb25fMS5kdXJhdGlvblRvTXMob2JqLmludGVydmFsKSA6IG51bGwsIG9iai5iYXNlX2VqZWN0aW9uX3RpbWUgPyBkdXJhdGlvbl8xLmR1cmF0aW9uVG9NcyhvYmouYmFzZV9lamVjdGlvbl90aW1lKSA6IG51bGwsIG9iai5tYXhfZWplY3Rpb25fdGltZSA/IGR1cmF0aW9uXzEuZHVyYXRpb25Ub01zKG9iai5tYXhfZWplY3Rpb25fdGltZSkgOiBudWxsLCAoX2EgPSBvYmoubWF4X2VqZWN0aW9uX3BlcmNlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwsIG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24sIG9iai5mYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24sIG9iai5jaGlsZF9wb2xpY3kubWFwKGxvYWRfYmFsYW5jZXJfMS52YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWcpKTtcbiAgICB9XG59XG5leHBvcnRzLk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnID0gT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWc7XG5jbGFzcyBPdXRsaWVyRGV0ZWN0aW9uU3ViY2hhbm5lbFdyYXBwZXIgZXh0ZW5kcyBzdWJjaGFubmVsX2ludGVyZmFjZV8xLkJhc2VTdWJjaGFubmVsV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRTdWJjaGFubmVsLCBtYXBFbnRyeSkge1xuICAgICAgICBzdXBlcihjaGlsZFN1YmNoYW5uZWwpO1xuICAgICAgICB0aGlzLm1hcEVudHJ5ID0gbWFwRW50cnk7XG4gICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5lamVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVmQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmNoaWxkU3ViY2hhbm5lbFN0YXRlID0gY2hpbGRTdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCk7XG4gICAgICAgIGNoaWxkU3ViY2hhbm5lbC5hZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKChzdWJjaGFubmVsLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGlsZFN1YmNoYW5uZWxTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGVMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIodGhpcywgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKCkge1xuICAgICAgICBpZiAodGhpcy5lamVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZFN1YmNoYW5uZWxTdGF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHdyYXBwZXInc1xuICAgICAqIGNvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqL1xuICAgIGFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zdGF0ZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgbGlzdGVuZXIgcHJldmlvdXNseSBhZGRlZCB3aXRoIGBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyYFxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBBIHJlZmVyZW5jZSB0byBhIGZ1bmN0aW9uIHByZXZpb3VzbHkgcGFzc2VkIHRvXG4gICAgICogICAgIGBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyYFxuICAgICAqL1xuICAgIHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJJbmRleCA9IHRoaXMuc3RhdGVMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgIGlmIChsaXN0ZW5lckluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMuc3BsaWNlKGxpc3RlbmVySW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZigpIHtcbiAgICAgICAgdGhpcy5jaGlsZC5yZWYoKTtcbiAgICAgICAgdGhpcy5yZWZDb3VudCArPSAxO1xuICAgIH1cbiAgICB1bnJlZigpIHtcbiAgICAgICAgdGhpcy5jaGlsZC51bnJlZigpO1xuICAgICAgICB0aGlzLnJlZkNvdW50IC09IDE7XG4gICAgICAgIGlmICh0aGlzLnJlZkNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcEVudHJ5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycy5pbmRleE9mKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwRW50cnkuc3ViY2hhbm5lbFdyYXBwZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVqZWN0KCkge1xuICAgICAgICB0aGlzLmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGVMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKHRoaXMsIHRoaXMuY2hpbGRTdWJjaGFubmVsU3RhdGUsIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bmVqZWN0KCkge1xuICAgICAgICB0aGlzLmVqZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcih0aGlzLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgdGhpcy5jaGlsZFN1YmNoYW5uZWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TWFwRW50cnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcEVudHJ5O1xuICAgIH1cbiAgICBnZXRXcmFwcGVkU3ViY2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQ7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRW1wdHlCdWNrZXQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogMCxcbiAgICAgICAgZmFpbHVyZTogMFxuICAgIH07XG59XG5jbGFzcyBDYWxsQ291bnRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQnVja2V0ID0gY3JlYXRlRW1wdHlCdWNrZXQoKTtcbiAgICAgICAgdGhpcy5pbmFjdGl2ZUJ1Y2tldCA9IGNyZWF0ZUVtcHR5QnVja2V0KCk7XG4gICAgfVxuICAgIGFkZFN1Y2Nlc3MoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQnVja2V0LnN1Y2Nlc3MgKz0gMTtcbiAgICB9XG4gICAgYWRkRmFpbHVyZSgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVCdWNrZXQuZmFpbHVyZSArPSAxO1xuICAgIH1cbiAgICBzd2l0Y2hCdWNrZXRzKCkge1xuICAgICAgICB0aGlzLmluYWN0aXZlQnVja2V0ID0gdGhpcy5hY3RpdmVCdWNrZXQ7XG4gICAgICAgIHRoaXMuYWN0aXZlQnVja2V0ID0gY3JlYXRlRW1wdHlCdWNrZXQoKTtcbiAgICB9XG4gICAgZ2V0TGFzdFN1Y2Nlc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5hY3RpdmVCdWNrZXQuc3VjY2VzcztcbiAgICB9XG4gICAgZ2V0TGFzdEZhaWx1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmFjdGl2ZUJ1Y2tldC5mYWlsdXJlO1xuICAgIH1cbn1cbmNsYXNzIE91dGxpZXJEZXRlY3Rpb25Db3VudGVyRmlsdGVyIGV4dGVuZHMgZmlsdGVyXzEuQmFzZUZpbHRlciB7XG4gICAgY29uc3RydWN0b3IoY2FsbENvdW50ZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jYWxsQ291bnRlciA9IGNhbGxDb3VudGVyO1xuICAgIH1cbiAgICByZWNlaXZlVHJhaWxlcnMoc3RhdHVzKSB7XG4gICAgICAgIGlmIChzdGF0dXMuY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxDb3VudGVyLmFkZFN1Y2Nlc3MoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbENvdW50ZXIuYWRkRmFpbHVyZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxufVxuY2xhc3MgT3V0bGllckRldGVjdGlvbkNvdW50ZXJGaWx0ZXJGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsQ291bnRlcikge1xuICAgICAgICB0aGlzLmNhbGxDb3VudGVyID0gY2FsbENvdW50ZXI7XG4gICAgfVxuICAgIGNyZWF0ZUZpbHRlcihjYWxsU3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgT3V0bGllckRldGVjdGlvbkNvdW50ZXJGaWx0ZXIodGhpcy5jYWxsQ291bnRlcik7XG4gICAgfVxufVxuY2xhc3MgT3V0bGllckRldGVjdGlvblBpY2tlciB7XG4gICAgY29uc3RydWN0b3Iod3JhcHBlZFBpY2tlciwgY291bnRDYWxscykge1xuICAgICAgICB0aGlzLndyYXBwZWRQaWNrZXIgPSB3cmFwcGVkUGlja2VyO1xuICAgICAgICB0aGlzLmNvdW50Q2FsbHMgPSBjb3VudENhbGxzO1xuICAgIH1cbiAgICBwaWNrKHBpY2tBcmdzKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRQaWNrID0gdGhpcy53cmFwcGVkUGlja2VyLnBpY2socGlja0FyZ3MpO1xuICAgICAgICBpZiAod3JhcHBlZFBpY2sucGlja1Jlc3VsdFR5cGUgPT09IHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlLkNPTVBMRVRFKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsV3JhcHBlciA9IHdyYXBwZWRQaWNrLnN1YmNoYW5uZWw7XG4gICAgICAgICAgICBjb25zdCBtYXBFbnRyeSA9IHN1YmNoYW5uZWxXcmFwcGVyLmdldE1hcEVudHJ5KCk7XG4gICAgICAgICAgICBpZiAobWFwRW50cnkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHRyYUZpbHRlckZhY3RvcmllcyA9IFsuLi53cmFwcGVkUGljay5leHRyYUZpbHRlckZhY3Rvcmllc107XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY291bnRDYWxscykge1xuICAgICAgICAgICAgICAgICAgICBleHRyYUZpbHRlckZhY3Rvcmllcy5wdXNoKG5ldyBPdXRsaWVyRGV0ZWN0aW9uQ291bnRlckZpbHRlckZhY3RvcnkobWFwRW50cnkuY291bnRlcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3cmFwcGVkUGljayksIHsgc3ViY2hhbm5lbDogc3ViY2hhbm5lbFdyYXBwZXIuZ2V0V3JhcHBlZFN1YmNoYW5uZWwoKSwgZXh0cmFGaWx0ZXJGYWN0b3JpZXM6IGV4dHJhRmlsdGVyRmFjdG9yaWVzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd3JhcHBlZFBpY2spLCB7IHN1YmNoYW5uZWw6IHN1YmNoYW5uZWxXcmFwcGVyLmdldFdyYXBwZWRTdWJjaGFubmVsKCkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlZFBpY2s7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2VyIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsQ29udHJvbEhlbHBlcikge1xuICAgICAgICB0aGlzLmFkZHJlc3NNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubGF0ZXN0Q29uZmlnID0gbnVsbDtcbiAgICAgICAgdGhpcy50aW1lclN0YXJ0VGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlciA9IG5ldyBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMS5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXIoZXhwZXJpbWVudGFsXzEuY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlcihjaGFubmVsQ29udHJvbEhlbHBlciwge1xuICAgICAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3ViY2hhbm5lbCA9IGNoYW5uZWxDb250cm9sSGVscGVyLmNyZWF0ZVN1YmNoYW5uZWwoc3ViY2hhbm5lbEFkZHJlc3MsIHN1YmNoYW5uZWxBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXBFbnRyeSA9IHRoaXMuYWRkcmVzc01hcC5nZXQoc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyhzdWJjaGFubmVsQWRkcmVzcykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxXcmFwcGVyID0gbmV3IE91dGxpZXJEZXRlY3Rpb25TdWJjaGFubmVsV3JhcHBlcihvcmlnaW5hbFN1YmNoYW5uZWwsIG1hcEVudHJ5KTtcbiAgICAgICAgICAgICAgICBpZiAoKG1hcEVudHJ5ID09PSBudWxsIHx8IG1hcEVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXBFbnRyeS5jdXJyZW50RWplY3Rpb25UaW1lc3RhbXApICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhZGRyZXNzIGlzIGVqZWN0ZWQsIHByb3BhZ2F0ZSB0aGF0IHRvIHRoZSBuZXcgc3ViY2hhbm5lbCB3cmFwcGVyXG4gICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxXcmFwcGVyLmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcEVudHJ5ID09PSBudWxsIHx8IG1hcEVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXBFbnRyeS5zdWJjaGFubmVsV3JhcHBlcnMucHVzaChzdWJjaGFubmVsV3JhcHBlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YmNoYW5uZWxXcmFwcGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlOiAoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvbnRyb2xIZWxwZXIudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5U3RhdGUsIG5ldyBPdXRsaWVyRGV0ZWN0aW9uUGlja2VyKHBpY2tlciwgdGhpcy5pc0NvdW50aW5nRW5hYmxlZCgpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5lamVjdGlvblRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmVqZWN0aW9uVGltZXIpO1xuICAgIH1cbiAgICBpc0NvdW50aW5nRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF0ZXN0Q29uZmlnICE9PSBudWxsICYmXG4gICAgICAgICAgICAodGhpcy5sYXRlc3RDb25maWcuZ2V0U3VjY2Vzc1JhdGVFamVjdGlvbkNvbmZpZygpICE9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RDb25maWcuZ2V0RmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbkNvbmZpZygpICE9PSBudWxsKTtcbiAgICB9XG4gICAgZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCgpIHtcbiAgICAgICAgbGV0IGVqZWN0aW9uQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IG1hcEVudHJ5IG9mIHRoaXMuYWRkcmVzc01hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVqZWN0aW9uQ291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGVqZWN0aW9uQ291bnQgKiAxMDApIC8gdGhpcy5hZGRyZXNzTWFwLnNpemU7XG4gICAgfVxuICAgIHJ1blN1Y2Nlc3NSYXRlQ2hlY2soZWplY3Rpb25UaW1lc3RhbXApIHtcbiAgICAgICAgaWYgKCF0aGlzLmxhdGVzdENvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlQ29uZmlnID0gdGhpcy5sYXRlc3RDb25maWcuZ2V0U3VjY2Vzc1JhdGVFamVjdGlvbkNvbmZpZygpO1xuICAgICAgICBpZiAoIXN1Y2Nlc3NSYXRlQ29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2UoJ1J1bm5pbmcgc3VjY2VzcyByYXRlIGNoZWNrJyk7XG4gICAgICAgIC8vIFN0ZXAgMVxuICAgICAgICBjb25zdCB0YXJnZXRSZXF1ZXN0Vm9sdW1lID0gc3VjY2Vzc1JhdGVDb25maWcucmVxdWVzdF92b2x1bWU7XG4gICAgICAgIGxldCBhZGRyZXNlc1dpdGhUYXJnZXRWb2x1bWUgPSAwO1xuICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBtYXBFbnRyeSBvZiB0aGlzLmFkZHJlc3NNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdFN1Y2Nlc3NlcygpO1xuICAgICAgICAgICAgY29uc3QgZmFpbHVyZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RGYWlsdXJlcygpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyArIGZhaWx1cmVzID49IHRhcmdldFJlcXVlc3RWb2x1bWUpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNlc1dpdGhUYXJnZXRWb2x1bWUgKz0gMTtcbiAgICAgICAgICAgICAgICBzdWNjZXNzUmF0ZXMucHVzaChzdWNjZXNzZXMgLyAoc3VjY2Vzc2VzICsgZmFpbHVyZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnRm91bmQgJyArIGFkZHJlc2VzV2l0aFRhcmdldFZvbHVtZSArICcgc3VjY2VzcyByYXRlIGNhbmRpZGF0ZXM7IGN1cnJlbnRFamVjdGlvblBlcmNlbnQ9JyArIHRoaXMuZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCgpICsgJyBzdWNjZXNzUmF0ZXM9WycgKyBzdWNjZXNzUmF0ZXMgKyAnXScpO1xuICAgICAgICBpZiAoYWRkcmVzZXNXaXRoVGFyZ2V0Vm9sdW1lIDwgc3VjY2Vzc1JhdGVDb25maWcubWluaW11bV9ob3N0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0ZXAgMlxuICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZU1lYW4gPSBzdWNjZXNzUmF0ZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYikgLyBzdWNjZXNzUmF0ZXMubGVuZ3RoO1xuICAgICAgICBsZXQgc3VjY2Vzc1JhdGVEZXZpYXRpb25TdW0gPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHJhdGUgb2Ygc3VjY2Vzc1JhdGVzKSB7XG4gICAgICAgICAgICBjb25zdCBkZXZpYXRpb24gPSByYXRlIC0gc3VjY2Vzc1JhdGVNZWFuO1xuICAgICAgICAgICAgc3VjY2Vzc1JhdGVEZXZpYXRpb25TdW0gKz0gZGV2aWF0aW9uICogZGV2aWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlVmFyaWFuY2UgPSBzdWNjZXNzUmF0ZURldmlhdGlvblN1bSAvIHN1Y2Nlc3NSYXRlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlU3RkZXYgPSBNYXRoLnNxcnQoc3VjY2Vzc1JhdGVWYXJpYW5jZSk7XG4gICAgICAgIGNvbnN0IGVqZWN0aW9uVGhyZXNob2xkID0gc3VjY2Vzc1JhdGVNZWFuIC0gc3VjY2Vzc1JhdGVTdGRldiAqIChzdWNjZXNzUmF0ZUNvbmZpZy5zdGRldl9mYWN0b3IgLyAxMDAwKTtcbiAgICAgICAgdHJhY2UoJ3N0ZGV2PScgKyBzdWNjZXNzUmF0ZVN0ZGV2ICsgJyBlamVjdGlvblRocmVzaG9sZD0nICsgZWplY3Rpb25UaHJlc2hvbGQpO1xuICAgICAgICAvLyBTdGVwIDNcbiAgICAgICAgZm9yIChjb25zdCBbYWRkcmVzcywgbWFwRW50cnldIG9mIHRoaXMuYWRkcmVzc01hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIC8vIFN0ZXAgMy5pXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRDdXJyZW50RWplY3Rpb25QZXJjZW50KCkgPj0gdGhpcy5sYXRlc3RDb25maWcuZ2V0TWF4RWplY3Rpb25QZXJjZW50KCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0ZXAgMy5paVxuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc2VzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0U3VjY2Vzc2VzKCk7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdEZhaWx1cmVzKCk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgZmFpbHVyZXMgPCB0YXJnZXRSZXF1ZXN0Vm9sdW1lKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGVwIDMuaWlpXG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZSA9IHN1Y2Nlc3NlcyAvIChzdWNjZXNzZXMgKyBmYWlsdXJlcyk7XG4gICAgICAgICAgICB0cmFjZSgnQ2hlY2tpbmcgY2FuZGlkYXRlICcgKyBhZGRyZXNzICsgJyBzdWNjZXNzUmF0ZT0nICsgc3VjY2Vzc1JhdGUpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NSYXRlIDwgZWplY3Rpb25UaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5kb21OdW1iZXIgPSBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgICAgICAgICAgIHRyYWNlKCdDYW5kaWRhdGUgJyArIGFkZHJlc3MgKyAnIHJhbmRvbU51bWJlcj0nICsgcmFuZG9tTnVtYmVyICsgJyBlbmZvcmNlbWVudF9wZXJjZW50YWdlPScgKyBzdWNjZXNzUmF0ZUNvbmZpZy5lbmZvcmNlbWVudF9wZXJjZW50YWdlKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZG9tTnVtYmVyIDwgc3VjY2Vzc1JhdGVDb25maWcuZW5mb3JjZW1lbnRfcGVyY2VudGFnZSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgnRWplY3RpbmcgY2FuZGlkYXRlICcgKyBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lamVjdChtYXBFbnRyeSwgZWplY3Rpb25UaW1lc3RhbXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5GYWlsdXJlUGVyY2VudGFnZUNoZWNrKGVqZWN0aW9uVGltZXN0YW1wKSB7XG4gICAgICAgIGlmICghdGhpcy5sYXRlc3RDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZyA9IHRoaXMubGF0ZXN0Q29uZmlnLmdldEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcoKTtcbiAgICAgICAgaWYgKCFmYWlsdXJlUGVyY2VudGFnZUNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlKCdSdW5uaW5nIGZhaWx1cmUgcGVyY2VudGFnZSBjaGVjay4gdGhyZXNob2xkPScgKyBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy50aHJlc2hvbGQgKyAnIHJlcXVlc3Qgdm9sdW1lIHRocmVzaG9sZD0nICsgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcucmVxdWVzdF92b2x1bWUpO1xuICAgICAgICAvLyBTdGVwIDFcbiAgICAgICAgbGV0IGFkZHJlc3Nlc1dpdGhUYXJnZXRWb2x1bWUgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IG1hcEVudHJ5IG9mIHRoaXMuYWRkcmVzc01hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc2VzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0U3VjY2Vzc2VzKCk7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdEZhaWx1cmVzKCk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgZmFpbHVyZXMgPj0gZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcucmVxdWVzdF92b2x1bWUpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzZXNXaXRoVGFyZ2V0Vm9sdW1lICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZHJlc3Nlc1dpdGhUYXJnZXRWb2x1bWUgPCBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5taW5pbXVtX2hvc3RzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RlcCAyXG4gICAgICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIG1hcEVudHJ5XSBvZiB0aGlzLmFkZHJlc3NNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICAvLyBTdGVwIDIuaVxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCgpID49IHRoaXMubGF0ZXN0Q29uZmlnLmdldE1heEVqZWN0aW9uUGVyY2VudCgpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGVwIDIuaWlcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdFN1Y2Nlc3NlcygpO1xuICAgICAgICAgICAgY29uc3QgZmFpbHVyZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RGYWlsdXJlcygpO1xuICAgICAgICAgICAgdHJhY2UoJ0NhbmRpZGF0ZSBzdWNjZXNzZXM9JyArIHN1Y2Nlc3NlcyArICcgZmFpbHVyZXM9JyArIGZhaWx1cmVzKTtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzZXMgKyBmYWlsdXJlcyA8IGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLnJlcXVlc3Rfdm9sdW1lKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGVwIDIuaWlpXG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlUGVyY2VudGFnZSA9IChmYWlsdXJlcyAqIDEwMCkgLyAoZmFpbHVyZXMgKyBzdWNjZXNzZXMpO1xuICAgICAgICAgICAgaWYgKGZhaWx1cmVQZXJjZW50YWdlID4gZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZG9tTnVtYmVyID0gTWF0aC5yYW5kb20oKSAqIDEwMDtcbiAgICAgICAgICAgICAgICB0cmFjZSgnQ2FuZGlkYXRlICcgKyBhZGRyZXNzICsgJyByYW5kb21OdW1iZXI9JyArIHJhbmRvbU51bWJlciArICcgZW5mb3JjZW1lbnRfcGVyY2VudGFnZT0nICsgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcuZW5mb3JjZW1lbnRfcGVyY2VudGFnZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmRvbU51bWJlciA8IGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLmVuZm9yY2VtZW50X3BlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ0VqZWN0aW5nIGNhbmRpZGF0ZSAnICsgYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWplY3QobWFwRW50cnksIGVqZWN0aW9uVGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWplY3QobWFwRW50cnksIGVqZWN0aW9uVGltZXN0YW1wKSB7XG4gICAgICAgIG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIG1hcEVudHJ5LmVqZWN0aW9uVGltZU11bHRpcGxpZXIgKz0gMTtcbiAgICAgICAgZm9yIChjb25zdCBzdWJjaGFubmVsV3JhcHBlciBvZiBtYXBFbnRyeS5zdWJjaGFubmVsV3JhcHBlcnMpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWxXcmFwcGVyLmVqZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5lamVjdChtYXBFbnRyeSkge1xuICAgICAgICBtYXBFbnRyeS5jdXJyZW50RWplY3Rpb25UaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWxXcmFwcGVyIG9mIG1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycykge1xuICAgICAgICAgICAgc3ViY2hhbm5lbFdyYXBwZXIudW5lamVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaEFsbEJ1Y2tldHMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgbWFwRW50cnkgb2YgdGhpcy5hZGRyZXNzTWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBtYXBFbnRyeS5jb3VudGVyLnN3aXRjaEJ1Y2tldHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydFRpbWVyKGRlbGF5TXMpIHtcbiAgICAgICAgdGhpcy5lamVjdGlvblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnJ1bkNoZWNrcygpLCBkZWxheU1zKTtcbiAgICB9XG4gICAgcnVuQ2hlY2tzKCkge1xuICAgICAgICBjb25zdCBlamVjdGlvblRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRyYWNlKCdFamVjdGlvbiB0aW1lciBydW5uaW5nJyk7XG4gICAgICAgIHRoaXMuc3dpdGNoQWxsQnVja2V0cygpO1xuICAgICAgICBpZiAoIXRoaXMubGF0ZXN0Q29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aW1lclN0YXJ0VGltZSA9IGVqZWN0aW9uVGltZXN0YW1wO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZXIodGhpcy5sYXRlc3RDb25maWcuZ2V0SW50ZXJ2YWxNcygpKTtcbiAgICAgICAgdGhpcy5ydW5TdWNjZXNzUmF0ZUNoZWNrKGVqZWN0aW9uVGltZXN0YW1wKTtcbiAgICAgICAgdGhpcy5ydW5GYWlsdXJlUGVyY2VudGFnZUNoZWNrKGVqZWN0aW9uVGltZXN0YW1wKTtcbiAgICAgICAgZm9yIChjb25zdCBbYWRkcmVzcywgbWFwRW50cnldIG9mIHRoaXMuYWRkcmVzc01hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChtYXBFbnRyeS5jdXJyZW50RWplY3Rpb25UaW1lc3RhbXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VFamVjdGlvblRpbWVNcyA9IHRoaXMubGF0ZXN0Q29uZmlnLmdldEJhc2VFamVjdGlvblRpbWVNcygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heEVqZWN0aW9uVGltZU1zID0gdGhpcy5sYXRlc3RDb25maWcuZ2V0TWF4RWplY3Rpb25UaW1lTXMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXR1cm5UaW1lID0gbmV3IERhdGUobWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuVGltZS5zZXRNaWxsaXNlY29uZHMocmV0dXJuVGltZS5nZXRNaWxsaXNlY29uZHMoKSArIE1hdGgubWluKGJhc2VFamVjdGlvblRpbWVNcyAqIG1hcEVudHJ5LmVqZWN0aW9uVGltZU11bHRpcGxpZXIsIE1hdGgubWF4KGJhc2VFamVjdGlvblRpbWVNcywgbWF4RWplY3Rpb25UaW1lTXMpKSk7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVyblRpbWUgPCBuZXcgRGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdVbmVqZWN0aW5nICcgKyBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bmVqZWN0KG1hcEVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGxiQ29uZmlnLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmICghKGxiQ29uZmlnIGluc3RhbmNlb2YgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3ViY2hhbm5lbEFkZHJlc3NlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIGFkZHJlc3NMaXN0KSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsQWRkcmVzc2VzLmFkZChzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKGFkZHJlc3MpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2Ygc3ViY2hhbm5lbEFkZHJlc3Nlcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFkZHJlc3NNYXAuaGFzKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ0FkZGluZyBtYXAgZW50cnkgZm9yICcgKyBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZHJlc3NNYXAuc2V0KGFkZHJlc3MsIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcjogbmV3IENhbGxDb3VudGVyKCksXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFamVjdGlvblRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZWplY3Rpb25UaW1lTXVsdGlwbGllcjogMCxcbiAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFdyYXBwZXJzOiBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMuYWRkcmVzc01hcC5rZXlzKCkpIHtcbiAgICAgICAgICAgIGlmICghc3ViY2hhbm5lbEFkZHJlc3Nlcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHRyYWNlKCdSZW1vdmluZyBtYXAgZW50cnkgZm9yICcgKyBrZXkpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkcmVzc01hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZFBvbGljeSA9IGxvYWRfYmFsYW5jZXJfMS5nZXRGaXJzdFVzYWJsZUNvbmZpZyhsYkNvbmZpZy5nZXRDaGlsZFBvbGljeSgpLCB0cnVlKTtcbiAgICAgICAgdGhpcy5jaGlsZEJhbGFuY2VyLnVwZGF0ZUFkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBjaGlsZFBvbGljeSwgYXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChsYkNvbmZpZy5nZXRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKCkgfHwgbGJDb25maWcuZ2V0RmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbkNvbmZpZygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50aW1lclN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIHRyYWNlKCdQcmV2aW91cyB0aW1lciBleGlzdGVkLiBSZXBsYWNpbmcgdGltZXInKTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5lamVjdGlvblRpbWVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmdEZWxheSA9IGxiQ29uZmlnLmdldEludGVydmFsTXMoKSAtICgobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gdGhpcy50aW1lclN0YXJ0VGltZS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lcihyZW1haW5pbmdEZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFjZSgnU3RhcnRpbmcgbmV3IHRpbWVyJyk7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lclN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFRpbWVyKGxiQ29uZmlnLmdldEludGVydmFsTXMoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zd2l0Y2hBbGxCdWNrZXRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cmFjZSgnQ291bnRpbmcgZGlzYWJsZWQuIENhbmNlbGxpbmcgdGltZXIuJyk7XG4gICAgICAgICAgICB0aGlzLnRpbWVyU3RhcnRUaW1lID0gbnVsbDtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmVqZWN0aW9uVGltZXIpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBtYXBFbnRyeSBvZiB0aGlzLmFkZHJlc3NNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuZWplY3QobWFwRW50cnkpO1xuICAgICAgICAgICAgICAgIG1hcEVudHJ5LmVqZWN0aW9uVGltZU11bHRpcGxpZXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF0ZXN0Q29uZmlnID0gbGJDb25maWc7XG4gICAgfVxuICAgIGV4aXRJZGxlKCkge1xuICAgICAgICB0aGlzLmNoaWxkQmFsYW5jZXIuZXhpdElkbGUoKTtcbiAgICB9XG4gICAgcmVzZXRCYWNrb2ZmKCkge1xuICAgICAgICB0aGlzLmNoaWxkQmFsYW5jZXIucmVzZXRCYWNrb2ZmKCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmVqZWN0aW9uVGltZXIpO1xuICAgICAgICB0aGlzLmNoaWxkQmFsYW5jZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBnZXRUeXBlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFRZUEVfTkFNRTtcbiAgICB9XG59XG5leHBvcnRzLk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jZXIgPSBPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2VyO1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgaWYgKE9VVExJRVJfREVURUNUSU9OX0VOQUJMRUQpIHtcbiAgICAgICAgZXhwZXJpbWVudGFsXzEucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlKFRZUEVfTkFNRSwgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciwgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcpO1xuICAgIH1cbn1cbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtYmFsYW5jZXItb3V0bGllci1kZXRlY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbIl9hIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzZXR1cCIsIk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jZXIiLCJPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZyIsImNvbm5lY3Rpdml0eV9zdGF0ZV8xIiwicmVxdWlyZSIsImNvbnN0YW50c18xIiwiZHVyYXRpb25fMSIsImV4cGVyaW1lbnRhbF8xIiwiZmlsdGVyXzEiLCJsb2FkX2JhbGFuY2VyXzEiLCJsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMSIsInBpY2tlcl8xIiwic3ViY2hhbm5lbF9hZGRyZXNzXzEiLCJzdWJjaGFubmVsX2ludGVyZmFjZV8xIiwibG9nZ2luZyIsIlRSQUNFUl9OQU1FIiwidHJhY2UiLCJ0ZXh0IiwiTG9nVmVyYm9zaXR5IiwiREVCVUciLCJUWVBFX05BTUUiLCJPVVRMSUVSX0RFVEVDVElPTl9FTkFCTEVEIiwicHJvY2VzcyIsImVudiIsIkdSUENfRVhQRVJJTUVOVEFMX0VOQUJMRV9PVVRMSUVSX0RFVEVDVElPTiIsImRlZmF1bHRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnIiwic3RkZXZfZmFjdG9yIiwiZW5mb3JjZW1lbnRfcGVyY2VudGFnZSIsIm1pbmltdW1faG9zdHMiLCJyZXF1ZXN0X3ZvbHVtZSIsImRlZmF1bHRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnIiwidGhyZXNob2xkIiwidmFsaWRhdGVGaWVsZFR5cGUiLCJvYmoiLCJmaWVsZE5hbWUiLCJleHBlY3RlZFR5cGUiLCJvYmplY3ROYW1lIiwiZnVsbEZpZWxkTmFtZSIsIkVycm9yIiwidmFsaWRhdGVQb3NpdGl2ZUR1cmF0aW9uIiwiaXNEdXJhdGlvbiIsInNlY29uZHMiLCJuYW5vcyIsInZhbGlkYXRlUGVyY2VudGFnZSIsImNvbnN0cnVjdG9yIiwiaW50ZXJ2YWxNcyIsImJhc2VFamVjdGlvblRpbWVNcyIsIm1heEVqZWN0aW9uVGltZU1zIiwibWF4RWplY3Rpb25QZXJjZW50Iiwic3VjY2Vzc1JhdGVFamVjdGlvbiIsImZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb24iLCJjaGlsZFBvbGljeSIsImFzc2lnbiIsImdldExvYWRCYWxhbmNlck5hbWUiLCJ0b0pzb25PYmplY3QiLCJpbnRlcnZhbCIsIm1zVG9EdXJhdGlvbiIsImJhc2VfZWplY3Rpb25fdGltZSIsIm1heF9lamVjdGlvbl90aW1lIiwibWF4X2VqZWN0aW9uX3BlcmNlbnQiLCJzdWNjZXNzX3JhdGVfZWplY3Rpb24iLCJmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24iLCJjaGlsZF9wb2xpY3kiLCJtYXAiLCJwb2xpY3kiLCJnZXRJbnRlcnZhbE1zIiwiZ2V0QmFzZUVqZWN0aW9uVGltZU1zIiwiZ2V0TWF4RWplY3Rpb25UaW1lTXMiLCJnZXRNYXhFamVjdGlvblBlcmNlbnQiLCJnZXRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnIiwiZ2V0RmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbkNvbmZpZyIsImdldENoaWxkUG9saWN5IiwiY29weVdpdGhDaGlsZFBvbGljeSIsImNyZWF0ZUZyb21Kc29uIiwiZHVyYXRpb25Ub01zIiwidmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnIiwiT3V0bGllckRldGVjdGlvblN1YmNoYW5uZWxXcmFwcGVyIiwiQmFzZVN1YmNoYW5uZWxXcmFwcGVyIiwiY2hpbGRTdWJjaGFubmVsIiwibWFwRW50cnkiLCJzdGF0ZUxpc3RlbmVycyIsImVqZWN0ZWQiLCJyZWZDb3VudCIsImNoaWxkU3ViY2hhbm5lbFN0YXRlIiwiZ2V0Q29ubmVjdGl2aXR5U3RhdGUiLCJhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyIiwic3ViY2hhbm5lbCIsInByZXZpb3VzU3RhdGUiLCJuZXdTdGF0ZSIsImxpc3RlbmVyIiwiQ29ubmVjdGl2aXR5U3RhdGUiLCJUUkFOU0lFTlRfRkFJTFVSRSIsInB1c2giLCJyZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyIiwibGlzdGVuZXJJbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJyZWYiLCJjaGlsZCIsInVucmVmIiwiaW5kZXgiLCJzdWJjaGFubmVsV3JhcHBlcnMiLCJlamVjdCIsInVuZWplY3QiLCJnZXRNYXBFbnRyeSIsImdldFdyYXBwZWRTdWJjaGFubmVsIiwiY3JlYXRlRW1wdHlCdWNrZXQiLCJzdWNjZXNzIiwiZmFpbHVyZSIsIkNhbGxDb3VudGVyIiwiYWN0aXZlQnVja2V0IiwiaW5hY3RpdmVCdWNrZXQiLCJhZGRTdWNjZXNzIiwiYWRkRmFpbHVyZSIsInN3aXRjaEJ1Y2tldHMiLCJnZXRMYXN0U3VjY2Vzc2VzIiwiZ2V0TGFzdEZhaWx1cmVzIiwiT3V0bGllckRldGVjdGlvbkNvdW50ZXJGaWx0ZXIiLCJCYXNlRmlsdGVyIiwiY2FsbENvdW50ZXIiLCJyZWNlaXZlVHJhaWxlcnMiLCJzdGF0dXMiLCJjb2RlIiwiU3RhdHVzIiwiT0siLCJPdXRsaWVyRGV0ZWN0aW9uQ291bnRlckZpbHRlckZhY3RvcnkiLCJjcmVhdGVGaWx0ZXIiLCJjYWxsU3RyZWFtIiwiT3V0bGllckRldGVjdGlvblBpY2tlciIsIndyYXBwZWRQaWNrZXIiLCJjb3VudENhbGxzIiwicGljayIsInBpY2tBcmdzIiwid3JhcHBlZFBpY2siLCJwaWNrUmVzdWx0VHlwZSIsIlBpY2tSZXN1bHRUeXBlIiwiQ09NUExFVEUiLCJzdWJjaGFubmVsV3JhcHBlciIsImV4dHJhRmlsdGVyRmFjdG9yaWVzIiwiY291bnRlciIsImNoYW5uZWxDb250cm9sSGVscGVyIiwiYWRkcmVzc01hcCIsIk1hcCIsImxhdGVzdENvbmZpZyIsInRpbWVyU3RhcnRUaW1lIiwiY2hpbGRCYWxhbmNlciIsIkNoaWxkTG9hZEJhbGFuY2VySGFuZGxlciIsImNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIiLCJjcmVhdGVTdWJjaGFubmVsIiwic3ViY2hhbm5lbEFkZHJlc3MiLCJzdWJjaGFubmVsQXJncyIsIm9yaWdpbmFsU3ViY2hhbm5lbCIsImdldCIsInN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmciLCJjdXJyZW50RWplY3Rpb25UaW1lc3RhbXAiLCJ1cGRhdGVTdGF0ZSIsImNvbm5lY3Rpdml0eVN0YXRlIiwicGlja2VyIiwiUkVBRFkiLCJpc0NvdW50aW5nRW5hYmxlZCIsImVqZWN0aW9uVGltZXIiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJnZXRDdXJyZW50RWplY3Rpb25QZXJjZW50IiwiZWplY3Rpb25Db3VudCIsInZhbHVlcyIsInNpemUiLCJydW5TdWNjZXNzUmF0ZUNoZWNrIiwiZWplY3Rpb25UaW1lc3RhbXAiLCJzdWNjZXNzUmF0ZUNvbmZpZyIsInRhcmdldFJlcXVlc3RWb2x1bWUiLCJhZGRyZXNlc1dpdGhUYXJnZXRWb2x1bWUiLCJzdWNjZXNzUmF0ZXMiLCJzdWNjZXNzZXMiLCJmYWlsdXJlcyIsInN1Y2Nlc3NSYXRlTWVhbiIsInJlZHVjZSIsImEiLCJiIiwibGVuZ3RoIiwic3VjY2Vzc1JhdGVEZXZpYXRpb25TdW0iLCJyYXRlIiwiZGV2aWF0aW9uIiwic3VjY2Vzc1JhdGVWYXJpYW5jZSIsInN1Y2Nlc3NSYXRlU3RkZXYiLCJNYXRoIiwic3FydCIsImVqZWN0aW9uVGhyZXNob2xkIiwiYWRkcmVzcyIsImVudHJpZXMiLCJzdWNjZXNzUmF0ZSIsInJhbmRvbU51bWJlciIsInJhbmRvbSIsInJ1bkZhaWx1cmVQZXJjZW50YWdlQ2hlY2siLCJmYWlsdXJlUGVyY2VudGFnZUNvbmZpZyIsImFkZHJlc3Nlc1dpdGhUYXJnZXRWb2x1bWUiLCJmYWlsdXJlUGVyY2VudGFnZSIsIkRhdGUiLCJlamVjdGlvblRpbWVNdWx0aXBsaWVyIiwic3dpdGNoQWxsQnVja2V0cyIsInN0YXJ0VGltZXIiLCJkZWxheU1zIiwic2V0VGltZW91dCIsInJ1bkNoZWNrcyIsInJldHVyblRpbWUiLCJnZXRUaW1lIiwic2V0TWlsbGlzZWNvbmRzIiwiZ2V0TWlsbGlzZWNvbmRzIiwibWluIiwibWF4IiwidXBkYXRlQWRkcmVzc0xpc3QiLCJhZGRyZXNzTGlzdCIsImxiQ29uZmlnIiwiYXR0cmlidXRlcyIsInN1YmNoYW5uZWxBZGRyZXNzZXMiLCJTZXQiLCJhZGQiLCJoYXMiLCJzZXQiLCJrZXkiLCJrZXlzIiwiZGVsZXRlIiwiZ2V0Rmlyc3RVc2FibGVDb25maWciLCJjbGVhclRpbWVvdXQiLCJyZW1haW5pbmdEZWxheSIsImV4aXRJZGxlIiwicmVzZXRCYWNrb2ZmIiwiZGVzdHJveSIsImdldFR5cGVOYW1lIiwicmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = exports.PickFirstLoadBalancer = exports.PickFirstLoadBalancingConfig = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = \"pick_first\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = \"pick_first\";\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */ const CONNECTION_DELAY_INTERVAL_MS = 250;\nclass PickFirstLoadBalancingConfig {\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    constructor(){}\n    toJsonObject() {\n        return {\n            [TYPE_NAME]: {}\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static createFromJson(obj) {\n        return new PickFirstLoadBalancingConfig();\n    }\n}\nexports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */ class PickFirstPicker {\n    constructor(subchannel){\n        this.subchannel = subchannel;\n    }\n    pick(pickArgs) {\n        return {\n            pickResultType: picker_1.PickResultType.COMPLETE,\n            subchannel: this.subchannel,\n            status: null,\n            extraFilterFactories: [],\n            onCallStarted: null\n        };\n    }\n}\nclass PickFirstLoadBalancer {\n    /**\n     * Load balancer that attempts to connect to each backend in the address list\n     * in order, and picks the first one that connects, using it for every\n     * request.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     */ constructor(channelControlHelper){\n        this.channelControlHelper = channelControlHelper;\n        /**\n         * The list of backend addresses most recently passed to `updateAddressList`.\n         */ this.latestAddressList = [];\n        /**\n         * The list of subchannels this load balancer is currently attempting to\n         * connect to.\n         */ this.subchannels = [];\n        /**\n         * The current connectivity state of the load balancer.\n         */ this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The index within the `subchannels` array of the subchannel with the most\n         * recently started connection attempt.\n         */ this.currentSubchannelIndex = 0;\n        /**\n         * The currently picked subchannel used for making calls. Populated if\n         * and only if the load balancer's current state is READY. In that case,\n         * the subchannel's current state is also READY.\n         */ this.currentPick = null;\n        this.triedAllSubchannels = false;\n        this.subchannelStateCounts = {\n            [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n            [connectivity_state_1.ConnectivityState.IDLE]: 0,\n            [connectivity_state_1.ConnectivityState.READY]: 0,\n            [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n            [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n        };\n        this.subchannelStateListener = (subchannel, previousState, newState)=>{\n            this.subchannelStateCounts[previousState] -= 1;\n            this.subchannelStateCounts[newState] += 1;\n            /* If the subchannel we most recently attempted to start connecting\n             * to goes into TRANSIENT_FAILURE, immediately try to start\n             * connecting to the next one instead of waiting for the connection\n             * delay timer. */ if (subchannel === this.subchannels[this.currentSubchannelIndex] && newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                this.startNextSubchannelConnecting();\n            }\n            if (newState === connectivity_state_1.ConnectivityState.READY) {\n                this.pickSubchannel(subchannel);\n                return;\n            } else {\n                if (this.triedAllSubchannels && this.subchannelStateCounts[connectivity_state_1.ConnectivityState.IDLE] === this.subchannels.length) {\n                    /* If all of the subchannels are IDLE we should go back to a\n                     * basic IDLE state where there is no subchannel list to avoid\n                     * holding unused resources. We do not reset triedAllSubchannels\n                     * because that is a reminder to request reresolution the next time\n                     * this LB policy needs to connect. */ this.resetSubchannelList(false);\n                    this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n                    return;\n                }\n                if (this.currentPick === null) {\n                    if (this.triedAllSubchannels) {\n                        let newLBState;\n                        if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n                            newLBState = connectivity_state_1.ConnectivityState.CONNECTING;\n                        } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n                            newLBState = connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n                        } else {\n                            newLBState = connectivity_state_1.ConnectivityState.IDLE;\n                        }\n                        if (newLBState !== this.currentState) {\n                            if (newLBState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                                this.updateState(newLBState, new picker_1.UnavailablePicker());\n                            } else {\n                                this.updateState(newLBState, new picker_1.QueuePicker(this));\n                            }\n                        }\n                    } else {\n                        this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n                    }\n                }\n            }\n        };\n        this.pickedSubchannelStateListener = (subchannel, previousState, newState)=>{\n            if (newState !== connectivity_state_1.ConnectivityState.READY) {\n                this.currentPick = null;\n                subchannel.unref();\n                subchannel.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n                this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n                if (this.subchannels.length > 0) {\n                    if (this.triedAllSubchannels) {\n                        let newLBState;\n                        if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n                            newLBState = connectivity_state_1.ConnectivityState.CONNECTING;\n                        } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n                            newLBState = connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n                        } else {\n                            newLBState = connectivity_state_1.ConnectivityState.IDLE;\n                        }\n                        if (newLBState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                            this.updateState(newLBState, new picker_1.UnavailablePicker());\n                        } else {\n                            this.updateState(newLBState, new picker_1.QueuePicker(this));\n                        }\n                    } else {\n                        this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n                    }\n                } else {\n                    /* We don't need to backoff here because this only happens if a\n                     * subchannel successfully connects then disconnects, so it will not\n                     * create a loop of attempting to connect to an unreachable backend\n                     */ this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n                }\n            }\n        };\n        this.connectionDelayTimeout = setTimeout(()=>{}, 0);\n        clearTimeout(this.connectionDelayTimeout);\n    }\n    startNextSubchannelConnecting() {\n        if (this.triedAllSubchannels) {\n            return;\n        }\n        for (const [index, subchannel] of this.subchannels.entries()){\n            if (index > this.currentSubchannelIndex) {\n                const subchannelState = subchannel.getConnectivityState();\n                if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                    this.startConnecting(index);\n                    return;\n                }\n            }\n        }\n        this.triedAllSubchannels = true;\n    }\n    /**\n     * Have a single subchannel in the `subchannels` list start connecting.\n     * @param subchannelIndex The index into the `subchannels` list.\n     */ startConnecting(subchannelIndex) {\n        clearTimeout(this.connectionDelayTimeout);\n        this.currentSubchannelIndex = subchannelIndex;\n        if (this.subchannels[subchannelIndex].getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {\n            trace(\"Start connecting to subchannel with address \" + this.subchannels[subchannelIndex].getAddress());\n            process.nextTick(()=>{\n                this.subchannels[subchannelIndex].startConnecting();\n            });\n        }\n        this.connectionDelayTimeout = setTimeout(()=>{\n            this.startNextSubchannelConnecting();\n        }, CONNECTION_DELAY_INTERVAL_MS);\n    }\n    pickSubchannel(subchannel) {\n        trace(\"Pick subchannel with address \" + subchannel.getAddress());\n        if (this.currentPick !== null) {\n            this.currentPick.unref();\n            this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n        }\n        this.currentPick = subchannel;\n        this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(subchannel));\n        subchannel.addConnectivityStateListener(this.pickedSubchannelStateListener);\n        subchannel.ref();\n        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n        this.resetSubchannelList();\n        clearTimeout(this.connectionDelayTimeout);\n    }\n    updateState(newState, picker) {\n        trace(connectivity_state_1.ConnectivityState[this.currentState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker);\n    }\n    resetSubchannelList(resetTriedAllSubchannels = true) {\n        for (const subchannel of this.subchannels){\n            subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n            subchannel.unref();\n            this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n        }\n        this.currentSubchannelIndex = 0;\n        this.subchannelStateCounts = {\n            [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n            [connectivity_state_1.ConnectivityState.IDLE]: 0,\n            [connectivity_state_1.ConnectivityState.READY]: 0,\n            [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n            [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n        };\n        this.subchannels = [];\n        if (resetTriedAllSubchannels) {\n            this.triedAllSubchannels = false;\n        }\n    }\n    /**\n     * Start connecting to the address list most recently passed to\n     * `updateAddressList`.\n     */ connectToAddressList() {\n        this.resetSubchannelList();\n        trace(\"Connect to address list \" + this.latestAddressList.map((address)=>subchannel_address_1.subchannelAddressToString(address)));\n        this.subchannels = this.latestAddressList.map((address)=>this.channelControlHelper.createSubchannel(address, {}));\n        for (const subchannel of this.subchannels){\n            subchannel.ref();\n            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n        }\n        for (const subchannel of this.subchannels){\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\n            this.subchannelStateCounts[subchannel.getConnectivityState()] += 1;\n            if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {\n                this.pickSubchannel(subchannel);\n                this.resetSubchannelList();\n                return;\n            }\n        }\n        for (const [index, subchannel] of this.subchannels.entries()){\n            const subchannelState = subchannel.getConnectivityState();\n            if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                this.startConnecting(index);\n                if (this.currentPick === null) {\n                    this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n                }\n                return;\n            }\n        }\n        // If the code reaches this point, every subchannel must be in TRANSIENT_FAILURE\n        if (this.currentPick === null) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n        }\n    }\n    updateAddressList(addressList, lbConfig) {\n        // lbConfig has no useful information for pick first load balancing\n        /* To avoid unnecessary churn, we only do something with this address list\n         * if we're not currently trying to establish a connection, or if the new\n         * address list is different from the existing one */ if (this.subchannels.length === 0 || !this.latestAddressList.every((value, index)=>addressList[index] === value)) {\n            this.latestAddressList = addressList;\n            this.connectToAddressList();\n        }\n    }\n    exitIdle() {\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE || this.triedAllSubchannels) {\n            this.channelControlHelper.requestReresolution();\n        }\n        for (const subchannel of this.subchannels){\n            subchannel.startConnecting();\n        }\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n            if (this.latestAddressList.length > 0) {\n                this.connectToAddressList();\n            }\n        }\n    }\n    resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n         * does nothing */ }\n    destroy() {\n        this.resetSubchannelList();\n        if (this.currentPick !== null) {\n            /* Unref can cause a state change, which can cause a change in the value\n             * of this.currentPick, so we hold a local reference to make sure that\n             * does not impact this function. */ const currentPick = this.currentPick;\n            currentPick.unref();\n            currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n            this.channelControlHelper.removeChannelzChild(currentPick.getChannelzRef());\n        }\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\nfunction setup() {\n    load_balancer_1.registerLoadBalancerType(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);\n    load_balancer_1.registerDefaultLoadBalancerType(TYPE_NAME);\n}\nexports.setup = setup; //# sourceMappingURL=load-balancer-pick-first.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1waWNrLWZpcnN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxhQUFhLEdBQUdBLDZCQUE2QixHQUFHQSxvQ0FBb0MsR0FBRyxLQUFLO0FBQzVGLE1BQU1LLGtCQUFrQkMsbUJBQU9BLENBQUMsc0ZBQWlCO0FBQ2pELE1BQU1DLHVCQUF1QkQsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DLE1BQU1HLHVCQUF1QkgsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1JLFVBQVVKLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1LLGNBQWNMLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1NLGNBQWM7QUFDcEIsU0FBU0MsTUFBTUMsSUFBSTtJQUNmSixRQUFRRyxLQUFLLENBQUNGLFlBQVlJLFlBQVksQ0FBQ0MsS0FBSyxFQUFFSixhQUFhRTtBQUMvRDtBQUNBLE1BQU1HLFlBQVk7QUFDbEI7OztDQUdDLEdBQ0QsTUFBTUMsK0JBQStCO0FBQ3JDLE1BQU1kO0lBQ0ZlLHNCQUFzQjtRQUNsQixPQUFPRjtJQUNYO0lBQ0FHLGFBQWMsQ0FBRTtJQUNoQkMsZUFBZTtRQUNYLE9BQU87WUFDSCxDQUFDSixVQUFVLEVBQUUsQ0FBQztRQUNsQjtJQUNKO0lBQ0EsOERBQThEO0lBQzlELE9BQU9LLGVBQWVDLEdBQUcsRUFBRTtRQUN2QixPQUFPLElBQUluQjtJQUNmO0FBQ0o7QUFDQUosb0NBQW9DLEdBQUdJO0FBQ3ZDOzs7Q0FHQyxHQUNELE1BQU1vQjtJQUNGSixZQUFZSyxVQUFVLENBQUU7UUFDcEIsSUFBSSxDQUFDQSxVQUFVLEdBQUdBO0lBQ3RCO0lBQ0FDLEtBQUtDLFFBQVEsRUFBRTtRQUNYLE9BQU87WUFDSEMsZ0JBQWdCcEIsU0FBU3FCLGNBQWMsQ0FBQ0MsUUFBUTtZQUNoREwsWUFBWSxJQUFJLENBQUNBLFVBQVU7WUFDM0JNLFFBQVE7WUFDUkMsc0JBQXNCLEVBQUU7WUFDeEJDLGVBQWU7UUFDbkI7SUFDSjtBQUNKO0FBQ0EsTUFBTTlCO0lBQ0Y7Ozs7OztLQU1DLEdBQ0RpQixZQUFZYyxvQkFBb0IsQ0FBRTtRQUM5QixJQUFJLENBQUNBLG9CQUFvQixHQUFHQTtRQUM1Qjs7U0FFQyxHQUNELElBQUksQ0FBQ0MsaUJBQWlCLEdBQUcsRUFBRTtRQUMzQjs7O1NBR0MsR0FDRCxJQUFJLENBQUNDLFdBQVcsR0FBRyxFQUFFO1FBQ3JCOztTQUVDLEdBQ0QsSUFBSSxDQUFDQyxZQUFZLEdBQUc5QixxQkFBcUIrQixpQkFBaUIsQ0FBQ0MsSUFBSTtRQUMvRDs7O1NBR0MsR0FDRCxJQUFJLENBQUNDLHNCQUFzQixHQUFHO1FBQzlCOzs7O1NBSUMsR0FDRCxJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLG1CQUFtQixHQUFHO1FBQzNCLElBQUksQ0FBQ0MscUJBQXFCLEdBQUc7WUFDekIsQ0FBQ3BDLHFCQUFxQitCLGlCQUFpQixDQUFDTSxVQUFVLENBQUMsRUFBRTtZQUNyRCxDQUFDckMscUJBQXFCK0IsaUJBQWlCLENBQUNDLElBQUksQ0FBQyxFQUFFO1lBQy9DLENBQUNoQyxxQkFBcUIrQixpQkFBaUIsQ0FBQ08sS0FBSyxDQUFDLEVBQUU7WUFDaEQsQ0FBQ3RDLHFCQUFxQitCLGlCQUFpQixDQUFDUSxRQUFRLENBQUMsRUFBRTtZQUNuRCxDQUFDdkMscUJBQXFCK0IsaUJBQWlCLENBQUNTLGlCQUFpQixDQUFDLEVBQUU7UUFDaEU7UUFDQSxJQUFJLENBQUNDLHVCQUF1QixHQUFHLENBQUN2QixZQUFZd0IsZUFBZUM7WUFDdkQsSUFBSSxDQUFDUCxxQkFBcUIsQ0FBQ00sY0FBYyxJQUFJO1lBQzdDLElBQUksQ0FBQ04scUJBQXFCLENBQUNPLFNBQVMsSUFBSTtZQUN4Qzs7OzRCQUdnQixHQUNoQixJQUFJekIsZUFBZSxJQUFJLENBQUNXLFdBQVcsQ0FBQyxJQUFJLENBQUNJLHNCQUFzQixDQUFDLElBQzVEVSxhQUFhM0MscUJBQXFCK0IsaUJBQWlCLENBQUNTLGlCQUFpQixFQUFFO2dCQUN2RSxJQUFJLENBQUNJLDZCQUE2QjtZQUN0QztZQUNBLElBQUlELGFBQWEzQyxxQkFBcUIrQixpQkFBaUIsQ0FBQ08sS0FBSyxFQUFFO2dCQUMzRCxJQUFJLENBQUNPLGNBQWMsQ0FBQzNCO2dCQUNwQjtZQUNKLE9BQ0s7Z0JBQ0QsSUFBSSxJQUFJLENBQUNpQixtQkFBbUIsSUFDeEIsSUFBSSxDQUFDQyxxQkFBcUIsQ0FBQ3BDLHFCQUFxQitCLGlCQUFpQixDQUFDQyxJQUFJLENBQUMsS0FDbkUsSUFBSSxDQUFDSCxXQUFXLENBQUNpQixNQUFNLEVBQUU7b0JBQzdCOzs7O3dEQUlvQyxHQUNwQyxJQUFJLENBQUNDLG1CQUFtQixDQUFDO29CQUN6QixJQUFJLENBQUNDLFdBQVcsQ0FBQ2hELHFCQUFxQitCLGlCQUFpQixDQUFDQyxJQUFJLEVBQUUsSUFBSS9CLFNBQVNnRCxXQUFXLENBQUMsSUFBSTtvQkFDM0Y7Z0JBQ0o7Z0JBQ0EsSUFBSSxJQUFJLENBQUNmLFdBQVcsS0FBSyxNQUFNO29CQUMzQixJQUFJLElBQUksQ0FBQ0MsbUJBQW1CLEVBQUU7d0JBQzFCLElBQUllO3dCQUNKLElBQUksSUFBSSxDQUFDZCxxQkFBcUIsQ0FBQ3BDLHFCQUFxQitCLGlCQUFpQixDQUFDTSxVQUFVLENBQUMsR0FBRyxHQUFHOzRCQUNuRmEsYUFBYWxELHFCQUFxQitCLGlCQUFpQixDQUFDTSxVQUFVO3dCQUNsRSxPQUNLLElBQUksSUFBSSxDQUFDRCxxQkFBcUIsQ0FBQ3BDLHFCQUFxQitCLGlCQUFpQixDQUFDUyxpQkFBaUIsQ0FBQyxHQUN6RixHQUFHOzRCQUNIVSxhQUFhbEQscUJBQXFCK0IsaUJBQWlCLENBQUNTLGlCQUFpQjt3QkFDekUsT0FDSzs0QkFDRFUsYUFBYWxELHFCQUFxQitCLGlCQUFpQixDQUFDQyxJQUFJO3dCQUM1RDt3QkFDQSxJQUFJa0IsZUFBZSxJQUFJLENBQUNwQixZQUFZLEVBQUU7NEJBQ2xDLElBQUlvQixlQUFlbEQscUJBQXFCK0IsaUJBQWlCLENBQUNTLGlCQUFpQixFQUFFO2dDQUN6RSxJQUFJLENBQUNRLFdBQVcsQ0FBQ0UsWUFBWSxJQUFJakQsU0FBU2tELGlCQUFpQjs0QkFDL0QsT0FDSztnQ0FDRCxJQUFJLENBQUNILFdBQVcsQ0FBQ0UsWUFBWSxJQUFJakQsU0FBU2dELFdBQVcsQ0FBQyxJQUFJOzRCQUM5RDt3QkFDSjtvQkFDSixPQUNLO3dCQUNELElBQUksQ0FBQ0QsV0FBVyxDQUFDaEQscUJBQXFCK0IsaUJBQWlCLENBQUNNLFVBQVUsRUFBRSxJQUFJcEMsU0FBU2dELFdBQVcsQ0FBQyxJQUFJO29CQUNyRztnQkFDSjtZQUNKO1FBQ0o7UUFDQSxJQUFJLENBQUNHLDZCQUE2QixHQUFHLENBQUNsQyxZQUFZd0IsZUFBZUM7WUFDN0QsSUFBSUEsYUFBYTNDLHFCQUFxQitCLGlCQUFpQixDQUFDTyxLQUFLLEVBQUU7Z0JBQzNELElBQUksQ0FBQ0osV0FBVyxHQUFHO2dCQUNuQmhCLFdBQVdtQyxLQUFLO2dCQUNoQm5DLFdBQVdvQywrQkFBK0IsQ0FBQyxJQUFJLENBQUNGLDZCQUE2QjtnQkFDN0UsSUFBSSxDQUFDekIsb0JBQW9CLENBQUM0QixtQkFBbUIsQ0FBQ3JDLFdBQVdzQyxjQUFjO2dCQUN2RSxJQUFJLElBQUksQ0FBQzNCLFdBQVcsQ0FBQ2lCLE1BQU0sR0FBRyxHQUFHO29CQUM3QixJQUFJLElBQUksQ0FBQ1gsbUJBQW1CLEVBQUU7d0JBQzFCLElBQUllO3dCQUNKLElBQUksSUFBSSxDQUFDZCxxQkFBcUIsQ0FBQ3BDLHFCQUFxQitCLGlCQUFpQixDQUFDTSxVQUFVLENBQUMsR0FBRyxHQUFHOzRCQUNuRmEsYUFBYWxELHFCQUFxQitCLGlCQUFpQixDQUFDTSxVQUFVO3dCQUNsRSxPQUNLLElBQUksSUFBSSxDQUFDRCxxQkFBcUIsQ0FBQ3BDLHFCQUFxQitCLGlCQUFpQixDQUFDUyxpQkFBaUIsQ0FBQyxHQUN6RixHQUFHOzRCQUNIVSxhQUFhbEQscUJBQXFCK0IsaUJBQWlCLENBQUNTLGlCQUFpQjt3QkFDekUsT0FDSzs0QkFDRFUsYUFBYWxELHFCQUFxQitCLGlCQUFpQixDQUFDQyxJQUFJO3dCQUM1RDt3QkFDQSxJQUFJa0IsZUFBZWxELHFCQUFxQitCLGlCQUFpQixDQUFDUyxpQkFBaUIsRUFBRTs0QkFDekUsSUFBSSxDQUFDUSxXQUFXLENBQUNFLFlBQVksSUFBSWpELFNBQVNrRCxpQkFBaUI7d0JBQy9ELE9BQ0s7NEJBQ0QsSUFBSSxDQUFDSCxXQUFXLENBQUNFLFlBQVksSUFBSWpELFNBQVNnRCxXQUFXLENBQUMsSUFBSTt3QkFDOUQ7b0JBQ0osT0FDSzt3QkFDRCxJQUFJLENBQUNELFdBQVcsQ0FBQ2hELHFCQUFxQitCLGlCQUFpQixDQUFDTSxVQUFVLEVBQUUsSUFBSXBDLFNBQVNnRCxXQUFXLENBQUMsSUFBSTtvQkFDckc7Z0JBQ0osT0FDSztvQkFDRDs7O3FCQUdDLEdBQ0QsSUFBSSxDQUFDRCxXQUFXLENBQUNoRCxxQkFBcUIrQixpQkFBaUIsQ0FBQ0MsSUFBSSxFQUFFLElBQUkvQixTQUFTZ0QsV0FBVyxDQUFDLElBQUk7Z0JBQy9GO1lBQ0o7UUFDSjtRQUNBLElBQUksQ0FBQ1Esc0JBQXNCLEdBQUdDLFdBQVcsS0FBUSxHQUFHO1FBQ3BEQyxhQUFhLElBQUksQ0FBQ0Ysc0JBQXNCO0lBQzVDO0lBQ0FiLGdDQUFnQztRQUM1QixJQUFJLElBQUksQ0FBQ1QsbUJBQW1CLEVBQUU7WUFDMUI7UUFDSjtRQUNBLEtBQUssTUFBTSxDQUFDeUIsT0FBTzFDLFdBQVcsSUFBSSxJQUFJLENBQUNXLFdBQVcsQ0FBQ2dDLE9BQU8sR0FBSTtZQUMxRCxJQUFJRCxRQUFRLElBQUksQ0FBQzNCLHNCQUFzQixFQUFFO2dCQUNyQyxNQUFNNkIsa0JBQWtCNUMsV0FBVzZDLG9CQUFvQjtnQkFDdkQsSUFBSUQsb0JBQW9COUQscUJBQXFCK0IsaUJBQWlCLENBQUNDLElBQUksSUFDL0Q4QixvQkFBb0I5RCxxQkFBcUIrQixpQkFBaUIsQ0FBQ00sVUFBVSxFQUFFO29CQUN2RSxJQUFJLENBQUMyQixlQUFlLENBQUNKO29CQUNyQjtnQkFDSjtZQUNKO1FBQ0o7UUFDQSxJQUFJLENBQUN6QixtQkFBbUIsR0FBRztJQUMvQjtJQUNBOzs7S0FHQyxHQUNENkIsZ0JBQWdCQyxlQUFlLEVBQUU7UUFDN0JOLGFBQWEsSUFBSSxDQUFDRixzQkFBc0I7UUFDeEMsSUFBSSxDQUFDeEIsc0JBQXNCLEdBQUdnQztRQUM5QixJQUFJLElBQUksQ0FBQ3BDLFdBQVcsQ0FBQ29DLGdCQUFnQixDQUFDRixvQkFBb0IsT0FDdEQvRCxxQkFBcUIrQixpQkFBaUIsQ0FBQ0MsSUFBSSxFQUFFO1lBQzdDMUIsTUFBTSxpREFDRixJQUFJLENBQUN1QixXQUFXLENBQUNvQyxnQkFBZ0IsQ0FBQ0MsVUFBVTtZQUNoREMsUUFBUUMsUUFBUSxDQUFDO2dCQUNiLElBQUksQ0FBQ3ZDLFdBQVcsQ0FBQ29DLGdCQUFnQixDQUFDRCxlQUFlO1lBQ3JEO1FBQ0o7UUFDQSxJQUFJLENBQUNQLHNCQUFzQixHQUFHQyxXQUFXO1lBQ3JDLElBQUksQ0FBQ2QsNkJBQTZCO1FBQ3RDLEdBQUdqQztJQUNQO0lBQ0FrQyxlQUFlM0IsVUFBVSxFQUFFO1FBQ3ZCWixNQUFNLGtDQUFrQ1ksV0FBV2dELFVBQVU7UUFDN0QsSUFBSSxJQUFJLENBQUNoQyxXQUFXLEtBQUssTUFBTTtZQUMzQixJQUFJLENBQUNBLFdBQVcsQ0FBQ21CLEtBQUs7WUFDdEIsSUFBSSxDQUFDbkIsV0FBVyxDQUFDb0IsK0JBQStCLENBQUMsSUFBSSxDQUFDRiw2QkFBNkI7UUFDdkY7UUFDQSxJQUFJLENBQUNsQixXQUFXLEdBQUdoQjtRQUNuQixJQUFJLENBQUM4QixXQUFXLENBQUNoRCxxQkFBcUIrQixpQkFBaUIsQ0FBQ08sS0FBSyxFQUFFLElBQUlyQixnQkFBZ0JDO1FBQ25GQSxXQUFXbUQsNEJBQTRCLENBQUMsSUFBSSxDQUFDakIsNkJBQTZCO1FBQzFFbEMsV0FBV29ELEdBQUc7UUFDZCxJQUFJLENBQUMzQyxvQkFBb0IsQ0FBQzRDLGdCQUFnQixDQUFDckQsV0FBV3NDLGNBQWM7UUFDcEUsSUFBSSxDQUFDVCxtQkFBbUI7UUFDeEJZLGFBQWEsSUFBSSxDQUFDRixzQkFBc0I7SUFDNUM7SUFDQVQsWUFBWUwsUUFBUSxFQUFFNkIsTUFBTSxFQUFFO1FBQzFCbEUsTUFBTU4scUJBQXFCK0IsaUJBQWlCLENBQUMsSUFBSSxDQUFDRCxZQUFZLENBQUMsR0FDM0QsU0FDQTlCLHFCQUFxQitCLGlCQUFpQixDQUFDWSxTQUFTO1FBQ3BELElBQUksQ0FBQ2IsWUFBWSxHQUFHYTtRQUNwQixJQUFJLENBQUNoQixvQkFBb0IsQ0FBQ3FCLFdBQVcsQ0FBQ0wsVUFBVTZCO0lBQ3BEO0lBQ0F6QixvQkFBb0IwQiwyQkFBMkIsSUFBSSxFQUFFO1FBQ2pELEtBQUssTUFBTXZELGNBQWMsSUFBSSxDQUFDVyxXQUFXLENBQUU7WUFDdkNYLFdBQVdvQywrQkFBK0IsQ0FBQyxJQUFJLENBQUNiLHVCQUF1QjtZQUN2RXZCLFdBQVdtQyxLQUFLO1lBQ2hCLElBQUksQ0FBQzFCLG9CQUFvQixDQUFDNEIsbUJBQW1CLENBQUNyQyxXQUFXc0MsY0FBYztRQUMzRTtRQUNBLElBQUksQ0FBQ3ZCLHNCQUFzQixHQUFHO1FBQzlCLElBQUksQ0FBQ0cscUJBQXFCLEdBQUc7WUFDekIsQ0FBQ3BDLHFCQUFxQitCLGlCQUFpQixDQUFDTSxVQUFVLENBQUMsRUFBRTtZQUNyRCxDQUFDckMscUJBQXFCK0IsaUJBQWlCLENBQUNDLElBQUksQ0FBQyxFQUFFO1lBQy9DLENBQUNoQyxxQkFBcUIrQixpQkFBaUIsQ0FBQ08sS0FBSyxDQUFDLEVBQUU7WUFDaEQsQ0FBQ3RDLHFCQUFxQitCLGlCQUFpQixDQUFDUSxRQUFRLENBQUMsRUFBRTtZQUNuRCxDQUFDdkMscUJBQXFCK0IsaUJBQWlCLENBQUNTLGlCQUFpQixDQUFDLEVBQUU7UUFDaEU7UUFDQSxJQUFJLENBQUNYLFdBQVcsR0FBRyxFQUFFO1FBQ3JCLElBQUk0QywwQkFBMEI7WUFDMUIsSUFBSSxDQUFDdEMsbUJBQW1CLEdBQUc7UUFDL0I7SUFDSjtJQUNBOzs7S0FHQyxHQUNEdUMsdUJBQXVCO1FBQ25CLElBQUksQ0FBQzNCLG1CQUFtQjtRQUN4QnpDLE1BQU0sNkJBQ0YsSUFBSSxDQUFDc0IsaUJBQWlCLENBQUMrQyxHQUFHLENBQUMsQ0FBQ0MsVUFBWTFFLHFCQUFxQjJFLHlCQUF5QixDQUFDRDtRQUMzRixJQUFJLENBQUMvQyxXQUFXLEdBQUcsSUFBSSxDQUFDRCxpQkFBaUIsQ0FBQytDLEdBQUcsQ0FBQyxDQUFDQyxVQUFZLElBQUksQ0FBQ2pELG9CQUFvQixDQUFDbUQsZ0JBQWdCLENBQUNGLFNBQVMsQ0FBQztRQUNoSCxLQUFLLE1BQU0xRCxjQUFjLElBQUksQ0FBQ1csV0FBVyxDQUFFO1lBQ3ZDWCxXQUFXb0QsR0FBRztZQUNkLElBQUksQ0FBQzNDLG9CQUFvQixDQUFDNEMsZ0JBQWdCLENBQUNyRCxXQUFXc0MsY0FBYztRQUN4RTtRQUNBLEtBQUssTUFBTXRDLGNBQWMsSUFBSSxDQUFDVyxXQUFXLENBQUU7WUFDdkNYLFdBQVdtRCw0QkFBNEIsQ0FBQyxJQUFJLENBQUM1Qix1QkFBdUI7WUFDcEUsSUFBSSxDQUFDTCxxQkFBcUIsQ0FBQ2xCLFdBQVc2QyxvQkFBb0IsR0FBRyxJQUFJO1lBQ2pFLElBQUk3QyxXQUFXNkMsb0JBQW9CLE9BQU8vRCxxQkFBcUIrQixpQkFBaUIsQ0FBQ08sS0FBSyxFQUFFO2dCQUNwRixJQUFJLENBQUNPLGNBQWMsQ0FBQzNCO2dCQUNwQixJQUFJLENBQUM2QixtQkFBbUI7Z0JBQ3hCO1lBQ0o7UUFDSjtRQUNBLEtBQUssTUFBTSxDQUFDYSxPQUFPMUMsV0FBVyxJQUFJLElBQUksQ0FBQ1csV0FBVyxDQUFDZ0MsT0FBTyxHQUFJO1lBQzFELE1BQU1DLGtCQUFrQjVDLFdBQVc2QyxvQkFBb0I7WUFDdkQsSUFBSUQsb0JBQW9COUQscUJBQXFCK0IsaUJBQWlCLENBQUNDLElBQUksSUFDL0Q4QixvQkFBb0I5RCxxQkFBcUIrQixpQkFBaUIsQ0FBQ00sVUFBVSxFQUFFO2dCQUN2RSxJQUFJLENBQUMyQixlQUFlLENBQUNKO2dCQUNyQixJQUFJLElBQUksQ0FBQzFCLFdBQVcsS0FBSyxNQUFNO29CQUMzQixJQUFJLENBQUNjLFdBQVcsQ0FBQ2hELHFCQUFxQitCLGlCQUFpQixDQUFDTSxVQUFVLEVBQUUsSUFBSXBDLFNBQVNnRCxXQUFXLENBQUMsSUFBSTtnQkFDckc7Z0JBQ0E7WUFDSjtRQUNKO1FBQ0EsZ0ZBQWdGO1FBQ2hGLElBQUksSUFBSSxDQUFDZixXQUFXLEtBQUssTUFBTTtZQUMzQixJQUFJLENBQUNjLFdBQVcsQ0FBQ2hELHFCQUFxQitCLGlCQUFpQixDQUFDUyxpQkFBaUIsRUFBRSxJQUFJdkMsU0FBU2tELGlCQUFpQjtRQUM3RztJQUNKO0lBQ0E0QixrQkFBa0JDLFdBQVcsRUFBRUMsUUFBUSxFQUFFO1FBQ3JDLG1FQUFtRTtRQUNuRTs7MkRBRW1ELEdBQ25ELElBQUksSUFBSSxDQUFDcEQsV0FBVyxDQUFDaUIsTUFBTSxLQUFLLEtBQzVCLENBQUMsSUFBSSxDQUFDbEIsaUJBQWlCLENBQUNzRCxLQUFLLENBQUMsQ0FBQ3hGLE9BQU9rRSxRQUFVb0IsV0FBVyxDQUFDcEIsTUFBTSxLQUFLbEUsUUFBUTtZQUMvRSxJQUFJLENBQUNrQyxpQkFBaUIsR0FBR29EO1lBQ3pCLElBQUksQ0FBQ04sb0JBQW9CO1FBQzdCO0lBQ0o7SUFDQVMsV0FBVztRQUNQLElBQUksSUFBSSxDQUFDckQsWUFBWSxLQUFLOUIscUJBQXFCK0IsaUJBQWlCLENBQUNDLElBQUksSUFDakUsSUFBSSxDQUFDRyxtQkFBbUIsRUFBRTtZQUMxQixJQUFJLENBQUNSLG9CQUFvQixDQUFDeUQsbUJBQW1CO1FBQ2pEO1FBQ0EsS0FBSyxNQUFNbEUsY0FBYyxJQUFJLENBQUNXLFdBQVcsQ0FBRTtZQUN2Q1gsV0FBVzhDLGVBQWU7UUFDOUI7UUFDQSxJQUFJLElBQUksQ0FBQ2xDLFlBQVksS0FBSzlCLHFCQUFxQitCLGlCQUFpQixDQUFDQyxJQUFJLEVBQUU7WUFDbkUsSUFBSSxJQUFJLENBQUNKLGlCQUFpQixDQUFDa0IsTUFBTSxHQUFHLEdBQUc7Z0JBQ25DLElBQUksQ0FBQzRCLG9CQUFvQjtZQUM3QjtRQUNKO0lBQ0o7SUFDQVcsZUFBZTtJQUNYO3dCQUNnQixHQUNwQjtJQUNBQyxVQUFVO1FBQ04sSUFBSSxDQUFDdkMsbUJBQW1CO1FBQ3hCLElBQUksSUFBSSxDQUFDYixXQUFXLEtBQUssTUFBTTtZQUMzQjs7OENBRWtDLEdBQ2xDLE1BQU1BLGNBQWMsSUFBSSxDQUFDQSxXQUFXO1lBQ3BDQSxZQUFZbUIsS0FBSztZQUNqQm5CLFlBQVlvQiwrQkFBK0IsQ0FBQyxJQUFJLENBQUNGLDZCQUE2QjtZQUM5RSxJQUFJLENBQUN6QixvQkFBb0IsQ0FBQzRCLG1CQUFtQixDQUFDckIsWUFBWXNCLGNBQWM7UUFDNUU7SUFDSjtJQUNBK0IsY0FBYztRQUNWLE9BQU83RTtJQUNYO0FBQ0o7QUFDQWpCLDZCQUE2QixHQUFHRztBQUNoQyxTQUFTRDtJQUNMRyxnQkFBZ0IwRix3QkFBd0IsQ0FBQzlFLFdBQVdkLHVCQUF1QkM7SUFDM0VDLGdCQUFnQjJGLCtCQUErQixDQUFDL0U7QUFDcEQ7QUFDQWpCLGFBQWEsR0FBR0UsT0FDaEIsb0RBQW9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNobWl0dC1ndXB0YS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLXBpY2stZmlyc3QuanM/NTM4MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXR1cCA9IGV4cG9ydHMuUGlja0ZpcnN0TG9hZEJhbGFuY2VyID0gZXhwb3J0cy5QaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnID0gdm9pZCAwO1xuY29uc3QgbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlclwiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdwaWNrX2ZpcnN0JztcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xufVxuY29uc3QgVFlQRV9OQU1FID0gJ3BpY2tfZmlyc3QnO1xuLyoqXG4gKiBEZWxheSBhZnRlciBzdGFydGluZyBhIGNvbm5lY3Rpb24gb24gYSBzdWJjaGFubmVsIGJlZm9yZSBzdGFydGluZyBhXG4gKiBjb25uZWN0aW9uIG9uIHRoZSBuZXh0IHN1YmNoYW5uZWwgaW4gdGhlIGxpc3QsIGZvciBIYXBweSBFeWViYWxscyBhbGdvcml0aG0uXG4gKi9cbmNvbnN0IENPTk5FQ1RJT05fREVMQVlfSU5URVJWQUxfTVMgPSAyNTA7XG5jbGFzcyBQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnIHtcbiAgICBnZXRMb2FkQmFsYW5jZXJOYW1lKCkge1xuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgIHRvSnNvbk9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtUWVBFX05BTUVdOiB7fSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgY3JlYXRlRnJvbUpzb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZygpO1xuICAgIH1cbn1cbmV4cG9ydHMuUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZyA9IFBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWc7XG4vKipcbiAqIFBpY2tlciBmb3IgYSBgUGlja0ZpcnN0TG9hZEJhbGFuY2VyYCBpbiB0aGUgUkVBRFkgc3RhdGUuIEFsd2F5cyByZXR1cm5zIHRoZVxuICogcGlja2VkIHN1YmNoYW5uZWwuXG4gKi9cbmNsYXNzIFBpY2tGaXJzdFBpY2tlciB7XG4gICAgY29uc3RydWN0b3Ioc3ViY2hhbm5lbCkge1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWwgPSBzdWJjaGFubmVsO1xuICAgIH1cbiAgICBwaWNrKHBpY2tBcmdzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwaWNrUmVzdWx0VHlwZTogcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuQ09NUExFVEUsXG4gICAgICAgICAgICBzdWJjaGFubmVsOiB0aGlzLnN1YmNoYW5uZWwsXG4gICAgICAgICAgICBzdGF0dXM6IG51bGwsXG4gICAgICAgICAgICBleHRyYUZpbHRlckZhY3RvcmllczogW10sXG4gICAgICAgICAgICBvbkNhbGxTdGFydGVkOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmNsYXNzIFBpY2tGaXJzdExvYWRCYWxhbmNlciB7XG4gICAgLyoqXG4gICAgICogTG9hZCBiYWxhbmNlciB0aGF0IGF0dGVtcHRzIHRvIGNvbm5lY3QgdG8gZWFjaCBiYWNrZW5kIGluIHRoZSBhZGRyZXNzIGxpc3RcbiAgICAgKiBpbiBvcmRlciwgYW5kIHBpY2tzIHRoZSBmaXJzdCBvbmUgdGhhdCBjb25uZWN0cywgdXNpbmcgaXQgZm9yIGV2ZXJ5XG4gICAgICogcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gY2hhbm5lbENvbnRyb2xIZWxwZXIgYENoYW5uZWxDb250cm9sSGVscGVyYCBpbnN0YW5jZSBwcm92aWRlZCBieVxuICAgICAqICAgICB0aGlzIGxvYWQgYmFsYW5jZXIncyBvd25lci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsQ29udHJvbEhlbHBlcikge1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyID0gY2hhbm5lbENvbnRyb2xIZWxwZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGlzdCBvZiBiYWNrZW5kIGFkZHJlc3NlcyBtb3N0IHJlY2VudGx5IHBhc3NlZCB0byBgdXBkYXRlQWRkcmVzc0xpc3RgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXRlc3RBZGRyZXNzTGlzdCA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpc3Qgb2Ygc3ViY2hhbm5lbHMgdGhpcyBsb2FkIGJhbGFuY2VyIGlzIGN1cnJlbnRseSBhdHRlbXB0aW5nIHRvXG4gICAgICAgICAqIGNvbm5lY3QgdG8uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBjb25uZWN0aXZpdHkgc3RhdGUgb2YgdGhlIGxvYWQgYmFsYW5jZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5kZXggd2l0aGluIHRoZSBgc3ViY2hhbm5lbHNgIGFycmF5IG9mIHRoZSBzdWJjaGFubmVsIHdpdGggdGhlIG1vc3RcbiAgICAgICAgICogcmVjZW50bHkgc3RhcnRlZCBjb25uZWN0aW9uIGF0dGVtcHQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRTdWJjaGFubmVsSW5kZXggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnRseSBwaWNrZWQgc3ViY2hhbm5lbCB1c2VkIGZvciBtYWtpbmcgY2FsbHMuIFBvcHVsYXRlZCBpZlxuICAgICAgICAgKiBhbmQgb25seSBpZiB0aGUgbG9hZCBiYWxhbmNlcidzIGN1cnJlbnQgc3RhdGUgaXMgUkVBRFkuIEluIHRoYXQgY2FzZSxcbiAgICAgICAgICogdGhlIHN1YmNoYW5uZWwncyBjdXJyZW50IHN0YXRlIGlzIGFsc28gUkVBRFkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRQaWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmllZEFsbFN1YmNoYW5uZWxzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbFN0YXRlQ291bnRzID0ge1xuICAgICAgICAgICAgW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkddOiAwLFxuICAgICAgICAgICAgW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEVdOiAwLFxuICAgICAgICAgICAgW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZXTogMCxcbiAgICAgICAgICAgIFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5TSFVURE9XTl06IDAsXG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkVdOiAwLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyID0gKHN1YmNoYW5uZWwsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUNvdW50c1twcmV2aW91c1N0YXRlXSAtPSAxO1xuICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsU3RhdGVDb3VudHNbbmV3U3RhdGVdICs9IDE7XG4gICAgICAgICAgICAvKiBJZiB0aGUgc3ViY2hhbm5lbCB3ZSBtb3N0IHJlY2VudGx5IGF0dGVtcHRlZCB0byBzdGFydCBjb25uZWN0aW5nXG4gICAgICAgICAgICAgKiB0byBnb2VzIGludG8gVFJBTlNJRU5UX0ZBSUxVUkUsIGltbWVkaWF0ZWx5IHRyeSB0byBzdGFydFxuICAgICAgICAgICAgICogY29ubmVjdGluZyB0byB0aGUgbmV4dCBvbmUgaW5zdGVhZCBvZiB3YWl0aW5nIGZvciB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgICogZGVsYXkgdGltZXIuICovXG4gICAgICAgICAgICBpZiAoc3ViY2hhbm5lbCA9PT0gdGhpcy5zdWJjaGFubmVsc1t0aGlzLmN1cnJlbnRTdWJjaGFubmVsSW5kZXhdICYmXG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydE5leHRTdWJjaGFubmVsQ29ubmVjdGluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGlja1N1YmNoYW5uZWwoc3ViY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJpZWRBbGxTdWJjaGFubmVscyAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUNvdW50c1tjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFXSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIElmIGFsbCBvZiB0aGUgc3ViY2hhbm5lbHMgYXJlIElETEUgd2Ugc2hvdWxkIGdvIGJhY2sgdG8gYVxuICAgICAgICAgICAgICAgICAgICAgKiBiYXNpYyBJRExFIHN0YXRlIHdoZXJlIHRoZXJlIGlzIG5vIHN1YmNoYW5uZWwgbGlzdCB0byBhdm9pZFxuICAgICAgICAgICAgICAgICAgICAgKiBob2xkaW5nIHVudXNlZCByZXNvdXJjZXMuIFdlIGRvIG5vdCByZXNldCB0cmllZEFsbFN1YmNoYW5uZWxzXG4gICAgICAgICAgICAgICAgICAgICAqIGJlY2F1c2UgdGhhdCBpcyBhIHJlbWluZGVyIHRvIHJlcXVlc3QgcmVyZXNvbHV0aW9uIHRoZSBuZXh0IHRpbWVcbiAgICAgICAgICAgICAgICAgICAgICogdGhpcyBMQiBwb2xpY3kgbmVlZHMgdG8gY29ubmVjdC4gKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFLCBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRQaWNrID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyaWVkQWxsU3ViY2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdMQlN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3ViY2hhbm5lbFN0YXRlQ291bnRzW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkddID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xCU3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdWJjaGFubmVsU3RhdGVDb3VudHNbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkVdID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TEJTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TEJTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3TEJTdGF0ZSAhPT0gdGhpcy5jdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3TEJTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShuZXdMQlN0YXRlLCBuZXcgcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKG5ld0xCU3RhdGUsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HLCBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBpY2tlZFN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyID0gKHN1YmNoYW5uZWwsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlKSA9PiB7XG4gICAgICAgICAgICBpZiAobmV3U3RhdGUgIT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGljayA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3ViY2hhbm5lbC51bnJlZigpO1xuICAgICAgICAgICAgICAgIHN1YmNoYW5uZWwucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnBpY2tlZFN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnJlbW92ZUNoYW5uZWx6Q2hpbGQoc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWJjaGFubmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyaWVkQWxsU3ViY2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdMQlN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3ViY2hhbm5lbFN0YXRlQ291bnRzW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkddID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xCU3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdWJjaGFubmVsU3RhdGVDb3VudHNbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkVdID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TEJTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TEJTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3TEJTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKG5ld0xCU3RhdGUsIG5ldyBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUobmV3TEJTdGF0ZSwgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORywgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLyogV2UgZG9uJ3QgbmVlZCB0byBiYWNrb2ZmIGhlcmUgYmVjYXVzZSB0aGlzIG9ubHkgaGFwcGVucyBpZiBhXG4gICAgICAgICAgICAgICAgICAgICAqIHN1YmNoYW5uZWwgc3VjY2Vzc2Z1bGx5IGNvbm5lY3RzIHRoZW4gZGlzY29ubmVjdHMsIHNvIGl0IHdpbGwgbm90XG4gICAgICAgICAgICAgICAgICAgICAqIGNyZWF0ZSBhIGxvb3Agb2YgYXR0ZW1wdGluZyB0byBjb25uZWN0IHRvIGFuIHVucmVhY2hhYmxlIGJhY2tlbmRcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSwgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCk7XG4gICAgfVxuICAgIHN0YXJ0TmV4dFN1YmNoYW5uZWxDb25uZWN0aW5nKCkge1xuICAgICAgICBpZiAodGhpcy50cmllZEFsbFN1YmNoYW5uZWxzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIHN1YmNoYW5uZWxdIG9mIHRoaXMuc3ViY2hhbm5lbHMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiB0aGlzLmN1cnJlbnRTdWJjaGFubmVsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsU3RhdGUgPSBzdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN1YmNoYW5uZWxTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSB8fFxuICAgICAgICAgICAgICAgICAgICBzdWJjaGFubmVsU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydENvbm5lY3RpbmcoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZWRBbGxTdWJjaGFubmVscyA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhdmUgYSBzaW5nbGUgc3ViY2hhbm5lbCBpbiB0aGUgYHN1YmNoYW5uZWxzYCBsaXN0IHN0YXJ0IGNvbm5lY3RpbmcuXG4gICAgICogQHBhcmFtIHN1YmNoYW5uZWxJbmRleCBUaGUgaW5kZXggaW50byB0aGUgYHN1YmNoYW5uZWxzYCBsaXN0LlxuICAgICAqL1xuICAgIHN0YXJ0Q29ubmVjdGluZyhzdWJjaGFubmVsSW5kZXgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCk7XG4gICAgICAgIHRoaXMuY3VycmVudFN1YmNoYW5uZWxJbmRleCA9IHN1YmNoYW5uZWxJbmRleDtcbiAgICAgICAgaWYgKHRoaXMuc3ViY2hhbm5lbHNbc3ViY2hhbm5lbEluZGV4XS5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PVxuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xuICAgICAgICAgICAgdHJhY2UoJ1N0YXJ0IGNvbm5lY3RpbmcgdG8gc3ViY2hhbm5lbCB3aXRoIGFkZHJlc3MgJyArXG4gICAgICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsc1tzdWJjaGFubmVsSW5kZXhdLmdldEFkZHJlc3MoKSk7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxzW3N1YmNoYW5uZWxJbmRleF0uc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25EZWxheVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnROZXh0U3ViY2hhbm5lbENvbm5lY3RpbmcoKTtcbiAgICAgICAgfSwgQ09OTkVDVElPTl9ERUxBWV9JTlRFUlZBTF9NUyk7XG4gICAgfVxuICAgIHBpY2tTdWJjaGFubmVsKHN1YmNoYW5uZWwpIHtcbiAgICAgICAgdHJhY2UoJ1BpY2sgc3ViY2hhbm5lbCB3aXRoIGFkZHJlc3MgJyArIHN1YmNoYW5uZWwuZ2V0QWRkcmVzcygpKTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBpY2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBpY2sudW5yZWYoKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBpY2sucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnBpY2tlZFN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRQaWNrID0gc3ViY2hhbm5lbDtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSwgbmV3IFBpY2tGaXJzdFBpY2tlcihzdWJjaGFubmVsKSk7XG4gICAgICAgIHN1YmNoYW5uZWwuYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnBpY2tlZFN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgc3ViY2hhbm5lbC5yZWYoKTtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkKHN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgIHRoaXMucmVzZXRTdWJjaGFubmVsTGlzdCgpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0KTtcbiAgICB9XG4gICAgdXBkYXRlU3RhdGUobmV3U3RhdGUsIHBpY2tlcikge1xuICAgICAgICB0cmFjZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmN1cnJlbnRTdGF0ZV0gK1xuICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIudXBkYXRlU3RhdGUobmV3U3RhdGUsIHBpY2tlcik7XG4gICAgfVxuICAgIHJlc2V0U3ViY2hhbm5lbExpc3QocmVzZXRUcmllZEFsbFN1YmNoYW5uZWxzID0gdHJ1ZSkge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWwgb2YgdGhpcy5zdWJjaGFubmVscykge1xuICAgICAgICAgICAgc3ViY2hhbm5lbC5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgc3ViY2hhbm5lbC51bnJlZigpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkKHN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2hhbm5lbEluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsU3RhdGVDb3VudHMgPSB7XG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElOR106IDAsXG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRV06IDAsXG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFldOiAwLFxuICAgICAgICAgICAgW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOXTogMCxcbiAgICAgICAgICAgIFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRV06IDAsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbHMgPSBbXTtcbiAgICAgICAgaWYgKHJlc2V0VHJpZWRBbGxTdWJjaGFubmVscykge1xuICAgICAgICAgICAgdGhpcy50cmllZEFsbFN1YmNoYW5uZWxzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgY29ubmVjdGluZyB0byB0aGUgYWRkcmVzcyBsaXN0IG1vc3QgcmVjZW50bHkgcGFzc2VkIHRvXG4gICAgICogYHVwZGF0ZUFkZHJlc3NMaXN0YC5cbiAgICAgKi9cbiAgICBjb25uZWN0VG9BZGRyZXNzTGlzdCgpIHtcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XG4gICAgICAgIHRyYWNlKCdDb25uZWN0IHRvIGFkZHJlc3MgbGlzdCAnICtcbiAgICAgICAgICAgIHRoaXMubGF0ZXN0QWRkcmVzc0xpc3QubWFwKChhZGRyZXNzKSA9PiBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKGFkZHJlc3MpKSk7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbHMgPSB0aGlzLmxhdGVzdEFkZHJlc3NMaXN0Lm1hcCgoYWRkcmVzcykgPT4gdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5jcmVhdGVTdWJjaGFubmVsKGFkZHJlc3MsIHt9KSk7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbCBvZiB0aGlzLnN1YmNoYW5uZWxzKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsLnJlZigpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkKHN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBzdWJjaGFubmVsIG9mIHRoaXMuc3ViY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWwuYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbFN0YXRlQ291bnRzW3N1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKV0gKz0gMTtcbiAgICAgICAgICAgIGlmIChzdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waWNrU3ViY2hhbm5lbChzdWJjaGFubmVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0U3ViY2hhbm5lbExpc3QoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIHN1YmNoYW5uZWxdIG9mIHRoaXMuc3ViY2hhbm5lbHMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsU3RhdGUgPSBzdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCk7XG4gICAgICAgICAgICBpZiAoc3ViY2hhbm5lbFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFIHx8XG4gICAgICAgICAgICAgICAgc3ViY2hhbm5lbFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydENvbm5lY3RpbmcoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRQaWNrID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORywgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBjb2RlIHJlYWNoZXMgdGhpcyBwb2ludCwgZXZlcnkgc3ViY2hhbm5lbCBtdXN0IGJlIGluIFRSQU5TSUVOVF9GQUlMVVJFXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQaWNrID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFLCBuZXcgcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXIoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGxiQ29uZmlnKSB7XG4gICAgICAgIC8vIGxiQ29uZmlnIGhhcyBubyB1c2VmdWwgaW5mb3JtYXRpb24gZm9yIHBpY2sgZmlyc3QgbG9hZCBiYWxhbmNpbmdcbiAgICAgICAgLyogVG8gYXZvaWQgdW5uZWNlc3NhcnkgY2h1cm4sIHdlIG9ubHkgZG8gc29tZXRoaW5nIHdpdGggdGhpcyBhZGRyZXNzIGxpc3RcbiAgICAgICAgICogaWYgd2UncmUgbm90IGN1cnJlbnRseSB0cnlpbmcgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiwgb3IgaWYgdGhlIG5ld1xuICAgICAgICAgKiBhZGRyZXNzIGxpc3QgaXMgZGlmZmVyZW50IGZyb20gdGhlIGV4aXN0aW5nIG9uZSAqL1xuICAgICAgICBpZiAodGhpcy5zdWJjaGFubmVscy5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgICAgICF0aGlzLmxhdGVzdEFkZHJlc3NMaXN0LmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IGFkZHJlc3NMaXN0W2luZGV4XSA9PT0gdmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmxhdGVzdEFkZHJlc3NMaXN0ID0gYWRkcmVzc0xpc3Q7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RUb0FkZHJlc3NMaXN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhpdElkbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSB8fFxuICAgICAgICAgICAgdGhpcy50cmllZEFsbFN1YmNoYW5uZWxzKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnJlcXVlc3RSZXJlc29sdXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWwgb2YgdGhpcy5zdWJjaGFubmVscykge1xuICAgICAgICAgICAgc3ViY2hhbm5lbC5zdGFydENvbm5lY3RpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhdGVzdEFkZHJlc3NMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RUb0FkZHJlc3NMaXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzZXRCYWNrb2ZmKCkge1xuICAgICAgICAvKiBUaGUgcGljayBmaXJzdCBsb2FkIGJhbGFuY2VyIGRvZXMgbm90IGhhdmUgYSBjb25uZWN0aW9uIGJhY2tvZmYsIHNvIHRoaXNcbiAgICAgICAgICogZG9lcyBub3RoaW5nICovXG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVzZXRTdWJjaGFubmVsTGlzdCgpO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGljayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLyogVW5yZWYgY2FuIGNhdXNlIGEgc3RhdGUgY2hhbmdlLCB3aGljaCBjYW4gY2F1c2UgYSBjaGFuZ2UgaW4gdGhlIHZhbHVlXG4gICAgICAgICAgICAgKiBvZiB0aGlzLmN1cnJlbnRQaWNrLCBzbyB3ZSBob2xkIGEgbG9jYWwgcmVmZXJlbmNlIHRvIG1ha2Ugc3VyZSB0aGF0XG4gICAgICAgICAgICAgKiBkb2VzIG5vdCBpbXBhY3QgdGhpcyBmdW5jdGlvbi4gKi9cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQaWNrID0gdGhpcy5jdXJyZW50UGljaztcbiAgICAgICAgICAgIGN1cnJlbnRQaWNrLnVucmVmKCk7XG4gICAgICAgICAgICBjdXJyZW50UGljay5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMucGlja2VkU3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkKGN1cnJlbnRQaWNrLmdldENoYW5uZWx6UmVmKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFR5cGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xuICAgIH1cbn1cbmV4cG9ydHMuUGlja0ZpcnN0TG9hZEJhbGFuY2VyID0gUGlja0ZpcnN0TG9hZEJhbGFuY2VyO1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgbG9hZF9iYWxhbmNlcl8xLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZShUWVBFX05BTUUsIFBpY2tGaXJzdExvYWRCYWxhbmNlciwgUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZyk7XG4gICAgbG9hZF9iYWxhbmNlcl8xLnJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUoVFlQRV9OQU1FKTtcbn1cbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtYmFsYW5jZXItcGljay1maXJzdC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzZXR1cCIsIlBpY2tGaXJzdExvYWRCYWxhbmNlciIsIlBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWciLCJsb2FkX2JhbGFuY2VyXzEiLCJyZXF1aXJlIiwiY29ubmVjdGl2aXR5X3N0YXRlXzEiLCJwaWNrZXJfMSIsInN1YmNoYW5uZWxfYWRkcmVzc18xIiwibG9nZ2luZyIsImNvbnN0YW50c18xIiwiVFJBQ0VSX05BTUUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIlRZUEVfTkFNRSIsIkNPTk5FQ1RJT05fREVMQVlfSU5URVJWQUxfTVMiLCJnZXRMb2FkQmFsYW5jZXJOYW1lIiwiY29uc3RydWN0b3IiLCJ0b0pzb25PYmplY3QiLCJjcmVhdGVGcm9tSnNvbiIsIm9iaiIsIlBpY2tGaXJzdFBpY2tlciIsInN1YmNoYW5uZWwiLCJwaWNrIiwicGlja0FyZ3MiLCJwaWNrUmVzdWx0VHlwZSIsIlBpY2tSZXN1bHRUeXBlIiwiQ09NUExFVEUiLCJzdGF0dXMiLCJleHRyYUZpbHRlckZhY3RvcmllcyIsIm9uQ2FsbFN0YXJ0ZWQiLCJjaGFubmVsQ29udHJvbEhlbHBlciIsImxhdGVzdEFkZHJlc3NMaXN0Iiwic3ViY2hhbm5lbHMiLCJjdXJyZW50U3RhdGUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIklETEUiLCJjdXJyZW50U3ViY2hhbm5lbEluZGV4IiwiY3VycmVudFBpY2siLCJ0cmllZEFsbFN1YmNoYW5uZWxzIiwic3ViY2hhbm5lbFN0YXRlQ291bnRzIiwiQ09OTkVDVElORyIsIlJFQURZIiwiU0hVVERPV04iLCJUUkFOU0lFTlRfRkFJTFVSRSIsInN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyIiwicHJldmlvdXNTdGF0ZSIsIm5ld1N0YXRlIiwic3RhcnROZXh0U3ViY2hhbm5lbENvbm5lY3RpbmciLCJwaWNrU3ViY2hhbm5lbCIsImxlbmd0aCIsInJlc2V0U3ViY2hhbm5lbExpc3QiLCJ1cGRhdGVTdGF0ZSIsIlF1ZXVlUGlja2VyIiwibmV3TEJTdGF0ZSIsIlVuYXZhaWxhYmxlUGlja2VyIiwicGlja2VkU3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIiLCJ1bnJlZiIsInJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIiLCJyZW1vdmVDaGFubmVsekNoaWxkIiwiZ2V0Q2hhbm5lbHpSZWYiLCJjb25uZWN0aW9uRGVsYXlUaW1lb3V0Iiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsImluZGV4IiwiZW50cmllcyIsInN1YmNoYW5uZWxTdGF0ZSIsImdldENvbm5lY3Rpdml0eVN0YXRlIiwic3RhcnRDb25uZWN0aW5nIiwic3ViY2hhbm5lbEluZGV4IiwiZ2V0QWRkcmVzcyIsInByb2Nlc3MiLCJuZXh0VGljayIsImFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIiLCJyZWYiLCJhZGRDaGFubmVsekNoaWxkIiwicGlja2VyIiwicmVzZXRUcmllZEFsbFN1YmNoYW5uZWxzIiwiY29ubmVjdFRvQWRkcmVzc0xpc3QiLCJtYXAiLCJhZGRyZXNzIiwic3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyIsImNyZWF0ZVN1YmNoYW5uZWwiLCJ1cGRhdGVBZGRyZXNzTGlzdCIsImFkZHJlc3NMaXN0IiwibGJDb25maWciLCJldmVyeSIsImV4aXRJZGxlIiwicmVxdWVzdFJlcmVzb2x1dGlvbiIsInJlc2V0QmFja29mZiIsImRlc3Ryb3kiLCJnZXRUeXBlTmFtZSIsInJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSIsInJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = exports.RoundRobinLoadBalancer = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = \"round_robin\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = \"round_robin\";\nclass RoundRobinLoadBalancingConfig {\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    constructor(){}\n    toJsonObject() {\n        return {\n            [TYPE_NAME]: {}\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static createFromJson(obj) {\n        return new RoundRobinLoadBalancingConfig();\n    }\n}\nclass RoundRobinPicker {\n    constructor(subchannelList, nextIndex = 0){\n        this.subchannelList = subchannelList;\n        this.nextIndex = nextIndex;\n    }\n    pick(pickArgs) {\n        const pickedSubchannel = this.subchannelList[this.nextIndex];\n        this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;\n        return {\n            pickResultType: picker_1.PickResultType.COMPLETE,\n            subchannel: pickedSubchannel,\n            status: null,\n            extraFilterFactories: [],\n            onCallStarted: null\n        };\n    }\n    /**\n     * Check what the next subchannel returned would be. Used by the load\n     * balancer implementation to preserve this part of the picker state if\n     * possible when a subchannel connects or disconnects.\n     */ peekNextSubchannel() {\n        return this.subchannelList[this.nextIndex];\n    }\n}\nclass RoundRobinLoadBalancer {\n    constructor(channelControlHelper){\n        this.channelControlHelper = channelControlHelper;\n        this.subchannels = [];\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        this.currentReadyPicker = null;\n        this.subchannelStateCounts = {\n            [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n            [connectivity_state_1.ConnectivityState.IDLE]: 0,\n            [connectivity_state_1.ConnectivityState.READY]: 0,\n            [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n            [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n        };\n        this.subchannelStateListener = (subchannel, previousState, newState)=>{\n            this.subchannelStateCounts[previousState] -= 1;\n            this.subchannelStateCounts[newState] += 1;\n            this.calculateAndUpdateState();\n            if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE || newState === connectivity_state_1.ConnectivityState.IDLE) {\n                this.channelControlHelper.requestReresolution();\n                subchannel.startConnecting();\n            }\n        };\n    }\n    calculateAndUpdateState() {\n        if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.READY] > 0) {\n            const readySubchannels = this.subchannels.filter((subchannel)=>subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);\n            let index = 0;\n            if (this.currentReadyPicker !== null) {\n                index = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());\n                if (index < 0) {\n                    index = 0;\n                }\n            }\n            this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index));\n        } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n        } else {\n            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        }\n    }\n    updateState(newState, picker) {\n        trace(connectivity_state_1.ConnectivityState[this.currentState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        if (newState === connectivity_state_1.ConnectivityState.READY) {\n            this.currentReadyPicker = picker;\n        } else {\n            this.currentReadyPicker = null;\n        }\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker);\n    }\n    resetSubchannelList() {\n        for (const subchannel of this.subchannels){\n            subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n            subchannel.unref();\n            this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n        }\n        this.subchannelStateCounts = {\n            [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n            [connectivity_state_1.ConnectivityState.IDLE]: 0,\n            [connectivity_state_1.ConnectivityState.READY]: 0,\n            [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n            [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n        };\n        this.subchannels = [];\n    }\n    updateAddressList(addressList, lbConfig) {\n        this.resetSubchannelList();\n        trace(\"Connect to address list \" + addressList.map((address)=>subchannel_address_1.subchannelAddressToString(address)));\n        this.subchannels = addressList.map((address)=>this.channelControlHelper.createSubchannel(address, {}));\n        for (const subchannel of this.subchannels){\n            subchannel.ref();\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\n            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n            const subchannelState = subchannel.getConnectivityState();\n            this.subchannelStateCounts[subchannelState] += 1;\n            if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                subchannel.startConnecting();\n            }\n        }\n        this.calculateAndUpdateState();\n    }\n    exitIdle() {\n        for (const subchannel of this.subchannels){\n            subchannel.startConnecting();\n        }\n    }\n    resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n         * does nothing */ }\n    destroy() {\n        this.resetSubchannelList();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;\nfunction setup() {\n    load_balancer_1.registerLoadBalancerType(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);\n}\nexports.setup = setup; //# sourceMappingURL=load-balancer-round-robin.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1yb3VuZC1yb2Jpbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHQSw4QkFBOEIsR0FBRyxLQUFLO0FBQ3RELE1BQU1JLGtCQUFrQkMsbUJBQU9BLENBQUMsc0ZBQWlCO0FBQ2pELE1BQU1DLHVCQUF1QkQsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DLE1BQU1HLHVCQUF1QkgsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1JLFVBQVVKLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1LLGNBQWNMLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1NLGNBQWM7QUFDcEIsU0FBU0MsTUFBTUMsSUFBSTtJQUNmSixRQUFRRyxLQUFLLENBQUNGLFlBQVlJLFlBQVksQ0FBQ0MsS0FBSyxFQUFFSixhQUFhRTtBQUMvRDtBQUNBLE1BQU1HLFlBQVk7QUFDbEIsTUFBTUM7SUFDRkMsc0JBQXNCO1FBQ2xCLE9BQU9GO0lBQ1g7SUFDQUcsYUFBYyxDQUFFO0lBQ2hCQyxlQUFlO1FBQ1gsT0FBTztZQUNILENBQUNKLFVBQVUsRUFBRSxDQUFDO1FBQ2xCO0lBQ0o7SUFDQSw4REFBOEQ7SUFDOUQsT0FBT0ssZUFBZUMsR0FBRyxFQUFFO1FBQ3ZCLE9BQU8sSUFBSUw7SUFDZjtBQUNKO0FBQ0EsTUFBTU07SUFDRkosWUFBWUssY0FBYyxFQUFFQyxZQUFZLENBQUMsQ0FBRTtRQUN2QyxJQUFJLENBQUNELGNBQWMsR0FBR0E7UUFDdEIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO0lBQ3JCO0lBQ0FDLEtBQUtDLFFBQVEsRUFBRTtRQUNYLE1BQU1DLG1CQUFtQixJQUFJLENBQUNK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MkIsZUFBZTtJQUNYO3dCQUNnQixHQUNwQjtJQUNBQyxVQUFVO1FBQ04sSUFBSSxDQUFDbEIsbUJBQW1CO0lBQzVCO0lBQ0FtQixjQUFjO1FBQ1YsT0FBT25FO0lBQ1g7QUFDSjtBQUNBaEIsOEJBQThCLEdBQUdHO0FBQ2pDLFNBQVNEO0lBQ0xFLGdCQUFnQmdGLHdCQUF3QixDQUFDcEUsV0FBV2Isd0JBQXdCYztBQUNoRjtBQUNBakIsYUFBYSxHQUFHRSxPQUNoQixxREFBcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc2htaXR0LWd1cHRhLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvYWQtYmFsYW5jZXItcm91bmQtcm9iaW4uanM/OWVkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXR1cCA9IGV4cG9ydHMuUm91bmRSb2JpbkxvYWRCYWxhbmNlciA9IHZvaWQgMDtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IHBpY2tlcl8xID0gcmVxdWlyZShcIi4vcGlja2VyXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncm91bmRfcm9iaW4nO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jb25zdCBUWVBFX05BTUUgPSAncm91bmRfcm9iaW4nO1xuY2xhc3MgUm91bmRSb2JpbkxvYWRCYWxhbmNpbmdDb25maWcge1xuICAgIGdldExvYWRCYWxhbmNlck5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgdG9Kc29uT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW1RZUEVfTkFNRV06IHt9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tSnNvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSb3VuZFJvYmluTG9hZEJhbGFuY2luZ0NvbmZpZygpO1xuICAgIH1cbn1cbmNsYXNzIFJvdW5kUm9iaW5QaWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKHN1YmNoYW5uZWxMaXN0LCBuZXh0SW5kZXggPSAwKSB7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbExpc3QgPSBzdWJjaGFubmVsTGlzdDtcbiAgICAgICAgdGhpcy5uZXh0SW5kZXggPSBuZXh0SW5kZXg7XG4gICAgfVxuICAgIHBpY2socGlja0FyZ3MpIHtcbiAgICAgICAgY29uc3QgcGlja2VkU3ViY2hhbm5lbCA9IHRoaXMuc3ViY2hhbm5lbExpc3RbdGhpcy5uZXh0SW5kZXhdO1xuICAgICAgICB0aGlzLm5leHRJbmRleCA9ICh0aGlzLm5leHRJbmRleCArIDEpICUgdGhpcy5zdWJjaGFubmVsTGlzdC5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwaWNrUmVzdWx0VHlwZTogcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuQ09NUExFVEUsXG4gICAgICAgICAgICBzdWJjaGFubmVsOiBwaWNrZWRTdWJjaGFubmVsLFxuICAgICAgICAgICAgc3RhdHVzOiBudWxsLFxuICAgICAgICAgICAgZXh0cmFGaWx0ZXJGYWN0b3JpZXM6IFtdLFxuICAgICAgICAgICAgb25DYWxsU3RhcnRlZDogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hhdCB0aGUgbmV4dCBzdWJjaGFubmVsIHJldHVybmVkIHdvdWxkIGJlLiBVc2VkIGJ5IHRoZSBsb2FkXG4gICAgICogYmFsYW5jZXIgaW1wbGVtZW50YXRpb24gdG8gcHJlc2VydmUgdGhpcyBwYXJ0IG9mIHRoZSBwaWNrZXIgc3RhdGUgaWZcbiAgICAgKiBwb3NzaWJsZSB3aGVuIGEgc3ViY2hhbm5lbCBjb25uZWN0cyBvciBkaXNjb25uZWN0cy5cbiAgICAgKi9cbiAgICBwZWVrTmV4dFN1YmNoYW5uZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YmNoYW5uZWxMaXN0W3RoaXMubmV4dEluZGV4XTtcbiAgICB9XG59XG5jbGFzcyBSb3VuZFJvYmluTG9hZEJhbGFuY2VyIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsQ29udHJvbEhlbHBlcikge1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyID0gY2hhbm5lbENvbnRyb2xIZWxwZXI7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbHMgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICB0aGlzLmN1cnJlbnRSZWFkeVBpY2tlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbFN0YXRlQ291bnRzID0ge1xuICAgICAgICAgICAgW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkddOiAwLFxuICAgICAgICAgICAgW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEVdOiAwLFxuICAgICAgICAgICAgW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZXTogMCxcbiAgICAgICAgICAgIFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5TSFVURE9XTl06IDAsXG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkVdOiAwLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyID0gKHN1YmNoYW5uZWwsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUNvdW50c1twcmV2aW91c1N0YXRlXSAtPSAxO1xuICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsU3RhdGVDb3VudHNbbmV3U3RhdGVdICs9IDE7XG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUFuZFVwZGF0ZVN0YXRlKCk7XG4gICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFIHx8XG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnJlcXVlc3RSZXJlc29sdXRpb24oKTtcbiAgICAgICAgICAgICAgICBzdWJjaGFubmVsLnN0YXJ0Q29ubmVjdGluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjYWxjdWxhdGVBbmRVcGRhdGVTdGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3ViY2hhbm5lbFN0YXRlQ291bnRzW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZXSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWR5U3ViY2hhbm5lbHMgPSB0aGlzLnN1YmNoYW5uZWxzLmZpbHRlcigoc3ViY2hhbm5lbCkgPT4gc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSk7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFJlYWR5UGlja2VyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSByZWFkeVN1YmNoYW5uZWxzLmluZGV4T2YodGhpcy5jdXJyZW50UmVhZHlQaWNrZXIucGVla05leHRTdWJjaGFubmVsKCkpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFksIG5ldyBSb3VuZFJvYmluUGlja2VyKHJlYWR5U3ViY2hhbm5lbHMsIGluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdWJjaGFubmVsU3RhdGVDb3VudHNbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElOR10gPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdWJjaGFubmVsU3RhdGVDb3VudHNbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkVdID4gMCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFLCBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBwaWNrZXIpIHtcbiAgICAgICAgdHJhY2UoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jdXJyZW50U3RhdGVdICtcbiAgICAgICAgICAgICcgLT4gJyArXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xuICAgICAgICBpZiAobmV3U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZWFkeVBpY2tlciA9IHBpY2tlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlYWR5UGlja2VyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBwaWNrZXIpO1xuICAgIH1cbiAgICByZXNldFN1YmNoYW5uZWxMaXN0KCkge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWwgb2YgdGhpcy5zdWJjaGFubmVscykge1xuICAgICAgICAgICAgc3ViY2hhbm5lbC5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgc3ViY2hhbm5lbC51bnJlZigpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkKHN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJjaGFubmVsU3RhdGVDb3VudHMgPSB7XG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElOR106IDAsXG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRV06IDAsXG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFldOiAwLFxuICAgICAgICAgICAgW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOXTogMCxcbiAgICAgICAgICAgIFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRV06IDAsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbHMgPSBbXTtcbiAgICB9XG4gICAgdXBkYXRlQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGxiQ29uZmlnKSB7XG4gICAgICAgIHRoaXMucmVzZXRTdWJjaGFubmVsTGlzdCgpO1xuICAgICAgICB0cmFjZSgnQ29ubmVjdCB0byBhZGRyZXNzIGxpc3QgJyArXG4gICAgICAgICAgICBhZGRyZXNzTGlzdC5tYXAoKGFkZHJlc3MpID0+IHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcoYWRkcmVzcykpKTtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVscyA9IGFkZHJlc3NMaXN0Lm1hcCgoYWRkcmVzcykgPT4gdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5jcmVhdGVTdWJjaGFubmVsKGFkZHJlc3MsIHt9KSk7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbCBvZiB0aGlzLnN1YmNoYW5uZWxzKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsLnJlZigpO1xuICAgICAgICAgICAgc3ViY2hhbm5lbC5hZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkKHN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsU3RhdGUgPSBzdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCk7XG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUNvdW50c1tzdWJjaGFubmVsU3RhdGVdICs9IDE7XG4gICAgICAgICAgICBpZiAoc3ViY2hhbm5lbFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFIHx8XG4gICAgICAgICAgICAgICAgc3ViY2hhbm5lbFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgIHN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRVcGRhdGVTdGF0ZSgpO1xuICAgIH1cbiAgICBleGl0SWRsZSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWJjaGFubmVsIG9mIHRoaXMuc3ViY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzZXRCYWNrb2ZmKCkge1xuICAgICAgICAvKiBUaGUgcGljayBmaXJzdCBsb2FkIGJhbGFuY2VyIGRvZXMgbm90IGhhdmUgYSBjb25uZWN0aW9uIGJhY2tvZmYsIHNvIHRoaXNcbiAgICAgICAgICogZG9lcyBub3RoaW5nICovXG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVzZXRTdWJjaGFubmVsTGlzdCgpO1xuICAgIH1cbiAgICBnZXRUeXBlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFRZUEVfTkFNRTtcbiAgICB9XG59XG5leHBvcnRzLlJvdW5kUm9iaW5Mb2FkQmFsYW5jZXIgPSBSb3VuZFJvYmluTG9hZEJhbGFuY2VyO1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgbG9hZF9iYWxhbmNlcl8xLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZShUWVBFX05BTUUsIFJvdW5kUm9iaW5Mb2FkQmFsYW5jZXIsIFJvdW5kUm9iaW5Mb2FkQmFsYW5jaW5nQ29uZmlnKTtcbn1cbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtYmFsYW5jZXItcm91bmQtcm9iaW4uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2V0dXAiLCJSb3VuZFJvYmluTG9hZEJhbGFuY2VyIiwibG9hZF9iYWxhbmNlcl8xIiwicmVxdWlyZSIsImNvbm5lY3Rpdml0eV9zdGF0ZV8xIiwicGlja2VyXzEiLCJzdWJjaGFubmVsX2FkZHJlc3NfMSIsImxvZ2dpbmciLCJjb25zdGFudHNfMSIsIlRSQUNFUl9OQU1FIiwidHJhY2UiLCJ0ZXh0IiwiTG9nVmVyYm9zaXR5IiwiREVCVUciLCJUWVBFX05BTUUiLCJSb3VuZFJvYmluTG9hZEJhbGFuY2luZ0NvbmZpZyIsImdldExvYWRCYWxhbmNlck5hbWUiLCJjb25zdHJ1Y3RvciIsInRvSnNvbk9iamVjdCIsImNyZWF0ZUZyb21Kc29uIiwib2JqIiwiUm91bmRSb2JpblBpY2tlciIsInN1YmNoYW5uZWxMaXN0IiwibmV4dEluZGV4IiwicGljayIsInBpY2tBcmdzIiwicGlja2VkU3ViY2hhbm5lbCIsImxlbmd0aCIsInBpY2tSZXN1bHRUeXBlIiwiUGlja1Jlc3VsdFR5cGUiLCJDT01QTEVURSIsInN1YmNoYW5uZWwiLCJzdGF0dXMiLCJleHRyYUZpbHRlckZhY3RvcmllcyIsIm9uQ2FsbFN0YXJ0ZWQiLCJwZWVrTmV4dFN1YmNoYW5uZWwiLCJjaGFubmVsQ29udHJvbEhlbHBlciIsInN1YmNoYW5uZWxzIiwiY3VycmVudFN0YXRlIiwiQ29ubmVjdGl2aXR5U3RhdGUiLCJJRExFIiwiY3VycmVudFJlYWR5UGlja2VyIiwic3ViY2hhbm5lbFN0YXRlQ291bnRzIiwiQ09OTkVDVElORyIsIlJFQURZIiwiU0hVVERPV04iLCJUUkFOU0lFTlRfRkFJTFVSRSIsInN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyIiwicHJldmlvdXNTdGF0ZSIsIm5ld1N0YXRlIiwiY2FsY3VsYXRlQW5kVXBkYXRlU3RhdGUiLCJyZXF1ZXN0UmVyZXNvbHV0aW9uIiwic3RhcnRDb25uZWN0aW5nIiwicmVhZHlTdWJjaGFubmVscyIsImZpbHRlciIsImdldENvbm5lY3Rpdml0eVN0YXRlIiwiaW5kZXgiLCJpbmRleE9mIiwidXBkYXRlU3RhdGUiLCJRdWV1ZVBpY2tlciIsIlVuYXZhaWxhYmxlUGlja2VyIiwicGlja2VyIiwicmVzZXRTdWJjaGFubmVsTGlzdCIsInJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIiLCJ1bnJlZiIsInJlbW92ZUNoYW5uZWx6Q2hpbGQiLCJnZXRDaGFubmVselJlZiIsInVwZGF0ZUFkZHJlc3NMaXN0IiwiYWRkcmVzc0xpc3QiLCJsYkNvbmZpZyIsIm1hcCIsImFkZHJlc3MiLCJzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nIiwiY3JlYXRlU3ViY2hhbm5lbCIsInJlZiIsImFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIiLCJhZGRDaGFubmVsekNoaWxkIiwic3ViY2hhbm5lbFN0YXRlIiwiZXhpdElkbGUiLCJyZXNldEJhY2tvZmYiLCJkZXN0cm95IiwiZ2V0VHlwZU5hbWUiLCJyZWdpc3RlckxvYWRCYWxhbmNlclR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.validateLoadBalancingConfig = exports.getFirstUsableConfig = exports.isLoadBalancerNameRegistered = exports.createLoadBalancer = exports.registerDefaultLoadBalancerType = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = void 0;\n/**\n * Create a child ChannelControlHelper that overrides some methods of the\n * parent while letting others pass through to the parent unmodified. This\n * allows other code to create these children without needing to know about\n * all of the methods to be passed through.\n * @param parent\n * @param overrides\n */ function createChildChannelControlHelper(parent, overrides) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    return {\n        createSubchannel: (_b = (_a = overrides.createSubchannel) === null || _a === void 0 ? void 0 : _a.bind(overrides)) !== null && _b !== void 0 ? _b : parent.createSubchannel.bind(parent),\n        updateState: (_d = (_c = overrides.updateState) === null || _c === void 0 ? void 0 : _c.bind(overrides)) !== null && _d !== void 0 ? _d : parent.updateState.bind(parent),\n        requestReresolution: (_f = (_e = overrides.requestReresolution) === null || _e === void 0 ? void 0 : _e.bind(overrides)) !== null && _f !== void 0 ? _f : parent.requestReresolution.bind(parent),\n        addChannelzChild: (_h = (_g = overrides.addChannelzChild) === null || _g === void 0 ? void 0 : _g.bind(overrides)) !== null && _h !== void 0 ? _h : parent.addChannelzChild.bind(parent),\n        removeChannelzChild: (_k = (_j = overrides.removeChannelzChild) === null || _j === void 0 ? void 0 : _j.bind(overrides)) !== null && _k !== void 0 ? _k : parent.removeChannelzChild.bind(parent)\n    };\n}\nexports.createChildChannelControlHelper = createChildChannelControlHelper;\nconst registeredLoadBalancerTypes = {};\nlet defaultLoadBalancerType = null;\nfunction registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {\n    registeredLoadBalancerTypes[typeName] = {\n        LoadBalancer: loadBalancerType,\n        LoadBalancingConfig: loadBalancingConfigType\n    };\n}\nexports.registerLoadBalancerType = registerLoadBalancerType;\nfunction registerDefaultLoadBalancerType(typeName) {\n    defaultLoadBalancerType = typeName;\n}\nexports.registerDefaultLoadBalancerType = registerDefaultLoadBalancerType;\nfunction createLoadBalancer(config, channelControlHelper) {\n    const typeName = config.getLoadBalancerName();\n    if (typeName in registeredLoadBalancerTypes) {\n        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper);\n    } else {\n        return null;\n    }\n}\nexports.createLoadBalancer = createLoadBalancer;\nfunction isLoadBalancerNameRegistered(typeName) {\n    return typeName in registeredLoadBalancerTypes;\n}\nexports.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;\nfunction getFirstUsableConfig(configs, fallbackTodefault = false) {\n    for (const config of configs){\n        if (config.getLoadBalancerName() in registeredLoadBalancerTypes) {\n            return config;\n        }\n    }\n    if (fallbackTodefault) {\n        if (defaultLoadBalancerType) {\n            return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();\n        } else {\n            return null;\n        }\n    } else {\n        return null;\n    }\n}\nexports.getFirstUsableConfig = getFirstUsableConfig;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction validateLoadBalancingConfig(obj) {\n    if (!(obj !== null && typeof obj === \"object\")) {\n        throw new Error(\"Load balancing config must be an object\");\n    }\n    const keys = Object.keys(obj);\n    if (keys.length !== 1) {\n        throw new Error(\"Provided load balancing config has multiple conflicting entries\");\n    }\n    const typeName = keys[0];\n    if (typeName in registeredLoadBalancerTypes) {\n        return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(obj[typeName]);\n    } else {\n        throw new Error(`Unrecognized load balancing config name ${typeName}`);\n    }\n}\nexports.validateLoadBalancingConfig = validateLoadBalancingConfig; //# sourceMappingURL=load-balancer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUNBQW1DLEdBQUdBLDRCQUE0QixHQUFHQSxvQ0FBb0MsR0FBR0EsMEJBQTBCLEdBQUdBLHVDQUF1QyxHQUFHQSxnQ0FBZ0MsR0FBR0EsdUNBQXVDLEdBQUcsS0FBSztBQUNyUTs7Ozs7OztDQU9DLEdBQ0QsU0FBU1EsZ0NBQWdDQyxNQUFNLEVBQUVDLFNBQVM7SUFDdEQsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUM7SUFDeEMsT0FBTztRQUNIQyxrQkFBa0IsQ0FBQ1QsS0FBSyxDQUFDRCxLQUFLRCxVQUFVVyxnQkFBZ0IsTUFBTSxRQUFRVixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdXLElBQUksQ0FBQ1osVUFBUyxNQUFPLFFBQVFFLE9BQU8sS0FBSyxJQUFJQSxLQUFLSCxPQUFPWSxnQkFBZ0IsQ0FBQ0MsSUFBSSxDQUFDYjtRQUNqTGMsYUFBYSxDQUFDVCxLQUFLLENBQUNELEtBQUtILFVBQVVhLFdBQVcsTUFBTSxRQUFRVixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdTLElBQUksQ0FBQ1osVUFBUyxNQUFPLFFBQVFJLE9BQU8sS0FBSyxJQUFJQSxLQUFLTCxPQUFPYyxXQUFXLENBQUNELElBQUksQ0FBQ2I7UUFDbEtlLHFCQUFxQixDQUFDUixLQUFLLENBQUNELEtBQUtMLFVBQVVjLG1CQUFtQixNQUFNLFFBQVFULE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR08sSUFBSSxDQUFDWixVQUFTLE1BQU8sUUFBUU0sT0FBTyxLQUFLLElBQUlBLEtBQUtQLE9BQU9lLG1CQUFtQixDQUFDRixJQUFJLENBQUNiO1FBQzFMZ0Isa0JBQWtCLENBQUNQLEtBQUssQ0FBQ0QsS0FBS1AsVUFBVWUsZ0JBQWdCLE1BQU0sUUFBUVIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSyxJQUFJLENBQUNaLFVBQVMsTUFBTyxRQUFRUSxPQUFPLEtBQUssSUFBSUEsS0FBS1QsT0FBT2dCLGdCQUFnQixDQUFDSCxJQUFJLENBQUNiO1FBQ2pMaUIscUJBQXFCLENBQUNOLEtBQUssQ0FBQ0QsS0FBS1QsVUFBVWdCLG1CQUFtQixNQUFNLFFBQVFQLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0csSUFBSSxDQUFDWixVQUFTLE1BQU8sUUFBUVUsT0FBTyxLQUFLLElBQUlBLEtBQUtYLE9BQU9pQixtQkFBbUIsQ0FBQ0osSUFBSSxDQUFDYjtJQUM5TDtBQUNKO0FBQ0FULHVDQUF1QyxHQUFHUTtBQUMxQyxNQUFNbUIsOEJBQThCLENBQUM7QUFDckMsSUFBSUMsMEJBQTBCO0FBQzlCLFNBQVNyQix5QkFBeUJzQixRQUFRLEVBQUVDLGdCQUFnQixFQUFFQyx1QkFBdUI7SUFDakZKLDJCQUEyQixDQUFDRSxTQUFTLEdBQUc7UUFDcENHLGNBQWNGO1FBQ2RHLHFCQUFxQkY7SUFDekI7QUFDSjtBQUNBL0IsZ0NBQWdDLEdBQUdPO0FBQ25DLFNBQVNELGdDQUFnQ3VCLFFBQVE7SUFDN0NELDBCQUEwQkM7QUFDOUI7QUFDQTdCLHVDQUF1QyxHQUFHTTtBQUMxQyxTQUFTRCxtQkFBbUI2QixNQUFNLEVBQUVDLG9CQUFvQjtJQUNwRCxNQUFNTixXQUFXSyxPQUFPRSxtQkFBbUI7SUFDM0MsSUFBSVAsWUFBWUYsNkJBQTZCO1FBQ3pDLE9BQU8sSUFBSUEsMkJBQTJCLENBQUNFLFNBQVMsQ0FBQ0csWUFBWSxDQUFDRztJQUNsRSxPQUNLO1FBQ0QsT0FBTztJQUNYO0FBQ0o7QUFDQW5DLDBCQUEwQixHQUFHSztBQUM3QixTQUFTRCw2QkFBNkJ5QixRQUFRO0lBQzFDLE9BQU9BLFlBQVlGO0FBQ3ZCO0FBQ0EzQixvQ0FBb0MsR0FBR0k7QUFDdkMsU0FBU0QscUJBQXFCa0MsT0FBTyxFQUFFQyxvQkFBb0IsS0FBSztJQUM1RCxLQUFLLE1BQU1KLFVBQVVHLFFBQVM7UUFDMUIsSUFBSUgsT0FBT0UsbUJBQW1CLE1BQU1ULDZCQUE2QjtZQUM3RCxPQUFPTztRQUNYO0lBQ0o7SUFDQSxJQUFJSSxtQkFBbUI7UUFDbkIsSUFBSVYseUJBQXlCO1lBQ3pCLE9BQU8sSUFBSUQsMkJBQTJCLENBQUNDLHdCQUF3QixDQUFDSyxtQkFBbUI7UUFDdkYsT0FDSztZQUNELE9BQU87UUFDWDtJQUNKLE9BQ0s7UUFDRCxPQUFPO0lBQ1g7QUFDSjtBQUNBakMsNEJBQTRCLEdBQUdHO0FBQy9CLDhEQUE4RDtBQUM5RCxTQUFTRCw0QkFBNEJxQyxHQUFHO0lBQ3BDLElBQUksQ0FBRUEsQ0FBQUEsUUFBUSxRQUFRLE9BQU9BLFFBQVEsUUFBTyxHQUFJO1FBQzVDLE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtJQUNBLE1BQU1DLE9BQU8zQyxPQUFPMkMsSUFBSSxDQUFDRjtJQUN6QixJQUFJRSxLQUFLQyxNQUFNLEtBQUssR0FBRztRQUNuQixNQUFNLElBQUlGLE1BQU07SUFDcEI7SUFDQSxNQUFNWCxXQUFXWSxJQUFJLENBQUMsRUFBRTtJQUN4QixJQUFJWixZQUFZRiw2QkFBNkI7UUFDekMsT0FBT0EsMkJBQTJCLENBQUNFLFNBQVMsQ0FBQ0ksbUJBQW1CLENBQUNVLGNBQWMsQ0FBQ0osR0FBRyxDQUFDVixTQUFTO0lBQ2pHLE9BQ0s7UUFDRCxNQUFNLElBQUlXLE1BQU0sQ0FBQyx3Q0FBd0MsRUFBRVgsU0FBUyxDQUFDO0lBQ3pFO0FBQ0o7QUFDQTdCLG1DQUFtQyxHQUFHRSw2QkFDdEMseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNobWl0dC1ndXB0YS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLmpzPzI3Y2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnID0gZXhwb3J0cy5nZXRGaXJzdFVzYWJsZUNvbmZpZyA9IGV4cG9ydHMuaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZCA9IGV4cG9ydHMuY3JlYXRlTG9hZEJhbGFuY2VyID0gZXhwb3J0cy5yZWdpc3RlckRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlID0gZXhwb3J0cy5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGUgPSBleHBvcnRzLmNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIgPSB2b2lkIDA7XG4vKipcbiAqIENyZWF0ZSBhIGNoaWxkIENoYW5uZWxDb250cm9sSGVscGVyIHRoYXQgb3ZlcnJpZGVzIHNvbWUgbWV0aG9kcyBvZiB0aGVcbiAqIHBhcmVudCB3aGlsZSBsZXR0aW5nIG90aGVycyBwYXNzIHRocm91Z2ggdG8gdGhlIHBhcmVudCB1bm1vZGlmaWVkLiBUaGlzXG4gKiBhbGxvd3Mgb3RoZXIgY29kZSB0byBjcmVhdGUgdGhlc2UgY2hpbGRyZW4gd2l0aG91dCBuZWVkaW5nIHRvIGtub3cgYWJvdXRcbiAqIGFsbCBvZiB0aGUgbWV0aG9kcyB0byBiZSBwYXNzZWQgdGhyb3VnaC5cbiAqIEBwYXJhbSBwYXJlbnRcbiAqIEBwYXJhbSBvdmVycmlkZXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlcihwYXJlbnQsIG92ZXJyaWRlcykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaztcbiAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGVTdWJjaGFubmVsOiAoX2IgPSAoX2EgPSBvdmVycmlkZXMuY3JlYXRlU3ViY2hhbm5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJpbmQob3ZlcnJpZGVzKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogcGFyZW50LmNyZWF0ZVN1YmNoYW5uZWwuYmluZChwYXJlbnQpLFxuICAgICAgICB1cGRhdGVTdGF0ZTogKF9kID0gKF9jID0gb3ZlcnJpZGVzLnVwZGF0ZVN0YXRlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYmluZChvdmVycmlkZXMpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBwYXJlbnQudXBkYXRlU3RhdGUuYmluZChwYXJlbnQpLFxuICAgICAgICByZXF1ZXN0UmVyZXNvbHV0aW9uOiAoX2YgPSAoX2UgPSBvdmVycmlkZXMucmVxdWVzdFJlcmVzb2x1dGlvbikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmJpbmQob3ZlcnJpZGVzKSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogcGFyZW50LnJlcXVlc3RSZXJlc29sdXRpb24uYmluZChwYXJlbnQpLFxuICAgICAgICBhZGRDaGFubmVsekNoaWxkOiAoX2ggPSAoX2cgPSBvdmVycmlkZXMuYWRkQ2hhbm5lbHpDaGlsZCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmJpbmQob3ZlcnJpZGVzKSkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogcGFyZW50LmFkZENoYW5uZWx6Q2hpbGQuYmluZChwYXJlbnQpLFxuICAgICAgICByZW1vdmVDaGFubmVsekNoaWxkOiAoX2sgPSAoX2ogPSBvdmVycmlkZXMucmVtb3ZlQ2hhbm5lbHpDaGlsZCkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLmJpbmQob3ZlcnJpZGVzKSkgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogcGFyZW50LnJlbW92ZUNoYW5uZWx6Q2hpbGQuYmluZChwYXJlbnQpXG4gICAgfTtcbn1cbmV4cG9ydHMuY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlciA9IGNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXI7XG5jb25zdCByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXMgPSB7fTtcbmxldCBkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSA9IG51bGw7XG5mdW5jdGlvbiByZWdpc3RlckxvYWRCYWxhbmNlclR5cGUodHlwZU5hbWUsIGxvYWRCYWxhbmNlclR5cGUsIGxvYWRCYWxhbmNpbmdDb25maWdUeXBlKSB7XG4gICAgcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzW3R5cGVOYW1lXSA9IHtcbiAgICAgICAgTG9hZEJhbGFuY2VyOiBsb2FkQmFsYW5jZXJUeXBlLFxuICAgICAgICBMb2FkQmFsYW5jaW5nQ29uZmlnOiBsb2FkQmFsYW5jaW5nQ29uZmlnVHlwZSxcbiAgICB9O1xufVxuZXhwb3J0cy5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGUgPSByZWdpc3RlckxvYWRCYWxhbmNlclR5cGU7XG5mdW5jdGlvbiByZWdpc3RlckRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlKHR5cGVOYW1lKSB7XG4gICAgZGVmYXVsdExvYWRCYWxhbmNlclR5cGUgPSB0eXBlTmFtZTtcbn1cbmV4cG9ydHMucmVnaXN0ZXJEZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSA9IHJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGU7XG5mdW5jdGlvbiBjcmVhdGVMb2FkQmFsYW5jZXIoY29uZmlnLCBjaGFubmVsQ29udHJvbEhlbHBlcikge1xuICAgIGNvbnN0IHR5cGVOYW1lID0gY29uZmlnLmdldExvYWRCYWxhbmNlck5hbWUoKTtcbiAgICBpZiAodHlwZU5hbWUgaW4gcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzW3R5cGVOYW1lXS5Mb2FkQmFsYW5jZXIoY2hhbm5lbENvbnRyb2xIZWxwZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVMb2FkQmFsYW5jZXIgPSBjcmVhdGVMb2FkQmFsYW5jZXI7XG5mdW5jdGlvbiBpc0xvYWRCYWxhbmNlck5hbWVSZWdpc3RlcmVkKHR5cGVOYW1lKSB7XG4gICAgcmV0dXJuIHR5cGVOYW1lIGluIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlcztcbn1cbmV4cG9ydHMuaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZCA9IGlzTG9hZEJhbGFuY2VyTmFtZVJlZ2lzdGVyZWQ7XG5mdW5jdGlvbiBnZXRGaXJzdFVzYWJsZUNvbmZpZyhjb25maWdzLCBmYWxsYmFja1RvZGVmYXVsdCA9IGZhbHNlKSB7XG4gICAgZm9yIChjb25zdCBjb25maWcgb2YgY29uZmlncykge1xuICAgICAgICBpZiAoY29uZmlnLmdldExvYWRCYWxhbmNlck5hbWUoKSBpbiByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZhbGxiYWNrVG9kZWZhdWx0KSB7XG4gICAgICAgIGlmIChkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXNbZGVmYXVsdExvYWRCYWxhbmNlclR5cGVdLkxvYWRCYWxhbmNpbmdDb25maWcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLmdldEZpcnN0VXNhYmxlQ29uZmlnID0gZ2V0Rmlyc3RVc2FibGVDb25maWc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gdmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnKG9iaikge1xuICAgIGlmICghKG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2FkIGJhbGFuY2luZyBjb25maWcgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgaWYgKGtleXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgbG9hZCBiYWxhbmNpbmcgY29uZmlnIGhhcyBtdWx0aXBsZSBjb25mbGljdGluZyBlbnRyaWVzJyk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGVOYW1lID0ga2V5c1swXTtcbiAgICBpZiAodHlwZU5hbWUgaW4gcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzKSB7XG4gICAgICAgIHJldHVybiByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXNbdHlwZU5hbWVdLkxvYWRCYWxhbmNpbmdDb25maWcuY3JlYXRlRnJvbUpzb24ob2JqW3R5cGVOYW1lXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBsb2FkIGJhbGFuY2luZyBjb25maWcgbmFtZSAke3R5cGVOYW1lfWApO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnID0gdmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC1iYWxhbmNlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ2YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWciLCJnZXRGaXJzdFVzYWJsZUNvbmZpZyIsImlzTG9hZEJhbGFuY2VyTmFtZVJlZ2lzdGVyZWQiLCJjcmVhdGVMb2FkQmFsYW5jZXIiLCJyZWdpc3RlckRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlIiwicmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlIiwiY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlciIsInBhcmVudCIsIm92ZXJyaWRlcyIsIl9hIiwiX2IiLCJfYyIsIl9kIiwiX2UiLCJfZiIsIl9nIiwiX2giLCJfaiIsIl9rIiwiY3JlYXRlU3ViY2hhbm5lbCIsImJpbmQiLCJ1cGRhdGVTdGF0ZSIsInJlcXVlc3RSZXJlc29sdXRpb24iLCJhZGRDaGFubmVsekNoaWxkIiwicmVtb3ZlQ2hhbm5lbHpDaGlsZCIsInJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlcyIsImRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlIiwidHlwZU5hbWUiLCJsb2FkQmFsYW5jZXJUeXBlIiwibG9hZEJhbGFuY2luZ0NvbmZpZ1R5cGUiLCJMb2FkQmFsYW5jZXIiLCJMb2FkQmFsYW5jaW5nQ29uZmlnIiwiY29uZmlnIiwiY2hhbm5lbENvbnRyb2xIZWxwZXIiLCJnZXRMb2FkQmFsYW5jZXJOYW1lIiwiY29uZmlncyIsImZhbGxiYWNrVG9kZWZhdWx0Iiwib2JqIiwiRXJyb3IiLCJrZXlzIiwibGVuZ3RoIiwiY3JlYXRlRnJvbUpzb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/logging.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ var _a, _b, _c, _d;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isTracerEnabled = exports.trace = exports.log = exports.setLoggerVerbosity = exports.setLogger = exports.getLogger = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst DEFAULT_LOGGER = {\n    error: (message, ...optionalParams)=>{\n        console.error(\"E \" + message, ...optionalParams);\n    },\n    info: (message, ...optionalParams)=>{\n        console.error(\"I \" + message, ...optionalParams);\n    },\n    debug: (message, ...optionalParams)=>{\n        console.error(\"D \" + message, ...optionalParams);\n    }\n};\nlet _logger = DEFAULT_LOGGER;\nlet _logVerbosity = constants_1.LogVerbosity.ERROR;\nconst verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== void 0 ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== void 0 ? _b : \"\";\nswitch(verbosityString.toUpperCase()){\n    case \"DEBUG\":\n        _logVerbosity = constants_1.LogVerbosity.DEBUG;\n        break;\n    case \"INFO\":\n        _logVerbosity = constants_1.LogVerbosity.INFO;\n        break;\n    case \"ERROR\":\n        _logVerbosity = constants_1.LogVerbosity.ERROR;\n        break;\n    case \"NONE\":\n        _logVerbosity = constants_1.LogVerbosity.NONE;\n        break;\n    default:\n}\nexports.getLogger = ()=>{\n    return _logger;\n};\nexports.setLogger = (logger)=>{\n    _logger = logger;\n};\nexports.setLoggerVerbosity = (verbosity)=>{\n    _logVerbosity = verbosity;\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexports.log = (severity, ...args)=>{\n    let logFunction;\n    if (severity >= _logVerbosity) {\n        switch(severity){\n            case constants_1.LogVerbosity.DEBUG:\n                logFunction = _logger.debug;\n                break;\n            case constants_1.LogVerbosity.INFO:\n                logFunction = _logger.info;\n                break;\n            case constants_1.LogVerbosity.ERROR:\n                logFunction = _logger.error;\n                break;\n        }\n        /* Fall back to _logger.error when other methods are not available for\n         * compatiblity with older behavior that always logged to _logger.error */ if (!logFunction) {\n            logFunction = _logger.error;\n        }\n        if (logFunction) {\n            logFunction.bind(_logger)(...args);\n        }\n    }\n};\nconst tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== void 0 ? _c : process.env.GRPC_TRACE) !== null && _d !== void 0 ? _d : \"\";\nconst enabledTracers = new Set();\nconst disabledTracers = new Set();\nfor (const tracerName of tracersString.split(\",\")){\n    if (tracerName.startsWith(\"-\")) {\n        disabledTracers.add(tracerName.substring(1));\n    } else {\n        enabledTracers.add(tracerName);\n    }\n}\nconst allEnabled = enabledTracers.has(\"all\");\nfunction trace(severity, tracer, text) {\n    if (isTracerEnabled(tracer)) {\n        exports.log(severity, new Date().toISOString() + \" | \" + tracer + \" | \" + text);\n    }\n}\nexports.trace = trace;\nfunction isTracerEnabled(tracer) {\n    return !disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer));\n}\nexports.isTracerEnabled = isTracerEnabled; //# sourceMappingURL=logging.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9nZ2luZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELElBQUlBLElBQUlDLElBQUlDLElBQUlDO0FBQ2hCQyw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUJBQXVCLEdBQUdBLGFBQWEsR0FBR0EsV0FBVyxHQUFHQSwwQkFBMEIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHLEtBQUs7QUFDbEksTUFBTVEsY0FBY0MsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUMsaUJBQWlCO0lBQ25CQyxPQUFPLENBQUNDLFNBQVMsR0FBR0M7UUFDaEJDLFFBQVFILEtBQUssQ0FBQyxPQUFPQyxZQUFZQztJQUNyQztJQUNBRSxNQUFNLENBQUNILFNBQVMsR0FBR0M7UUFDZkMsUUFBUUgsS0FBSyxDQUFDLE9BQU9DLFlBQVlDO0lBQ3JDO0lBQ0FHLE9BQU8sQ0FBQ0osU0FBUyxHQUFHQztRQUNoQkMsUUFBUUgsS0FBSyxDQUFDLE9BQU9DLFlBQVlDO0lBQ3JDO0FBQ0o7QUFDQSxJQUFJSSxVQUFVUDtBQUNkLElBQUlRLGdCQUFnQlYsWUFBWVcsWUFBWSxDQUFDQyxLQUFLO0FBQ2xELE1BQU1DLGtCQUFrQixDQUFDMUIsS0FBSyxDQUFDRCxLQUFLNEIsUUFBUUMsR0FBRyxDQUFDQyxtQkFBbUIsTUFBTSxRQUFROUIsT0FBTyxLQUFLLElBQUlBLEtBQUs0QixRQUFRQyxHQUFHLENBQUNFLGNBQWMsTUFBTSxRQUFROUIsT0FBTyxLQUFLLElBQUlBLEtBQUs7QUFDbkssT0FBUTBCLGdCQUFnQkssV0FBVztJQUMvQixLQUFLO1FBQ0RSLGdCQUFnQlYsWUFBWVcsWUFBWSxDQUFDUSxLQUFLO1FBQzlDO0lBQ0osS0FBSztRQUNEVCxnQkFBZ0JWLFlBQVlXLFlBQVksQ0FBQ1MsSUFBSTtRQUM3QztJQUNKLEtBQUs7UUFDRFYsZ0JBQWdCVixZQUFZVyxZQUFZLENBQUNDLEtBQUs7UUFDOUM7SUFDSixLQUFLO1FBQ0RGLGdCQUFnQlYsWUFBWVcsWUFBWSxDQUFDVSxJQUFJO1FBQzdDO0lBQ0o7QUFFSjtBQUNBN0IsaUJBQWlCLEdBQUc7SUFDaEIsT0FBT2lCO0FBQ1g7QUFDQWpCLGlCQUFpQixHQUFHLENBQUM4QjtJQUNqQmIsVUFBVWE7QUFDZDtBQUNBOUIsMEJBQTBCLEdBQUcsQ0FBQytCO0lBQzFCYixnQkFBZ0JhO0FBQ3BCO0FBQ0EsOERBQThEO0FBQzlEL0IsV0FBVyxHQUFHLENBQUNnQyxVQUFVLEdBQUdDO0lBQ3hCLElBQUlDO0lBQ0osSUFBSUYsWUFBWWQsZUFBZTtRQUMzQixPQUFRYztZQUNKLEtBQUt4QixZQUFZVyxZQUFZLENBQUNRLEtBQUs7Z0JBQy9CTyxjQUFjakIsUUFBUUQsS0FBSztnQkFDM0I7WUFDSixLQUFLUixZQUFZVyxZQUFZLENBQUNTLElBQUk7Z0JBQzlCTSxjQUFjakIsUUFBUUYsSUFBSTtnQkFDMUI7WUFDSixLQUFLUCxZQUFZVyxZQUFZLENBQUNDLEtBQUs7Z0JBQy9CYyxjQUFjakIsUUFBUU4sS0FBSztnQkFDM0I7UUFDUjtRQUNBO2dGQUN3RSxHQUN4RSxJQUFJLENBQUN1QixhQUFhO1lBQ2RBLGNBQWNqQixRQUFRTixLQUFLO1FBQy9CO1FBQ0EsSUFBSXVCLGFBQWE7WUFDYkEsWUFBWUMsSUFBSSxDQUFDbEIsWUFBWWdCO1FBQ2pDO0lBQ0o7QUFDSjtBQUNBLE1BQU1HLGdCQUFnQixDQUFDdkMsS0FBSyxDQUFDRCxLQUFLMEIsUUFBUUMsR0FBRyxDQUFDYyxlQUFlLE1BQU0sUUFBUXpDLE9BQU8sS0FBSyxJQUFJQSxLQUFLMEIsUUFBUUMsR0FBRyxDQUFDZSxVQUFVLE1BQU0sUUFBUXpDLE9BQU8sS0FBSyxJQUFJQSxLQUFLO0FBQ3pKLE1BQU0wQyxpQkFBaUIsSUFBSUM7QUFDM0IsTUFBTUMsa0JBQWtCLElBQUlEO0FBQzVCLEtBQUssTUFBTUUsY0FBY04sY0FBY08sS0FBSyxDQUFDLEtBQU07SUFDL0MsSUFBSUQsV0FBV0UsVUFBVSxDQUFDLE1BQU07UUFDNUJILGdCQUFnQkksR0FBRyxDQUFDSCxXQUFXSSxTQUFTLENBQUM7SUFDN0MsT0FDSztRQUNEUCxlQUFlTSxHQUFHLENBQUNIO0lBQ3ZCO0FBQ0o7QUFDQSxNQUFNSyxhQUFhUixlQUFlUyxHQUFHLENBQUM7QUFDdEMsU0FBUzdDLE1BQU02QixRQUFRLEVBQUVpQixNQUFNLEVBQUVDLElBQUk7SUFDakMsSUFBSWhELGdCQUFnQitDLFNBQVM7UUFDekJqRCxRQUFRSSxHQUFHLENBQUM0QixVQUFVLElBQUltQixPQUFPQyxXQUFXLEtBQUssUUFBUUgsU0FBUyxRQUFRQztJQUM5RTtBQUNKO0FBQ0FsRCxhQUFhLEdBQUdHO0FBQ2hCLFNBQVNELGdCQUFnQitDLE1BQU07SUFDM0IsT0FBTyxDQUFDUixnQkFBZ0JPLEdBQUcsQ0FBQ0MsV0FDdkJGLENBQUFBLGNBQWNSLGVBQWVTLEdBQUcsQ0FBQ0MsT0FBTTtBQUNoRDtBQUNBakQsdUJBQXVCLEdBQUdFLGlCQUMxQixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc2htaXR0LWd1cHRhLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvZ2dpbmcuanM/NDUzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xudmFyIF9hLCBfYiwgX2MsIF9kO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1RyYWNlckVuYWJsZWQgPSBleHBvcnRzLnRyYWNlID0gZXhwb3J0cy5sb2cgPSBleHBvcnRzLnNldExvZ2dlclZlcmJvc2l0eSA9IGV4cG9ydHMuc2V0TG9nZ2VyID0gZXhwb3J0cy5nZXRMb2dnZXIgPSB2b2lkIDA7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IERFRkFVTFRfTE9HR0VSID0ge1xuICAgIGVycm9yOiAobWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRSAnICsgbWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpO1xuICAgIH0sXG4gICAgaW5mbzogKG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0kgJyArIG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKTtcbiAgICB9LFxuICAgIGRlYnVnOiAobWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRCAnICsgbWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpO1xuICAgIH0sXG59O1xubGV0IF9sb2dnZXIgPSBERUZBVUxUX0xPR0dFUjtcbmxldCBfbG9nVmVyYm9zaXR5ID0gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SO1xuY29uc3QgdmVyYm9zaXR5U3RyaW5nID0gKF9iID0gKF9hID0gcHJvY2Vzcy5lbnYuR1JQQ19OT0RFX1ZFUkJPU0lUWSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcHJvY2Vzcy5lbnYuR1JQQ19WRVJCT1NJVFkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuc3dpdGNoICh2ZXJib3NpdHlTdHJpbmcudG9VcHBlckNhc2UoKSkge1xuICAgIGNhc2UgJ0RFQlVHJzpcbiAgICAgICAgX2xvZ1ZlcmJvc2l0eSA9IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRztcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnSU5GTyc6XG4gICAgICAgIF9sb2dWZXJib3NpdHkgPSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuSU5GTztcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnRVJST1InOlxuICAgICAgICBfbG9nVmVyYm9zaXR5ID0gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdOT05FJzpcbiAgICAgICAgX2xvZ1ZlcmJvc2l0eSA9IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5OT05FO1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgIC8vIElnbm9yZSBhbnkgb3RoZXIgdmFsdWVzXG59XG5leHBvcnRzLmdldExvZ2dlciA9ICgpID0+IHtcbiAgICByZXR1cm4gX2xvZ2dlcjtcbn07XG5leHBvcnRzLnNldExvZ2dlciA9IChsb2dnZXIpID0+IHtcbiAgICBfbG9nZ2VyID0gbG9nZ2VyO1xufTtcbmV4cG9ydHMuc2V0TG9nZ2VyVmVyYm9zaXR5ID0gKHZlcmJvc2l0eSkgPT4ge1xuICAgIF9sb2dWZXJib3NpdHkgPSB2ZXJib3NpdHk7XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydHMubG9nID0gKHNldmVyaXR5LCAuLi5hcmdzKSA9PiB7XG4gICAgbGV0IGxvZ0Z1bmN0aW9uO1xuICAgIGlmIChzZXZlcml0eSA+PSBfbG9nVmVyYm9zaXR5KSB7XG4gICAgICAgIHN3aXRjaCAoc2V2ZXJpdHkpIHtcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHOlxuICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uID0gX2xvZ2dlci5kZWJ1ZztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LklORk86XG4gICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24gPSBfbG9nZ2VyLmluZm87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUjpcbiAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbiA9IF9sb2dnZXIuZXJyb3I7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLyogRmFsbCBiYWNrIHRvIF9sb2dnZXIuZXJyb3Igd2hlbiBvdGhlciBtZXRob2RzIGFyZSBub3QgYXZhaWxhYmxlIGZvclxuICAgICAgICAgKiBjb21wYXRpYmxpdHkgd2l0aCBvbGRlciBiZWhhdmlvciB0aGF0IGFsd2F5cyBsb2dnZWQgdG8gX2xvZ2dlci5lcnJvciAqL1xuICAgICAgICBpZiAoIWxvZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICBsb2dGdW5jdGlvbiA9IF9sb2dnZXIuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICBsb2dGdW5jdGlvbi5iaW5kKF9sb2dnZXIpKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHRyYWNlcnNTdHJpbmcgPSAoX2QgPSAoX2MgPSBwcm9jZXNzLmVudi5HUlBDX05PREVfVFJBQ0UpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHByb2Nlc3MuZW52LkdSUENfVFJBQ0UpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICcnO1xuY29uc3QgZW5hYmxlZFRyYWNlcnMgPSBuZXcgU2V0KCk7XG5jb25zdCBkaXNhYmxlZFRyYWNlcnMgPSBuZXcgU2V0KCk7XG5mb3IgKGNvbnN0IHRyYWNlck5hbWUgb2YgdHJhY2Vyc1N0cmluZy5zcGxpdCgnLCcpKSB7XG4gICAgaWYgKHRyYWNlck5hbWUuc3RhcnRzV2l0aCgnLScpKSB7XG4gICAgICAgIGRpc2FibGVkVHJhY2Vycy5hZGQodHJhY2VyTmFtZS5zdWJzdHJpbmcoMSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW5hYmxlZFRyYWNlcnMuYWRkKHRyYWNlck5hbWUpO1xuICAgIH1cbn1cbmNvbnN0IGFsbEVuYWJsZWQgPSBlbmFibGVkVHJhY2Vycy5oYXMoJ2FsbCcpO1xuZnVuY3Rpb24gdHJhY2Uoc2V2ZXJpdHksIHRyYWNlciwgdGV4dCkge1xuICAgIGlmIChpc1RyYWNlckVuYWJsZWQodHJhY2VyKSkge1xuICAgICAgICBleHBvcnRzLmxvZyhzZXZlcml0eSwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgJyB8ICcgKyB0cmFjZXIgKyAnIHwgJyArIHRleHQpO1xuICAgIH1cbn1cbmV4cG9ydHMudHJhY2UgPSB0cmFjZTtcbmZ1bmN0aW9uIGlzVHJhY2VyRW5hYmxlZCh0cmFjZXIpIHtcbiAgICByZXR1cm4gIWRpc2FibGVkVHJhY2Vycy5oYXModHJhY2VyKSAmJlxuICAgICAgICAoYWxsRW5hYmxlZCB8fCBlbmFibGVkVHJhY2Vycy5oYXModHJhY2VyKSk7XG59XG5leHBvcnRzLmlzVHJhY2VyRW5hYmxlZCA9IGlzVHJhY2VyRW5hYmxlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dpbmcuanMubWFwIl0sIm5hbWVzIjpbIl9hIiwiX2IiLCJfYyIsIl9kIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpc1RyYWNlckVuYWJsZWQiLCJ0cmFjZSIsImxvZyIsInNldExvZ2dlclZlcmJvc2l0eSIsInNldExvZ2dlciIsImdldExvZ2dlciIsImNvbnN0YW50c18xIiwicmVxdWlyZSIsIkRFRkFVTFRfTE9HR0VSIiwiZXJyb3IiLCJtZXNzYWdlIiwib3B0aW9uYWxQYXJhbXMiLCJjb25zb2xlIiwiaW5mbyIsImRlYnVnIiwiX2xvZ2dlciIsIl9sb2dWZXJib3NpdHkiLCJMb2dWZXJib3NpdHkiLCJFUlJPUiIsInZlcmJvc2l0eVN0cmluZyIsInByb2Nlc3MiLCJlbnYiLCJHUlBDX05PREVfVkVSQk9TSVRZIiwiR1JQQ19WRVJCT1NJVFkiLCJ0b1VwcGVyQ2FzZSIsIkRFQlVHIiwiSU5GTyIsIk5PTkUiLCJsb2dnZXIiLCJ2ZXJib3NpdHkiLCJzZXZlcml0eSIsImFyZ3MiLCJsb2dGdW5jdGlvbiIsImJpbmQiLCJ0cmFjZXJzU3RyaW5nIiwiR1JQQ19OT0RFX1RSQUNFIiwiR1JQQ19UUkFDRSIsImVuYWJsZWRUcmFjZXJzIiwiU2V0IiwiZGlzYWJsZWRUcmFjZXJzIiwidHJhY2VyTmFtZSIsInNwbGl0Iiwic3RhcnRzV2l0aCIsImFkZCIsInN1YnN0cmluZyIsImFsbEVuYWJsZWQiLCJoYXMiLCJ0cmFjZXIiLCJ0ZXh0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/make-client.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/make-client.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.loadPackageDefinition = exports.makeClientConstructor = void 0;\nconst client_1 = __webpack_require__(/*! ./client */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/client.js\");\n/**\n * Map with short names for each of the requester maker functions. Used in\n * makeClientConstructor\n * @private\n */ const requesterFuncs = {\n    unary: client_1.Client.prototype.makeUnaryRequest,\n    server_stream: client_1.Client.prototype.makeServerStreamRequest,\n    client_stream: client_1.Client.prototype.makeClientStreamRequest,\n    bidi: client_1.Client.prototype.makeBidiStreamRequest\n};\n/**\n * Returns true, if given key is included in the blacklisted\n * keys.\n * @param key key for check, string.\n */ function isPrototypePolluted(key) {\n    return [\n        \"__proto__\",\n        \"prototype\",\n        \"constructor\"\n    ].includes(key);\n}\n/**\n * Creates a constructor for a client with the given methods, as specified in\n * the methods argument. The resulting class will have an instance method for\n * each method in the service, which is a partial application of one of the\n * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`\n * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`\n * arguments predefined.\n * @param methods An object mapping method names to\n *     method attributes\n * @param serviceName The fully qualified name of the service\n * @param classOptions An options object.\n * @return New client constructor, which is a subclass of\n *     {@link grpc.Client}, and has the same arguments as that constructor.\n */ function makeClientConstructor(methods, serviceName, classOptions) {\n    if (!classOptions) {\n        classOptions = {};\n    }\n    class ServiceClientImpl extends client_1.Client {\n    }\n    Object.keys(methods).forEach((name)=>{\n        if (isPrototypePolluted(name)) {\n            return;\n        }\n        const attrs = methods[name];\n        let methodType;\n        // TODO(murgatroid99): Verify that we don't need this anymore\n        if (typeof name === \"string\" && name.charAt(0) === \"$\") {\n            throw new Error(\"Method names cannot start with $\");\n        }\n        if (attrs.requestStream) {\n            if (attrs.responseStream) {\n                methodType = \"bidi\";\n            } else {\n                methodType = \"client_stream\";\n            }\n        } else {\n            if (attrs.responseStream) {\n                methodType = \"server_stream\";\n            } else {\n                methodType = \"unary\";\n            }\n        }\n        const serialize = attrs.requestSerialize;\n        const deserialize = attrs.responseDeserialize;\n        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);\n        ServiceClientImpl.prototype[name] = methodFunc;\n        // Associate all provided attributes with the method\n        Object.assign(ServiceClientImpl.prototype[name], attrs);\n        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {\n            ServiceClientImpl.prototype[attrs.originalName] = ServiceClientImpl.prototype[name];\n        }\n    });\n    ServiceClientImpl.service = methods;\n    ServiceClientImpl.serviceName = serviceName;\n    return ServiceClientImpl;\n}\nexports.makeClientConstructor = makeClientConstructor;\nfunction partial(fn, path, serialize, deserialize) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return function(...args) {\n        return fn.call(this, path, serialize, deserialize, ...args);\n    };\n}\nfunction isProtobufTypeDefinition(obj) {\n    return \"format\" in obj;\n}\n/**\n * Load a gRPC package definition as a gRPC object hierarchy.\n * @param packageDef The package definition object.\n * @return The resulting gRPC object.\n */ function loadPackageDefinition(packageDef) {\n    const result = {};\n    for(const serviceFqn in packageDef){\n        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {\n            const service = packageDef[serviceFqn];\n            const nameComponents = serviceFqn.split(\".\");\n            if (nameComponents.some((comp)=>isPrototypePolluted(comp))) {\n                continue;\n            }\n            const serviceName = nameComponents[nameComponents.length - 1];\n            let current = result;\n            for (const packageName of nameComponents.slice(0, -1)){\n                if (!current[packageName]) {\n                    current[packageName] = {};\n                }\n                current = current[packageName];\n            }\n            if (isProtobufTypeDefinition(service)) {\n                current[serviceName] = service;\n            } else {\n                current[serviceName] = makeClientConstructor(service, serviceName, {});\n            }\n        }\n    }\n    return result;\n}\nexports.loadPackageDefinition = loadPackageDefinition; //# sourceMappingURL=make-client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWFrZS1jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHQSw2QkFBNkIsR0FBRyxLQUFLO0FBQ3JFLE1BQU1JLFdBQVdDLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DOzs7O0NBSUMsR0FDRCxNQUFNQyxpQkFBaUI7SUFDbkJDLE9BQU9ILFNBQVNJLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDQyxnQkFBZ0I7SUFDakRDLGVBQWVQLFNBQVNJLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDRyx1QkFBdUI7SUFDaEVDLGVBQWVULFNBQVNJLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDSyx1QkFBdUI7SUFDaEVDLE1BQU1YLFNBQVNJLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDTyxxQkFBcUI7QUFDekQ7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU0Msb0JBQW9CQyxHQUFHO0lBQzVCLE9BQU87UUFBQztRQUFhO1FBQWE7S0FBYyxDQUFDQyxRQUFRLENBQUNEO0FBQzlEO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNELFNBQVNmLHNCQUFzQmlCLE9BQU8sRUFBRUMsV0FBVyxFQUFFQyxZQUFZO0lBQzdELElBQUksQ0FBQ0EsY0FBYztRQUNmQSxlQUFlLENBQUM7SUFDcEI7SUFDQSxNQUFNQywwQkFBMEJuQixTQUFTSSxNQUFNO0lBQy9DO0lBQ0FWLE9BQU8wQixJQUFJLENBQUNKLFNBQVNLLE9BQU8sQ0FBQyxDQUFDQztRQUMxQixJQUFJVCxvQkFBb0JTLE9BQU87WUFDM0I7UUFDSjtRQUNBLE1BQU1DLFFBQVFQLE9BQU8sQ0FBQ00sS0FBSztRQUMzQixJQUFJRTtRQUNKLDZEQUE2RDtRQUM3RCxJQUFJLE9BQU9GLFNBQVMsWUFBWUEsS0FBS0csTUFBTSxDQUFDLE9BQU8sS0FBSztZQUNwRCxNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxJQUFJSCxNQUFNSSxhQUFhLEVBQUU7WUFDckIsSUFBSUosTUFBTUssY0FBYyxFQUFFO2dCQUN0QkosYUFBYTtZQUNqQixPQUNLO2dCQUNEQSxhQUFhO1lBQ2pCO1FBQ0osT0FDSztZQUNELElBQUlELE1BQU1LLGNBQWMsRUFBRTtnQkFDdEJKLGFBQWE7WUFDakIsT0FDSztnQkFDREEsYUFBYTtZQUNqQjtRQUNKO1FBQ0EsTUFBTUssWUFBWU4sTUFBTU8sZ0JBQWdCO1FBQ3hDLE1BQU1DLGNBQWNSLE1BQU1TLG1CQUFtQjtRQUM3QyxNQUFNQyxhQUFhQyxRQUFRaEMsY0FBYyxDQUFDc0IsV0FBVyxFQUFFRCxNQUFNWSxJQUFJLEVBQUVOLFdBQVdFO1FBQzlFWixrQkFBa0JkLFNBQVMsQ0FBQ2lCLEtBQUssR0FBR1c7UUFDcEMsb0RBQW9EO1FBQ3BEdkMsT0FBTzBDLE1BQU0sQ0FBQ2pCLGtCQUFrQmQsU0FBUyxDQUFDaUIsS0FBSyxFQUFFQztRQUNqRCxJQUFJQSxNQUFNYyxZQUFZLElBQUksQ0FBQ3hCLG9CQUFvQlUsTUFBTWMsWUFBWSxHQUFHO1lBQ2hFbEIsa0JBQWtCZCxTQUFTLENBQUNrQixNQUFNYyxZQUFZLENBQUMsR0FDM0NsQixrQkFBa0JkLFNBQVMsQ0FBQ2lCLEtBQUs7UUFDekM7SUFDSjtJQUNBSCxrQkFBa0JtQixPQUFPLEdBQUd0QjtJQUM1Qkcsa0JBQWtCRixXQUFXLEdBQUdBO0lBQ2hDLE9BQU9FO0FBQ1g7QUFDQXZCLDZCQUE2QixHQUFHRztBQUNoQyxTQUFTbUMsUUFBUUssRUFBRSxFQUFFSixJQUFJLEVBQUVOLFNBQVMsRUFBRUUsV0FBVztJQUM3Qyw4REFBOEQ7SUFDOUQsT0FBTyxTQUFVLEdBQUdTLElBQUk7UUFDcEIsT0FBT0QsR0FBR0UsSUFBSSxDQUFDLElBQUksRUFBRU4sTUFBTU4sV0FBV0UsZ0JBQWdCUztJQUMxRDtBQUNKO0FBQ0EsU0FBU0UseUJBQXlCQyxHQUFHO0lBQ2pDLE9BQU8sWUFBWUE7QUFDdkI7QUFDQTs7OztDQUlDLEdBQ0QsU0FBUzdDLHNCQUFzQjhDLFVBQVU7SUFDckMsTUFBTUMsU0FBUyxDQUFDO0lBQ2hCLElBQUssTUFBTUMsY0FBY0YsV0FBWTtRQUNqQyxJQUFJbEQsT0FBT1csU0FBUyxDQUFDMEMsY0FBYyxDQUFDTixJQUFJLENBQUNHLFlBQVlFLGFBQWE7WUFDOUQsTUFBTVIsVUFBVU0sVUFBVSxDQUFDRSxXQUFXO1lBQ3RDLE1BQU1FLGlCQUFpQkYsV0FBV0csS0FBSyxDQUFDO1lBQ3hDLElBQUlELGVBQWVFLElBQUksQ0FBQyxDQUFDQyxPQUFTdEMsb0JBQW9Cc0MsUUFBUTtnQkFDMUQ7WUFDSjtZQUNBLE1BQU1sQyxjQUFjK0IsY0FBYyxDQUFDQSxlQUFlSSxNQUFNLEdBQUcsRUFBRTtZQUM3RCxJQUFJQyxVQUFVUjtZQUNkLEtBQUssTUFBTVMsZUFBZU4sZUFBZU8sS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFJO2dCQUNuRCxJQUFJLENBQUNGLE9BQU8sQ0FBQ0MsWUFBWSxFQUFFO29CQUN2QkQsT0FBTyxDQUFDQyxZQUFZLEdBQUcsQ0FBQztnQkFDNUI7Z0JBQ0FELFVBQVVBLE9BQU8sQ0FBQ0MsWUFBWTtZQUNsQztZQUNBLElBQUlaLHlCQUF5QkosVUFBVTtnQkFDbkNlLE9BQU8sQ0FBQ3BDLFlBQVksR0FBR3FCO1lBQzNCLE9BQ0s7Z0JBQ0RlLE9BQU8sQ0FBQ3BDLFlBQVksR0FBR2xCLHNCQUFzQnVDLFNBQVNyQixhQUFhLENBQUM7WUFDeEU7UUFDSjtJQUNKO0lBQ0EsT0FBTzRCO0FBQ1g7QUFDQWpELDZCQUE2QixHQUFHRSx1QkFDaEMsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNobWl0dC1ndXB0YS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9tYWtlLWNsaWVudC5qcz82YmJiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmxvYWRQYWNrYWdlRGVmaW5pdGlvbiA9IGV4cG9ydHMubWFrZUNsaWVudENvbnN0cnVjdG9yID0gdm9pZCAwO1xuY29uc3QgY2xpZW50XzEgPSByZXF1aXJlKFwiLi9jbGllbnRcIik7XG4vKipcbiAqIE1hcCB3aXRoIHNob3J0IG5hbWVzIGZvciBlYWNoIG9mIHRoZSByZXF1ZXN0ZXIgbWFrZXIgZnVuY3Rpb25zLiBVc2VkIGluXG4gKiBtYWtlQ2xpZW50Q29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHJlcXVlc3RlckZ1bmNzID0ge1xuICAgIHVuYXJ5OiBjbGllbnRfMS5DbGllbnQucHJvdG90eXBlLm1ha2VVbmFyeVJlcXVlc3QsXG4gICAgc2VydmVyX3N0cmVhbTogY2xpZW50XzEuQ2xpZW50LnByb3RvdHlwZS5tYWtlU2VydmVyU3RyZWFtUmVxdWVzdCxcbiAgICBjbGllbnRfc3RyZWFtOiBjbGllbnRfMS5DbGllbnQucHJvdG90eXBlLm1ha2VDbGllbnRTdHJlYW1SZXF1ZXN0LFxuICAgIGJpZGk6IGNsaWVudF8xLkNsaWVudC5wcm90b3R5cGUubWFrZUJpZGlTdHJlYW1SZXF1ZXN0LFxufTtcbi8qKlxuICogUmV0dXJucyB0cnVlLCBpZiBnaXZlbiBrZXkgaXMgaW5jbHVkZWQgaW4gdGhlIGJsYWNrbGlzdGVkXG4gKiBrZXlzLlxuICogQHBhcmFtIGtleSBrZXkgZm9yIGNoZWNrLCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlUG9sbHV0ZWQoa2V5KSB7XG4gICAgcmV0dXJuIFsnX19wcm90b19fJywgJ3Byb3RvdHlwZScsICdjb25zdHJ1Y3RvciddLmluY2x1ZGVzKGtleSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBjb25zdHJ1Y3RvciBmb3IgYSBjbGllbnQgd2l0aCB0aGUgZ2l2ZW4gbWV0aG9kcywgYXMgc3BlY2lmaWVkIGluXG4gKiB0aGUgbWV0aG9kcyBhcmd1bWVudC4gVGhlIHJlc3VsdGluZyBjbGFzcyB3aWxsIGhhdmUgYW4gaW5zdGFuY2UgbWV0aG9kIGZvclxuICogZWFjaCBtZXRob2QgaW4gdGhlIHNlcnZpY2UsIHdoaWNoIGlzIGEgcGFydGlhbCBhcHBsaWNhdGlvbiBvZiBvbmUgb2YgdGhlXG4gKiBbQ2xpZW50XXtAbGluayBncnBjLkNsaWVudH0gcmVxdWVzdCBtZXRob2RzLCBkZXBlbmRpbmcgb24gYHJlcXVlc3RTZXJpYWxpemVgXG4gKiBhbmQgYHJlc3BvbnNlU2VyaWFsaXplYCwgd2l0aCB0aGUgYG1ldGhvZGAsIGBzZXJpYWxpemVgLCBhbmQgYGRlc2VyaWFsaXplYFxuICogYXJndW1lbnRzIHByZWRlZmluZWQuXG4gKiBAcGFyYW0gbWV0aG9kcyBBbiBvYmplY3QgbWFwcGluZyBtZXRob2QgbmFtZXMgdG9cbiAqICAgICBtZXRob2QgYXR0cmlidXRlc1xuICogQHBhcmFtIHNlcnZpY2VOYW1lIFRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZSBvZiB0aGUgc2VydmljZVxuICogQHBhcmFtIGNsYXNzT3B0aW9ucyBBbiBvcHRpb25zIG9iamVjdC5cbiAqIEByZXR1cm4gTmV3IGNsaWVudCBjb25zdHJ1Y3Rvciwgd2hpY2ggaXMgYSBzdWJjbGFzcyBvZlxuICogICAgIHtAbGluayBncnBjLkNsaWVudH0sIGFuZCBoYXMgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHRoYXQgY29uc3RydWN0b3IuXG4gKi9cbmZ1bmN0aW9uIG1ha2VDbGllbnRDb25zdHJ1Y3RvcihtZXRob2RzLCBzZXJ2aWNlTmFtZSwgY2xhc3NPcHRpb25zKSB7XG4gICAgaWYgKCFjbGFzc09wdGlvbnMpIHtcbiAgICAgICAgY2xhc3NPcHRpb25zID0ge307XG4gICAgfVxuICAgIGNsYXNzIFNlcnZpY2VDbGllbnRJbXBsIGV4dGVuZHMgY2xpZW50XzEuQ2xpZW50IHtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMobWV0aG9kcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICBpZiAoaXNQcm90b3R5cGVQb2xsdXRlZChuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHJzID0gbWV0aG9kc1tuYW1lXTtcbiAgICAgICAgbGV0IG1ldGhvZFR5cGU7XG4gICAgICAgIC8vIFRPRE8obXVyZ2F0cm9pZDk5KTogVmVyaWZ5IHRoYXQgd2UgZG9uJ3QgbmVlZCB0aGlzIGFueW1vcmVcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyAmJiBuYW1lLmNoYXJBdCgwKSA9PT0gJyQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBuYW1lcyBjYW5ub3Qgc3RhcnQgd2l0aCAkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJzLnJlcXVlc3RTdHJlYW0pIHtcbiAgICAgICAgICAgIGlmIChhdHRycy5yZXNwb25zZVN0cmVhbSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAnYmlkaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ2NsaWVudF9zdHJlYW0nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGF0dHJzLnJlc3BvbnNlU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICdzZXJ2ZXJfc3RyZWFtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAndW5hcnknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZSA9IGF0dHJzLnJlcXVlc3RTZXJpYWxpemU7XG4gICAgICAgIGNvbnN0IGRlc2VyaWFsaXplID0gYXR0cnMucmVzcG9uc2VEZXNlcmlhbGl6ZTtcbiAgICAgICAgY29uc3QgbWV0aG9kRnVuYyA9IHBhcnRpYWwocmVxdWVzdGVyRnVuY3NbbWV0aG9kVHlwZV0sIGF0dHJzLnBhdGgsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUpO1xuICAgICAgICBTZXJ2aWNlQ2xpZW50SW1wbC5wcm90b3R5cGVbbmFtZV0gPSBtZXRob2RGdW5jO1xuICAgICAgICAvLyBBc3NvY2lhdGUgYWxsIHByb3ZpZGVkIGF0dHJpYnV0ZXMgd2l0aCB0aGUgbWV0aG9kXG4gICAgICAgIE9iamVjdC5hc3NpZ24oU2VydmljZUNsaWVudEltcGwucHJvdG90eXBlW25hbWVdLCBhdHRycyk7XG4gICAgICAgIGlmIChhdHRycy5vcmlnaW5hbE5hbWUgJiYgIWlzUHJvdG90eXBlUG9sbHV0ZWQoYXR0cnMub3JpZ2luYWxOYW1lKSkge1xuICAgICAgICAgICAgU2VydmljZUNsaWVudEltcGwucHJvdG90eXBlW2F0dHJzLm9yaWdpbmFsTmFtZV0gPVxuICAgICAgICAgICAgICAgIFNlcnZpY2VDbGllbnRJbXBsLnByb3RvdHlwZVtuYW1lXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFNlcnZpY2VDbGllbnRJbXBsLnNlcnZpY2UgPSBtZXRob2RzO1xuICAgIFNlcnZpY2VDbGllbnRJbXBsLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XG4gICAgcmV0dXJuIFNlcnZpY2VDbGllbnRJbXBsO1xufVxuZXhwb3J0cy5tYWtlQ2xpZW50Q29uc3RydWN0b3IgPSBtYWtlQ2xpZW50Q29uc3RydWN0b3I7XG5mdW5jdGlvbiBwYXJ0aWFsKGZuLCBwYXRoLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgcGF0aCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgLi4uYXJncyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlzUHJvdG9idWZUeXBlRGVmaW5pdGlvbihvYmopIHtcbiAgICByZXR1cm4gJ2Zvcm1hdCcgaW4gb2JqO1xufVxuLyoqXG4gKiBMb2FkIGEgZ1JQQyBwYWNrYWdlIGRlZmluaXRpb24gYXMgYSBnUlBDIG9iamVjdCBoaWVyYXJjaHkuXG4gKiBAcGFyYW0gcGFja2FnZURlZiBUaGUgcGFja2FnZSBkZWZpbml0aW9uIG9iamVjdC5cbiAqIEByZXR1cm4gVGhlIHJlc3VsdGluZyBnUlBDIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gbG9hZFBhY2thZ2VEZWZpbml0aW9uKHBhY2thZ2VEZWYpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHNlcnZpY2VGcW4gaW4gcGFja2FnZURlZikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhY2thZ2VEZWYsIHNlcnZpY2VGcW4pKSB7XG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlID0gcGFja2FnZURlZltzZXJ2aWNlRnFuXTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVDb21wb25lbnRzID0gc2VydmljZUZxbi5zcGxpdCgnLicpO1xuICAgICAgICAgICAgaWYgKG5hbWVDb21wb25lbnRzLnNvbWUoKGNvbXApID0+IGlzUHJvdG90eXBlUG9sbHV0ZWQoY29tcCkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlTmFtZSA9IG5hbWVDb21wb25lbnRzW25hbWVDb21wb25lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSByZXN1bHQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhY2thZ2VOYW1lIG9mIG5hbWVDb21wb25lbnRzLnNsaWNlKDAsIC0xKSkge1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFtwYWNrYWdlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFtwYWNrYWdlTmFtZV0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGFja2FnZU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJvdG9idWZUeXBlRGVmaW5pdGlvbihzZXJ2aWNlKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRbc2VydmljZU5hbWVdID0gc2VydmljZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRbc2VydmljZU5hbWVdID0gbWFrZUNsaWVudENvbnN0cnVjdG9yKHNlcnZpY2UsIHNlcnZpY2VOYW1lLCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMubG9hZFBhY2thZ2VEZWZpbml0aW9uID0gbG9hZFBhY2thZ2VEZWZpbml0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZS1jbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibG9hZFBhY2thZ2VEZWZpbml0aW9uIiwibWFrZUNsaWVudENvbnN0cnVjdG9yIiwiY2xpZW50XzEiLCJyZXF1aXJlIiwicmVxdWVzdGVyRnVuY3MiLCJ1bmFyeSIsIkNsaWVudCIsInByb3RvdHlwZSIsIm1ha2VVbmFyeVJlcXVlc3QiLCJzZXJ2ZXJfc3RyZWFtIiwibWFrZVNlcnZlclN0cmVhbVJlcXVlc3QiLCJjbGllbnRfc3RyZWFtIiwibWFrZUNsaWVudFN0cmVhbVJlcXVlc3QiLCJiaWRpIiwibWFrZUJpZGlTdHJlYW1SZXF1ZXN0IiwiaXNQcm90b3R5cGVQb2xsdXRlZCIsImtleSIsImluY2x1ZGVzIiwibWV0aG9kcyIsInNlcnZpY2VOYW1lIiwiY2xhc3NPcHRpb25zIiwiU2VydmljZUNsaWVudEltcGwiLCJrZXlzIiwiZm9yRWFjaCIsIm5hbWUiLCJhdHRycyIsIm1ldGhvZFR5cGUiLCJjaGFyQXQiLCJFcnJvciIsInJlcXVlc3RTdHJlYW0iLCJyZXNwb25zZVN0cmVhbSIsInNlcmlhbGl6ZSIsInJlcXVlc3RTZXJpYWxpemUiLCJkZXNlcmlhbGl6ZSIsInJlc3BvbnNlRGVzZXJpYWxpemUiLCJtZXRob2RGdW5jIiwicGFydGlhbCIsInBhdGgiLCJhc3NpZ24iLCJvcmlnaW5hbE5hbWUiLCJzZXJ2aWNlIiwiZm4iLCJhcmdzIiwiY2FsbCIsImlzUHJvdG9idWZUeXBlRGVmaW5pdGlvbiIsIm9iaiIsInBhY2thZ2VEZWYiLCJyZXN1bHQiLCJzZXJ2aWNlRnFuIiwiaGFzT3duUHJvcGVydHkiLCJuYW1lQ29tcG9uZW50cyIsInNwbGl0Iiwic29tZSIsImNvbXAiLCJsZW5ndGgiLCJjdXJyZW50IiwicGFja2FnZU5hbWUiLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/make-client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.MaxMessageSizeFilterFactory = exports.MaxMessageSizeFilter = void 0;\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nclass MaxMessageSizeFilter extends filter_1.BaseFilter {\n    constructor(options, callStream){\n        super();\n        this.options = options;\n        this.callStream = callStream;\n        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        if (\"grpc.max_send_message_length\" in options) {\n            this.maxSendMessageSize = options[\"grpc.max_send_message_length\"];\n        }\n        if (\"grpc.max_receive_message_length\" in options) {\n            this.maxReceiveMessageSize = options[\"grpc.max_receive_message_length\"];\n        }\n    }\n    async sendMessage(message) {\n        /* A configured size of -1 means that there is no limit, so skip the check\n         * entirely */ if (this.maxSendMessageSize === -1) {\n            return message;\n        } else {\n            const concreteMessage = await message;\n            if (concreteMessage.message.length > this.maxSendMessageSize) {\n                this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Sent message larger than max (${concreteMessage.message.length} vs. ${this.maxSendMessageSize})`);\n                return Promise.reject(\"Message too large\");\n            } else {\n                return concreteMessage;\n            }\n        }\n    }\n    async receiveMessage(message) {\n        /* A configured size of -1 means that there is no limit, so skip the check\n         * entirely */ if (this.maxReceiveMessageSize === -1) {\n            return message;\n        } else {\n            const concreteMessage = await message;\n            if (concreteMessage.length > this.maxReceiveMessageSize) {\n                this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Received message larger than max (${concreteMessage.length} vs. ${this.maxReceiveMessageSize})`);\n                return Promise.reject(\"Message too large\");\n            } else {\n                return concreteMessage;\n            }\n        }\n    }\n}\nexports.MaxMessageSizeFilter = MaxMessageSizeFilter;\nclass MaxMessageSizeFilterFactory {\n    constructor(options){\n        this.options = options;\n    }\n    createFilter(callStream) {\n        return new MaxMessageSizeFilter(this.options, callStream);\n    }\n}\nexports.MaxMessageSizeFilterFactory = MaxMessageSizeFilterFactory; //# sourceMappingURL=max-message-size-filter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWF4LW1lc3NhZ2Utc2l6ZS1maWx0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1DQUFtQyxHQUFHQSw0QkFBNEIsR0FBRyxLQUFLO0FBQzFFLE1BQU1JLFdBQVdDLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1GLDZCQUE2QkMsU0FBU0csVUFBVTtJQUNsREMsWUFBWUMsT0FBTyxFQUFFQyxVQUFVLENBQUU7UUFDN0IsS0FBSztRQUNMLElBQUksQ0FBQ0QsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLGtCQUFrQixHQUFHTCxZQUFZTSwrQkFBK0I7UUFDckUsSUFBSSxDQUFDQyxxQkFBcUIsR0FBR1AsWUFBWVEsa0NBQWtDO1FBQzNFLElBQUksa0NBQWtDTCxTQUFTO1lBQzNDLElBQUksQ0FBQ0Usa0JBQWtCLEdBQUdGLE9BQU8sQ0FBQywrQkFBK0I7UUFDckU7UUFDQSxJQUFJLHFDQUFxQ0EsU0FBUztZQUM5QyxJQUFJLENBQUNJLHFCQUFxQixHQUFHSixPQUFPLENBQUMsa0NBQWtDO1FBQzNFO0lBQ0o7SUFDQSxNQUFNTSxZQUFZQyxPQUFPLEVBQUU7UUFDdkI7b0JBQ1ksR0FDWixJQUFJLElBQUksQ0FBQ0wsa0JBQWtCLEtBQUssQ0FBQyxHQUFHO1lBQ2hDLE9BQU9LO1FBQ1gsT0FDSztZQUNELE1BQU1DLGtCQUFrQixNQUFNRDtZQUM5QixJQUFJQyxnQkFBZ0JELE9BQU8sQ0FBQ0UsTUFBTSxHQUFHLElBQUksQ0FBQ1Asa0JBQWtCLEVBQUU7Z0JBQzFELElBQUksQ0FBQ0QsVUFBVSxDQUFDUyxnQkFBZ0IsQ0FBQ2IsWUFBWWMsTUFBTSxDQUFDQyxrQkFBa0IsRUFBRSxDQUFDLDhCQUE4QixFQUFFSixnQkFBZ0JELE9BQU8sQ0FBQ0UsTUFBTSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUNQLGtCQUFrQixDQUFDLENBQUMsQ0FBQztnQkFDekssT0FBT1csUUFBUUMsTUFBTSxDQUFDO1lBQzFCLE9BQ0s7Z0JBQ0QsT0FBT047WUFDWDtRQUNKO0lBQ0o7SUFDQSxNQUFNTyxlQUFlUixPQUFPLEVBQUU7UUFDMUI7b0JBQ1ksR0FDWixJQUFJLElBQUksQ0FBQ0gscUJBQXFCLEtBQUssQ0FBQyxHQUFHO1lBQ25DLE9BQU9HO1FBQ1gsT0FDSztZQUNELE1BQU1DLGtCQUFrQixNQUFNRDtZQUM5QixJQUFJQyxnQkFBZ0JDLE1BQU0sR0FBRyxJQUFJLENBQUNMLHFCQUFxQixFQUFFO2dCQUNyRCxJQUFJLENBQUNILFVBQVUsQ0FBQ1MsZ0JBQWdCLENBQUNiLFlBQVljLE1BQU0sQ0FBQ0Msa0JBQWtCLEVBQUUsQ0FBQyxrQ0FBa0MsRUFBRUosZ0JBQWdCQyxNQUFNLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQ0wscUJBQXFCLENBQUMsQ0FBQyxDQUFDO2dCQUN4SyxPQUFPUyxRQUFRQyxNQUFNLENBQUM7WUFDMUIsT0FDSztnQkFDRCxPQUFPTjtZQUNYO1FBQ0o7SUFDSjtBQUNKO0FBQ0FqQiw0QkFBNEIsR0FBR0c7QUFDL0IsTUFBTUQ7SUFDRk0sWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNuQjtJQUNBZ0IsYUFBYWYsVUFBVSxFQUFFO1FBQ3JCLE9BQU8sSUFBSVAscUJBQXFCLElBQUksQ0FBQ00sT0FBTyxFQUFFQztJQUNsRDtBQUNKO0FBQ0FWLG1DQUFtQyxHQUFHRSw2QkFDdEMsbURBQW1EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNobWl0dC1ndXB0YS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9tYXgtbWVzc2FnZS1zaXplLWZpbHRlci5qcz9hYzc0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIwIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1heE1lc3NhZ2VTaXplRmlsdGVyRmFjdG9yeSA9IGV4cG9ydHMuTWF4TWVzc2FnZVNpemVGaWx0ZXIgPSB2b2lkIDA7XG5jb25zdCBmaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2ZpbHRlclwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY2xhc3MgTWF4TWVzc2FnZVNpemVGaWx0ZXIgZXh0ZW5kcyBmaWx0ZXJfMS5CYXNlRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjYWxsU3RyZWFtKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY2FsbFN0cmVhbSA9IGNhbGxTdHJlYW07XG4gICAgICAgIHRoaXMubWF4U2VuZE1lc3NhZ2VTaXplID0gY29uc3RhbnRzXzEuREVGQVVMVF9NQVhfU0VORF9NRVNTQUdFX0xFTkdUSDtcbiAgICAgICAgdGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUgPSBjb25zdGFudHNfMS5ERUZBVUxUX01BWF9SRUNFSVZFX01FU1NBR0VfTEVOR1RIO1xuICAgICAgICBpZiAoJ2dycGMubWF4X3NlbmRfbWVzc2FnZV9sZW5ndGgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubWF4U2VuZE1lc3NhZ2VTaXplID0gb3B0aW9uc1snZ3JwYy5tYXhfc2VuZF9tZXNzYWdlX2xlbmd0aCddO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZ3JwYy5tYXhfcmVjZWl2ZV9tZXNzYWdlX2xlbmd0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUgPSBvcHRpb25zWydncnBjLm1heF9yZWNlaXZlX21lc3NhZ2VfbGVuZ3RoJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAvKiBBIGNvbmZpZ3VyZWQgc2l6ZSBvZiAtMSBtZWFucyB0aGF0IHRoZXJlIGlzIG5vIGxpbWl0LCBzbyBza2lwIHRoZSBjaGVja1xuICAgICAgICAgKiBlbnRpcmVseSAqL1xuICAgICAgICBpZiAodGhpcy5tYXhTZW5kTWVzc2FnZVNpemUgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmNyZXRlTWVzc2FnZSA9IGF3YWl0IG1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAoY29uY3JldGVNZXNzYWdlLm1lc3NhZ2UubGVuZ3RoID4gdGhpcy5tYXhTZW5kTWVzc2FnZVNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxTdHJlYW0uY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVELCBgU2VudCBtZXNzYWdlIGxhcmdlciB0aGFuIG1heCAoJHtjb25jcmV0ZU1lc3NhZ2UubWVzc2FnZS5sZW5ndGh9IHZzLiAke3RoaXMubWF4U2VuZE1lc3NhZ2VTaXplfSlgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ01lc3NhZ2UgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uY3JldGVNZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgLyogQSBjb25maWd1cmVkIHNpemUgb2YgLTEgbWVhbnMgdGhhdCB0aGVyZSBpcyBubyBsaW1pdCwgc28gc2tpcCB0aGUgY2hlY2tcbiAgICAgICAgICogZW50aXJlbHkgKi9cbiAgICAgICAgaWYgKHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjb25jcmV0ZU1lc3NhZ2UgPSBhd2FpdCBtZXNzYWdlO1xuICAgICAgICAgICAgaWYgKGNvbmNyZXRlTWVzc2FnZS5sZW5ndGggPiB0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFN0cmVhbS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsIGBSZWNlaXZlZCBtZXNzYWdlIGxhcmdlciB0aGFuIG1heCAoJHtjb25jcmV0ZU1lc3NhZ2UubGVuZ3RofSB2cy4gJHt0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZX0pYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdNZXNzYWdlIHRvbyBsYXJnZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNyZXRlTWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTWF4TWVzc2FnZVNpemVGaWx0ZXIgPSBNYXhNZXNzYWdlU2l6ZUZpbHRlcjtcbmNsYXNzIE1heE1lc3NhZ2VTaXplRmlsdGVyRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBjcmVhdGVGaWx0ZXIoY2FsbFN0cmVhbSkge1xuICAgICAgICByZXR1cm4gbmV3IE1heE1lc3NhZ2VTaXplRmlsdGVyKHRoaXMub3B0aW9ucywgY2FsbFN0cmVhbSk7XG4gICAgfVxufVxuZXhwb3J0cy5NYXhNZXNzYWdlU2l6ZUZpbHRlckZhY3RvcnkgPSBNYXhNZXNzYWdlU2l6ZUZpbHRlckZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXgtbWVzc2FnZS1zaXplLWZpbHRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJNYXhNZXNzYWdlU2l6ZUZpbHRlckZhY3RvcnkiLCJNYXhNZXNzYWdlU2l6ZUZpbHRlciIsImZpbHRlcl8xIiwicmVxdWlyZSIsImNvbnN0YW50c18xIiwiQmFzZUZpbHRlciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImNhbGxTdHJlYW0iLCJtYXhTZW5kTWVzc2FnZVNpemUiLCJERUZBVUxUX01BWF9TRU5EX01FU1NBR0VfTEVOR1RIIiwibWF4UmVjZWl2ZU1lc3NhZ2VTaXplIiwiREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSCIsInNlbmRNZXNzYWdlIiwibWVzc2FnZSIsImNvbmNyZXRlTWVzc2FnZSIsImxlbmd0aCIsImNhbmNlbFdpdGhTdGF0dXMiLCJTdGF0dXMiLCJSRVNPVVJDRV9FWEhBVVNURUQiLCJQcm9taXNlIiwicmVqZWN0IiwicmVjZWl2ZU1lc3NhZ2UiLCJjcmVhdGVGaWx0ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/metadata.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Metadata = void 0;\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\nfunction isLegalKey(key) {\n    return LEGAL_KEY_REGEX.test(key);\n}\nfunction isLegalNonBinaryValue(value) {\n    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\nfunction isBinaryKey(key) {\n    return key.endsWith(\"-bin\");\n}\nfunction isCustomMetadata(key) {\n    return !key.startsWith(\"grpc-\");\n}\nfunction normalizeKey(key) {\n    return key.toLowerCase();\n}\nfunction validate(key, value) {\n    if (!isLegalKey(key)) {\n        throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n    }\n    if (value !== null && value !== undefined) {\n        if (isBinaryKey(key)) {\n            if (!Buffer.isBuffer(value)) {\n                throw new Error(\"keys that end with '-bin' must have Buffer values\");\n            }\n        } else {\n            if (Buffer.isBuffer(value)) {\n                throw new Error(\"keys that don't end with '-bin' must have String values\");\n            }\n            if (!isLegalNonBinaryValue(value)) {\n                throw new Error('Metadata string value \"' + value + '\" contains illegal characters');\n            }\n        }\n    }\n}\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */ class Metadata {\n    constructor(options = {}){\n        this.internalRepr = new Map();\n        this.options = options;\n    }\n    /**\n     * Sets the given value for the given key by replacing any other values\n     * associated with that key. Normalizes the key.\n     * @param key The key to whose value should be set.\n     * @param value The value to set. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */ set(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        this.internalRepr.set(key, [\n            value\n        ]);\n    }\n    /**\n     * Adds the given value for the given key by appending to a list of previous\n     * values associated with that key. Normalizes the key.\n     * @param key The key for which a new value should be appended.\n     * @param value The value to add. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */ add(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        const existingValue = this.internalRepr.get(key);\n        if (existingValue === undefined) {\n            this.internalRepr.set(key, [\n                value\n            ]);\n        } else {\n            existingValue.push(value);\n        }\n    }\n    /**\n     * Removes the given key and any associated values. Normalizes the key.\n     * @param key The key whose values should be removed.\n     */ remove(key) {\n        key = normalizeKey(key);\n        // validate(key);\n        this.internalRepr.delete(key);\n    }\n    /**\n     * Gets a list of all values associated with the key. Normalizes the key.\n     * @param key The key whose value should be retrieved.\n     * @return A list of values associated with the given key.\n     */ get(key) {\n        key = normalizeKey(key);\n        // validate(key);\n        return this.internalRepr.get(key) || [];\n    }\n    /**\n     * Gets a plain object mapping each key to the first value associated with it.\n     * This reflects the most common way that people will want to see metadata.\n     * @return A key/value mapping of the metadata.\n     */ getMap() {\n        const result = {};\n        for (const [key, values] of this.internalRepr){\n            if (values.length > 0) {\n                const v = values[0];\n                result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;\n            }\n        }\n        return result;\n    }\n    /**\n     * Clones the metadata object.\n     * @return The newly cloned object.\n     */ clone() {\n        const newMetadata = new Metadata(this.options);\n        const newInternalRepr = newMetadata.internalRepr;\n        for (const [key, value] of this.internalRepr){\n            const clonedValue = value.map((v)=>{\n                if (Buffer.isBuffer(v)) {\n                    return Buffer.from(v);\n                } else {\n                    return v;\n                }\n            });\n            newInternalRepr.set(key, clonedValue);\n        }\n        return newMetadata;\n    }\n    /**\n     * Merges all key-value pairs from a given Metadata object into this one.\n     * If both this object and the given object have values in the same key,\n     * values from the other Metadata object will be appended to this object's\n     * values.\n     * @param other A Metadata object.\n     */ merge(other) {\n        for (const [key, values] of other.internalRepr){\n            const mergedValue = (this.internalRepr.get(key) || []).concat(values);\n            this.internalRepr.set(key, mergedValue);\n        }\n    }\n    setOptions(options) {\n        this.options = options;\n    }\n    getOptions() {\n        return this.options;\n    }\n    /**\n     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n     */ toHttp2Headers() {\n        // NOTE: Node <8.9 formats http2 headers incorrectly.\n        const result = {};\n        for (const [key, values] of this.internalRepr){\n            // We assume that the user's interaction with this object is limited to\n            // through its public API (i.e. keys and values are already validated).\n            result[key] = values.map(bufToString);\n        }\n        return result;\n    }\n    // For compatibility with the other Metadata implementation\n    _getCoreRepresentation() {\n        return this.internalRepr;\n    }\n    /**\n     * This modifies the behavior of JSON.stringify to show an object\n     * representation of the metadata map.\n     */ toJSON() {\n        const result = {};\n        for (const [key, values] of this.internalRepr){\n            result[key] = values;\n        }\n        return result;\n    }\n    /**\n     * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n     * object.\n     * @param headers An IncomingHttpHeaders object.\n     */ static fromHttp2Headers(headers) {\n        const result = new Metadata();\n        for (const key of Object.keys(headers)){\n            // Reserved headers (beginning with `:`) are not valid keys.\n            if (key.charAt(0) === \":\") {\n                continue;\n            }\n            const values = headers[key];\n            try {\n                if (isBinaryKey(key)) {\n                    if (Array.isArray(values)) {\n                        values.forEach((value)=>{\n                            result.add(key, Buffer.from(value, \"base64\"));\n                        });\n                    } else if (values !== undefined) {\n                        if (isCustomMetadata(key)) {\n                            values.split(\",\").forEach((v)=>{\n                                result.add(key, Buffer.from(v.trim(), \"base64\"));\n                            });\n                        } else {\n                            result.add(key, Buffer.from(values, \"base64\"));\n                        }\n                    }\n                } else {\n                    if (Array.isArray(values)) {\n                        values.forEach((value)=>{\n                            result.add(key, value);\n                        });\n                    } else if (values !== undefined) {\n                        result.add(key, values);\n                    }\n                }\n            } catch (error) {\n                const message = `Failed to add metadata entry ${key}: ${values}. ${error.message}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\n                logging_1.log(constants_1.LogVerbosity.ERROR, message);\n            }\n        }\n        return result;\n    }\n}\nexports.Metadata = Metadata;\nconst bufToString = (val)=>{\n    return Buffer.isBuffer(val) ? val.toString(\"base64\") : val;\n}; //# sourceMappingURL=metadata.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWV0YWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdCQUFnQixHQUFHLEtBQUs7QUFDeEIsTUFBTUcsWUFBWUMsbUJBQU9BLENBQUMsMEVBQVc7QUFDckMsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUUsa0JBQWtCO0FBQ3hCLE1BQU1DLCtCQUErQjtBQUNyQyxTQUFTQyxXQUFXQyxHQUFHO0lBQ25CLE9BQU9ILGdCQUFnQkksSUFBSSxDQUFDRDtBQUNoQztBQUNBLFNBQVNFLHNCQUFzQlYsS0FBSztJQUNoQyxPQUFPTSw2QkFBNkJHLElBQUksQ0FBQ1Q7QUFDN0M7QUFDQSxTQUFTVyxZQUFZSCxHQUFHO0lBQ3BCLE9BQU9BLElBQUlJLFFBQVEsQ0FBQztBQUN4QjtBQUNBLFNBQVNDLGlCQUFpQkwsR0FBRztJQUN6QixPQUFPLENBQUNBLElBQUlNLFVBQVUsQ0FBQztBQUMzQjtBQUNBLFNBQVNDLGFBQWFQLEdBQUc7SUFDckIsT0FBT0EsSUFBSVEsV0FBVztBQUMxQjtBQUNBLFNBQVNDLFNBQVNULEdBQUcsRUFBRVIsS0FBSztJQUN4QixJQUFJLENBQUNPLFdBQVdDLE1BQU07UUFDbEIsTUFBTSxJQUFJVSxNQUFNLG1CQUFtQlYsTUFBTTtJQUM3QztJQUNBLElBQUlSLFVBQVUsUUFBUUEsVUFBVW1CLFdBQVc7UUFDdkMsSUFBSVIsWUFBWUgsTUFBTTtZQUNsQixJQUFJLENBQUNZLE9BQU9DLFFBQVEsQ0FBQ3JCLFFBQVE7Z0JBQ3pCLE1BQU0sSUFBSWtCLE1BQU07WUFDcEI7UUFDSixPQUNLO1lBQ0QsSUFBSUUsT0FBT0MsUUFBUSxDQUFDckIsUUFBUTtnQkFDeEIsTUFBTSxJQUFJa0IsTUFBTTtZQUNwQjtZQUNBLElBQUksQ0FB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LElBQUlOLGlCQUFpQkwsTUFBTTs0QkFDdkIyQixPQUFPMEIsS0FBSyxDQUFDLEtBQUtELE9BQU8sQ0FBQyxDQUFDdkI7Z0NBQ3ZCSCxPQUFPUCxHQUFHLENBQUNuQixLQUFLWSxPQUFPa0IsSUFBSSxDQUFDRCxFQUFFeUIsSUFBSSxJQUFJOzRCQUMxQzt3QkFDSixPQUNLOzRCQUNENUIsT0FBT1AsR0FBRyxDQUFDbkIsS0FBS1ksT0FBT2tCLElBQUksQ0FBQ0gsUUFBUTt3QkFDeEM7b0JBQ0o7Z0JBQ0osT0FDSztvQkFDRCxJQUFJdUIsTUFBTUMsT0FBTyxDQUFDeEIsU0FBUzt3QkFDdkJBLE9BQU95QixPQUFPLENBQUMsQ0FBQzVEOzRCQUNaa0MsT0FBT1AsR0FBRyxDQUFDbkIsS0FBS1I7d0JBQ3BCO29CQUNKLE9BQ0ssSUFBSW1DLFdBQVdoQixXQUFXO3dCQUMzQmUsT0FBT1AsR0FBRyxDQUFDbkIsS0FBSzJCO29CQUNwQjtnQkFDSjtZQUNKLEVBQ0EsT0FBTzRCLE9BQU87Z0JBQ1YsTUFBTUMsVUFBVSxDQUFDLDZCQUE2QixFQUFFeEQsSUFBSSxFQUFFLEVBQUUyQixPQUFPLEVBQUUsRUFBRTRCLE1BQU1DLE9BQU8sQ0FBQyx3RUFBd0UsQ0FBQztnQkFDMUo5RCxVQUFVK0QsR0FBRyxDQUFDN0QsWUFBWThELFlBQVksQ0FBQ0MsS0FBSyxFQUFFSDtZQUNsRDtRQUNKO1FBQ0EsT0FBTzlCO0lBQ1g7QUFDSjtBQUNBbkMsZ0JBQWdCLEdBQUdFO0FBQ25CLE1BQU1rRCxjQUFjLENBQUNpQjtJQUNqQixPQUFPaEQsT0FBT0MsUUFBUSxDQUFDK0MsT0FBT0EsSUFBSUMsUUFBUSxDQUFDLFlBQVlEO0FBQzNELEdBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNobWl0dC1ndXB0YS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9tZXRhZGF0YS5qcz8xYzVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1ldGFkYXRhID0gdm9pZCAwO1xuY29uc3QgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgTEVHQUxfS0VZX1JFR0VYID0gL15bMC05YS16Xy4tXSskLztcbmNvbnN0IExFR0FMX05PTl9CSU5BUllfVkFMVUVfUkVHRVggPSAvXlsgLX5dKiQvO1xuZnVuY3Rpb24gaXNMZWdhbEtleShrZXkpIHtcbiAgICByZXR1cm4gTEVHQUxfS0VZX1JFR0VYLnRlc3Qoa2V5KTtcbn1cbmZ1bmN0aW9uIGlzTGVnYWxOb25CaW5hcnlWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBMRUdBTF9OT05fQklOQVJZX1ZBTFVFX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNCaW5hcnlLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5lbmRzV2l0aCgnLWJpbicpO1xufVxuZnVuY3Rpb24gaXNDdXN0b21NZXRhZGF0YShrZXkpIHtcbiAgICByZXR1cm4gIWtleS5zdGFydHNXaXRoKCdncnBjLScpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplS2V5KGtleSkge1xuICAgIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzTGVnYWxLZXkoa2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFkYXRhIGtleSBcIicgKyBrZXkgKyAnXCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc0JpbmFyeUtleShrZXkpKSB7XG4gICAgICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXlzIHRoYXQgZW5kIHdpdGggJy1iaW4nIG11c3QgaGF2ZSBCdWZmZXIgdmFsdWVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXlzIHRoYXQgZG9uJ3QgZW5kIHdpdGggJy1iaW4nIG11c3QgaGF2ZSBTdHJpbmcgdmFsdWVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0xlZ2FsTm9uQmluYXJ5VmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhZGF0YSBzdHJpbmcgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEEgY2xhc3MgZm9yIHN0b3JpbmcgbWV0YWRhdGEuIEtleXMgYXJlIG5vcm1hbGl6ZWQgdG8gbG93ZXJjYXNlIEFTQ0lJLlxuICovXG5jbGFzcyBNZXRhZGF0YSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxSZXByID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBnaXZlbiB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleSBieSByZXBsYWNpbmcgYW55IG90aGVyIHZhbHVlc1xuICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGF0IGtleS4gTm9ybWFsaXplcyB0aGUga2V5LlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byB3aG9zZSB2YWx1ZSBzaG91bGQgYmUgc2V0LlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LiBNdXN0IGJlIGEgYnVmZmVyIGlmIGFuZCBvbmx5XG4gICAgICogICBpZiB0aGUgbm9ybWFsaXplZCBrZXkgZW5kcyB3aXRoICctYmluJy5cbiAgICAgKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcbiAgICAgICAgdmFsaWRhdGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxSZXByLnNldChrZXksIFt2YWx1ZV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleSBieSBhcHBlbmRpbmcgdG8gYSBsaXN0IG9mIHByZXZpb3VzXG4gICAgICogdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGF0IGtleS4gTm9ybWFsaXplcyB0aGUga2V5LlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBmb3Igd2hpY2ggYSBuZXcgdmFsdWUgc2hvdWxkIGJlIGFwcGVuZGVkLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkLiBNdXN0IGJlIGEgYnVmZmVyIGlmIGFuZCBvbmx5XG4gICAgICogICBpZiB0aGUgbm9ybWFsaXplZCBrZXkgZW5kcyB3aXRoICctYmluJy5cbiAgICAgKi9cbiAgICBhZGQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcbiAgICAgICAgdmFsaWRhdGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVmFsdWUgPSB0aGlzLmludGVybmFsUmVwci5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFJlcHIuc2V0KGtleSwgW3ZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleGlzdGluZ1ZhbHVlLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIGtleSBhbmQgYW55IGFzc29jaWF0ZWQgdmFsdWVzLiBOb3JtYWxpemVzIHRoZSBrZXkuXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHdob3NlIHZhbHVlcyBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICByZW1vdmUoa2V5KSB7XG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuICAgICAgICAvLyB2YWxpZGF0ZShrZXkpO1xuICAgICAgICB0aGlzLmludGVybmFsUmVwci5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2YgYWxsIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGtleS4gTm9ybWFsaXplcyB0aGUga2V5LlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB3aG9zZSB2YWx1ZSBzaG91bGQgYmUgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4gQSBsaXN0IG9mIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGtleS5cbiAgICAgKi9cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuICAgICAgICAvLyB2YWxpZGF0ZShrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFJlcHIuZ2V0KGtleSkgfHwgW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBwbGFpbiBvYmplY3QgbWFwcGluZyBlYWNoIGtleSB0byB0aGUgZmlyc3QgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICAgICAqIFRoaXMgcmVmbGVjdHMgdGhlIG1vc3QgY29tbW9uIHdheSB0aGF0IHBlb3BsZSB3aWxsIHdhbnQgdG8gc2VlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm4gQSBrZXkvdmFsdWUgbWFwcGluZyBvZiB0aGUgbWV0YWRhdGEuXG4gICAgICovXG4gICAgZ2V0TWFwKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIHRoaXMuaW50ZXJuYWxSZXByKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gdmFsdWVzWzBdO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gQnVmZmVyLmlzQnVmZmVyKHYpID8gQnVmZmVyLmZyb20odikgOiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lcyB0aGUgbWV0YWRhdGEgb2JqZWN0LlxuICAgICAqIEByZXR1cm4gVGhlIG5ld2x5IGNsb25lZCBvYmplY3QuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IG5ld01ldGFkYXRhID0gbmV3IE1ldGFkYXRhKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG5ld0ludGVybmFsUmVwciA9IG5ld01ldGFkYXRhLmludGVybmFsUmVwcjtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5pbnRlcm5hbFJlcHIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lZFZhbHVlID0gdmFsdWUubWFwKCh2KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5ld0ludGVybmFsUmVwci5zZXQoa2V5LCBjbG9uZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld01ldGFkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgYWxsIGtleS12YWx1ZSBwYWlycyBmcm9tIGEgZ2l2ZW4gTWV0YWRhdGEgb2JqZWN0IGludG8gdGhpcyBvbmUuXG4gICAgICogSWYgYm90aCB0aGlzIG9iamVjdCBhbmQgdGhlIGdpdmVuIG9iamVjdCBoYXZlIHZhbHVlcyBpbiB0aGUgc2FtZSBrZXksXG4gICAgICogdmFsdWVzIGZyb20gdGhlIG90aGVyIE1ldGFkYXRhIG9iamVjdCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoaXMgb2JqZWN0J3NcbiAgICAgKiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIG90aGVyIEEgTWV0YWRhdGEgb2JqZWN0LlxuICAgICAqL1xuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVzXSBvZiBvdGhlci5pbnRlcm5hbFJlcHIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZFZhbHVlID0gKHRoaXMuaW50ZXJuYWxSZXByLmdldChrZXkpIHx8IFtdKS5jb25jYXQodmFsdWVzKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxSZXByLnNldChrZXksIG1lcmdlZFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgZ2V0T3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPdXRnb2luZ0h0dHBIZWFkZXJzIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHdpdGggdGhlIGh0dHAyIEFQSS5cbiAgICAgKi9cbiAgICB0b0h0dHAySGVhZGVycygpIHtcbiAgICAgICAgLy8gTk9URTogTm9kZSA8OC45IGZvcm1hdHMgaHR0cDIgaGVhZGVycyBpbmNvcnJlY3RseS5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVzXSBvZiB0aGlzLmludGVybmFsUmVwcikge1xuICAgICAgICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgdGhlIHVzZXIncyBpbnRlcmFjdGlvbiB3aXRoIHRoaXMgb2JqZWN0IGlzIGxpbWl0ZWQgdG9cbiAgICAgICAgICAgIC8vIHRocm91Z2ggaXRzIHB1YmxpYyBBUEkgKGkuZS4ga2V5cyBhbmQgdmFsdWVzIGFyZSBhbHJlYWR5IHZhbGlkYXRlZCkuXG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlcy5tYXAoYnVmVG9TdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEZvciBjb21wYXRpYmlsaXR5IHdpdGggdGhlIG90aGVyIE1ldGFkYXRhIGltcGxlbWVudGF0aW9uXG4gICAgX2dldENvcmVSZXByZXNlbnRhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxSZXByO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1vZGlmaWVzIHRoZSBiZWhhdmlvciBvZiBKU09OLnN0cmluZ2lmeSB0byBzaG93IGFuIG9iamVjdFxuICAgICAqIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtZXRhZGF0YSBtYXAuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIHRoaXMuaW50ZXJuYWxSZXByKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IE1ldGFkYXRhIG9iamVjdCBiYXNlZCBmaWVsZHMgaW4gYSBnaXZlbiBJbmNvbWluZ0h0dHBIZWFkZXJzXG4gICAgICogb2JqZWN0LlxuICAgICAqIEBwYXJhbSBoZWFkZXJzIEFuIEluY29taW5nSHR0cEhlYWRlcnMgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSHR0cDJIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1ldGFkYXRhKCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgICAvLyBSZXNlcnZlZCBoZWFkZXJzIChiZWdpbm5pbmcgd2l0aCBgOmApIGFyZSBub3QgdmFsaWQga2V5cy5cbiAgICAgICAgICAgIGlmIChrZXkuY2hhckF0KDApID09PSAnOicpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQmluYXJ5S2V5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIEJ1ZmZlci5mcm9tKHZhbHVlLCAnYmFzZTY0JykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0N1c3RvbU1ldGFkYXRhKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuc3BsaXQoJywnKS5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoa2V5LCBCdWZmZXIuZnJvbSh2LnRyaW0oKSwgJ2Jhc2U2NCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoa2V5LCBCdWZmZXIuZnJvbSh2YWx1ZXMsICdiYXNlNjQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYEZhaWxlZCB0byBhZGQgbWV0YWRhdGEgZW50cnkgJHtrZXl9OiAke3ZhbHVlc30uICR7ZXJyb3IubWVzc2FnZX0uIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjLW5vZGUvaXNzdWVzLzExNzNgO1xuICAgICAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuTWV0YWRhdGEgPSBNZXRhZGF0YTtcbmNvbnN0IGJ1ZlRvU3RyaW5nID0gKHZhbCkgPT4ge1xuICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIodmFsKSA/IHZhbC50b1N0cmluZygnYmFzZTY0JykgOiB2YWw7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTWV0YWRhdGEiLCJsb2dnaW5nXzEiLCJyZXF1aXJlIiwiY29uc3RhbnRzXzEiLCJMRUdBTF9LRVlfUkVHRVgiLCJMRUdBTF9OT05fQklOQVJZX1ZBTFVFX1JFR0VYIiwiaXNMZWdhbEtleSIsImtleSIsInRlc3QiLCJpc0xlZ2FsTm9uQmluYXJ5VmFsdWUiLCJpc0JpbmFyeUtleSIsImVuZHNXaXRoIiwiaXNDdXN0b21NZXRhZGF0YSIsInN0YXJ0c1dpdGgiLCJub3JtYWxpemVLZXkiLCJ0b0xvd2VyQ2FzZSIsInZhbGlkYXRlIiwiRXJyb3IiLCJ1bmRlZmluZWQiLCJCdWZmZXIiLCJpc0J1ZmZlciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImludGVybmFsUmVwciIsIk1hcCIsInNldCIsImFkZCIsImV4aXN0aW5nVmFsdWUiLCJnZXQiLCJwdXNoIiwicmVtb3ZlIiwiZGVsZXRlIiwiZ2V0TWFwIiwicmVzdWx0IiwidmFsdWVzIiwibGVuZ3RoIiwidiIsImZyb20iLCJjbG9uZSIsIm5ld01ldGFkYXRhIiwibmV3SW50ZXJuYWxSZXByIiwiY2xvbmVkVmFsdWUiLCJtYXAiLCJtZXJnZSIsIm90aGVyIiwibWVyZ2VkVmFsdWUiLCJjb25jYXQiLCJzZXRPcHRpb25zIiwiZ2V0T3B0aW9ucyIsInRvSHR0cDJIZWFkZXJzIiwiYnVmVG9TdHJpbmciLCJfZ2V0Q29yZVJlcHJlc2VudGF0aW9uIiwidG9KU09OIiwiZnJvbUh0dHAySGVhZGVycyIsImhlYWRlcnMiLCJrZXlzIiwiY2hhckF0IiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsInNwbGl0IiwidHJpbSIsImVycm9yIiwibWVzc2FnZSIsImxvZyIsIkxvZ1ZlcmJvc2l0eSIsIkVSUk9SIiwidmFsIiwidG9TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/picker.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.QueuePicker = exports.UnavailablePicker = exports.PickResultType = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nvar PickResultType;\n(function(PickResultType) {\n    PickResultType[PickResultType[\"COMPLETE\"] = 0] = \"COMPLETE\";\n    PickResultType[PickResultType[\"QUEUE\"] = 1] = \"QUEUE\";\n    PickResultType[PickResultType[\"TRANSIENT_FAILURE\"] = 2] = \"TRANSIENT_FAILURE\";\n    PickResultType[PickResultType[\"DROP\"] = 3] = \"DROP\";\n})(PickResultType = exports.PickResultType || (exports.PickResultType = {}));\n/**\n * A standard picker representing a load balancer in the TRANSIENT_FAILURE\n * state. Always responds to every pick request with an UNAVAILABLE status.\n */ class UnavailablePicker {\n    constructor(status){\n        if (status !== undefined) {\n            this.status = status;\n        } else {\n            this.status = {\n                code: constants_1.Status.UNAVAILABLE,\n                details: \"No connection established\",\n                metadata: new metadata_1.Metadata()\n            };\n        }\n    }\n    pick(pickArgs) {\n        return {\n            pickResultType: PickResultType.TRANSIENT_FAILURE,\n            subchannel: null,\n            status: this.status,\n            extraFilterFactories: [],\n            onCallStarted: null\n        };\n    }\n}\nexports.UnavailablePicker = UnavailablePicker;\n/**\n * A standard picker representing a load balancer in the IDLE or CONNECTING\n * state. Always responds to every pick request with a QUEUE pick result\n * indicating that the pick should be tried again with the next `Picker`. Also\n * reports back to the load balancer that a connection should be established\n * once any pick is attempted.\n */ class QueuePicker {\n    // Constructed with a load balancer. Calls exitIdle on it the first time pick is called\n    constructor(loadBalancer){\n        this.loadBalancer = loadBalancer;\n        this.calledExitIdle = false;\n    }\n    pick(pickArgs) {\n        if (!this.calledExitIdle) {\n            process.nextTick(()=>{\n                this.loadBalancer.exitIdle();\n            });\n            this.calledExitIdle = true;\n        }\n        return {\n            pickResultType: PickResultType.QUEUE,\n            subchannel: null,\n            status: null,\n            extraFilterFactories: [],\n            onCallStarted: null\n        };\n    }\n}\nexports.QueuePicker = QueuePicker; //# sourceMappingURL=picker.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcGlja2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQkFBbUIsR0FBR0EseUJBQXlCLEdBQUdBLHNCQUFzQixHQUFHLEtBQUs7QUFDaEYsTUFBTUssYUFBYUMsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsSUFBSUY7QUFDSCxVQUFVQSxjQUFjO0lBQ3JCQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxXQUFXLEdBQUcsRUFBRSxHQUFHO0lBQ2pEQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQzlDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxvQkFBb0IsR0FBRyxFQUFFLEdBQUc7SUFDMURBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7QUFDakQsR0FBR0EsaUJBQWlCSixRQUFRSSxjQUFjLElBQUtKLENBQUFBLHNCQUFzQixHQUFHLENBQUM7QUFDekU7OztDQUdDLEdBQ0QsTUFBTUc7SUFDRkssWUFBWUMsTUFBTSxDQUFFO1FBQ2hCLElBQUlBLFdBQVdDLFdBQVc7WUFDdEIsSUFBSSxDQUFDRCxNQUFNLEdBQUdBO1FBQ2xCLE9BQ0s7WUFDRCxJQUFJLENBQUNBLE1BQU0sR0FBRztnQkFDVkUsTUFBTUosWUFBWUssTUFBTSxDQUFDQyxXQUFXO2dCQUNwQ0MsU0FBUztnQkFDVEMsVUFBVSxJQUFJVixXQUFXVyxRQUFRO1lBQ3JDO1FBQ0o7SUFDSjtJQUNBQyxLQUFLQyxRQUFRLEVBQUU7UUFDWCxPQUFPO1lBQ0hDLGdCQUFnQmYsZUFBZWdCLGlCQUFpQjtZQUNoREMsWUFBWTtZQUNaWixRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQmEsc0JBQXNCLEVBQUU7WUFDeEJDLGVBQWU7UUFDbkI7SUFDSjtBQUNKO0FBQ0F2Qix5QkFBeUIsR0FBR0c7QUFDNUI7Ozs7OztDQU1DLEdBQ0QsTUFBTUQ7SUFDRix1RkFBdUY7SUFDdkZNLFlBQVlnQixZQUFZLENBQUU7UUFDdEIsSUFBSSxDQUFDQSxZQUFZLEdBQUdBO1FBQ3BCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO0lBQzFCO0lBQ0FSLEtBQUtDLFFBQVEsRUFBRTtRQUNYLElBQUksQ0FBQyxJQUFJLENBQUNPLGNBQWMsRUFBRTtZQUN0QkMsUUFBUUMsUUFBUSxDQUFDO2dCQUNiLElBQUksQ0FBQ0gsWUFBWSxDQUFDSSxRQUFRO1lBQzlCO1lBQ0EsSUFBSSxDQUFDSCxjQUFjLEdBQUc7UUFDMUI7UUFDQSxPQUFPO1lBQ0hOLGdCQUFnQmYsZUFBZXlCLEtBQUs7WUFDcENSLFlBQVk7WUFDWlosUUFBUTtZQUNSYSxzQkFBc0IsRUFBRTtZQUN4QkMsZUFBZTtRQUNuQjtJQUNKO0FBQ0o7QUFDQXZCLG1CQUFtQixHQUFHRSxhQUN0QixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc2htaXR0LWd1cHRhLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3BpY2tlci5qcz81N2U2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlF1ZXVlUGlja2VyID0gZXhwb3J0cy5VbmF2YWlsYWJsZVBpY2tlciA9IGV4cG9ydHMuUGlja1Jlc3VsdFR5cGUgPSB2b2lkIDA7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbnZhciBQaWNrUmVzdWx0VHlwZTtcbihmdW5jdGlvbiAoUGlja1Jlc3VsdFR5cGUpIHtcbiAgICBQaWNrUmVzdWx0VHlwZVtQaWNrUmVzdWx0VHlwZVtcIkNPTVBMRVRFXCJdID0gMF0gPSBcIkNPTVBMRVRFXCI7XG4gICAgUGlja1Jlc3VsdFR5cGVbUGlja1Jlc3VsdFR5cGVbXCJRVUVVRVwiXSA9IDFdID0gXCJRVUVVRVwiO1xuICAgIFBpY2tSZXN1bHRUeXBlW1BpY2tSZXN1bHRUeXBlW1wiVFJBTlNJRU5UX0ZBSUxVUkVcIl0gPSAyXSA9IFwiVFJBTlNJRU5UX0ZBSUxVUkVcIjtcbiAgICBQaWNrUmVzdWx0VHlwZVtQaWNrUmVzdWx0VHlwZVtcIkRST1BcIl0gPSAzXSA9IFwiRFJPUFwiO1xufSkoUGlja1Jlc3VsdFR5cGUgPSBleHBvcnRzLlBpY2tSZXN1bHRUeXBlIHx8IChleHBvcnRzLlBpY2tSZXN1bHRUeXBlID0ge30pKTtcbi8qKlxuICogQSBzdGFuZGFyZCBwaWNrZXIgcmVwcmVzZW50aW5nIGEgbG9hZCBiYWxhbmNlciBpbiB0aGUgVFJBTlNJRU5UX0ZBSUxVUkVcbiAqIHN0YXRlLiBBbHdheXMgcmVzcG9uZHMgdG8gZXZlcnkgcGljayByZXF1ZXN0IHdpdGggYW4gVU5BVkFJTEFCTEUgc3RhdHVzLlxuICovXG5jbGFzcyBVbmF2YWlsYWJsZVBpY2tlciB7XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzKSB7XG4gICAgICAgIGlmIChzdGF0dXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogJ05vIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQnLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwaWNrKHBpY2tBcmdzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwaWNrUmVzdWx0VHlwZTogUGlja1Jlc3VsdFR5cGUuVFJBTlNJRU5UX0ZBSUxVUkUsXG4gICAgICAgICAgICBzdWJjaGFubmVsOiBudWxsLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIGV4dHJhRmlsdGVyRmFjdG9yaWVzOiBbXSxcbiAgICAgICAgICAgIG9uQ2FsbFN0YXJ0ZWQ6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5VbmF2YWlsYWJsZVBpY2tlciA9IFVuYXZhaWxhYmxlUGlja2VyO1xuLyoqXG4gKiBBIHN0YW5kYXJkIHBpY2tlciByZXByZXNlbnRpbmcgYSBsb2FkIGJhbGFuY2VyIGluIHRoZSBJRExFIG9yIENPTk5FQ1RJTkdcbiAqIHN0YXRlLiBBbHdheXMgcmVzcG9uZHMgdG8gZXZlcnkgcGljayByZXF1ZXN0IHdpdGggYSBRVUVVRSBwaWNrIHJlc3VsdFxuICogaW5kaWNhdGluZyB0aGF0IHRoZSBwaWNrIHNob3VsZCBiZSB0cmllZCBhZ2FpbiB3aXRoIHRoZSBuZXh0IGBQaWNrZXJgLiBBbHNvXG4gKiByZXBvcnRzIGJhY2sgdG8gdGhlIGxvYWQgYmFsYW5jZXIgdGhhdCBhIGNvbm5lY3Rpb24gc2hvdWxkIGJlIGVzdGFibGlzaGVkXG4gKiBvbmNlIGFueSBwaWNrIGlzIGF0dGVtcHRlZC5cbiAqL1xuY2xhc3MgUXVldWVQaWNrZXIge1xuICAgIC8vIENvbnN0cnVjdGVkIHdpdGggYSBsb2FkIGJhbGFuY2VyLiBDYWxscyBleGl0SWRsZSBvbiBpdCB0aGUgZmlyc3QgdGltZSBwaWNrIGlzIGNhbGxlZFxuICAgIGNvbnN0cnVjdG9yKGxvYWRCYWxhbmNlcikge1xuICAgICAgICB0aGlzLmxvYWRCYWxhbmNlciA9IGxvYWRCYWxhbmNlcjtcbiAgICAgICAgdGhpcy5jYWxsZWRFeGl0SWRsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBwaWNrKHBpY2tBcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWxsZWRFeGl0SWRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkQmFsYW5jZXIuZXhpdElkbGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jYWxsZWRFeGl0SWRsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBpY2tSZXN1bHRUeXBlOiBQaWNrUmVzdWx0VHlwZS5RVUVVRSxcbiAgICAgICAgICAgIHN1YmNoYW5uZWw6IG51bGwsXG4gICAgICAgICAgICBzdGF0dXM6IG51bGwsXG4gICAgICAgICAgICBleHRyYUZpbHRlckZhY3RvcmllczogW10sXG4gICAgICAgICAgICBvbkNhbGxTdGFydGVkOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuUXVldWVQaWNrZXIgPSBRdWV1ZVBpY2tlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBpY2tlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJRdWV1ZVBpY2tlciIsIlVuYXZhaWxhYmxlUGlja2VyIiwiUGlja1Jlc3VsdFR5cGUiLCJtZXRhZGF0YV8xIiwicmVxdWlyZSIsImNvbnN0YW50c18xIiwiY29uc3RydWN0b3IiLCJzdGF0dXMiLCJ1bmRlZmluZWQiLCJjb2RlIiwiU3RhdHVzIiwiVU5BVkFJTEFCTEUiLCJkZXRhaWxzIiwibWV0YWRhdGEiLCJNZXRhZGF0YSIsInBpY2siLCJwaWNrQXJncyIsInBpY2tSZXN1bHRUeXBlIiwiVFJBTlNJRU5UX0ZBSUxVUkUiLCJzdWJjaGFubmVsIiwiZXh0cmFGaWx0ZXJGYWN0b3JpZXMiLCJvbkNhbGxTdGFydGVkIiwibG9hZEJhbGFuY2VyIiwiY2FsbGVkRXhpdElkbGUiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJleGl0SWRsZSIsIlFVRVVFIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-dns.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = void 0;\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst dns = __webpack_require__(/*! dns */ \"dns\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst TRACER_NAME = \"dns_resolver\";\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */ const DEFAULT_PORT = 443;\nconst DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30000;\nconst resolveTxtPromise = util.promisify(dns.resolveTxt);\nconst dnsLookupPromise = util.promisify(dns.lookup);\n/**\n * Merge any number of arrays into a single alternating array\n * @param arrays\n */ function mergeArrays(...arrays) {\n    const result = [];\n    for(let i = 0; i < Math.max.apply(null, arrays.map((array)=>array.length)); i++){\n        for (const array of arrays){\n            if (i < array.length) {\n                result.push(array[i]);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */ class DnsResolver {\n    constructor(target, listener, channelOptions){\n        var _a, _b, _c;\n        this.target = target;\n        this.listener = listener;\n        this.pendingLookupPromise = null;\n        this.pendingTxtPromise = null;\n        this.latestLookupResult = null;\n        this.latestServiceConfig = null;\n        this.latestServiceConfigError = null;\n        this.continueResolving = false;\n        this.isNextResolutionTimerRunning = false;\n        trace(\"Resolver constructed for target \" + uri_parser_1.uriToString(target));\n        const hostPort = uri_parser_1.splitHostPort(target.path);\n        if (hostPort === null) {\n            this.ipResult = null;\n            this.dnsHostname = null;\n            this.port = null;\n        } else {\n            if (net_1.isIPv4(hostPort.host) || net_1.isIPv6(hostPort.host)) {\n                this.ipResult = [\n                    {\n                        host: hostPort.host,\n                        port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT\n                    }\n                ];\n                this.dnsHostname = null;\n                this.port = null;\n            } else {\n                this.ipResult = null;\n                this.dnsHostname = hostPort.host;\n                this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : DEFAULT_PORT;\n            }\n        }\n        this.percentage = Math.random() * 100;\n        this.defaultResolutionError = {\n            code: constants_1.Status.UNAVAILABLE,\n            details: `Name resolution failed for target ${uri_parser_1.uriToString(this.target)}`,\n            metadata: new metadata_1.Metadata()\n        };\n        const backoffOptions = {\n            initialDelay: channelOptions[\"grpc.initial_reconnect_backoff_ms\"],\n            maxDelay: channelOptions[\"grpc.max_reconnect_backoff_ms\"]\n        };\n        this.backoff = new backoff_timeout_1.BackoffTimeout(()=>{\n            if (this.continueResolving) {\n                this.startResolutionWithBackoff();\n            }\n        }, backoffOptions);\n        this.backoff.unref();\n        this.minTimeBetweenResolutionsMs = (_c = channelOptions[\"grpc.dns_min_time_between_resolutions_ms\"]) !== null && _c !== void 0 ? _c : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;\n        this.nextResolutionTimer = setTimeout(()=>{}, 0);\n        clearTimeout(this.nextResolutionTimer);\n    }\n    /**\n     * If the target is an IP address, just provide that address as a result.\n     * Otherwise, initiate A, AAAA, and TXT lookups\n     */ startResolution() {\n        if (this.ipResult !== null) {\n            trace(\"Returning IP address for target \" + uri_parser_1.uriToString(this.target));\n            setImmediate(()=>{\n                this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});\n            });\n            this.backoff.stop();\n            this.backoff.reset();\n            return;\n        }\n        if (this.dnsHostname === null) {\n            trace(\"Failed to parse DNS address \" + uri_parser_1.uriToString(this.target));\n            setImmediate(()=>{\n                this.listener.onError({\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse DNS address ${uri_parser_1.uriToString(this.target)}`,\n                    metadata: new metadata_1.Metadata()\n                });\n            });\n            this.stopNextResolutionTimer();\n        } else {\n            if (this.pendingLookupPromise !== null) {\n                return;\n            }\n            trace(\"Looking up DNS hostname \" + this.dnsHostname);\n            /* We clear out latestLookupResult here to ensure that it contains the\n             * latest result since the last time we started resolving. That way, the\n             * TXT resolution handler can use it, but only if it finishes second. We\n             * don't clear out any previous service config results because it's\n             * better to use a service config that's slightly out of date than to\n             * revert to an effectively blank one. */ this.latestLookupResult = null;\n            const hostname = this.dnsHostname;\n            /* We lookup both address families here and then split them up later\n             * because when looking up a single family, dns.lookup outputs an error\n             * if the name exists but there are no records for that family, and that\n             * error is indistinguishable from other kinds of errors */ this.pendingLookupPromise = dnsLookupPromise(hostname, {\n                all: true\n            });\n            this.pendingLookupPromise.then((addressList)=>{\n                this.pendingLookupPromise = null;\n                this.backoff.reset();\n                this.backoff.stop();\n                const ip4Addresses = addressList.filter((addr)=>addr.family === 4);\n                const ip6Addresses = addressList.filter((addr)=>addr.family === 6);\n                this.latestLookupResult = mergeArrays(ip6Addresses, ip4Addresses).map((addr)=>({\n                        host: addr.address,\n                        port: +this.port\n                    }));\n                const allAddressesString = \"[\" + this.latestLookupResult.map((addr)=>addr.host + \":\" + addr.port).join(\",\") + \"]\";\n                trace(\"Resolved addresses for target \" + uri_parser_1.uriToString(this.target) + \": \" + allAddressesString);\n                if (this.latestLookupResult.length === 0) {\n                    this.listener.onError(this.defaultResolutionError);\n                    return;\n                }\n                /* If the TXT lookup has not yet finished, both of the last two\n                 * arguments will be null, which is the equivalent of getting an\n                 * empty TXT response. When the TXT lookup does finish, its handler\n                 * can update the service config by using the same address list */ this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n            }, (err)=>{\n                trace(\"Resolution error for target \" + uri_parser_1.uriToString(this.target) + \": \" + err.message);\n                this.pendingLookupPromise = null;\n                this.stopNextResolutionTimer();\n                this.listener.onError(this.defaultResolutionError);\n            });\n            /* If there already is a still-pending TXT resolution, we can just use\n             * that result when it comes in */ if (this.pendingTxtPromise === null) {\n                /* We handle the TXT query promise differently than the others because\n                 * the name resolution attempt as a whole is a success even if the TXT\n                 * lookup fails */ this.pendingTxtPromise = resolveTxtPromise(hostname);\n                this.pendingTxtPromise.then((txtRecord)=>{\n                    this.pendingTxtPromise = null;\n                    try {\n                        this.latestServiceConfig = service_config_1.extractAndSelectServiceConfig(txtRecord, this.percentage);\n                    } catch (err) {\n                        this.latestServiceConfigError = {\n                            code: constants_1.Status.UNAVAILABLE,\n                            details: \"Parsing service config failed\",\n                            metadata: new metadata_1.Metadata()\n                        };\n                    }\n                    if (this.latestLookupResult !== null) {\n                        /* We rely here on the assumption that calling this function with\n                         * identical parameters will be essentialy idempotent, and calling\n                         * it with the same address list and a different service config\n                         * should result in a fast and seamless switchover. */ this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n                    }\n                }, (err)=>{\n                /* If TXT lookup fails we should do nothing, which means that we\n                     * continue to use the result of the most recent successful lookup,\n                     * or the default null config object if there has never been a\n                     * successful lookup. We do not set the latestServiceConfigError\n                     * here because that is specifically used for response validation\n                     * errors. We still need to handle this error so that it does not\n                     * bubble up as an unhandled promise rejection. */ });\n            }\n        }\n    }\n    startNextResolutionTimer() {\n        var _a, _b;\n        clearTimeout(this.nextResolutionTimer);\n        this.nextResolutionTimer = (_b = (_a = setTimeout(()=>{\n            this.stopNextResolutionTimer();\n            if (this.continueResolving) {\n                this.startResolutionWithBackoff();\n            }\n        }, this.minTimeBetweenResolutionsMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.isNextResolutionTimerRunning = true;\n    }\n    stopNextResolutionTimer() {\n        clearTimeout(this.nextResolutionTimer);\n        this.isNextResolutionTimerRunning = false;\n    }\n    startResolutionWithBackoff() {\n        if (this.pendingLookupPromise === null) {\n            this.continueResolving = false;\n            this.startResolution();\n            this.backoff.runOnce();\n            this.startNextResolutionTimer();\n        }\n    }\n    updateResolution() {\n        /* If there is a pending lookup, just let it finish. Otherwise, if the\n         * nextResolutionTimer or backoff timer is running, set the\n         * continueResolving flag to resolve when whichever of those timers\n         * fires. Otherwise, start resolving immediately. */ if (this.pendingLookupPromise === null) {\n            if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {\n                this.continueResolving = true;\n            } else {\n                this.startResolutionWithBackoff();\n            }\n        }\n    }\n    destroy() {\n        this.continueResolving = false;\n        this.backoff.stop();\n        this.stopNextResolutionTimer();\n    }\n    /**\n     * Get the default authority for the given target. For IP targets, that is\n     * the IP address. For DNS targets, it is the hostname.\n     * @param target\n     */ static getDefaultAuthority(target) {\n        return target.path;\n    }\n}\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */ function setup() {\n    resolver_1.registerResolver(\"dns\", DnsResolver);\n    resolver_1.registerDefaultScheme(\"dns\");\n}\nexports.setup = setup; //# sourceMappingURL=resolver-dns.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItZG5zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGFBQWEsR0FBRyxLQUFLO0FBQ3JCLE1BQU1HLGFBQWFDLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1DLE1BQU1ELG1CQUFPQSxDQUFDLGdCQUFLO0FBQ3pCLE1BQU1FLE9BQU9GLG1CQUFPQSxDQUFDLGtCQUFNO0FBQzNCLE1BQU1HLG1CQUFtQkgsbUJBQU9BLENBQUMsd0ZBQWtCO0FBQ25ELE1BQU1JLGNBQWNKLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1LLGFBQWFMLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1NLFVBQVVOLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1PLGNBQWNQLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1RLGVBQWVSLG1CQUFPQSxDQUFDLGdGQUFjO0FBQzNDLE1BQU1TLFFBQVFULG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCLE1BQU1VLG9CQUFvQlYsbUJBQU9BLENBQUMsMEZBQW1CO0FBQ3JELE1BQU1XLGNBQWM7QUFDcEIsU0FBU0MsTUFBTUMsSUFBSTtJQUNmUCxRQUFRTSxLQUFLLENBQUNMLFlBQVlPLFlBQVksQ0FBQ0MsS0FBSyxFQUFFSixhQUFhRTtBQUMvRDtBQUNBOztDQUVDLEdBQ0QsTUFBTUcsZUFBZTtBQUNyQixNQUFNQywwQ0FBMEM7QUFDaEQsTUFBTUMsb0JBQW9CaEIsS0FBS2lCLFNBQVMsQ0FBQ2xCLElBQUltQixVQUFVO0FBQ3ZELE1BQU1DLG1CQUFtQm5CLEtBQUtpQixTQUFTLENBQUNsQixJQUFJcUIsTUFBTTtBQUNsRDs7O0NBR0MsR0FDRCxTQUFTQyxZQUFZLEdBQUdDLE1BQU07SUFDMUIsTUFBTUMsU0FBUyxFQUFF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UUFDekIsSUFBSSxDQUFDd0IsT0FBTyxDQUFDVyxJQUFJO1FBQ2pCLElBQUksQ0FBQ0csdUJBQXVCO0lBQ2hDO0lBQ0E7Ozs7S0FJQyxHQUNELE9BQU91QixvQkFBb0J4RSxNQUFNLEVBQUU7UUFDL0IsT0FBT0EsT0FBT2dCLElBQUk7SUFDdEI7QUFDSjtBQUNBOzs7Q0FHQyxHQUNELFNBQVN0RDtJQUNMQyxXQUFXOEcsZ0JBQWdCLENBQUMsT0FBTzNFO0lBQ25DbkMsV0FBVytHLHFCQUFxQixDQUFDO0FBQ3JDO0FBQ0FsSCxhQUFhLEdBQUdFLE9BQ2hCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2FzaG1pdHQtZ3VwdGEvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItZG5zLmpzPzcxZTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXR1cCA9IHZvaWQgMDtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IGRucyA9IHJlcXVpcmUoXCJkbnNcIik7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBzZXJ2aWNlX2NvbmZpZ18xID0gcmVxdWlyZShcIi4vc2VydmljZS1jb25maWdcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzIgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3QgYmFja29mZl90aW1lb3V0XzEgPSByZXF1aXJlKFwiLi9iYWNrb2ZmLXRpbWVvdXRcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdkbnNfcmVzb2x2ZXInO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzIuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IFRDUCBwb3J0IHRvIGNvbm5lY3QgdG8gaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIGluIHRoZSB0YXJnZXQuXG4gKi9cbmNvbnN0IERFRkFVTFRfUE9SVCA9IDQ0MztcbmNvbnN0IERFRkFVTFRfTUlOX1RJTUVfQkVUV0VFTl9SRVNPTFVUSU9OU19NUyA9IDMwMDAwO1xuY29uc3QgcmVzb2x2ZVR4dFByb21pc2UgPSB1dGlsLnByb21pc2lmeShkbnMucmVzb2x2ZVR4dCk7XG5jb25zdCBkbnNMb29rdXBQcm9taXNlID0gdXRpbC5wcm9taXNpZnkoZG5zLmxvb2t1cCk7XG4vKipcbiAqIE1lcmdlIGFueSBudW1iZXIgb2YgYXJyYXlzIGludG8gYSBzaW5nbGUgYWx0ZXJuYXRpbmcgYXJyYXlcbiAqIEBwYXJhbSBhcnJheXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2VBcnJheXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPFxuICAgICAgICBNYXRoLm1heC5hcHBseShudWxsLCBhcnJheXMubWFwKChhcnJheSkgPT4gYXJyYXkubGVuZ3RoKSk7IGkrKykge1xuICAgICAgICBmb3IgKGNvbnN0IGFycmF5IG9mIGFycmF5cykge1xuICAgICAgICAgICAgaWYgKGkgPCBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUmVzb2x2ZXIgaW1wbGVtZW50YXRpb24gdGhhdCBoYW5kbGVzIEROUyBuYW1lcyBhbmQgSVAgYWRkcmVzc2VzLlxuICovXG5jbGFzcyBEbnNSZXNvbHZlciB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBsaXN0ZW5lciwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdUeHRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXRlc3RMb29rdXBSZXN1bHQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWcgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWdFcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRyYWNlKCdSZXNvbHZlciBjb25zdHJ1Y3RlZCBmb3IgdGFyZ2V0ICcgKyB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcodGFyZ2V0KSk7XG4gICAgICAgIGNvbnN0IGhvc3RQb3J0ID0gdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQodGFyZ2V0LnBhdGgpO1xuICAgICAgICBpZiAoaG9zdFBvcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaXBSZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5kbnNIb3N0bmFtZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBvcnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5ldF8xLmlzSVB2NChob3N0UG9ydC5ob3N0KSB8fCBuZXRfMS5pc0lQdjYoaG9zdFBvcnQuaG9zdCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlwUmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBob3N0UG9ydC5ob3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogKF9hID0gaG9zdFBvcnQucG9ydCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogREVGQVVMVF9QT1JULFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgdGhpcy5kbnNIb3N0bmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaXBSZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZG5zSG9zdG5hbWUgPSBob3N0UG9ydC5ob3N0O1xuICAgICAgICAgICAgICAgIHRoaXMucG9ydCA9IChfYiA9IGhvc3RQb3J0LnBvcnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IERFRkFVTFRfUE9SVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlcmNlbnRhZ2UgPSBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgICB0aGlzLmRlZmF1bHRSZXNvbHV0aW9uRXJyb3IgPSB7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICBkZXRhaWxzOiBgTmFtZSByZXNvbHV0aW9uIGZhaWxlZCBmb3IgdGFyZ2V0ICR7dXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRoaXMudGFyZ2V0KX1gLFxuICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJhY2tvZmZPcHRpb25zID0ge1xuICAgICAgICAgICAgaW5pdGlhbERlbGF5OiBjaGFubmVsT3B0aW9uc1snZ3JwYy5pbml0aWFsX3JlY29ubmVjdF9iYWNrb2ZmX21zJ10sXG4gICAgICAgICAgICBtYXhEZWxheTogY2hhbm5lbE9wdGlvbnNbJ2dycGMubWF4X3JlY29ubmVjdF9iYWNrb2ZmX21zJ10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmFja29mZiA9IG5ldyBiYWNrb2ZmX3RpbWVvdXRfMS5CYWNrb2ZmVGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250aW51ZVJlc29sdmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgYmFja29mZk9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJhY2tvZmYudW5yZWYoKTtcbiAgICAgICAgdGhpcy5taW5UaW1lQmV0d2VlblJlc29sdXRpb25zTXMgPSAoX2MgPSBjaGFubmVsT3B0aW9uc1snZ3JwYy5kbnNfbWluX3RpbWVfYmV0d2Vlbl9yZXNvbHV0aW9uc19tcyddKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBERUZBVUxUX01JTl9USU1FX0JFVFdFRU5fUkVTT0xVVElPTlNfTVM7XG4gICAgICAgIHRoaXMubmV4dFJlc29sdXRpb25UaW1lciA9IHNldFRpbWVvdXQoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubmV4dFJlc29sdXRpb25UaW1lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSB0YXJnZXQgaXMgYW4gSVAgYWRkcmVzcywganVzdCBwcm92aWRlIHRoYXQgYWRkcmVzcyBhcyBhIHJlc3VsdC5cbiAgICAgKiBPdGhlcndpc2UsIGluaXRpYXRlIEEsIEFBQUEsIGFuZCBUWFQgbG9va3Vwc1xuICAgICAqL1xuICAgIHN0YXJ0UmVzb2x1dGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXBSZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYWNlKCdSZXR1cm5pbmcgSVAgYWRkcmVzcyBmb3IgdGFyZ2V0ICcgKyB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcodGhpcy50YXJnZXQpKTtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uKHRoaXMuaXBSZXN1bHQsIG51bGwsIG51bGwsIG51bGwsIHt9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRuc0hvc3RuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICB0cmFjZSgnRmFpbGVkIHRvIHBhcnNlIEROUyBhZGRyZXNzICcgKyB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcodGhpcy50YXJnZXQpKTtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgRmFpbGVkIHRvIHBhcnNlIEROUyBhZGRyZXNzICR7dXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRoaXMudGFyZ2V0KX1gLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zdG9wTmV4dFJlc29sdXRpb25UaW1lcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZSgnTG9va2luZyB1cCBETlMgaG9zdG5hbWUgJyArIHRoaXMuZG5zSG9zdG5hbWUpO1xuICAgICAgICAgICAgLyogV2UgY2xlYXIgb3V0IGxhdGVzdExvb2t1cFJlc3VsdCBoZXJlIHRvIGVuc3VyZSB0aGF0IGl0IGNvbnRhaW5zIHRoZVxuICAgICAgICAgICAgICogbGF0ZXN0IHJlc3VsdCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlIHN0YXJ0ZWQgcmVzb2x2aW5nLiBUaGF0IHdheSwgdGhlXG4gICAgICAgICAgICAgKiBUWFQgcmVzb2x1dGlvbiBoYW5kbGVyIGNhbiB1c2UgaXQsIGJ1dCBvbmx5IGlmIGl0IGZpbmlzaGVzIHNlY29uZC4gV2VcbiAgICAgICAgICAgICAqIGRvbid0IGNsZWFyIG91dCBhbnkgcHJldmlvdXMgc2VydmljZSBjb25maWcgcmVzdWx0cyBiZWNhdXNlIGl0J3NcbiAgICAgICAgICAgICAqIGJldHRlciB0byB1c2UgYSBzZXJ2aWNlIGNvbmZpZyB0aGF0J3Mgc2xpZ2h0bHkgb3V0IG9mIGRhdGUgdGhhbiB0b1xuICAgICAgICAgICAgICogcmV2ZXJ0IHRvIGFuIGVmZmVjdGl2ZWx5IGJsYW5rIG9uZS4gKi9cbiAgICAgICAgICAgIHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGhvc3RuYW1lID0gdGhpcy5kbnNIb3N0bmFtZTtcbiAgICAgICAgICAgIC8qIFdlIGxvb2t1cCBib3RoIGFkZHJlc3MgZmFtaWxpZXMgaGVyZSBhbmQgdGhlbiBzcGxpdCB0aGVtIHVwIGxhdGVyXG4gICAgICAgICAgICAgKiBiZWNhdXNlIHdoZW4gbG9va2luZyB1cCBhIHNpbmdsZSBmYW1pbHksIGRucy5sb29rdXAgb3V0cHV0cyBhbiBlcnJvclxuICAgICAgICAgICAgICogaWYgdGhlIG5hbWUgZXhpc3RzIGJ1dCB0aGVyZSBhcmUgbm8gcmVjb3JkcyBmb3IgdGhhdCBmYW1pbHksIGFuZCB0aGF0XG4gICAgICAgICAgICAgKiBlcnJvciBpcyBpbmRpc3Rpbmd1aXNoYWJsZSBmcm9tIG90aGVyIGtpbmRzIG9mIGVycm9ycyAqL1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9IGRuc0xvb2t1cFByb21pc2UoaG9zdG5hbWUsIHsgYWxsOiB0cnVlIH0pO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZS50aGVuKChhZGRyZXNzTGlzdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYmFja29mZi5zdG9wKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXA0QWRkcmVzc2VzID0gYWRkcmVzc0xpc3QuZmlsdGVyKChhZGRyKSA9PiBhZGRyLmZhbWlseSA9PT0gNCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXA2QWRkcmVzc2VzID0gYWRkcmVzc0xpc3QuZmlsdGVyKChhZGRyKSA9PiBhZGRyLmZhbWlseSA9PT0gNik7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RMb29rdXBSZXN1bHQgPSBtZXJnZUFycmF5cyhpcDZBZGRyZXNzZXMsIGlwNEFkZHJlc3NlcykubWFwKChhZGRyKSA9PiAoeyBob3N0OiBhZGRyLmFkZHJlc3MsIHBvcnQ6ICt0aGlzLnBvcnQgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsbEFkZHJlc3Nlc1N0cmluZyA9ICdbJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKChhZGRyKSA9PiBhZGRyLmhvc3QgKyAnOicgKyBhZGRyLnBvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignLCcpICtcbiAgICAgICAgICAgICAgICAgICAgJ10nO1xuICAgICAgICAgICAgICAgIHRyYWNlKCdSZXNvbHZlZCBhZGRyZXNzZXMgZm9yIHRhcmdldCAnICtcbiAgICAgICAgICAgICAgICAgICAgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRoaXMudGFyZ2V0KSArXG4gICAgICAgICAgICAgICAgICAgICc6ICcgK1xuICAgICAgICAgICAgICAgICAgICBhbGxBZGRyZXNzZXNTdHJpbmcpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhdGVzdExvb2t1cFJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vbkVycm9yKHRoaXMuZGVmYXVsdFJlc29sdXRpb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogSWYgdGhlIFRYVCBsb29rdXAgaGFzIG5vdCB5ZXQgZmluaXNoZWQsIGJvdGggb2YgdGhlIGxhc3QgdHdvXG4gICAgICAgICAgICAgICAgICogYXJndW1lbnRzIHdpbGwgYmUgbnVsbCwgd2hpY2ggaXMgdGhlIGVxdWl2YWxlbnQgb2YgZ2V0dGluZyBhblxuICAgICAgICAgICAgICAgICAqIGVtcHR5IFRYVCByZXNwb25zZS4gV2hlbiB0aGUgVFhUIGxvb2t1cCBkb2VzIGZpbmlzaCwgaXRzIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgKiBjYW4gdXBkYXRlIHRoZSBzZXJ2aWNlIGNvbmZpZyBieSB1c2luZyB0aGUgc2FtZSBhZGRyZXNzIGxpc3QgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24odGhpcy5sYXRlc3RMb29rdXBSZXN1bHQsIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZywgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnRXJyb3IsIG51bGwsIHt9KTtcbiAgICAgICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICB0cmFjZSgnUmVzb2x1dGlvbiBlcnJvciBmb3IgdGFyZ2V0ICcgK1xuICAgICAgICAgICAgICAgICAgICB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcodGhpcy50YXJnZXQpICtcbiAgICAgICAgICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BOZXh0UmVzb2x1dGlvblRpbWVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vbkVycm9yKHRoaXMuZGVmYXVsdFJlc29sdXRpb25FcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qIElmIHRoZXJlIGFscmVhZHkgaXMgYSBzdGlsbC1wZW5kaW5nIFRYVCByZXNvbHV0aW9uLCB3ZSBjYW4ganVzdCB1c2VcbiAgICAgICAgICAgICAqIHRoYXQgcmVzdWx0IHdoZW4gaXQgY29tZXMgaW4gKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdUeHRQcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLyogV2UgaGFuZGxlIHRoZSBUWFQgcXVlcnkgcHJvbWlzZSBkaWZmZXJlbnRseSB0aGFuIHRoZSBvdGhlcnMgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAqIHRoZSBuYW1lIHJlc29sdXRpb24gYXR0ZW1wdCBhcyBhIHdob2xlIGlzIGEgc3VjY2VzcyBldmVuIGlmIHRoZSBUWFRcbiAgICAgICAgICAgICAgICAgKiBsb29rdXAgZmFpbHMgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUeHRQcm9taXNlID0gcmVzb2x2ZVR4dFByb21pc2UoaG9zdG5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1R4dFByb21pc2UudGhlbigodHh0UmVjb3JkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1R4dFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnID0gc2VydmljZV9jb25maWdfMS5leHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZyh0eHRSZWNvcmQsIHRoaXMucGVyY2VudGFnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnRXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdQYXJzaW5nIHNlcnZpY2UgY29uZmlnIGZhaWxlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogV2UgcmVseSBoZXJlIG9uIHRoZSBhc3N1bXB0aW9uIHRoYXQgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGlkZW50aWNhbCBwYXJhbWV0ZXJzIHdpbGwgYmUgZXNzZW50aWFseSBpZGVtcG90ZW50LCBhbmQgY2FsbGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICogaXQgd2l0aCB0aGUgc2FtZSBhZGRyZXNzIGxpc3QgYW5kIGEgZGlmZmVyZW50IHNlcnZpY2UgY29uZmlnXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBzaG91bGQgcmVzdWx0IGluIGEgZmFzdCBhbmQgc2VhbWxlc3Mgc3dpdGNob3Zlci4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbih0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCwgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnLCB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWdFcnJvciwgbnVsbCwge30pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKiBJZiBUWFQgbG9va3VwIGZhaWxzIHdlIHNob3VsZCBkbyBub3RoaW5nLCB3aGljaCBtZWFucyB0aGF0IHdlXG4gICAgICAgICAgICAgICAgICAgICAqIGNvbnRpbnVlIHRvIHVzZSB0aGUgcmVzdWx0IG9mIHRoZSBtb3N0IHJlY2VudCBzdWNjZXNzZnVsIGxvb2t1cCxcbiAgICAgICAgICAgICAgICAgICAgICogb3IgdGhlIGRlZmF1bHQgbnVsbCBjb25maWcgb2JqZWN0IGlmIHRoZXJlIGhhcyBuZXZlciBiZWVuIGFcbiAgICAgICAgICAgICAgICAgICAgICogc3VjY2Vzc2Z1bCBsb29rdXAuIFdlIGRvIG5vdCBzZXQgdGhlIGxhdGVzdFNlcnZpY2VDb25maWdFcnJvclxuICAgICAgICAgICAgICAgICAgICAgKiBoZXJlIGJlY2F1c2UgdGhhdCBpcyBzcGVjaWZpY2FsbHkgdXNlZCBmb3IgcmVzcG9uc2UgdmFsaWRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgKiBlcnJvcnMuIFdlIHN0aWxsIG5lZWQgdG8gaGFuZGxlIHRoaXMgZXJyb3Igc28gdGhhdCBpdCBkb2VzIG5vdFxuICAgICAgICAgICAgICAgICAgICAgKiBidWJibGUgdXAgYXMgYW4gdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uLiAqL1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0TmV4dFJlc29sdXRpb25UaW1lcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubmV4dFJlc29sdXRpb25UaW1lcik7XG4gICAgICAgIHRoaXMubmV4dFJlc29sdXRpb25UaW1lciA9IChfYiA9IChfYSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdG9wTmV4dFJlc29sdXRpb25UaW1lcigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGludWVSZXNvbHZpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UmVzb2x1dGlvbldpdGhCYWNrb2ZmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMubWluVGltZUJldHdlZW5SZXNvbHV0aW9uc01zKSkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgdGhpcy5pc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgc3RvcE5leHRSZXNvbHV0aW9uVGltZXIoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm5leHRSZXNvbHV0aW9uVGltZXIpO1xuICAgICAgICB0aGlzLmlzTmV4dFJlc29sdXRpb25UaW1lclJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UmVzb2x1dGlvbigpO1xuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnJ1bk9uY2UoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnROZXh0UmVzb2x1dGlvblRpbWVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlUmVzb2x1dGlvbigpIHtcbiAgICAgICAgLyogSWYgdGhlcmUgaXMgYSBwZW5kaW5nIGxvb2t1cCwganVzdCBsZXQgaXQgZmluaXNoLiBPdGhlcndpc2UsIGlmIHRoZVxuICAgICAgICAgKiBuZXh0UmVzb2x1dGlvblRpbWVyIG9yIGJhY2tvZmYgdGltZXIgaXMgcnVubmluZywgc2V0IHRoZVxuICAgICAgICAgKiBjb250aW51ZVJlc29sdmluZyBmbGFnIHRvIHJlc29sdmUgd2hlbiB3aGljaGV2ZXIgb2YgdGhvc2UgdGltZXJzXG4gICAgICAgICAqIGZpcmVzLiBPdGhlcndpc2UsIHN0YXJ0IHJlc29sdmluZyBpbW1lZGlhdGVseS4gKi9cbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTmV4dFJlc29sdXRpb25UaW1lclJ1bm5pbmcgfHwgdGhpcy5iYWNrb2ZmLmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UmVzb2x1dGlvbldpdGhCYWNrb2ZmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJhY2tvZmYuc3RvcCgpO1xuICAgICAgICB0aGlzLnN0b3BOZXh0UmVzb2x1dGlvblRpbWVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGVmYXVsdCBhdXRob3JpdHkgZm9yIHRoZSBnaXZlbiB0YXJnZXQuIEZvciBJUCB0YXJnZXRzLCB0aGF0IGlzXG4gICAgICogdGhlIElQIGFkZHJlc3MuIEZvciBETlMgdGFyZ2V0cywgaXQgaXMgdGhlIGhvc3RuYW1lLlxuICAgICAqIEBwYXJhbSB0YXJnZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5wYXRoO1xuICAgIH1cbn1cbi8qKlxuICogU2V0IHVwIHRoZSBETlMgcmVzb2x2ZXIgY2xhc3MgYnkgcmVnaXN0ZXJpbmcgaXQgYXMgdGhlIGhhbmRsZXIgZm9yIHRoZVxuICogXCJkbnM6XCIgcHJlZml4IGFuZCBhcyB0aGUgZGVmYXVsdCByZXNvbHZlci5cbiAqL1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgcmVzb2x2ZXJfMS5yZWdpc3RlclJlc29sdmVyKCdkbnMnLCBEbnNSZXNvbHZlcik7XG4gICAgcmVzb2x2ZXJfMS5yZWdpc3RlckRlZmF1bHRTY2hlbWUoJ2RucycpO1xufVxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZXItZG5zLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInNldHVwIiwicmVzb2x2ZXJfMSIsInJlcXVpcmUiLCJkbnMiLCJ1dGlsIiwic2VydmljZV9jb25maWdfMSIsImNvbnN0YW50c18xIiwibWV0YWRhdGFfMSIsImxvZ2dpbmciLCJjb25zdGFudHNfMiIsInVyaV9wYXJzZXJfMSIsIm5ldF8xIiwiYmFja29mZl90aW1lb3V0XzEiLCJUUkFDRVJfTkFNRSIsInRyYWNlIiwidGV4dCIsIkxvZ1ZlcmJvc2l0eSIsIkRFQlVHIiwiREVGQVVMVF9QT1JUIiwiREVGQVVMVF9NSU5fVElNRV9CRVRXRUVOX1JFU09MVVRJT05TX01TIiwicmVzb2x2ZVR4dFByb21pc2UiLCJwcm9taXNpZnkiLCJyZXNvbHZlVHh0IiwiZG5zTG9va3VwUHJvbWlzZSIsImxvb2t1cCIsIm1lcmdlQXJyYXlzIiwiYXJyYXlzIiwicmVzdWx0IiwiaSIsIk1hdGgiLCJtYXgiLCJhcHBseSIsIm1hcCIsImFycmF5IiwibGVuZ3RoIiwicHVzaCIsIkRuc1Jlc29sdmVyIiwiY29uc3RydWN0b3IiLCJ0YXJnZXQiLCJsaXN0ZW5lciIsImNoYW5uZWxPcHRpb25zIiwiX2EiLCJfYiIsIl9jIiwicGVuZGluZ0xvb2t1cFByb21pc2UiLCJwZW5kaW5nVHh0UHJvbWlzZSIsImxhdGVzdExvb2t1cFJlc3VsdCIsImxhdGVzdFNlcnZpY2VDb25maWciLCJsYXRlc3RTZXJ2aWNlQ29uZmlnRXJyb3IiLCJjb250aW51ZVJlc29sdmluZyIsImlzTmV4dFJlc29sdXRpb25UaW1lclJ1bm5pbmciLCJ1cmlUb1N0cmluZyIsImhvc3RQb3J0Iiwic3BsaXRIb3N0UG9ydCIsInBhdGgiLCJpcFJlc3VsdCIsImRuc0hvc3RuYW1lIiwicG9ydCIsImlzSVB2NCIsImhvc3QiLCJpc0lQdjYiLCJwZXJjZW50YWdlIiwicmFuZG9tIiwiZGVmYXVsdFJlc29sdXRpb25FcnJvciIsImNvZGUiLCJTdGF0dXMiLCJVTkFWQUlMQUJMRSIsImRldGFpbHMiLCJtZXRhZGF0YSIsIk1ldGFkYXRhIiwiYmFja29mZk9wdGlvbnMiLCJpbml0aWFsRGVsYXkiLCJtYXhEZWxheSIsImJhY2tvZmYiLCJCYWNrb2ZmVGltZW91dCIsInN0YXJ0UmVzb2x1dGlvbldpdGhCYWNrb2ZmIiwidW5yZWYiLCJtaW5UaW1lQmV0d2VlblJlc29sdXRpb25zTXMiLCJuZXh0UmVzb2x1dGlvblRpbWVyIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInN0YXJ0UmVzb2x1dGlvbiIsInNldEltbWVkaWF0ZSIsIm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24iLCJzdG9wIiwicmVzZXQiLCJvbkVycm9yIiwic3RvcE5leHRSZXNvbHV0aW9uVGltZXIiLCJob3N0bmFtZSIsImFsbCIsInRoZW4iLCJhZGRyZXNzTGlzdCIsImlwNEFkZHJlc3NlcyIsImZpbHRlciIsImFkZHIiLCJmYW1pbHkiLCJpcDZBZGRyZXNzZXMiLCJhZGRyZXNzIiwiYWxsQWRkcmVzc2VzU3RyaW5nIiwiam9pbiIsImVyciIsIm1lc3NhZ2UiLCJ0eHRSZWNvcmQiLCJleHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZyIsInN0YXJ0TmV4dFJlc29sdXRpb25UaW1lciIsImNhbGwiLCJydW5PbmNlIiwidXBkYXRlUmVzb2x1dGlvbiIsImlzUnVubmluZyIsImRlc3Ryb3kiLCJnZXREZWZhdWx0QXV0aG9yaXR5IiwicmVnaXN0ZXJSZXNvbHZlciIsInJlZ2lzdGVyRGVmYXVsdFNjaGVtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-ip.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = \"ip_resolver\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst IPV4_SCHEME = \"ipv4\";\nconst IPV6_SCHEME = \"ipv6\";\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */ const DEFAULT_PORT = 443;\nclass IpResolver {\n    constructor(target, listener, channelOptions){\n        var _a;\n        this.target = target;\n        this.listener = listener;\n        this.addresses = [];\n        this.error = null;\n        trace(\"Resolver constructed for target \" + uri_parser_1.uriToString(target));\n        const addresses = [];\n        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {\n            this.error = {\n                code: constants_1.Status.UNAVAILABLE,\n                details: `Unrecognized scheme ${target.scheme} in IP resolver`,\n                metadata: new metadata_1.Metadata()\n            };\n            return;\n        }\n        const pathList = target.path.split(\",\");\n        for (const path of pathList){\n            const hostPort = uri_parser_1.splitHostPort(path);\n            if (hostPort === null) {\n                this.error = {\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse ${target.scheme} address ${path}`,\n                    metadata: new metadata_1.Metadata()\n                };\n                return;\n            }\n            if (target.scheme === IPV4_SCHEME && !net_1.isIPv4(hostPort.host) || target.scheme === IPV6_SCHEME && !net_1.isIPv6(hostPort.host)) {\n                this.error = {\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse ${target.scheme} address ${path}`,\n                    metadata: new metadata_1.Metadata()\n                };\n                return;\n            }\n            addresses.push({\n                host: hostPort.host,\n                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT\n            });\n        }\n        this.addresses = addresses;\n        trace(\"Parsed \" + target.scheme + \" address list \" + this.addresses);\n    }\n    updateResolution() {\n        process.nextTick(()=>{\n            if (this.error) {\n                this.listener.onError(this.error);\n            } else {\n                this.listener.onSuccessfulResolution(this.addresses, null, null, null, {});\n            }\n        });\n    }\n    destroy() {\n    // This resolver owns no resources, so we do nothing here.\n    }\n    static getDefaultAuthority(target) {\n        return target.path.split(\",\")[0];\n    }\n}\nfunction setup() {\n    resolver_1.registerResolver(IPV4_SCHEME, IpResolver);\n    resolver_1.registerResolver(IPV6_SCHEME, IpResolver);\n}\nexports.setup = setup; //# sourceMappingURL=resolver-ip.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItaXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHLEtBQUs7QUFDckIsTUFBTUcsUUFBUUMsbUJBQU9BLENBQUMsZ0JBQUs7QUFDM0IsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUUsYUFBYUYsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUcsYUFBYUgsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUksZUFBZUosbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTUssVUFBVUwsbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTU0sY0FBYztBQUNwQixTQUFTQyxNQUFNQyxJQUFJO0lBQ2ZILFFBQVFFLEtBQUssQ0FBQ04sWUFBWVEsWUFBWSxDQUFDQyxLQUFLLEVBQUVKLGFBQWFFO0FBQy9EO0FBQ0EsTUFBTUcsY0FBYztBQUNwQixNQUFNQyxjQUFjO0FBQ3BCOztDQUVDLEdBQ0QsTUFBTUMsZUFBZTtBQUNyQixNQUFNQztJQUNGQyxZQUFZQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsY0FBYyxDQUFFO1FBQzFDLElBQUlDO1FBQ0osSUFBSSxDQUFDSCxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0csU0FBUyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFDYmQsTUFBTSxxQ0FBcUNILGFBQWFrQixXQUFXLENBQUNOO1FBQ3BFLE1BQU1JLFlBQVksRUFBRTtRQUNwQixJQUFJLENBQUVKLENBQUFBLE9BQU9PLE1BQU0sS0FBS1osZUFBZUssT0FBT08sTUFBTSxLQUFLWCxXQUFVLEdBQUk7WUFDbkUsSUFBSSxDQUFDUyxLQUFLLEdBQUc7Z0JBQ1RHLE1BQU12QixZQUFZd0IsTUFBTSxDQUFDQyxXQUFXO2dCQUNwQ0MsU0FBUyxDQUFDLG9CQUFvQixFQUFFWCxPQUFPTyxNQUFNLENBQUMsZUFBZSxDQUFDO2dCQUM5REssVUFBVSxJQUFJMUIsV0FBVzJCLFFBQVE7WUFDckM7WUFDQTtRQUNKO1FBQ0EsTUFBTUMsV0FBV2QsT0FBT2UsSUFBSSxDQUFDQyxLQUFLLENBQUM7UUFDbkMsS0FBSyxNQUFNRCxRQUFRRCxTQUFVO1lBQ3pCLE1BQU1HLFdBQVc3QixhQUFhOEIsYUFBYSxDQUFDSDtZQUM1QyxJQUFJRSxhQUFhLE1BQU07Z0JBQ25CLElBQUksQ0FBQ1osS0FBSyxHQUFHO29CQUNURyxNQUFNdkIsWUFBWXdCLE1BQU0sQ0FBQ0MsV0FBVztvQkFDcENDLFNBQVMsQ0FBQyxnQkFBZ0IsRUFBRVgsT0FBT08sTUFBTSxDQUFDLFNBQVMsRUFBRVEsS0FBSyxDQUFDO29CQUMzREgsVUFBVSxJQUFJMUIsV0FBVzJCLFFBQVE7Z0JBQ3JDO2dCQUNBO1lBQ0o7WUFDQSxJQUFJLE9BQVFOLE1BQU0sS0FBS1osZUFBZSxDQUFDWixNQUFNb0MsTUFBTSxDQUFDRixTQUFTRyxJQUFJLEtBQzVEcEIsT0FBT08sTUFBTSxLQUFLWCxlQUFlLENBQUNiLE1BQU1zQyxNQUFNLENBQUNKLFNBQVNHLElBQUksR0FBSTtnQkFDakUsSUFBSSxDQUFDZixLQUFLLEdBQUc7b0JBQ1RHLE1BQU12QixZQUFZd0IsTUFBTSxDQUFDQyxXQUFXO29CQUNwQ0MsU0FBUyxDQUFDLGdCQUFnQixFQUFFWCxPQUFPTyxNQUFNLENBQUMsU0FBUyxFQUFFUSxLQUFLLENBQUM7b0JBQzNESCxVQUFVLElBQUkxQixXQUFXMkIsUUFBUTtnQkFDckM7Z0JBQ0E7WUFDSjtZQUNBVCxVQUFVa0IsSUFBSSxDQUFDO2dCQUNYRixNQUFNSCxTQUFTRyxJQUFJO2dCQUNuQkcsTUFBTSxDQUFDcEIsS0FBS2MsU0FBU00sSUFBSSxNQUFNLFFBQVFwQixPQUFPLEtBQUssSUFBSUEsS0FBS047WUFDaEU7UUFDSjtRQUNBLElBQUksQ0FBQ08sU0FBUyxHQUFHQTtRQUNqQmIsTUFBTSxZQUFZUyxPQUFPTyxNQUFNLEdBQUcsbUJBQW1CLElBQUksQ0FBQ0gsU0FBUztJQUN2RTtJQUNBb0IsbUJBQW1CO1FBQ2ZDLFFBQVFDLFFBQVEsQ0FBQztZQUNiLElBQUksSUFBSSxDQUFDckIsS0FBSyxFQUFFO2dCQUNaLElBQUksQ0FBQ0osUUFBUSxDQUFDMEIsT0FBTyxDQUFDLElBQUksQ0FBQ3RCLEtBQUs7WUFDcEMsT0FDSztnQkFDRCxJQUFJLENBQUNKLFFBQVEsQ0FBQzJCLHNCQUFzQixDQUFDLElBQUksQ0FBQ3hCLFNBQVMsRUFBRSxNQUFNLE1BQU0sTUFBTSxDQUFDO1lBQzVFO1FBQ0o7SUFDSjtJQUNBeUIsVUFBVTtJQUNOLDBEQUEwRDtJQUM5RDtJQUNBLE9BQU9DLG9CQUFvQjlCLE1BQU0sRUFBRTtRQUMvQixPQUFPQSxPQUFPZSxJQUFJLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtJQUNwQztBQUNKO0FBQ0EsU0FBU2xDO0lBQ0xLLFdBQVc0QyxnQkFBZ0IsQ0FBQ3BDLGFBQWFHO0lBQ3pDWCxXQUFXNEMsZ0JBQWdCLENBQUNuQyxhQUFhRTtBQUM3QztBQUNBbEIsYUFBYSxHQUFHRSxPQUNoQix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc2htaXR0LWd1cHRhLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmVyLWlwLmpzPzdkMjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXR1cCA9IHZvaWQgMDtcbmNvbnN0IG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnaXBfcmVzb2x2ZXInO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jb25zdCBJUFY0X1NDSEVNRSA9ICdpcHY0JztcbmNvbnN0IElQVjZfU0NIRU1FID0gJ2lwdjYnO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBUQ1AgcG9ydCB0byBjb25uZWN0IHRvIGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCBpbiB0aGUgdGFyZ2V0LlxuICovXG5jb25zdCBERUZBVUxUX1BPUlQgPSA0NDM7XG5jbGFzcyBJcFJlc29sdmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGxpc3RlbmVyLCBjaGFubmVsT3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMuYWRkcmVzc2VzID0gW107XG4gICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgICAgICB0cmFjZSgnUmVzb2x2ZXIgY29uc3RydWN0ZWQgZm9yIHRhcmdldCAnICsgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRhcmdldCkpO1xuICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBbXTtcbiAgICAgICAgaWYgKCEodGFyZ2V0LnNjaGVtZSA9PT0gSVBWNF9TQ0hFTUUgfHwgdGFyZ2V0LnNjaGVtZSA9PT0gSVBWNl9TQ0hFTUUpKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBgVW5yZWNvZ25pemVkIHNjaGVtZSAke3RhcmdldC5zY2hlbWV9IGluIElQIHJlc29sdmVyYCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0aExpc3QgPSB0YXJnZXQucGF0aC5zcGxpdCgnLCcpO1xuICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aExpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGhvc3RQb3J0ID0gdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQocGF0aCk7XG4gICAgICAgICAgICBpZiAoaG9zdFBvcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBGYWlsZWQgdG8gcGFyc2UgJHt0YXJnZXQuc2NoZW1lfSBhZGRyZXNzICR7cGF0aH1gLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFyZ2V0LnNjaGVtZSA9PT0gSVBWNF9TQ0hFTUUgJiYgIW5ldF8xLmlzSVB2NChob3N0UG9ydC5ob3N0KSkgfHxcbiAgICAgICAgICAgICAgICAodGFyZ2V0LnNjaGVtZSA9PT0gSVBWNl9TQ0hFTUUgJiYgIW5ldF8xLmlzSVB2Nihob3N0UG9ydC5ob3N0KSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBGYWlsZWQgdG8gcGFyc2UgJHt0YXJnZXQuc2NoZW1lfSBhZGRyZXNzICR7cGF0aH1gLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZHJlc3Nlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBob3N0OiBob3N0UG9ydC5ob3N0LFxuICAgICAgICAgICAgICAgIHBvcnQ6IChfYSA9IGhvc3RQb3J0LnBvcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IERFRkFVTFRfUE9SVCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkcmVzc2VzID0gYWRkcmVzc2VzO1xuICAgICAgICB0cmFjZSgnUGFyc2VkICcgKyB0YXJnZXQuc2NoZW1lICsgJyBhZGRyZXNzIGxpc3QgJyArIHRoaXMuYWRkcmVzc2VzKTtcbiAgICB9XG4gICAgdXBkYXRlUmVzb2x1dGlvbigpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25FcnJvcih0aGlzLmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbih0aGlzLmFkZHJlc3NlcywgbnVsbCwgbnVsbCwgbnVsbCwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgLy8gVGhpcyByZXNvbHZlciBvd25zIG5vIHJlc291cmNlcywgc28gd2UgZG8gbm90aGluZyBoZXJlLlxuICAgIH1cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5wYXRoLnNwbGl0KCcsJylbMF07XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgcmVzb2x2ZXJfMS5yZWdpc3RlclJlc29sdmVyKElQVjRfU0NIRU1FLCBJcFJlc29sdmVyKTtcbiAgICByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXIoSVBWNl9TQ0hFTUUsIElwUmVzb2x2ZXIpO1xufVxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZXItaXAuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2V0dXAiLCJuZXRfMSIsInJlcXVpcmUiLCJjb25zdGFudHNfMSIsIm1ldGFkYXRhXzEiLCJyZXNvbHZlcl8xIiwidXJpX3BhcnNlcl8xIiwibG9nZ2luZyIsIlRSQUNFUl9OQU1FIiwidHJhY2UiLCJ0ZXh0IiwiTG9nVmVyYm9zaXR5IiwiREVCVUciLCJJUFY0X1NDSEVNRSIsIklQVjZfU0NIRU1FIiwiREVGQVVMVF9QT1JUIiwiSXBSZXNvbHZlciIsImNvbnN0cnVjdG9yIiwidGFyZ2V0IiwibGlzdGVuZXIiLCJjaGFubmVsT3B0aW9ucyIsIl9hIiwiYWRkcmVzc2VzIiwiZXJyb3IiLCJ1cmlUb1N0cmluZyIsInNjaGVtZSIsImNvZGUiLCJTdGF0dXMiLCJVTkFWQUlMQUJMRSIsImRldGFpbHMiLCJtZXRhZGF0YSIsIk1ldGFkYXRhIiwicGF0aExpc3QiLCJwYXRoIiwic3BsaXQiLCJob3N0UG9ydCIsInNwbGl0SG9zdFBvcnQiLCJpc0lQdjQiLCJob3N0IiwiaXNJUHY2IiwicHVzaCIsInBvcnQiLCJ1cGRhdGVSZXNvbHV0aW9uIiwicHJvY2VzcyIsIm5leHRUaWNrIiwib25FcnJvciIsIm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24iLCJkZXN0cm95IiwiZ2V0RGVmYXVsdEF1dGhvcml0eSIsInJlZ2lzdGVyUmVzb2x2ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-uds.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = void 0;\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nclass UdsResolver {\n    constructor(target, listener, channelOptions){\n        this.listener = listener;\n        this.addresses = [];\n        let path;\n        if (target.authority === \"\") {\n            path = \"/\" + target.path;\n        } else {\n            path = target.path;\n        }\n        this.addresses = [\n            {\n                path\n            }\n        ];\n    }\n    updateResolution() {\n        process.nextTick(this.listener.onSuccessfulResolution, this.addresses, null, null, null, {});\n    }\n    destroy() {\n    // This resolver owns no resources, so we do nothing here.\n    }\n    static getDefaultAuthority(target) {\n        return \"localhost\";\n    }\n}\nfunction setup() {\n    resolver_1.registerResolver(\"unix\", UdsResolver);\n}\nexports.setup = setup; //# sourceMappingURL=resolver-uds.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItdWRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGFBQWEsR0FBRyxLQUFLO0FBQ3JCLE1BQU1HLGFBQWFDLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1DO0lBQ0ZDLFlBQVlDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxjQUFjLENBQUU7UUFDMUMsSUFBSSxDQUFDRCxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0UsU0FBUyxHQUFHLEVBQUU7UUFDbkIsSUFBSUM7UUFDSixJQUFJSixPQUFPSyxTQUFTLEtBQUssSUFBSTtZQUN6QkQsT0FBTyxNQUFNSixPQUFPSSxJQUFJO1FBQzVCLE9BQ0s7WUFDREEsT0FBT0osT0FBT0ksSUFBSTtRQUN0QjtRQUNBLElBQUksQ0FBQ0QsU0FBUyxHQUFHO1lBQUM7Z0JBQUVDO1lBQUs7U0FBRTtJQUMvQjtJQUNBRSxtQkFBbUI7UUFDZkMsUUFBUUMsUUFBUSxDQUFDLElBQUksQ0FBQ1AsUUFBUSxDQUFDUSxzQkFBc0IsRUFBRSxJQUFJLENBQUNOLFNBQVMsRUFBRSxNQUFNLE1BQU0sTUFBTSxDQUFDO0lBQzlGO0lBQ0FPLFVBQVU7SUFDTiwwREFBMEQ7SUFDOUQ7SUFDQSxPQUFPQyxvQkFBb0JYLE1BQU0sRUFBRTtRQUMvQixPQUFPO0lBQ1g7QUFDSjtBQUNBLFNBQVNMO0lBQ0xDLFdBQVdnQixnQkFBZ0IsQ0FBQyxRQUFRZDtBQUN4QztBQUNBTCxhQUFhLEdBQUdFLE9BQ2hCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2FzaG1pdHQtZ3VwdGEvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItdWRzLmpzPzY5NTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXR1cCA9IHZvaWQgMDtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNsYXNzIFVkc1Jlc29sdmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGxpc3RlbmVyLCBjaGFubmVsT3B0aW9ucykge1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMuYWRkcmVzc2VzID0gW107XG4gICAgICAgIGxldCBwYXRoO1xuICAgICAgICBpZiAodGFyZ2V0LmF1dGhvcml0eSA9PT0gJycpIHtcbiAgICAgICAgICAgIHBhdGggPSAnLycgKyB0YXJnZXQucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGggPSB0YXJnZXQucGF0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZHJlc3NlcyA9IFt7IHBhdGggfV07XG4gICAgfVxuICAgIHVwZGF0ZVJlc29sdXRpb24oKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2sodGhpcy5saXN0ZW5lci5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uLCB0aGlzLmFkZHJlc3NlcywgbnVsbCwgbnVsbCwgbnVsbCwge30pO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAvLyBUaGlzIHJlc29sdmVyIG93bnMgbm8gcmVzb3VyY2VzLCBzbyB3ZSBkbyBub3RoaW5nIGhlcmUuXG4gICAgfVxuICAgIHN0YXRpYyBnZXREZWZhdWx0QXV0aG9yaXR5KHRhcmdldCkge1xuICAgICAgICByZXR1cm4gJ2xvY2FsaG9zdCc7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgcmVzb2x2ZXJfMS5yZWdpc3RlclJlc29sdmVyKCd1bml4JywgVWRzUmVzb2x2ZXIpO1xufVxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZXItdWRzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInNldHVwIiwicmVzb2x2ZXJfMSIsInJlcXVpcmUiLCJVZHNSZXNvbHZlciIsImNvbnN0cnVjdG9yIiwidGFyZ2V0IiwibGlzdGVuZXIiLCJjaGFubmVsT3B0aW9ucyIsImFkZHJlc3NlcyIsInBhdGgiLCJhdXRob3JpdHkiLCJ1cGRhdGVSZXNvbHV0aW9uIiwicHJvY2VzcyIsIm5leHRUaWNrIiwib25TdWNjZXNzZnVsUmVzb2x1dGlvbiIsImRlc3Ryb3kiLCJnZXREZWZhdWx0QXV0aG9yaXR5IiwicmVnaXN0ZXJSZXNvbHZlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.mapUriDefaultScheme = exports.getDefaultAuthority = exports.createResolver = exports.registerDefaultScheme = exports.registerResolver = void 0;\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst registeredResolvers = {};\nlet defaultScheme = null;\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */ function registerResolver(scheme, resolverClass) {\n    registeredResolvers[scheme] = resolverClass;\n}\nexports.registerResolver = registerResolver;\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */ function registerDefaultScheme(scheme) {\n    defaultScheme = scheme;\n}\nexports.registerDefaultScheme = registerDefaultScheme;\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */ function createResolver(target, listener, options) {\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n        return new registeredResolvers[target.scheme](target, listener, options);\n    } else {\n        throw new Error(`No resolver could be created for target ${uri_parser_1.uriToString(target)}`);\n    }\n}\nexports.createResolver = createResolver;\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */ function getDefaultAuthority(target) {\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n        return registeredResolvers[target.scheme].getDefaultAuthority(target);\n    } else {\n        throw new Error(`Invalid target ${uri_parser_1.uriToString(target)}`);\n    }\n}\nexports.getDefaultAuthority = getDefaultAuthority;\nfunction mapUriDefaultScheme(target) {\n    if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\n        if (defaultScheme !== null) {\n            return {\n                scheme: defaultScheme,\n                authority: undefined,\n                path: uri_parser_1.uriToString(target)\n            };\n        } else {\n            return null;\n        }\n    }\n    return target;\n}\nexports.mapUriDefaultScheme = mapUriDefaultScheme; //# sourceMappingURL=resolver.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJCQUEyQixHQUFHQSwyQkFBMkIsR0FBR0Esc0JBQXNCLEdBQUdBLDZCQUE2QixHQUFHQSx3QkFBd0IsR0FBRyxLQUFLO0FBQ3JKLE1BQU1PLGVBQWVDLG1CQUFPQSxDQUFDLGdGQUFjO0FBQzNDLE1BQU1DLHNCQUFzQixDQUFDO0FBQzdCLElBQUlDLGdCQUFnQjtBQUNwQjs7Ozs7O0NBTUMsR0FDRCxTQUFTSixpQkFBaUJLLE1BQU0sRUFBRUMsYUFBYTtJQUMzQ0gsbUJBQW1CLENBQUNFLE9BQU8sR0FBR0M7QUFDbEM7QUFDQVosd0JBQXdCLEdBQUdNO0FBQzNCOzs7O0NBSUMsR0FDRCxTQUFTRCxzQkFBc0JNLE1BQU07SUFDakNELGdCQUFnQkM7QUFDcEI7QUFDQVgsNkJBQTZCLEdBQUdLO0FBQ2hDOzs7OztDQUtDLEdBQ0QsU0FBU0QsZUFBZVMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLE9BQU87SUFDN0MsSUFBSUYsT0FBT0YsTUFBTSxLQUFLSyxhQUFhSCxPQUFPRixNQUFNLElBQUlGLHFCQUFxQjtRQUNyRSxPQUFPLElBQUlBLG1CQUFtQixDQUFDSSxPQUFPRixNQUFNLENBQUMsQ0FBQ0UsUUFBUUMsVUFBVUM7SUFDcEUsT0FDSztRQUNELE1BQU0sSUFBSUUsTUFBTSxDQUFDLHdDQUF3QyxFQUFFVixhQUFhVyxXQUFXLENBQUNMLFFBQVEsQ0FBQztJQUNqRztBQUNKO0FBQ0FiLHNCQUFzQixHQUFHSTtBQUN6Qjs7OztDQUlDLEdBQ0QsU0FBU0Qsb0JBQW9CVSxNQUFNO0lBQy9CLElBQUlBLE9BQU9GLE1BQU0sS0FBS0ssYUFBYUgsT0FBT0YsTUFBTSxJQUFJRixxQkFBcUI7UUFDckUsT0FBT0EsbUJBQW1CLENBQUNJLE9BQU9GLE1BQU0sQ0FBQyxDQUFDUixtQkFBbUIsQ0FBQ1U7SUFDbEUsT0FDSztRQUNELE1BQU0sSUFBSUksTUFBTSxDQUFDLGVBQWUsRUFBRVYsYUFBYVcsV0FBVyxDQUFDTCxRQUFRLENBQUM7SUFDeEU7QUFDSjtBQUNBYiwyQkFBMkIsR0FBR0c7QUFDOUIsU0FBU0Qsb0JBQW9CVyxNQUFNO0lBQy9CLElBQUlBLE9BQU9GLE1BQU0sS0FBS0ssYUFBYSxDQUFFSCxDQUFBQSxPQUFPRixNQUFNLElBQUlGLG1CQUFrQixHQUFJO1FBQ3hFLElBQUlDLGtCQUFrQixNQUFNO1lBQ3hCLE9BQU87Z0JBQ0hDLFFBQVFEO2dCQUNSUyxXQUFXSDtnQkFDWEksTUFBTWIsYUFBYVcsV0FBVyxDQUFDTDtZQUNuQztRQUNKLE9BQ0s7WUFDRCxPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU9BO0FBQ1g7QUFDQWIsMkJBQTJCLEdBQUdFLHFCQUM5QixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc2htaXR0LWd1cHRhLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmVyLmpzPzFkOTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWFwVXJpRGVmYXVsdFNjaGVtZSA9IGV4cG9ydHMuZ2V0RGVmYXVsdEF1dGhvcml0eSA9IGV4cG9ydHMuY3JlYXRlUmVzb2x2ZXIgPSBleHBvcnRzLnJlZ2lzdGVyRGVmYXVsdFNjaGVtZSA9IGV4cG9ydHMucmVnaXN0ZXJSZXNvbHZlciA9IHZvaWQgMDtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCByZWdpc3RlcmVkUmVzb2x2ZXJzID0ge307XG5sZXQgZGVmYXVsdFNjaGVtZSA9IG51bGw7XG4vKipcbiAqIFJlZ2lzdGVyIGEgcmVzb2x2ZXIgY2xhc3MgdG8gaGFuZGxlIHRhcmdldCBuYW1lcyBwcmVmaXhlZCB3aXRoIHRoZSBgcHJlZml4YFxuICogc3RyaW5nLiBUaGlzIHByZWZpeCBzaG91bGQgY29ycmVzcG9uZCB0byBhIFVSSSBzY2hlbWUgbmFtZSBsaXN0ZWQgaW4gdGhlXG4gKiBbZ1JQQyBOYW1lIFJlc29sdXRpb24gZG9jdW1lbnRdKGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMvYmxvYi9tYXN0ZXIvZG9jL25hbWluZy5tZClcbiAqIEBwYXJhbSBwcmVmaXhcbiAqIEBwYXJhbSByZXNvbHZlckNsYXNzXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVzb2x2ZXIoc2NoZW1lLCByZXNvbHZlckNsYXNzKSB7XG4gICAgcmVnaXN0ZXJlZFJlc29sdmVyc1tzY2hlbWVdID0gcmVzb2x2ZXJDbGFzcztcbn1cbmV4cG9ydHMucmVnaXN0ZXJSZXNvbHZlciA9IHJlZ2lzdGVyUmVzb2x2ZXI7XG4vKipcbiAqIFJlZ2lzdGVyIGEgZGVmYXVsdCByZXNvbHZlciB0byBoYW5kbGUgdGFyZ2V0IG5hbWVzIHRoYXQgZG8gbm90IHN0YXJ0IHdpdGhcbiAqIGFueSByZWdpc3RlcmVkIHByZWZpeC5cbiAqIEBwYXJhbSByZXNvbHZlckNsYXNzXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdFNjaGVtZShzY2hlbWUpIHtcbiAgICBkZWZhdWx0U2NoZW1lID0gc2NoZW1lO1xufVxuZXhwb3J0cy5yZWdpc3RlckRlZmF1bHRTY2hlbWUgPSByZWdpc3RlckRlZmF1bHRTY2hlbWU7XG4vKipcbiAqIENyZWF0ZSBhIG5hbWUgcmVzb2x2ZXIgZm9yIHRoZSBzcGVjaWZpZWQgdGFyZ2V0LCBpZiBwb3NzaWJsZS4gVGhyb3dzIGFuXG4gKiBlcnJvciBpZiBubyBzdWNoIG5hbWUgcmVzb2x2ZXIgY2FuIGJlIGNyZWF0ZWQuXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKiBAcGFyYW0gbGlzdGVuZXJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmVzb2x2ZXIodGFyZ2V0LCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIGlmICh0YXJnZXQuc2NoZW1lICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0LnNjaGVtZSBpbiByZWdpc3RlcmVkUmVzb2x2ZXJzKSB7XG4gICAgICAgIHJldHVybiBuZXcgcmVnaXN0ZXJlZFJlc29sdmVyc1t0YXJnZXQuc2NoZW1lXSh0YXJnZXQsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcmVzb2x2ZXIgY291bGQgYmUgY3JlYXRlZCBmb3IgdGFyZ2V0ICR7dXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRhcmdldCl9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVSZXNvbHZlciA9IGNyZWF0ZVJlc29sdmVyO1xuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgYXV0aG9yaXR5IGZvciB0aGUgc3BlY2lmaWVkIHRhcmdldCwgaWYgcG9zc2libGUuIFRocm93cyBhblxuICogZXJyb3IgaWYgbm8gcmVnaXN0ZXJlZCBuYW1lIHJlc29sdmVyIGNhbiBwYXJzZSB0aGF0IHRhcmdldCBzdHJpbmcuXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRBdXRob3JpdHkodGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5zY2hlbWUgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQuc2NoZW1lIGluIHJlZ2lzdGVyZWRSZXNvbHZlcnMpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRSZXNvbHZlcnNbdGFyZ2V0LnNjaGVtZV0uZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRhcmdldCAke3VyaV9wYXJzZXJfMS51cmlUb1N0cmluZyh0YXJnZXQpfWApO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0RGVmYXVsdEF1dGhvcml0eSA9IGdldERlZmF1bHRBdXRob3JpdHk7XG5mdW5jdGlvbiBtYXBVcmlEZWZhdWx0U2NoZW1lKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQuc2NoZW1lID09PSB1bmRlZmluZWQgfHwgISh0YXJnZXQuc2NoZW1lIGluIHJlZ2lzdGVyZWRSZXNvbHZlcnMpKSB7XG4gICAgICAgIGlmIChkZWZhdWx0U2NoZW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNjaGVtZTogZGVmYXVsdFNjaGVtZSxcbiAgICAgICAgICAgICAgICBhdXRob3JpdHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBwYXRoOiB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcodGFyZ2V0KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZXhwb3J0cy5tYXBVcmlEZWZhdWx0U2NoZW1lID0gbWFwVXJpRGVmYXVsdFNjaGVtZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1hcFVyaURlZmF1bHRTY2hlbWUiLCJnZXREZWZhdWx0QXV0aG9yaXR5IiwiY3JlYXRlUmVzb2x2ZXIiLCJyZWdpc3RlckRlZmF1bHRTY2hlbWUiLCJyZWdpc3RlclJlc29sdmVyIiwidXJpX3BhcnNlcl8xIiwicmVxdWlyZSIsInJlZ2lzdGVyZWRSZXNvbHZlcnMiLCJkZWZhdWx0U2NoZW1lIiwic2NoZW1lIiwicmVzb2x2ZXJDbGFzcyIsInRhcmdldCIsImxpc3RlbmVyIiwib3B0aW9ucyIsInVuZGVmaW5lZCIsIkVycm9yIiwidXJpVG9TdHJpbmciLCJhdXRob3JpdHkiLCJwYXRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ResolvingLoadBalancer = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nconst TRACER_NAME = \"resolving_load_balancer\";\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst DEFAULT_LOAD_BALANCER_NAME = \"pick_first\";\nfunction getDefaultConfigSelector(serviceConfig) {\n    return function defaultConfigSelector(methodName, metadata) {\n        var _a, _b;\n        const splitName = methodName.split(\"/\").filter((x)=>x.length > 0);\n        const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : \"\";\n        const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : \"\";\n        if (serviceConfig && serviceConfig.methodConfig) {\n            for (const methodConfig of serviceConfig.methodConfig){\n                for (const name of methodConfig.name){\n                    if (name.service === service && (name.method === undefined || name.method === method)) {\n                        return {\n                            methodConfig: methodConfig,\n                            pickInformation: {},\n                            status: constants_1.Status.OK,\n                            dynamicFilterFactories: []\n                        };\n                    }\n                }\n            }\n        }\n        return {\n            methodConfig: {\n                name: []\n            },\n            pickInformation: {},\n            status: constants_1.Status.OK,\n            dynamicFilterFactories: []\n        };\n    };\n}\nclass ResolvingLoadBalancer {\n    /**\n     * Wrapper class that behaves like a `LoadBalancer` and also handles name\n     * resolution internally.\n     * @param target The address of the backend to connect to.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     * @param defaultServiceConfig The default service configuration to be used\n     *     if none is provided by the name resolver. A `null` value indicates\n     *     that the default behavior should be the default unconfigured behavior.\n     *     In practice, that means using the \"pick first\" load balancer\n     *     implmentation\n     */ constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution){\n        this.target = target;\n        this.channelControlHelper = channelControlHelper;\n        this.channelOptions = channelOptions;\n        this.onSuccessfulResolution = onSuccessfulResolution;\n        this.onFailedResolution = onFailedResolution;\n        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\n        this.latestChildPicker = new picker_1.QueuePicker(this);\n        /**\n         * This resolving load balancer's current connectivity state.\n         */ this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The service config object from the last successful resolution, if\n         * available. A value of null indicates that we have not yet received a valid\n         * service config from the resolver.\n         */ this.previousServiceConfig = null;\n        /**\n         * Indicates whether we should attempt to resolve again after the backoff\n         * timer runs out.\n         */ this.continueResolving = false;\n        if (channelOptions[\"grpc.service_config\"]) {\n            this.defaultServiceConfig = service_config_1.validateServiceConfig(JSON.parse(channelOptions[\"grpc.service_config\"]));\n        } else {\n            this.defaultServiceConfig = {\n                loadBalancingConfig: [],\n                methodConfig: []\n            };\n        }\n        this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({\n            createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),\n            requestReresolution: ()=>{\n                /* If the backoffTimeout is running, we're still backing off from\n                 * making resolve requests, so we shouldn't make another one here.\n                 * In that case, the backoff timer callback will call\n                 * updateResolution */ if (this.backoffTimeout.isRunning()) {\n                    this.continueResolving = true;\n                } else {\n                    this.updateResolution();\n                }\n            },\n            updateState: (newState, picker)=>{\n                this.latestChildState = newState;\n                this.latestChildPicker = picker;\n                this.updateState(newState, picker);\n            },\n            addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),\n            removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper)\n        });\n        this.innerResolver = resolver_1.createResolver(target, {\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError, configSelector, attributes)=>{\n                var _a;\n                let workingServiceConfig = null;\n                /* This first group of conditionals implements the algorithm described\n                 * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\n                 * in the section called \"Behavior on receiving a new gRPC Config\".\n                 */ if (serviceConfig === null) {\n                    // Step 4 and 5\n                    if (serviceConfigError === null) {\n                        // Step 5\n                        this.previousServiceConfig = null;\n                        workingServiceConfig = this.defaultServiceConfig;\n                    } else {\n                        // Step 4\n                        if (this.previousServiceConfig === null) {\n                            // Step 4.ii\n                            this.handleResolutionFailure(serviceConfigError);\n                        } else {\n                            // Step 4.i\n                            workingServiceConfig = this.previousServiceConfig;\n                        }\n                    }\n                } else {\n                    // Step 3\n                    workingServiceConfig = serviceConfig;\n                    this.previousServiceConfig = serviceConfig;\n                }\n                const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];\n                const loadBalancingConfig = load_balancer_1.getFirstUsableConfig(workingConfigList, true);\n                if (loadBalancingConfig === null) {\n                    // There were load balancing configs but none are supported. This counts as a resolution failure\n                    this.handleResolutionFailure({\n                        code: constants_1.Status.UNAVAILABLE,\n                        details: \"All load balancer options in service config are not compatible\",\n                        metadata: new metadata_1.Metadata()\n                    });\n                    return;\n                }\n                this.childLoadBalancer.updateAddressList(addressList, loadBalancingConfig, attributes);\n                const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;\n                this.onSuccessfulResolution(configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));\n            },\n            onError: (error)=>{\n                this.handleResolutionFailure(error);\n            }\n        }, channelOptions);\n        const backoffOptions = {\n            initialDelay: channelOptions[\"grpc.initial_reconnect_backoff_ms\"],\n            maxDelay: channelOptions[\"grpc.max_reconnect_backoff_ms\"]\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(()=>{\n            if (this.continueResolving) {\n                this.updateResolution();\n                this.continueResolving = false;\n            } else {\n                this.updateState(this.latestChildState, this.latestChildPicker);\n            }\n        }, backoffOptions);\n        this.backoffTimeout.unref();\n    }\n    updateResolution() {\n        this.innerResolver.updateResolution();\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        }\n        this.backoffTimeout.runOnce();\n    }\n    updateState(connectivityState, picker) {\n        trace(uri_parser_1.uriToString(this.target) + \" \" + connectivity_state_1.ConnectivityState[this.currentState] + \" -> \" + connectivity_state_1.ConnectivityState[connectivityState]);\n        // Ensure that this.exitIdle() is called by the picker\n        if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {\n            picker = new picker_1.QueuePicker(this);\n        }\n        this.currentState = connectivityState;\n        this.channelControlHelper.updateState(connectivityState, picker);\n    }\n    handleResolutionFailure(error) {\n        if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));\n            this.onFailedResolution(error);\n        }\n    }\n    exitIdle() {\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE || this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n            if (this.backoffTimeout.isRunning()) {\n                this.continueResolving = true;\n            } else {\n                this.updateResolution();\n            }\n        }\n        this.childLoadBalancer.exitIdle();\n    }\n    updateAddressList(addressList, lbConfig) {\n        throw new Error(\"updateAddressList not supported on ResolvingLoadBalancer\");\n    }\n    resetBackoff() {\n        this.backoffTimeout.reset();\n        this.childLoadBalancer.resetBackoff();\n    }\n    destroy() {\n        this.childLoadBalancer.destroy();\n        this.innerResolver.destroy();\n        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN, new picker_1.UnavailablePicker());\n    }\n    getTypeName() {\n        return \"resolving_load_balancer\";\n    }\n}\nexports.ResolvingLoadBalancer = ResolvingLoadBalancer; //# sourceMappingURL=resolving-load-balancer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWxvYWQtYmFsYW5jZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHLEtBQUs7QUFDckMsTUFBTUcsa0JBQWtCQyxtQkFBT0EsQ0FBQyxzRkFBaUI7QUFDakQsTUFBTUMsbUJBQW1CRCxtQkFBT0EsQ0FBQyx3RkFBa0I7QUFDbkQsTUFBTUUsdUJBQXVCRixtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTUcsYUFBYUgsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUksV0FBV0osbUJBQU9BLENBQUMsd0VBQVU7QUFDbkMsTUFBTUssb0JBQW9CTCxtQkFBT0EsQ0FBQywwRkFBbUI7QUFDckQsTUFBTU0sY0FBY04sbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTU8sYUFBYVAsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTVEsVUFBVVIsbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTVMsY0FBY1QsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTVUsZUFBZVYsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTVcsZ0NBQWdDWCxtQkFBT0EsQ0FBQyxrSEFBK0I7QUFDN0UsTUFBTVksY0FBYztBQUNwQixTQUFTQyxNQUFNQyxJQUFJO0lBQ2ZOLFFBQVFLLEtBQUssQ0FBQ0osWUFBWU0sWUFBWSxDQUFDQyxLQUFLLEVBQUVKLGFBQWFFO0FBQy9EO0FBQ0EsTUFBTUcsNkJBQTZCO0FBQ25DLFNBQVNDLHlCQUF5QkMsYUFBYTtJQUMzQyxPQUFPLFNBQVNDLHNCQUFzQkMsVUFBVSxFQUFFQyxRQUFRO1FBQ3RELElBQUlDLElBQUlDO1FBQ1IsTUFBTUMsWUFBWUosV0FBV0ssS0FBSyxDQUFDLEtBQUtDLE1BQU0sQ0FBQyxD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LENBQUNvRCxpQkFBaUIsRUFBRTtZQUNySixJQUFJLElBQUksQ0FBQ2xDLGNBQWMsQ0FBQ0MsU0FBUyxJQUFJO2dCQUNqQyxJQUFJLENBQUNiLGlCQUFpQixHQUFHO1lBQzdCLE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDYyxnQkFBZ0I7WUFDekI7UUFDSjtRQUNBLElBQUksQ0FBQ1AsaUJBQWlCLENBQUN5QyxRQUFRO0lBQ25DO0lBQ0FmLGtCQUFrQlosV0FBVyxFQUFFNEIsUUFBUSxFQUFFO1FBQ3JDLE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtJQUNBQyxlQUFlO1FBQ1gsSUFBSSxDQUFDdkMsY0FBYyxDQUFDd0MsS0FBSztRQUN6QixJQUFJLENBQUM3QyxpQkFBaUIsQ0FBQzRDLFlBQVk7SUFDdkM7SUFDQUUsVUFBVTtRQUNOLElBQUksQ0FBQzlDLGlCQUFpQixDQUFDOEMsT0FBTztRQUM5QixJQUFJLENBQUNsQyxhQUFhLENBQUNrQyxPQUFPO1FBQzFCLElBQUksQ0FBQy9DLFdBQVcsQ0FBQ3pELHFCQUFxQjZDLGlCQUFpQixDQUFDNEQsUUFBUSxFQUFFLElBQUl2RyxTQUFTZ0csaUJBQWlCO0lBQ3BHO0lBQ0FRLGNBQWM7UUFDVixPQUFPO0lBQ1g7QUFDSjtBQUNBaEgsNkJBQTZCLEdBQUdFLHVCQUNoQyxtREFBbUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc2htaXR0LWd1cHRhLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmluZy1sb2FkLWJhbGFuY2VyLmpzPzQ5N2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVzb2x2aW5nTG9hZEJhbGFuY2VyID0gdm9pZCAwO1xuY29uc3QgbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlclwiKTtcbmNvbnN0IHNlcnZpY2VfY29uZmlnXzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlLWNvbmZpZ1wiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5jb25zdCBiYWNrb2ZmX3RpbWVvdXRfMSA9IHJlcXVpcmUoXCIuL2JhY2tvZmYtdGltZW91dFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb25zdGFudHNfMiA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItY2hpbGQtaGFuZGxlclwiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3Jlc29sdmluZ19sb2FkX2JhbGFuY2VyJztcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18yLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xufVxuY29uc3QgREVGQVVMVF9MT0FEX0JBTEFOQ0VSX05BTUUgPSAncGlja19maXJzdCc7XG5mdW5jdGlvbiBnZXREZWZhdWx0Q29uZmlnU2VsZWN0b3Ioc2VydmljZUNvbmZpZykge1xuICAgIHJldHVybiBmdW5jdGlvbiBkZWZhdWx0Q29uZmlnU2VsZWN0b3IobWV0aG9kTmFtZSwgbWV0YWRhdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3Qgc3BsaXROYW1lID0gbWV0aG9kTmFtZS5zcGxpdCgnLycpLmZpbHRlcigoeCkgPT4geC5sZW5ndGggPiAwKTtcbiAgICAgICAgY29uc3Qgc2VydmljZSA9IChfYSA9IHNwbGl0TmFtZVswXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IChfYiA9IHNwbGl0TmFtZVsxXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyc7XG4gICAgICAgIGlmIChzZXJ2aWNlQ29uZmlnICYmIHNlcnZpY2VDb25maWcubWV0aG9kQ29uZmlnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1ldGhvZENvbmZpZyBvZiBzZXJ2aWNlQ29uZmlnLm1ldGhvZENvbmZpZykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBtZXRob2RDb25maWcubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZS5zZXJ2aWNlID09PSBzZXJ2aWNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAobmFtZS5tZXRob2QgPT09IHVuZGVmaW5lZCB8fCBuYW1lLm1ldGhvZCA9PT0gbWV0aG9kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RDb25maWc6IG1ldGhvZENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWNrSW5mb3JtYXRpb246IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogY29uc3RhbnRzXzEuU3RhdHVzLk9LLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5bmFtaWNGaWx0ZXJGYWN0b3JpZXM6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXRob2RDb25maWc6IHsgbmFtZTogW10gfSxcbiAgICAgICAgICAgIHBpY2tJbmZvcm1hdGlvbjoge30sXG4gICAgICAgICAgICBzdGF0dXM6IGNvbnN0YW50c18xLlN0YXR1cy5PSyxcbiAgICAgICAgICAgIGR5bmFtaWNGaWx0ZXJGYWN0b3JpZXM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbn1cbmNsYXNzIFJlc29sdmluZ0xvYWRCYWxhbmNlciB7XG4gICAgLyoqXG4gICAgICogV3JhcHBlciBjbGFzcyB0aGF0IGJlaGF2ZXMgbGlrZSBhIGBMb2FkQmFsYW5jZXJgIGFuZCBhbHNvIGhhbmRsZXMgbmFtZVxuICAgICAqIHJlc29sdXRpb24gaW50ZXJuYWxseS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSBhZGRyZXNzIG9mIHRoZSBiYWNrZW5kIHRvIGNvbm5lY3QgdG8uXG4gICAgICogQHBhcmFtIGNoYW5uZWxDb250cm9sSGVscGVyIGBDaGFubmVsQ29udHJvbEhlbHBlcmAgaW5zdGFuY2UgcHJvdmlkZWQgYnlcbiAgICAgKiAgICAgdGhpcyBsb2FkIGJhbGFuY2VyJ3Mgb3duZXIuXG4gICAgICogQHBhcmFtIGRlZmF1bHRTZXJ2aWNlQ29uZmlnIFRoZSBkZWZhdWx0IHNlcnZpY2UgY29uZmlndXJhdGlvbiB0byBiZSB1c2VkXG4gICAgICogICAgIGlmIG5vbmUgaXMgcHJvdmlkZWQgYnkgdGhlIG5hbWUgcmVzb2x2ZXIuIEEgYG51bGxgIHZhbHVlIGluZGljYXRlc1xuICAgICAqICAgICB0aGF0IHRoZSBkZWZhdWx0IGJlaGF2aW9yIHNob3VsZCBiZSB0aGUgZGVmYXVsdCB1bmNvbmZpZ3VyZWQgYmVoYXZpb3IuXG4gICAgICogICAgIEluIHByYWN0aWNlLCB0aGF0IG1lYW5zIHVzaW5nIHRoZSBcInBpY2sgZmlyc3RcIiBsb2FkIGJhbGFuY2VyXG4gICAgICogICAgIGltcGxtZW50YXRpb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGNoYW5uZWxDb250cm9sSGVscGVyLCBjaGFubmVsT3B0aW9ucywgb25TdWNjZXNzZnVsUmVzb2x1dGlvbiwgb25GYWlsZWRSZXNvbHV0aW9uKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyID0gY2hhbm5lbENvbnRyb2xIZWxwZXI7XG4gICAgICAgIHRoaXMuY2hhbm5lbE9wdGlvbnMgPSBjaGFubmVsT3B0aW9ucztcbiAgICAgICAgdGhpcy5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uID0gb25TdWNjZXNzZnVsUmVzb2x1dGlvbjtcbiAgICAgICAgdGhpcy5vbkZhaWxlZFJlc29sdXRpb24gPSBvbkZhaWxlZFJlc29sdXRpb247XG4gICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRQaWNrZXIgPSBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHJlc29sdmluZyBsb2FkIGJhbGFuY2VyJ3MgY3VycmVudCBjb25uZWN0aXZpdHkgc3RhdGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2VydmljZSBjb25maWcgb2JqZWN0IGZyb20gdGhlIGxhc3Qgc3VjY2Vzc2Z1bCByZXNvbHV0aW9uLCBpZlxuICAgICAgICAgKiBhdmFpbGFibGUuIEEgdmFsdWUgb2YgbnVsbCBpbmRpY2F0ZXMgdGhhdCB3ZSBoYXZlIG5vdCB5ZXQgcmVjZWl2ZWQgYSB2YWxpZFxuICAgICAgICAgKiBzZXJ2aWNlIGNvbmZpZyBmcm9tIHRoZSByZXNvbHZlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldmlvdXNTZXJ2aWNlQ29uZmlnID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHdlIHNob3VsZCBhdHRlbXB0IHRvIHJlc29sdmUgYWdhaW4gYWZ0ZXIgdGhlIGJhY2tvZmZcbiAgICAgICAgICogdGltZXIgcnVucyBvdXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChjaGFubmVsT3B0aW9uc1snZ3JwYy5zZXJ2aWNlX2NvbmZpZyddKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRTZXJ2aWNlQ29uZmlnID0gc2VydmljZV9jb25maWdfMS52YWxpZGF0ZVNlcnZpY2VDb25maWcoSlNPTi5wYXJzZShjaGFubmVsT3B0aW9uc1snZ3JwYy5zZXJ2aWNlX2NvbmZpZyddKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRTZXJ2aWNlQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgIGxvYWRCYWxhbmNpbmdDb25maWc6IFtdLFxuICAgICAgICAgICAgICAgIG1ldGhvZENvbmZpZzogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSwgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpKTtcbiAgICAgICAgdGhpcy5jaGlsZExvYWRCYWxhbmNlciA9IG5ldyBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMS5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXIoe1xuICAgICAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogY2hhbm5lbENvbnRyb2xIZWxwZXIuY3JlYXRlU3ViY2hhbm5lbC5iaW5kKGNoYW5uZWxDb250cm9sSGVscGVyKSxcbiAgICAgICAgICAgIHJlcXVlc3RSZXJlc29sdXRpb246ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvKiBJZiB0aGUgYmFja29mZlRpbWVvdXQgaXMgcnVubmluZywgd2UncmUgc3RpbGwgYmFja2luZyBvZmYgZnJvbVxuICAgICAgICAgICAgICAgICAqIG1ha2luZyByZXNvbHZlIHJlcXVlc3RzLCBzbyB3ZSBzaG91bGRuJ3QgbWFrZSBhbm90aGVyIG9uZSBoZXJlLlxuICAgICAgICAgICAgICAgICAqIEluIHRoYXQgY2FzZSwgdGhlIGJhY2tvZmYgdGltZXIgY2FsbGJhY2sgd2lsbCBjYWxsXG4gICAgICAgICAgICAgICAgICogdXBkYXRlUmVzb2x1dGlvbiAqL1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJhY2tvZmZUaW1lb3V0LmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZXNvbHV0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlOiAobmV3U3RhdGUsIHBpY2tlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRQaWNrZXIgPSBwaWNrZXI7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRDaGFubmVsekNoaWxkOiBjaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkLmJpbmQoY2hhbm5lbENvbnRyb2xIZWxwZXIpLFxuICAgICAgICAgICAgcmVtb3ZlQ2hhbm5lbHpDaGlsZDogY2hhbm5lbENvbnRyb2xIZWxwZXIucmVtb3ZlQ2hhbm5lbHpDaGlsZC5iaW5kKGNoYW5uZWxDb250cm9sSGVscGVyKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbm5lclJlc29sdmVyID0gcmVzb2x2ZXJfMS5jcmVhdGVSZXNvbHZlcih0YXJnZXQsIHtcbiAgICAgICAgICAgIG9uU3VjY2Vzc2Z1bFJlc29sdXRpb246IChhZGRyZXNzTGlzdCwgc2VydmljZUNvbmZpZywgc2VydmljZUNvbmZpZ0Vycm9yLCBjb25maWdTZWxlY3RvciwgYXR0cmlidXRlcykgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBsZXQgd29ya2luZ1NlcnZpY2VDb25maWcgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8qIFRoaXMgZmlyc3QgZ3JvdXAgb2YgY29uZGl0aW9uYWxzIGltcGxlbWVudHMgdGhlIGFsZ29yaXRobSBkZXNjcmliZWRcbiAgICAgICAgICAgICAgICAgKiBpbiBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9wcm9wb3NhbC9ibG9iL21hc3Rlci9BMjEtc2VydmljZS1jb25maWctZXJyb3ItaGFuZGxpbmcubWRcbiAgICAgICAgICAgICAgICAgKiBpbiB0aGUgc2VjdGlvbiBjYWxsZWQgXCJCZWhhdmlvciBvbiByZWNlaXZpbmcgYSBuZXcgZ1JQQyBDb25maWdcIi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoc2VydmljZUNvbmZpZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGVwIDQgYW5kIDVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcnZpY2VDb25maWdFcnJvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCA1XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nU2VydmljZUNvbmZpZyA9IHRoaXMuZGVmYXVsdFNlcnZpY2VDb25maWc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGVwIDRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgNC5paVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzb2x1dGlvbkZhaWx1cmUoc2VydmljZUNvbmZpZ0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgNC5pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ1NlcnZpY2VDb25maWcgPSB0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCAzXG4gICAgICAgICAgICAgICAgICAgIHdvcmtpbmdTZXJ2aWNlQ29uZmlnID0gc2VydmljZUNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWcgPSBzZXJ2aWNlQ29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB3b3JraW5nQ29uZmlnTGlzdCA9IChfYSA9IHdvcmtpbmdTZXJ2aWNlQ29uZmlnID09PSBudWxsIHx8IHdvcmtpbmdTZXJ2aWNlQ29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3b3JraW5nU2VydmljZUNvbmZpZy5sb2FkQmFsYW5jaW5nQ29uZmlnKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2FkQmFsYW5jaW5nQ29uZmlnID0gbG9hZF9iYWxhbmNlcl8xLmdldEZpcnN0VXNhYmxlQ29uZmlnKHdvcmtpbmdDb25maWdMaXN0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAobG9hZEJhbGFuY2luZ0NvbmZpZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSB3ZXJlIGxvYWQgYmFsYW5jaW5nIGNvbmZpZ3MgYnV0IG5vbmUgYXJlIHN1cHBvcnRlZC4gVGhpcyBjb3VudHMgYXMgYSByZXNvbHV0aW9uIGZhaWx1cmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXNvbHV0aW9uRmFpbHVyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAnQWxsIGxvYWQgYmFsYW5jZXIgb3B0aW9ucyBpbiBzZXJ2aWNlIGNvbmZpZyBhcmUgbm90IGNvbXBhdGlibGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRMb2FkQmFsYW5jZXIudXBkYXRlQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGxvYWRCYWxhbmNpbmdDb25maWcsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsU2VydmljZUNvbmZpZyA9IHdvcmtpbmdTZXJ2aWNlQ29uZmlnICE9PSBudWxsICYmIHdvcmtpbmdTZXJ2aWNlQ29uZmlnICE9PSB2b2lkIDAgPyB3b3JraW5nU2VydmljZUNvbmZpZyA6IHRoaXMuZGVmYXVsdFNlcnZpY2VDb25maWc7XG4gICAgICAgICAgICAgICAgdGhpcy5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uKGNvbmZpZ1NlbGVjdG9yICE9PSBudWxsICYmIGNvbmZpZ1NlbGVjdG9yICE9PSB2b2lkIDAgPyBjb25maWdTZWxlY3RvciA6IGdldERlZmF1bHRDb25maWdTZWxlY3RvcihmaW5hbFNlcnZpY2VDb25maWcpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc29sdXRpb25GYWlsdXJlKGVycm9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIGNoYW5uZWxPcHRpb25zKTtcbiAgICAgICAgY29uc3QgYmFja29mZk9wdGlvbnMgPSB7XG4gICAgICAgICAgICBpbml0aWFsRGVsYXk6IGNoYW5uZWxPcHRpb25zWydncnBjLmluaXRpYWxfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgICAgIG1heERlbGF5OiBjaGFubmVsT3B0aW9uc1snZ3JwYy5tYXhfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dCA9IG5ldyBiYWNrb2ZmX3RpbWVvdXRfMS5CYWNrb2ZmVGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250aW51ZVJlc29sdmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUmVzb2x1dGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUodGhpcy5sYXRlc3RDaGlsZFN0YXRlLCB0aGlzLmxhdGVzdENoaWxkUGlja2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgYmFja29mZk9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnVucmVmKCk7XG4gICAgfVxuICAgIHVwZGF0ZVJlc29sdXRpb24oKSB7XG4gICAgICAgIHRoaXMuaW5uZXJSZXNvbHZlci51cGRhdGVSZXNvbHV0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HLCBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucnVuT25jZSgpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKSB7XG4gICAgICAgIHRyYWNlKHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZyh0aGlzLnRhcmdldCkgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3RoaXMuY3VycmVudFN0YXRlXSArXG4gICAgICAgICAgICAnIC0+ICcgK1xuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbY29ubmVjdGl2aXR5U3RhdGVdKTtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhpcy5leGl0SWRsZSgpIGlzIGNhbGxlZCBieSB0aGUgcGlja2VyXG4gICAgICAgIGlmIChjb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xuICAgICAgICAgICAgcGlja2VyID0gbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gY29ubmVjdGl2aXR5U3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlcik7XG4gICAgfVxuICAgIGhhbmRsZVJlc29sdXRpb25GYWlsdXJlKGVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLmxhdGVzdENoaWxkU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUsIG5ldyBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcihlcnJvcikpO1xuICAgICAgICAgICAgdGhpcy5vbkZhaWxlZFJlc29sdXRpb24oZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4aXRJZGxlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUgfHwgdGhpcy5jdXJyZW50U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5iYWNrb2ZmVGltZW91dC5pc1J1bm5pbmcoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZXNvbHV0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGlsZExvYWRCYWxhbmNlci5leGl0SWRsZSgpO1xuICAgIH1cbiAgICB1cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1cGRhdGVBZGRyZXNzTGlzdCBub3Qgc3VwcG9ydGVkIG9uIFJlc29sdmluZ0xvYWRCYWxhbmNlcicpO1xuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucmVzZXQoKTtcbiAgICAgICAgdGhpcy5jaGlsZExvYWRCYWxhbmNlci5yZXNldEJhY2tvZmYoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jaGlsZExvYWRCYWxhbmNlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaW5uZXJSZXNvbHZlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV04sIG5ldyBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcigpKTtcbiAgICB9XG4gICAgZ2V0VHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiAncmVzb2x2aW5nX2xvYWRfYmFsYW5jZXInO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVzb2x2aW5nTG9hZEJhbGFuY2VyID0gUmVzb2x2aW5nTG9hZEJhbGFuY2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2aW5nLWxvYWQtYmFsYW5jZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUmVzb2x2aW5nTG9hZEJhbGFuY2VyIiwibG9hZF9iYWxhbmNlcl8xIiwicmVxdWlyZSIsInNlcnZpY2VfY29uZmlnXzEiLCJjb25uZWN0aXZpdHlfc3RhdGVfMSIsInJlc29sdmVyXzEiLCJwaWNrZXJfMSIsImJhY2tvZmZfdGltZW91dF8xIiwiY29uc3RhbnRzXzEiLCJtZXRhZGF0YV8xIiwibG9nZ2luZyIsImNvbnN0YW50c18yIiwidXJpX3BhcnNlcl8xIiwibG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEiLCJUUkFDRVJfTkFNRSIsInRyYWNlIiwidGV4dCIsIkxvZ1ZlcmJvc2l0eSIsIkRFQlVHIiwiREVGQVVMVF9MT0FEX0JBTEFOQ0VSX05BTUUiLCJnZXREZWZhdWx0Q29uZmlnU2VsZWN0b3IiLCJzZXJ2aWNlQ29uZmlnIiwiZGVmYXVsdENvbmZpZ1NlbGVjdG9yIiwibWV0aG9kTmFtZSIsIm1ldGFkYXRhIiwiX2EiLCJfYiIsInNwbGl0TmFtZSIsInNwbGl0IiwiZmlsdGVyIiwieCIsImxlbmd0aCIsInNlcnZpY2UiLCJtZXRob2QiLCJtZXRob2RDb25maWciLCJuYW1lIiwidW5kZWZpbmVkIiwicGlja0luZm9ybWF0aW9uIiwic3RhdHVzIiwiU3RhdHVzIiwiT0siLCJkeW5hbWljRmlsdGVyRmFjdG9yaWVzIiwiY29uc3RydWN0b3IiLCJ0YXJnZXQiLCJjaGFubmVsQ29udHJvbEhlbHBlciIsImNoYW5uZWxPcHRpb25zIiwib25TdWNjZXNzZnVsUmVzb2x1dGlvbiIsIm9uRmFpbGVkUmVzb2x1dGlvbiIsImxhdGVzdENoaWxkU3RhdGUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIklETEUiLCJsYXRlc3RDaGlsZFBpY2tlciIsIlF1ZXVlUGlja2VyIiwiY3VycmVudFN0YXRlIiwicHJldmlvdXNTZXJ2aWNlQ29uZmlnIiwiY29udGludWVSZXNvbHZpbmciLCJkZWZhdWx0U2VydmljZUNvbmZpZyIsInZhbGlkYXRlU2VydmljZUNvbmZpZyIsIkpTT04iLCJwYXJzZSIsImxvYWRCYWxhbmNpbmdDb25maWciLCJ1cGRhdGVTdGF0ZSIsImNoaWxkTG9hZEJhbGFuY2VyIiwiQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyIiwiY3JlYXRlU3ViY2hhbm5lbCIsImJpbmQiLCJyZXF1ZXN0UmVyZXNvbHV0aW9uIiwiYmFja29mZlRpbWVvdXQiLCJpc1J1bm5pbmciLCJ1cGRhdGVSZXNvbHV0aW9uIiwibmV3U3RhdGUiLCJwaWNrZXIiLCJhZGRDaGFubmVsekNoaWxkIiwicmVtb3ZlQ2hhbm5lbHpDaGlsZCIsImlubmVyUmVzb2x2ZXIiLCJjcmVhdGVSZXNvbHZlciIsImFkZHJlc3NMaXN0Iiwic2VydmljZUNvbmZpZ0Vycm9yIiwiY29uZmlnU2VsZWN0b3IiLCJhdHRyaWJ1dGVzIiwid29ya2luZ1NlcnZpY2VDb25maWciLCJoYW5kbGVSZXNvbHV0aW9uRmFpbHVyZSIsIndvcmtpbmdDb25maWdMaXN0IiwiZ2V0Rmlyc3RVc2FibGVDb25maWciLCJjb2RlIiwiVU5BVkFJTEFCTEUiLCJkZXRhaWxzIiwiTWV0YWRhdGEiLCJ1cGRhdGVBZGRyZXNzTGlzdCIsImZpbmFsU2VydmljZUNvbmZpZyIsIm9uRXJyb3IiLCJlcnJvciIsImJhY2tvZmZPcHRpb25zIiwiaW5pdGlhbERlbGF5IiwibWF4RGVsYXkiLCJCYWNrb2ZmVGltZW91dCIsInVucmVmIiwiQ09OTkVDVElORyIsInJ1bk9uY2UiLCJjb25uZWN0aXZpdHlTdGF0ZSIsInVyaVRvU3RyaW5nIiwiVFJBTlNJRU5UX0ZBSUxVUkUiLCJVbmF2YWlsYWJsZVBpY2tlciIsImV4aXRJZGxlIiwibGJDb25maWciLCJFcnJvciIsInJlc2V0QmFja29mZiIsInJlc2V0IiwiZGVzdHJveSIsIlNIVVRET1dOIiwiZ2V0VHlwZU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/server-call.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-call.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Http2ServerCallStream = exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = \"server_call\";\nconst unzip = util_1.promisify(zlib.unzip);\nconst inflate = util_1.promisify(zlib.inflate);\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst GRPC_ACCEPT_ENCODING_HEADER = \"grpc-accept-encoding\";\nconst GRPC_ENCODING_HEADER = \"grpc-encoding\";\nconst GRPC_MESSAGE_HEADER = \"grpc-message\";\nconst GRPC_STATUS_HEADER = \"grpc-status\";\nconst GRPC_TIMEOUT_HEADER = \"grpc-timeout\";\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs = {\n    H: 3600000,\n    M: 60000,\n    S: 1000,\n    m: 1,\n    u: 0.001,\n    n: 0.000001\n};\nconst defaultResponseHeaders = {\n    // TODO(cjihrig): Remove these encoding headers from the default response\n    // once compression is integrated.\n    [GRPC_ACCEPT_ENCODING_HEADER]: \"identity,deflate,gzip\",\n    [GRPC_ENCODING_HEADER]: \"identity\",\n    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: \"application/grpc+proto\"\n};\nconst defaultResponseOptions = {\n    waitForTrailers: true\n};\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\n    constructor(call, metadata, request){\n        super();\n        this.call = call;\n        this.metadata = metadata;\n        this.request = request;\n        this.cancelled = false;\n        this.call.setupSurfaceCall(this);\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n}\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\nclass ServerReadableStreamImpl extends stream_1.Readable {\n    constructor(call, metadata, deserialize, encoding){\n        super({\n            objectMode: true\n        });\n        this.call = call;\n        this.metadata = metadata;\n        this.deserialize = deserialize;\n        this.cancelled = false;\n        this.call.setupSurfaceCall(this);\n        this.call.setupReadable(this, encoding);\n    }\n    _read(size) {\n        if (!this.call.consumeUnpushedMessages(this)) {\n            return;\n        }\n        this.call.resume();\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n}\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\nclass ServerWritableStreamImpl extends stream_1.Writable {\n    constructor(call, metadata, serialize, request){\n        super({\n            objectMode: true\n        });\n        this.call = call;\n        this.metadata = metadata;\n        this.serialize = serialize;\n        this.request = request;\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.call.setupSurfaceCall(this);\n        this.on(\"error\", (err)=>{\n            this.call.sendError(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n    _write(chunk, encoding, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback) {\n        try {\n            const response = this.call.serializeMessage(chunk);\n            if (!this.call.write(response)) {\n                this.call.once(\"drain\", callback);\n                return;\n            }\n        } catch (err) {\n            err.code = constants_1.Status.INTERNAL;\n            this.emit(\"error\", err);\n        }\n        callback();\n    }\n    _final(callback) {\n        this.call.sendStatus({\n            code: constants_1.Status.OK,\n            details: \"OK\",\n            metadata: this.trailingMetadata\n        });\n        callback(null);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        return super.end();\n    }\n}\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\n    constructor(call, metadata, serialize, deserialize, encoding){\n        super({\n            objectMode: true\n        });\n        this.call = call;\n        this.metadata = metadata;\n        this.serialize = serialize;\n        this.deserialize = deserialize;\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.call.setupSurfaceCall(this);\n        this.call.setupReadable(this, encoding);\n        this.on(\"error\", (err)=>{\n            this.call.sendError(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        return super.end();\n    }\n}\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\nServerDuplexStreamImpl.prototype._read = ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write = ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final = ServerWritableStreamImpl.prototype._final;\n// Internal class that wraps the HTTP2 request.\nclass Http2ServerCallStream extends events_1.EventEmitter {\n    constructor(stream, handler, options){\n        super();\n        this.stream = stream;\n        this.handler = handler;\n        this.options = options;\n        this.cancelled = false;\n        this.deadlineTimer = null;\n        this.statusSent = false;\n        this.deadline = Infinity;\n        this.wantTrailers = false;\n        this.metadataSent = false;\n        this.canPush = false;\n        this.isPushPending = false;\n        this.bufferedMessages = [];\n        this.messagesToPush = [];\n        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        this.stream.once(\"error\", (err)=>{\n        /* We need an error handler to avoid uncaught error event exceptions, but\n             * there is nothing we can reasonably do here. Any error event should\n             * have a corresponding close event, which handles emitting the cancelled\n             * event. And the stream is now in a bad state, so we can't reasonably\n             * expect to be able to send an error over it. */ });\n        this.stream.once(\"close\", ()=>{\n            var _a;\n            trace(\"Request to method \" + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + \" stream closed with rstCode \" + this.stream.rstCode);\n            if (!this.statusSent) {\n                this.cancelled = true;\n                this.emit(\"cancelled\", \"cancelled\");\n                this.emit(\"streamEnd\", false);\n                this.sendStatus({\n                    code: constants_1.Status.CANCELLED,\n                    details: \"Cancelled by client\",\n                    metadata: null\n                });\n            }\n        });\n        this.stream.on(\"drain\", ()=>{\n            this.emit(\"drain\");\n        });\n        if (\"grpc.max_send_message_length\" in options) {\n            this.maxSendMessageSize = options[\"grpc.max_send_message_length\"];\n        }\n        if (\"grpc.max_receive_message_length\" in options) {\n            this.maxReceiveMessageSize = options[\"grpc.max_receive_message_length\"];\n        }\n    }\n    checkCancelled() {\n        /* In some cases the stream can become destroyed before the close event\n         * fires. That creates a race condition that this check works around */ if (this.stream.destroyed || this.stream.closed) {\n            this.cancelled = true;\n        }\n        return this.cancelled;\n    }\n    getDecompressedMessage(message, encoding) {\n        if (encoding === \"deflate\") {\n            return inflate(message.subarray(5));\n        } else if (encoding === \"gzip\") {\n            return unzip(message.subarray(5));\n        } else if (encoding === \"identity\") {\n            return message.subarray(5);\n        }\n        return Promise.reject({\n            code: constants_1.Status.UNIMPLEMENTED,\n            details: `Received message compressed with unsupported encoding \"${encoding}\"`\n        });\n    }\n    sendMetadata(customMetadata) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.metadataSent) {\n            return;\n        }\n        this.metadataSent = true;\n        const custom = customMetadata ? customMetadata.toHttp2Headers() : null;\n        // TODO(cjihrig): Include compression headers.\n        const headers = Object.assign(Object.assign({}, defaultResponseHeaders), custom);\n        this.stream.respond(headers, defaultResponseOptions);\n    }\n    receiveMetadata(headers) {\n        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        if (logging.isTracerEnabled(TRACER_NAME)) {\n            trace(\"Request to \" + this.handler.path + \" received headers \" + JSON.stringify(metadata.toJSON()));\n        }\n        // TODO(cjihrig): Receive compression metadata.\n        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n        if (timeoutHeader.length > 0) {\n            const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n            if (match === null) {\n                const err = new Error(\"Invalid deadline\");\n                err.code = constants_1.Status.OUT_OF_RANGE;\n                this.sendError(err);\n                return metadata;\n            }\n            const timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;\n            const now = new Date();\n            this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n            this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n            metadata.remove(GRPC_TIMEOUT_HEADER);\n        }\n        // Remove several headers that should not be propagated to the application\n        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n        metadata.remove(http2.constants.HTTP2_HEADER_TE);\n        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n        metadata.remove(\"grpc-accept-encoding\");\n        return metadata;\n    }\n    receiveUnaryMessage(encoding, next) {\n        const { stream } = this;\n        let receivedLength = 0;\n        const call = this;\n        const body = [];\n        const limit = this.maxReceiveMessageSize;\n        stream.on(\"data\", onData);\n        stream.on(\"end\", onEnd);\n        stream.on(\"error\", onEnd);\n        function onData(chunk) {\n            receivedLength += chunk.byteLength;\n            if (limit !== -1 && receivedLength > limit) {\n                stream.removeListener(\"data\", onData);\n                stream.removeListener(\"end\", onEnd);\n                stream.removeListener(\"error\", onEnd);\n                next({\n                    code: constants_1.Status.RESOURCE_EXHAUSTED,\n                    details: `Received message larger than max (${receivedLength} vs. ${limit})`\n                });\n                return;\n            }\n            body.push(chunk);\n        }\n        function onEnd(err) {\n            stream.removeListener(\"data\", onData);\n            stream.removeListener(\"end\", onEnd);\n            stream.removeListener(\"error\", onEnd);\n            if (err !== undefined) {\n                next({\n                    code: constants_1.Status.INTERNAL,\n                    details: err.message\n                });\n                return;\n            }\n            if (receivedLength === 0) {\n                next({\n                    code: constants_1.Status.INTERNAL,\n                    details: \"received empty unary message\"\n                });\n                return;\n            }\n            call.emit(\"receiveMessage\");\n            const requestBytes = Buffer.concat(body, receivedLength);\n            const compressed = requestBytes.readUInt8(0) === 1;\n            const compressedMessageEncoding = compressed ? encoding : \"identity\";\n            const decompressedMessage = call.getDecompressedMessage(requestBytes, compressedMessageEncoding);\n            if (Buffer.isBuffer(decompressedMessage)) {\n                call.safeDeserializeMessage(decompressedMessage, next);\n                return;\n            }\n            decompressedMessage.then((decompressed)=>call.safeDeserializeMessage(decompressed, next), (err)=>next(err.code ? err : {\n                    code: constants_1.Status.INTERNAL,\n                    details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`\n                }));\n        }\n    }\n    safeDeserializeMessage(buffer, next) {\n        try {\n            next(null, this.deserializeMessage(buffer));\n        } catch (err) {\n            err.code = constants_1.Status.INTERNAL;\n            next(err);\n        }\n    }\n    serializeMessage(value) {\n        const messageBuffer = this.handler.serialize(value);\n        // TODO(cjihrig): Call compression aware serializeMessage().\n        const byteLength = messageBuffer.byteLength;\n        const output = Buffer.allocUnsafe(byteLength + 5);\n        output.writeUInt8(0, 0);\n        output.writeUInt32BE(byteLength, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    deserializeMessage(bytes) {\n        return this.handler.deserialize(bytes);\n    }\n    async sendUnaryMessage(err, value, metadata, flags) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (metadata === undefined) {\n            metadata = null;\n        }\n        if (err) {\n            if (!Object.prototype.hasOwnProperty.call(err, \"metadata\") && metadata) {\n                err.metadata = metadata;\n            }\n            this.sendError(err);\n            return;\n        }\n        try {\n            const response = this.serializeMessage(value);\n            this.write(response);\n            this.sendStatus({\n                code: constants_1.Status.OK,\n                details: \"OK\",\n                metadata\n            });\n        } catch (err) {\n            err.code = constants_1.Status.INTERNAL;\n            this.sendError(err);\n        }\n    }\n    sendStatus(statusObj) {\n        var _a;\n        this.emit(\"callEnd\", statusObj.code);\n        this.emit(\"streamEnd\", statusObj.code === constants_1.Status.OK);\n        if (this.checkCancelled()) {\n            return;\n        }\n        trace(\"Request to method \" + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + \" ended with status code: \" + constants_1.Status[statusObj.code] + \" details: \" + statusObj.details);\n        if (this.deadlineTimer) clearTimeout(this.deadlineTimer);\n        if (!this.wantTrailers) {\n            this.wantTrailers = true;\n            this.stream.once(\"wantTrailers\", ()=>{\n                var _a;\n                const trailersToSend = Object.assign({\n                    [GRPC_STATUS_HEADER]: statusObj.code,\n                    [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details)\n                }, (_a = statusObj.metadata) === null || _a === void 0 ? void 0 : _a.toHttp2Headers());\n                this.stream.sendTrailers(trailersToSend);\n                this.statusSent = true;\n            });\n            this.sendMetadata();\n            this.stream.end();\n        }\n    }\n    sendError(error) {\n        const status = {\n            code: constants_1.Status.UNKNOWN,\n            details: \"message\" in error ? error.message : \"Unknown Error\",\n            metadata: \"metadata\" in error && error.metadata !== undefined ? error.metadata : null\n        };\n        if (\"code\" in error && typeof error.code === \"number\" && Number.isInteger(error.code)) {\n            status.code = error.code;\n            if (\"details\" in error && typeof error.details === \"string\") {\n                status.details = error.details;\n            }\n        }\n        this.sendStatus(status);\n    }\n    write(chunk) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.maxSendMessageSize !== -1 && chunk.length > this.maxSendMessageSize) {\n            this.sendError({\n                code: constants_1.Status.RESOURCE_EXHAUSTED,\n                details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`\n            });\n            return;\n        }\n        this.sendMetadata();\n        this.emit(\"sendMessage\");\n        return this.stream.write(chunk);\n    }\n    resume() {\n        this.stream.resume();\n    }\n    setupSurfaceCall(call) {\n        this.once(\"cancelled\", (reason)=>{\n            call.cancelled = true;\n            call.emit(\"cancelled\", reason);\n        });\n        this.once(\"callEnd\", (status)=>call.emit(\"callEnd\", status));\n    }\n    setupReadable(readable, encoding) {\n        const decoder = new stream_decoder_1.StreamDecoder();\n        let readsDone = false;\n        let pendingMessageProcessing = false;\n        let pushedEnd = false;\n        const maybePushEnd = ()=>{\n            if (!pushedEnd && readsDone && !pendingMessageProcessing) {\n                pushedEnd = true;\n                this.pushOrBufferMessage(readable, null);\n            }\n        };\n        this.stream.on(\"data\", async (data)=>{\n            const messages = decoder.write(data);\n            pendingMessageProcessing = true;\n            this.stream.pause();\n            for (const message of messages){\n                if (this.maxReceiveMessageSize !== -1 && message.length > this.maxReceiveMessageSize) {\n                    this.sendError({\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\n                        details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`\n                    });\n                    return;\n                }\n                this.emit(\"receiveMessage\");\n                const compressed = message.readUInt8(0) === 1;\n                const compressedMessageEncoding = compressed ? encoding : \"identity\";\n                const decompressedMessage = await this.getDecompressedMessage(message, compressedMessageEncoding);\n                // Encountered an error with decompression; it'll already have been propogated back\n                // Just return early\n                if (!decompressedMessage) return;\n                this.pushOrBufferMessage(readable, decompressedMessage);\n            }\n            pendingMessageProcessing = false;\n            this.stream.resume();\n            maybePushEnd();\n        });\n        this.stream.once(\"end\", ()=>{\n            readsDone = true;\n            maybePushEnd();\n        });\n    }\n    consumeUnpushedMessages(readable) {\n        this.canPush = true;\n        while(this.messagesToPush.length > 0){\n            const nextMessage = this.messagesToPush.shift();\n            const canPush = readable.push(nextMessage);\n            if (nextMessage === null || canPush === false) {\n                this.canPush = false;\n                break;\n            }\n        }\n        return this.canPush;\n    }\n    pushOrBufferMessage(readable, messageBytes) {\n        if (this.isPushPending) {\n            this.bufferedMessages.push(messageBytes);\n        } else {\n            this.pushMessage(readable, messageBytes);\n        }\n    }\n    async pushMessage(readable, messageBytes) {\n        if (messageBytes === null) {\n            trace(\"Received end of stream\");\n            if (this.canPush) {\n                readable.push(null);\n            } else {\n                this.messagesToPush.push(null);\n            }\n            return;\n        }\n        trace(\"Received message of length \" + messageBytes.length);\n        this.isPushPending = true;\n        try {\n            const deserialized = await this.deserializeMessage(messageBytes);\n            if (this.canPush) {\n                if (!readable.push(deserialized)) {\n                    this.canPush = false;\n                    this.stream.pause();\n                }\n            } else {\n                this.messagesToPush.push(deserialized);\n            }\n        } catch (error) {\n            // Ignore any remaining messages when errors occur.\n            this.bufferedMessages.length = 0;\n            if (!(\"code\" in error && typeof error.code === \"number\" && Number.isInteger(error.code) && error.code >= constants_1.Status.OK && error.code <= constants_1.Status.UNAUTHENTICATED)) {\n                // The error code is not a valid gRPC code so its being overwritten.\n                error.code = constants_1.Status.INTERNAL;\n            }\n            readable.emit(\"error\", error);\n        }\n        this.isPushPending = false;\n        if (this.bufferedMessages.length > 0) {\n            this.pushMessage(readable, this.bufferedMessages.shift());\n        }\n    }\n    getPeer() {\n        const socket = this.stream.session.socket;\n        if (socket.remoteAddress) {\n            if (socket.remotePort) {\n                return `${socket.remoteAddress}:${socket.remotePort}`;\n            } else {\n                return socket.remoteAddress;\n            }\n        } else {\n            return \"unknown\";\n        }\n    }\n    getDeadline() {\n        return this.deadline;\n    }\n    getPath() {\n        return this.handler.path;\n    }\n}\nexports.Http2ServerCallStream = Http2ServerCallStream;\nfunction handleExpiredDeadline(call) {\n    const err = new Error(\"Deadline exceeded\");\n    err.code = constants_1.Status.DEADLINE_EXCEEDED;\n    call.sendError(err);\n    call.cancelled = true;\n    call.emit(\"cancelled\", \"deadline\");\n} //# sourceMappingURL=server-call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNhbGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHQSw4QkFBOEIsR0FBR0EsZ0NBQWdDLEdBQUdBLGdDQUFnQyxHQUFHQSwyQkFBMkIsR0FBRyxLQUFLO0FBQzFLLE1BQU1PLFdBQVdDLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDLE1BQU1DLFFBQVFELG1CQUFPQSxDQUFDLG9CQUFPO0FBQzdCLE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDLE1BQU1HLE9BQU9ILG1CQUFPQSxDQUFDLGtCQUFNO0FBQzNCLE1BQU1JLFNBQVNKLG1CQUFPQSxDQUFDLGtCQUFNO0FBQzdCLE1BQU1LLGNBQWNMLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1NLGFBQWFOLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1PLG1CQUFtQlAsbUJBQU9BLENBQUMsd0ZBQWtCO0FBQ25ELE1BQU1RLFVBQVVSLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1TLGNBQWM7QUFDcEIsTUFBTUMsUUFBUU4sT0FBT08sU0FBUyxDQUFDUixLQUFLTyxLQUFLO0FBQ3pDLE1BQU1FLFVBQVVSLE9BQU9PLFNBQVMsQ0FBQ1IsS0FBS1MsT0FBTztBQUM3QyxTQUFTQyxNQUFNQyxJQUFJO0lBQ2ZOLFFBQVFLLEtBQUssQ0FBQ1IsWUFBWVUsWUFBWSxDQUFDQyxLQUFLLEVBQUVQLGFBQWFLO0FBQy9EO0FBQ0EsTUFBTUcsOEJBQThCO0FBQ3BDLE1BQU1DLHVCQUF1QjtBQUM3QixNQUFNQyxzQkFBc0I7QUFDNUIsTUFBTUMscUJBQXFCO0FBQzNCLE1BQU1DLHNCQUFzQjtBQUM1QixNQUFNQyxpQkFBaUI7QUFDdkIsTUFBTUMsb0JBQW9CO0lBQ3RCQyxH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LENBQUMxSCxNQUFNLENBQUMySCxPQUFPLENBQUNELE1BQU07UUFDekMsSUFBSUEsT0FBT0UsYUFBYSxFQUFFO1lBQ3RCLElBQUlGLE9BQU9HLFVBQVUsRUFBRTtnQkFDbkIsT0FBTyxDQUFDLEVBQUVILE9BQU9FLGFBQWEsQ0FBQyxDQUFDLEVBQUVGLE9BQU9HLFVBQVUsQ0FBQyxDQUFDO1lBQ3pELE9BQ0s7Z0JBQ0QsT0FBT0gsT0FBT0UsYUFBYTtZQUMvQjtRQUNKLE9BQ0s7WUFDRCxPQUFPO1FBQ1g7SUFDSjtJQUNBaEssY0FBYztRQUNWLE9BQU8sSUFBSSxDQUFDeUMsUUFBUTtJQUN4QjtJQUNBeEMsVUFBVTtRQUNOLE9BQU8sSUFBSSxDQUFDb0MsT0FBTyxDQUFDaUIsSUFBSTtJQUM1QjtBQUNKO0FBQ0E3Ryw2QkFBNkIsR0FBR0U7QUFDaEMsU0FBU2dKLHNCQUFzQm5HLElBQUk7SUFDL0IsTUFBTXdCLE1BQU0sSUFBSW1FLE1BQU07SUFDdEJuRSxJQUFJVSxJQUFJLEdBQUdwRSxZQUFZcUUsTUFBTSxDQUFDdUksaUJBQWlCO0lBQy9DMUssS0FBS3lCLFNBQVMsQ0FBQ0Q7SUFDZnhCLEtBQUtHLFNBQVMsR0FBRztJQUNqQkgsS0FBS3FDLElBQUksQ0FBQyxhQUFhO0FBQzNCLEVBQ0EsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNobWl0dC1ndXB0YS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2ZXItY2FsbC5qcz83MjNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkh0dHAyU2VydmVyQ2FsbFN0cmVhbSA9IGV4cG9ydHMuU2VydmVyRHVwbGV4U3RyZWFtSW1wbCA9IGV4cG9ydHMuU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsID0gZXhwb3J0cy5TZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwgPSBleHBvcnRzLlNlcnZlclVuYXJ5Q2FsbEltcGwgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBodHRwMiA9IHJlcXVpcmUoXCJodHRwMlwiKTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IHpsaWIgPSByZXF1aXJlKFwiemxpYlwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBzdHJlYW1fZGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vc3RyZWFtLWRlY29kZXJcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3NlcnZlcl9jYWxsJztcbmNvbnN0IHVuemlwID0gdXRpbF8xLnByb21pc2lmeSh6bGliLnVuemlwKTtcbmNvbnN0IGluZmxhdGUgPSB1dGlsXzEucHJvbWlzaWZ5KHpsaWIuaW5mbGF0ZSk7XG5mdW5jdGlvbiB0cmFjZSh0ZXh0KSB7XG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcbn1cbmNvbnN0IEdSUENfQUNDRVBUX0VOQ09ESU5HX0hFQURFUiA9ICdncnBjLWFjY2VwdC1lbmNvZGluZyc7XG5jb25zdCBHUlBDX0VOQ09ESU5HX0hFQURFUiA9ICdncnBjLWVuY29kaW5nJztcbmNvbnN0IEdSUENfTUVTU0FHRV9IRUFERVIgPSAnZ3JwYy1tZXNzYWdlJztcbmNvbnN0IEdSUENfU1RBVFVTX0hFQURFUiA9ICdncnBjLXN0YXR1cyc7XG5jb25zdCBHUlBDX1RJTUVPVVRfSEVBREVSID0gJ2dycGMtdGltZW91dCc7XG5jb25zdCBERUFETElORV9SRUdFWCA9IC8oXFxkezEsOH0pXFxzKihbSE1TbXVuXSkvO1xuY29uc3QgZGVhZGxpbmVVbml0c1RvTXMgPSB7XG4gICAgSDogMzYwMDAwMCxcbiAgICBNOiA2MDAwMCxcbiAgICBTOiAxMDAwLFxuICAgIG06IDEsXG4gICAgdTogMC4wMDEsXG4gICAgbjogMC4wMDAwMDEsXG59O1xuY29uc3QgZGVmYXVsdFJlc3BvbnNlSGVhZGVycyA9IHtcbiAgICAvLyBUT0RPKGNqaWhyaWcpOiBSZW1vdmUgdGhlc2UgZW5jb2RpbmcgaGVhZGVycyBmcm9tIHRoZSBkZWZhdWx0IHJlc3BvbnNlXG4gICAgLy8gb25jZSBjb21wcmVzc2lvbiBpcyBpbnRlZ3JhdGVkLlxuICAgIFtHUlBDX0FDQ0VQVF9FTkNPRElOR19IRUFERVJdOiAnaWRlbnRpdHksZGVmbGF0ZSxnemlwJyxcbiAgICBbR1JQQ19FTkNPRElOR19IRUFERVJdOiAnaWRlbnRpdHknLFxuICAgIFtodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX1NUQVRVU106IGh0dHAyLmNvbnN0YW50cy5IVFRQX1NUQVRVU19PSyxcbiAgICBbaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEVdOiAnYXBwbGljYXRpb24vZ3JwYytwcm90bycsXG59O1xuY29uc3QgZGVmYXVsdFJlc3BvbnNlT3B0aW9ucyA9IHtcbiAgICB3YWl0Rm9yVHJhaWxlcnM6IHRydWUsXG59O1xuY2xhc3MgU2VydmVyVW5hcnlDYWxsSW1wbCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoY2FsbCwgbWV0YWRhdGEsIHJlcXVlc3QpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbGwuc2V0dXBTdXJmYWNlQ2FsbCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldERlYWRsaW5lKCk7XG4gICAgfVxuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGF0aCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyVW5hcnlDYWxsSW1wbCA9IFNlcnZlclVuYXJ5Q2FsbEltcGw7XG5jbGFzcyBTZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5SZWFkYWJsZSB7XG4gICAgY29uc3RydWN0b3IoY2FsbCwgbWV0YWRhdGEsIGRlc2VyaWFsaXplLCBlbmNvZGluZykge1xuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbGwuc2V0dXBTdXJmYWNlQ2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYWxsLnNldHVwUmVhZGFibGUodGhpcywgZW5jb2RpbmcpO1xuICAgIH1cbiAgICBfcmVhZChzaXplKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWxsLmNvbnN1bWVVbnB1c2hlZE1lc3NhZ2VzKHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsLnJlc3VtZSgpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBlZXIoKTtcbiAgICB9XG4gICAgc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5jYWxsLnNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgZ2V0RGVhZGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0RGVhZGxpbmUoKTtcbiAgICB9XG4gICAgZ2V0UGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQYXRoKCk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwgPSBTZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGw7XG5jbGFzcyBTZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5Xcml0YWJsZSB7XG4gICAgY29uc3RydWN0b3IoY2FsbCwgbWV0YWRhdGEsIHNlcmlhbGl6ZSwgcmVxdWVzdCkge1xuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHJhaWxpbmdNZXRhZGF0YSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XG4gICAgICAgIHRoaXMuY2FsbC5zZXR1cFN1cmZhY2VDYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FsbC5zZW5kRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBlZXIoKTtcbiAgICB9XG4gICAgc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5jYWxsLnNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgZ2V0RGVhZGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0RGVhZGxpbmUoKTtcbiAgICB9XG4gICAgZ2V0UGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQYXRoKCk7XG4gICAgfVxuICAgIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY2FsbGJhY2spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5jYWxsLnNlcmlhbGl6ZU1lc3NhZ2UoY2h1bmspO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbGwud3JpdGUocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsLm9uY2UoJ2RyYWluJywgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBlcnIuY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIF9maW5hbChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGwuc2VuZFN0YXR1cyh7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuT0ssXG4gICAgICAgICAgICBkZXRhaWxzOiAnT0snLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHRoaXMudHJhaWxpbmdNZXRhZGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGVuZChtZXRhZGF0YSkge1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMudHJhaWxpbmdNZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5lbmQoKTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbCA9IFNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbDtcbmNsYXNzIFNlcnZlckR1cGxleFN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5EdXBsZXgge1xuICAgIGNvbnN0cnVjdG9yKGNhbGwsIG1ldGFkYXRhLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCBlbmNvZGluZykge1xuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50cmFpbGluZ01ldGFkYXRhID0gbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKTtcbiAgICAgICAgdGhpcy5jYWxsLnNldHVwU3VyZmFjZUNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuY2FsbC5zZXR1cFJlYWRhYmxlKHRoaXMsIGVuY29kaW5nKTtcbiAgICAgICAgdGhpcy5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbGwuc2VuZEVycm9yKGVycik7XG4gICAgICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldERlYWRsaW5lKCk7XG4gICAgfVxuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGF0aCgpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGVuZChtZXRhZGF0YSkge1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMudHJhaWxpbmdNZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5lbmQoKTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlckR1cGxleFN0cmVhbUltcGwgPSBTZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsO1xuU2VydmVyRHVwbGV4U3RyZWFtSW1wbC5wcm90b3R5cGUuX3JlYWQgPVxuICAgIFNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbC5wcm90b3R5cGUuX3JlYWQ7XG5TZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsLnByb3RvdHlwZS5fd3JpdGUgPVxuICAgIFNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbC5wcm90b3R5cGUuX3dyaXRlO1xuU2VydmVyRHVwbGV4U3RyZWFtSW1wbC5wcm90b3R5cGUuX2ZpbmFsID1cbiAgICBTZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwucHJvdG90eXBlLl9maW5hbDtcbi8vIEludGVybmFsIGNsYXNzIHRoYXQgd3JhcHMgdGhlIEhUVFAyIHJlcXVlc3QuXG5jbGFzcyBIdHRwMlNlcnZlckNhbGxTdHJlYW0gZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHN0cmVhbSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWFkbGluZVRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0dXNTZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVhZGxpbmUgPSBJbmZpbml0eTtcbiAgICAgICAgdGhpcy53YW50VHJhaWxlcnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YVNlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5QdXNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNQdXNoUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlcmVkTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5tZXNzYWdlc1RvUHVzaCA9IFtdO1xuICAgICAgICB0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSA9IGNvbnN0YW50c18xLkRFRkFVTFRfTUFYX1NFTkRfTUVTU0FHRV9MRU5HVEg7XG4gICAgICAgIHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplID0gY29uc3RhbnRzXzEuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSDtcbiAgICAgICAgdGhpcy5zdHJlYW0ub25jZSgnZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAvKiBXZSBuZWVkIGFuIGVycm9yIGhhbmRsZXIgdG8gYXZvaWQgdW5jYXVnaHQgZXJyb3IgZXZlbnQgZXhjZXB0aW9ucywgYnV0XG4gICAgICAgICAgICAgKiB0aGVyZSBpcyBub3RoaW5nIHdlIGNhbiByZWFzb25hYmx5IGRvIGhlcmUuIEFueSBlcnJvciBldmVudCBzaG91bGRcbiAgICAgICAgICAgICAqIGhhdmUgYSBjb3JyZXNwb25kaW5nIGNsb3NlIGV2ZW50LCB3aGljaCBoYW5kbGVzIGVtaXR0aW5nIHRoZSBjYW5jZWxsZWRcbiAgICAgICAgICAgICAqIGV2ZW50LiBBbmQgdGhlIHN0cmVhbSBpcyBub3cgaW4gYSBiYWQgc3RhdGUsIHNvIHdlIGNhbid0IHJlYXNvbmFibHlcbiAgICAgICAgICAgICAqIGV4cGVjdCB0byBiZSBhYmxlIHRvIHNlbmQgYW4gZXJyb3Igb3ZlciBpdC4gKi9cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdHJhY2UoJ1JlcXVlc3QgdG8gbWV0aG9kICcgKyAoKF9hID0gdGhpcy5oYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF0aCkgK1xuICAgICAgICAgICAgICAgICcgc3RyZWFtIGNsb3NlZCB3aXRoIHJzdENvZGUgJyArXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ucnN0Q29kZSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhdHVzU2VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2NhbmNlbGxlZCcsICdjYW5jZWxsZWQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0cmVhbUVuZCcsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAnQ2FuY2VsbGVkIGJ5IGNsaWVudCcsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW0ub24oJ2RyYWluJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCdncnBjLm1heF9zZW5kX21lc3NhZ2VfbGVuZ3RoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSA9IG9wdGlvbnNbJ2dycGMubWF4X3NlbmRfbWVzc2FnZV9sZW5ndGgnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2dycGMubWF4X3JlY2VpdmVfbWVzc2FnZV9sZW5ndGgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplID0gb3B0aW9uc1snZ3JwYy5tYXhfcmVjZWl2ZV9tZXNzYWdlX2xlbmd0aCddO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrQ2FuY2VsbGVkKCkge1xuICAgICAgICAvKiBJbiBzb21lIGNhc2VzIHRoZSBzdHJlYW0gY2FuIGJlY29tZSBkZXN0cm95ZWQgYmVmb3JlIHRoZSBjbG9zZSBldmVudFxuICAgICAgICAgKiBmaXJlcy4gVGhhdCBjcmVhdGVzIGEgcmFjZSBjb25kaXRpb24gdGhhdCB0aGlzIGNoZWNrIHdvcmtzIGFyb3VuZCAqL1xuICAgICAgICBpZiAodGhpcy5zdHJlYW0uZGVzdHJveWVkIHx8IHRoaXMuc3RyZWFtLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhbmNlbGxlZDtcbiAgICB9XG4gICAgZ2V0RGVjb21wcmVzc2VkTWVzc2FnZShtZXNzYWdlLCBlbmNvZGluZykge1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdkZWZsYXRlJykge1xuICAgICAgICAgICAgcmV0dXJuIGluZmxhdGUobWVzc2FnZS5zdWJhcnJheSg1KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW5jb2RpbmcgPT09ICdnemlwJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuemlwKG1lc3NhZ2Uuc3ViYXJyYXkoNSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVuY29kaW5nID09PSAnaWRlbnRpdHknKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZS5zdWJhcnJheSg1KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoe1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOSU1QTEVNRU5URUQsXG4gICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgbWVzc2FnZSBjb21wcmVzc2VkIHdpdGggdW5zdXBwb3J0ZWQgZW5jb2RpbmcgXCIke2VuY29kaW5nfVwiYCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShjdXN0b21NZXRhZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5jaGVja0NhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWV0YWRhdGFTZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXRhZGF0YVNlbnQgPSB0cnVlO1xuICAgICAgICBjb25zdCBjdXN0b20gPSBjdXN0b21NZXRhZGF0YSA/IGN1c3RvbU1ldGFkYXRhLnRvSHR0cDJIZWFkZXJzKCkgOiBudWxsO1xuICAgICAgICAvLyBUT0RPKGNqaWhyaWcpOiBJbmNsdWRlIGNvbXByZXNzaW9uIGhlYWRlcnMuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRSZXNwb25zZUhlYWRlcnMpLCBjdXN0b20pO1xuICAgICAgICB0aGlzLnN0cmVhbS5yZXNwb25kKGhlYWRlcnMsIGRlZmF1bHRSZXNwb25zZU9wdGlvbnMpO1xuICAgIH1cbiAgICByZWNlaXZlTWV0YWRhdGEoaGVhZGVycykge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IG1ldGFkYXRhXzEuTWV0YWRhdGEuZnJvbUh0dHAySGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgaWYgKGxvZ2dpbmcuaXNUcmFjZXJFbmFibGVkKFRSQUNFUl9OQU1FKSkge1xuICAgICAgICAgICAgdHJhY2UoJ1JlcXVlc3QgdG8gJyArXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVyLnBhdGggK1xuICAgICAgICAgICAgICAgICcgcmVjZWl2ZWQgaGVhZGVycyAnICtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShtZXRhZGF0YS50b0pTT04oKSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8oY2ppaHJpZyk6IFJlY2VpdmUgY29tcHJlc3Npb24gbWV0YWRhdGEuXG4gICAgICAgIGNvbnN0IHRpbWVvdXRIZWFkZXIgPSBtZXRhZGF0YS5nZXQoR1JQQ19USU1FT1VUX0hFQURFUik7XG4gICAgICAgIGlmICh0aW1lb3V0SGVhZGVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdGltZW91dEhlYWRlclswXS50b1N0cmluZygpLm1hdGNoKERFQURMSU5FX1JFR0VYKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignSW52YWxpZCBkZWFkbGluZScpO1xuICAgICAgICAgICAgICAgIGVyci5jb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLk9VVF9PRl9SQU5HRTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSAoK21hdGNoWzFdICogZGVhZGxpbmVVbml0c1RvTXNbbWF0Y2hbMl1dKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5kZWFkbGluZSA9IG5vdy5zZXRNaWxsaXNlY29uZHMobm93LmdldE1pbGxpc2Vjb25kcygpICsgdGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLmRlYWRsaW5lVGltZXIgPSBzZXRUaW1lb3V0KGhhbmRsZUV4cGlyZWREZWFkbGluZSwgdGltZW91dCwgdGhpcyk7XG4gICAgICAgICAgICBtZXRhZGF0YS5yZW1vdmUoR1JQQ19USU1FT1VUX0hFQURFUik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHNldmVyYWwgaGVhZGVycyB0aGF0IHNob3VsZCBub3QgYmUgcHJvcGFnYXRlZCB0byB0aGUgYXBwbGljYXRpb25cbiAgICAgICAgbWV0YWRhdGEucmVtb3ZlKGh0dHAyLmNvbnN0YW50cy5IVFRQMl9IRUFERVJfQUNDRVBUX0VOQ09ESU5HKTtcbiAgICAgICAgbWV0YWRhdGEucmVtb3ZlKGh0dHAyLmNvbnN0YW50cy5IVFRQMl9IRUFERVJfVEUpO1xuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEUpO1xuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoJ2dycGMtYWNjZXB0LWVuY29kaW5nJyk7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgcmVjZWl2ZVVuYXJ5TWVzc2FnZShlbmNvZGluZywgbmV4dCkge1xuICAgICAgICBjb25zdCB7IHN0cmVhbSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHJlY2VpdmVkTGVuZ3RoID0gMDtcbiAgICAgICAgY29uc3QgY2FsbCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBbXTtcbiAgICAgICAgY29uc3QgbGltaXQgPSB0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZTtcbiAgICAgICAgc3RyZWFtLm9uKCdkYXRhJywgb25EYXRhKTtcbiAgICAgICAgc3RyZWFtLm9uKCdlbmQnLCBvbkVuZCk7XG4gICAgICAgIHN0cmVhbS5vbignZXJyb3InLCBvbkVuZCk7XG4gICAgICAgIGZ1bmN0aW9uIG9uRGF0YShjaHVuaykge1xuICAgICAgICAgICAgcmVjZWl2ZWRMZW5ndGggKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gLTEgJiYgcmVjZWl2ZWRMZW5ndGggPiBsaW1pdCkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uRGF0YSk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbkVuZCk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRW5kKTtcbiAgICAgICAgICAgICAgICBuZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFJlY2VpdmVkIG1lc3NhZ2UgbGFyZ2VyIHRoYW4gbWF4ICgke3JlY2VpdmVkTGVuZ3RofSB2cy4gJHtsaW1pdH0pYCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5LnB1c2goY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uRW5kKGVycikge1xuICAgICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25EYXRhKTtcbiAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25FbmQpO1xuICAgICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRW5kKTtcbiAgICAgICAgICAgIGlmIChlcnIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5leHQoeyBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsIGRldGFpbHM6IGVyci5tZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWNlaXZlZExlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG5leHQoeyBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsIGRldGFpbHM6ICdyZWNlaXZlZCBlbXB0eSB1bmFyeSBtZXNzYWdlJyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsLmVtaXQoJ3JlY2VpdmVNZXNzYWdlJyk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0Qnl0ZXMgPSBCdWZmZXIuY29uY2F0KGJvZHksIHJlY2VpdmVkTGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXByZXNzZWQgPSByZXF1ZXN0Qnl0ZXMucmVhZFVJbnQ4KDApID09PSAxO1xuICAgICAgICAgICAgY29uc3QgY29tcHJlc3NlZE1lc3NhZ2VFbmNvZGluZyA9IGNvbXByZXNzZWQgPyBlbmNvZGluZyA6ICdpZGVudGl0eSc7XG4gICAgICAgICAgICBjb25zdCBkZWNvbXByZXNzZWRNZXNzYWdlID0gY2FsbC5nZXREZWNvbXByZXNzZWRNZXNzYWdlKHJlcXVlc3RCeXRlcywgY29tcHJlc3NlZE1lc3NhZ2VFbmNvZGluZyk7XG4gICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRlY29tcHJlc3NlZE1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgY2FsbC5zYWZlRGVzZXJpYWxpemVNZXNzYWdlKGRlY29tcHJlc3NlZE1lc3NhZ2UsIG5leHQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29tcHJlc3NlZE1lc3NhZ2UudGhlbigoZGVjb21wcmVzc2VkKSA9PiBjYWxsLnNhZmVEZXNlcmlhbGl6ZU1lc3NhZ2UoZGVjb21wcmVzc2VkLCBuZXh0KSwgKGVycikgPT4gbmV4dChlcnIuY29kZVxuICAgICAgICAgICAgICAgID8gZXJyXG4gICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFJlY2VpdmVkIFwiZ3JwYy1lbmNvZGluZ1wiIGhlYWRlciBcIiR7ZW5jb2Rpbmd9XCIgYnV0ICR7ZW5jb2Rpbmd9IGRlY29tcHJlc3Npb24gZmFpbGVkYCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2FmZURlc2VyaWFsaXplTWVzc2FnZShidWZmZXIsIG5leHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5leHQobnVsbCwgdGhpcy5kZXNlcmlhbGl6ZU1lc3NhZ2UoYnVmZmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXJyLmNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgICAgICBuZXh0KGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VyaWFsaXplTWVzc2FnZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlQnVmZmVyID0gdGhpcy5oYW5kbGVyLnNlcmlhbGl6ZSh2YWx1ZSk7XG4gICAgICAgIC8vIFRPRE8oY2ppaHJpZyk6IENhbGwgY29tcHJlc3Npb24gYXdhcmUgc2VyaWFsaXplTWVzc2FnZSgpLlxuICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gbWVzc2FnZUJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnl0ZUxlbmd0aCArIDUpO1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50OCgwLCAwKTtcbiAgICAgICAgb3V0cHV0LndyaXRlVUludDMyQkUoYnl0ZUxlbmd0aCwgMSk7XG4gICAgICAgIG1lc3NhZ2VCdWZmZXIuY29weShvdXRwdXQsIDUpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBkZXNlcmlhbGl6ZU1lc3NhZ2UoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5kZXNlcmlhbGl6ZShieXRlcyk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRVbmFyeU1lc3NhZ2UoZXJyLCB2YWx1ZSwgbWV0YWRhdGEsIGZsYWdzKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWV0YWRhdGEgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVyciwgJ21ldGFkYXRhJykgJiYgbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBlcnIubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VuZEVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5zZXJpYWxpemVNZXNzYWdlKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGUocmVzcG9uc2UpO1xuICAgICAgICAgICAgdGhpcy5zZW5kU3RhdHVzKHsgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLk9LLCBkZXRhaWxzOiAnT0snLCBtZXRhZGF0YSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBlcnIuY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgIHRoaXMuc2VuZEVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZFN0YXR1cyhzdGF0dXNPYmopIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmVtaXQoJ2NhbGxFbmQnLCBzdGF0dXNPYmouY29kZSk7XG4gICAgICAgIHRoaXMuZW1pdCgnc3RyZWFtRW5kJywgc3RhdHVzT2JqLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSyk7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnUmVxdWVzdCB0byBtZXRob2QgJyArICgoX2EgPSB0aGlzLmhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXRoKSArXG4gICAgICAgICAgICAnIGVuZGVkIHdpdGggc3RhdHVzIGNvZGU6ICcgK1xuICAgICAgICAgICAgY29uc3RhbnRzXzEuU3RhdHVzW3N0YXR1c09iai5jb2RlXSArXG4gICAgICAgICAgICAnIGRldGFpbHM6ICcgK1xuICAgICAgICAgICAgc3RhdHVzT2JqLmRldGFpbHMpO1xuICAgICAgICBpZiAodGhpcy5kZWFkbGluZVRpbWVyKVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVhZGxpbmVUaW1lcik7XG4gICAgICAgIGlmICghdGhpcy53YW50VHJhaWxlcnMpIHtcbiAgICAgICAgICAgIHRoaXMud2FudFRyYWlsZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoJ3dhbnRUcmFpbGVycycsICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhaWxlcnNUb1NlbmQgPSBPYmplY3QuYXNzaWduKHsgW0dSUENfU1RBVFVTX0hFQURFUl06IHN0YXR1c09iai5jb2RlLCBbR1JQQ19NRVNTQUdFX0hFQURFUl06IGVuY29kZVVSSShzdGF0dXNPYmouZGV0YWlscykgfSwgKF9hID0gc3RhdHVzT2JqLm1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9IdHRwMkhlYWRlcnMoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0uc2VuZFRyYWlsZXJzKHRyYWlsZXJzVG9TZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c1NlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNlbmRNZXRhZGF0YSgpO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0uZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZEVycm9yKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOLFxuICAgICAgICAgICAgZGV0YWlsczogJ21lc3NhZ2UnIGluIGVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIEVycm9yJyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiAnbWV0YWRhdGEnIGluIGVycm9yICYmIGVycm9yLm1ldGFkYXRhICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IGVycm9yLm1ldGFkYXRhXG4gICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoJ2NvZGUnIGluIGVycm9yICYmXG4gICAgICAgICAgICB0eXBlb2YgZXJyb3IuY29kZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIE51bWJlci5pc0ludGVnZXIoZXJyb3IuY29kZSkpIHtcbiAgICAgICAgICAgIHN0YXR1cy5jb2RlID0gZXJyb3IuY29kZTtcbiAgICAgICAgICAgIGlmICgnZGV0YWlscycgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yLmRldGFpbHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRldGFpbHMgPSBlcnJvci5kZXRhaWxzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZFN0YXR1cyhzdGF0dXMpO1xuICAgIH1cbiAgICB3cml0ZShjaHVuaykge1xuICAgICAgICBpZiAodGhpcy5jaGVja0NhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWF4U2VuZE1lc3NhZ2VTaXplICE9PSAtMSAmJlxuICAgICAgICAgICAgY2h1bmsubGVuZ3RoID4gdGhpcy5tYXhTZW5kTWVzc2FnZVNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZEVycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVELFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGBTZW50IG1lc3NhZ2UgbGFyZ2VyIHRoYW4gbWF4ICgke2NodW5rLmxlbmd0aH0gdnMuICR7dGhpcy5tYXhTZW5kTWVzc2FnZVNpemV9KWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbmRNZXRhZGF0YSgpO1xuICAgICAgICB0aGlzLmVtaXQoJ3NlbmRNZXNzYWdlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZShjaHVuayk7XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICAgIHNldHVwU3VyZmFjZUNhbGwoY2FsbCkge1xuICAgICAgICB0aGlzLm9uY2UoJ2NhbmNlbGxlZCcsIChyZWFzb24pID0+IHtcbiAgICAgICAgICAgIGNhbGwuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNhbGwuZW1pdCgnY2FuY2VsbGVkJywgcmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25jZSgnY2FsbEVuZCcsIChzdGF0dXMpID0+IGNhbGwuZW1pdCgnY2FsbEVuZCcsIHN0YXR1cykpO1xuICAgIH1cbiAgICBzZXR1cFJlYWRhYmxlKHJlYWRhYmxlLCBlbmNvZGluZykge1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IHN0cmVhbV9kZWNvZGVyXzEuU3RyZWFtRGVjb2RlcigpO1xuICAgICAgICBsZXQgcmVhZHNEb25lID0gZmFsc2U7XG4gICAgICAgIGxldCBwZW5kaW5nTWVzc2FnZVByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgbGV0IHB1c2hlZEVuZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBtYXliZVB1c2hFbmQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXB1c2hlZEVuZCAmJiByZWFkc0RvbmUgJiYgIXBlbmRpbmdNZXNzYWdlUHJvY2Vzc2luZykge1xuICAgICAgICAgICAgICAgIHB1c2hlZEVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoT3JCdWZmZXJNZXNzYWdlKHJlYWRhYmxlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdHJlYW0ub24oJ2RhdGEnLCBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBkZWNvZGVyLndyaXRlKGRhdGEpO1xuICAgICAgICAgICAgcGVuZGluZ01lc3NhZ2VQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLnBhdXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUgIT09IC0xICYmXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGVuZ3RoID4gdGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBtZXNzYWdlIGxhcmdlciB0aGFuIG1heCAoJHttZXNzYWdlLmxlbmd0aH0gdnMuICR7dGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemV9KWAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVjZWl2ZU1lc3NhZ2UnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wcmVzc2VkID0gbWVzc2FnZS5yZWFkVUludDgoMCkgPT09IDE7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHJlc3NlZE1lc3NhZ2VFbmNvZGluZyA9IGNvbXByZXNzZWQgPyBlbmNvZGluZyA6ICdpZGVudGl0eSc7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVjb21wcmVzc2VkTWVzc2FnZSA9IGF3YWl0IHRoaXMuZ2V0RGVjb21wcmVzc2VkTWVzc2FnZShtZXNzYWdlLCBjb21wcmVzc2VkTWVzc2FnZUVuY29kaW5nKTtcbiAgICAgICAgICAgICAgICAvLyBFbmNvdW50ZXJlZCBhbiBlcnJvciB3aXRoIGRlY29tcHJlc3Npb247IGl0J2xsIGFscmVhZHkgaGF2ZSBiZWVuIHByb3BvZ2F0ZWQgYmFja1xuICAgICAgICAgICAgICAgIC8vIEp1c3QgcmV0dXJuIGVhcmx5XG4gICAgICAgICAgICAgICAgaWYgKCFkZWNvbXByZXNzZWRNZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoT3JCdWZmZXJNZXNzYWdlKHJlYWRhYmxlLCBkZWNvbXByZXNzZWRNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlbmRpbmdNZXNzYWdlUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0ucmVzdW1lKCk7XG4gICAgICAgICAgICBtYXliZVB1c2hFbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgIHJlYWRzRG9uZSA9IHRydWU7XG4gICAgICAgICAgICBtYXliZVB1c2hFbmQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN1bWVVbnB1c2hlZE1lc3NhZ2VzKHJlYWRhYmxlKSB7XG4gICAgICAgIHRoaXMuY2FuUHVzaCA9IHRydWU7XG4gICAgICAgIHdoaWxlICh0aGlzLm1lc3NhZ2VzVG9QdXNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRNZXNzYWdlID0gdGhpcy5tZXNzYWdlc1RvUHVzaC5zaGlmdCgpO1xuICAgICAgICAgICAgY29uc3QgY2FuUHVzaCA9IHJlYWRhYmxlLnB1c2gobmV4dE1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKG5leHRNZXNzYWdlID09PSBudWxsIHx8IGNhblB1c2ggPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5QdXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuUHVzaDtcbiAgICB9XG4gICAgcHVzaE9yQnVmZmVyTWVzc2FnZShyZWFkYWJsZSwgbWVzc2FnZUJ5dGVzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUHVzaFBlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyZWRNZXNzYWdlcy5wdXNoKG1lc3NhZ2VCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hNZXNzYWdlKHJlYWRhYmxlLCBtZXNzYWdlQnl0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHB1c2hNZXNzYWdlKHJlYWRhYmxlLCBtZXNzYWdlQnl0ZXMpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2VCeXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhY2UoJ1JlY2VpdmVkIGVuZCBvZiBzdHJlYW0nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhblB1c2gpIHtcbiAgICAgICAgICAgICAgICByZWFkYWJsZS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlc1RvUHVzaC5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlKCdSZWNlaXZlZCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZUJ5dGVzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuaXNQdXNoUGVuZGluZyA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWQgPSBhd2FpdCB0aGlzLmRlc2VyaWFsaXplTWVzc2FnZShtZXNzYWdlQnl0ZXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FuUHVzaCkge1xuICAgICAgICAgICAgICAgIGlmICghcmVhZGFibGUucHVzaChkZXNlcmlhbGl6ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuUHVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZXNUb1B1c2gucHVzaChkZXNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSWdub3JlIGFueSByZW1haW5pbmcgbWVzc2FnZXMgd2hlbiBlcnJvcnMgb2NjdXIuXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcmVkTWVzc2FnZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGlmICghKCdjb2RlJyBpbiBlcnJvciAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBlcnJvci5jb2RlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICAgIE51bWJlci5pc0ludGVnZXIoZXJyb3IuY29kZSkgJiZcbiAgICAgICAgICAgICAgICBlcnJvci5jb2RlID49IGNvbnN0YW50c18xLlN0YXR1cy5PSyAmJlxuICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPD0gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVVUSEVOVElDQVRFRCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZXJyb3IgY29kZSBpcyBub3QgYSB2YWxpZCBnUlBDIGNvZGUgc28gaXRzIGJlaW5nIG92ZXJ3cml0dGVuLlxuICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkYWJsZS5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUHVzaFBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyZWRNZXNzYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hNZXNzYWdlKHJlYWRhYmxlLCB0aGlzLmJ1ZmZlcmVkTWVzc2FnZXMuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5zdHJlYW0uc2Vzc2lvbi5zb2NrZXQ7XG4gICAgICAgIGlmIChzb2NrZXQucmVtb3RlQWRkcmVzcykge1xuICAgICAgICAgICAgaWYgKHNvY2tldC5yZW1vdGVQb3J0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3NvY2tldC5yZW1vdGVBZGRyZXNzfToke3NvY2tldC5yZW1vdGVQb3J0fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc29ja2V0LnJlbW90ZUFkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ3Vua25vd24nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldERlYWRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWFkbGluZTtcbiAgICB9XG4gICAgZ2V0UGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5wYXRoO1xuICAgIH1cbn1cbmV4cG9ydHMuSHR0cDJTZXJ2ZXJDYWxsU3RyZWFtID0gSHR0cDJTZXJ2ZXJDYWxsU3RyZWFtO1xuZnVuY3Rpb24gaGFuZGxlRXhwaXJlZERlYWRsaW5lKGNhbGwpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0RlYWRsaW5lIGV4Y2VlZGVkJyk7XG4gICAgZXJyLmNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuREVBRExJTkVfRVhDRUVERUQ7XG4gICAgY2FsbC5zZW5kRXJyb3IoZXJyKTtcbiAgICBjYWxsLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgY2FsbC5lbWl0KCdjYW5jZWxsZWQnLCAnZGVhZGxpbmUnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZlci1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkh0dHAyU2VydmVyQ2FsbFN0cmVhbSIsIlNlcnZlckR1cGxleFN0cmVhbUltcGwiLCJTZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwiLCJTZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwiLCJTZXJ2ZXJVbmFyeUNhbGxJbXBsIiwiZXZlbnRzXzEiLCJyZXF1aXJlIiwiaHR0cDIiLCJzdHJlYW1fMSIsInpsaWIiLCJ1dGlsXzEiLCJjb25zdGFudHNfMSIsIm1ldGFkYXRhXzEiLCJzdHJlYW1fZGVjb2Rlcl8xIiwibG9nZ2luZyIsIlRSQUNFUl9OQU1FIiwidW56aXAiLCJwcm9taXNpZnkiLCJpbmZsYXRlIiwidHJhY2UiLCJ0ZXh0IiwiTG9nVmVyYm9zaXR5IiwiREVCVUciLCJHUlBDX0FDQ0VQVF9FTkNPRElOR19IRUFERVIiLCJHUlBDX0VOQ09ESU5HX0hFQURFUiIsIkdSUENfTUVTU0FHRV9IRUFERVIiLCJHUlBDX1NUQVRVU19IRUFERVIiLCJHUlBDX1RJTUVPVVRfSEVBREVSIiwiREVBRExJTkVfUkVHRVgiLCJkZWFkbGluZVVuaXRzVG9NcyIsIkgiLCJNIiwiUyIsIm0iLCJ1IiwibiIsImRlZmF1bHRSZXNwb25zZUhlYWRlcnMiLCJjb25zdGFudHMiLCJIVFRQMl9IRUFERVJfU1RBVFVTIiwiSFRUUF9TVEFUVVNfT0siLCJIVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFIiwiZGVmYXVsdFJlc3BvbnNlT3B0aW9ucyIsIndhaXRGb3JUcmFpbGVycyIsIkV2ZW50RW1pdHRlciIsImNvbnN0cnVjdG9yIiwiY2FsbCIsIm1ldGFkYXRhIiwicmVxdWVzdCIsImNhbmNlbGxlZCIsInNldHVwU3VyZmFjZUNhbGwiLCJnZXRQZWVyIiwic2VuZE1ldGFkYXRhIiwicmVzcG9uc2VNZXRhZGF0YSIsImdldERlYWRsaW5lIiwiZ2V0UGF0aCIsIlJlYWRhYmxlIiwiZGVzZXJpYWxpemUiLCJlbmNvZGluZyIsIm9iamVjdE1vZGUiLCJzZXR1cFJlYWRhYmxlIiwiX3JlYWQiLCJzaXplIiwiY29uc3VtZVVucHVzaGVkTWVzc2FnZXMiLCJyZXN1bWUiLCJXcml0YWJsZSIsInNlcmlhbGl6ZSIsInRyYWlsaW5nTWV0YWRhdGEiLCJNZXRhZGF0YSIsIm9uIiwiZXJyIiwic2VuZEVycm9yIiwiZW5kIiwiX3dyaXRlIiwiY2h1bmsiLCJjYWxsYmFjayIsInJlc3BvbnNlIiwic2VyaWFsaXplTWVzc2FnZSIsIndyaXRlIiwib25jZSIsImNvZGUiLCJTdGF0dXMiLCJJTlRFUk5BTCIsImVtaXQiLCJfZmluYWwiLCJzZW5kU3RhdHVzIiwiT0siLCJkZXRhaWxzIiwiRHVwbGV4IiwicHJvdG90eXBlIiwic3RyZWFtIiwiaGFuZGxlciIsIm9wdGlvbnMiLCJkZWFkbGluZVRpbWVyIiwic3RhdHVzU2VudCIsImRlYWRsaW5lIiwiSW5maW5pdHkiLCJ3YW50VHJhaWxlcnMiLCJtZXRhZGF0YVNlbnQiLCJjYW5QdXNoIiwiaXNQdXNoUGVuZGluZyIsImJ1ZmZlcmVkTWVzc2FnZXMiLCJtZXNzYWdlc1RvUHVzaCIsIm1heFNlbmRNZXNzYWdlU2l6ZSIsIkRFRkFVTFRfTUFYX1NFTkRfTUVTU0FHRV9MRU5HVEgiLCJtYXhSZWNlaXZlTWVzc2FnZVNpemUiLCJERUZBVUxUX01BWF9SRUNFSVZFX01FU1NBR0VfTEVOR1RIIiwiX2EiLCJwYXRoIiwicnN0Q29kZSIsIkNBTkNFTExFRCIsImNoZWNrQ2FuY2VsbGVkIiwiZGVzdHJveWVkIiwiY2xvc2VkIiwiZ2V0RGVjb21wcmVzc2VkTWVzc2FnZSIsIm1lc3NhZ2UiLCJzdWJhcnJheSIsIlByb21pc2UiLCJyZWplY3QiLCJVTklNUExFTUVOVEVEIiwiY3VzdG9tTWV0YWRhdGEiLCJjdXN0b20iLCJ0b0h0dHAySGVhZGVycyIsImhlYWRlcnMiLCJhc3NpZ24iLCJyZXNwb25kIiwicmVjZWl2ZU1ldGFkYXRhIiwiZnJvbUh0dHAySGVhZGVycyIsImlzVHJhY2VyRW5hYmxlZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0b0pTT04iLCJ0aW1lb3V0SGVhZGVyIiwiZ2V0IiwibGVuZ3RoIiwibWF0Y2giLCJ0b1N0cmluZyIsIkVycm9yIiwiT1VUX09GX1JBTkdFIiwidGltZW91dCIsIm5vdyIsIkRhdGUiLCJzZXRNaWxsaXNlY29uZHMiLCJnZXRNaWxsaXNlY29uZHMiLCJzZXRUaW1lb3V0IiwiaGFuZGxlRXhwaXJlZERlYWRsaW5lIiwicmVtb3ZlIiwiSFRUUDJfSEVBREVSX0FDQ0VQVF9FTkNPRElORyIsIkhUVFAyX0hFQURFUl9URSIsInJlY2VpdmVVbmFyeU1lc3NhZ2UiLCJuZXh0IiwicmVjZWl2ZWRMZW5ndGgiLCJib2R5IiwibGltaXQiLCJvbkRhdGEiLCJvbkVuZCIsImJ5dGVMZW5ndGgiLCJyZW1vdmVMaXN0ZW5lciIsIlJFU09VUkNFX0VYSEFVU1RFRCIsInB1c2giLCJ1bmRlZmluZWQiLCJyZXF1ZXN0Qnl0ZXMiLCJCdWZmZXIiLCJjb25jYXQiLCJjb21wcmVzc2VkIiwicmVhZFVJbnQ4IiwiY29tcHJlc3NlZE1lc3NhZ2VFbmNvZGluZyIsImRlY29tcHJlc3NlZE1lc3NhZ2UiLCJpc0J1ZmZlciIsInNhZmVEZXNlcmlhbGl6ZU1lc3NhZ2UiLCJ0aGVuIiwiZGVjb21wcmVzc2VkIiwiYnVmZmVyIiwiZGVzZXJpYWxpemVNZXNzYWdlIiwibWVzc2FnZUJ1ZmZlciIsIm91dHB1dCIsImFsbG9jVW5zYWZlIiwid3JpdGVVSW50OCIsIndyaXRlVUludDMyQkUiLCJjb3B5IiwiYnl0ZXMiLCJzZW5kVW5hcnlNZXNzYWdlIiwiZmxhZ3MiLCJoYXNPd25Qcm9wZXJ0eSIsInN0YXR1c09iaiIsImNsZWFyVGltZW91dCIsInRyYWlsZXJzVG9TZW5kIiwiZW5jb2RlVVJJIiwic2VuZFRyYWlsZXJzIiwiZXJyb3IiLCJzdGF0dXMiLCJVTktOT1dOIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwicmVhc29uIiwicmVhZGFibGUiLCJkZWNvZGVyIiwiU3RyZWFtRGVjb2RlciIsInJlYWRzRG9uZSIsInBlbmRpbmdNZXNzYWdlUHJvY2Vzc2luZyIsInB1c2hlZEVuZCIsIm1heWJlUHVzaEVuZCIsInB1c2hPckJ1ZmZlck1lc3NhZ2UiLCJkYXRhIiwibWVzc2FnZXMiLCJwYXVzZSIsIm5leHRNZXNzYWdlIiwic2hpZnQiLCJtZXNzYWdlQnl0ZXMiLCJwdXNoTWVzc2FnZSIsImRlc2VyaWFsaXplZCIsIlVOQVVUSEVOVElDQVRFRCIsInNvY2tldCIsInNlc3Npb24iLCJyZW1vdGVBZGRyZXNzIiwicmVtb3RlUG9ydCIsIkRFQURMSU5FX0VYQ0VFREVEIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/server-call.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-credentials.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ServerCredentials = void 0;\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\nclass ServerCredentials {\n    static createInsecure() {\n        return new InsecureServerCredentials();\n    }\n    static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {\n        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {\n            throw new TypeError(\"rootCerts must be null or a Buffer\");\n        }\n        if (!Array.isArray(keyCertPairs)) {\n            throw new TypeError(\"keyCertPairs must be an array\");\n        }\n        if (typeof checkClientCertificate !== \"boolean\") {\n            throw new TypeError(\"checkClientCertificate must be a boolean\");\n        }\n        const cert = [];\n        const key = [];\n        for(let i = 0; i < keyCertPairs.length; i++){\n            const pair = keyCertPairs[i];\n            if (pair === null || typeof pair !== \"object\") {\n                throw new TypeError(`keyCertPair[${i}] must be an object`);\n            }\n            if (!Buffer.isBuffer(pair.private_key)) {\n                throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);\n            }\n            if (!Buffer.isBuffer(pair.cert_chain)) {\n                throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);\n            }\n            cert.push(pair.cert_chain);\n            key.push(pair.private_key);\n        }\n        return new SecureServerCredentials({\n            ca: rootCerts || tls_helpers_1.getDefaultRootsData() || undefined,\n            cert,\n            key,\n            requestCert: checkClientCertificate,\n            ciphers: tls_helpers_1.CIPHER_SUITES\n        });\n    }\n}\nexports.ServerCredentials = ServerCredentials;\nclass InsecureServerCredentials extends ServerCredentials {\n    _isSecure() {\n        return false;\n    }\n    _getSettings() {\n        return null;\n    }\n}\nclass SecureServerCredentials extends ServerCredentials {\n    constructor(options){\n        super();\n        this.options = options;\n    }\n    _isSecure() {\n        return true;\n    }\n    _getSettings() {\n        return this.options;\n    }\n} //# sourceMappingURL=server-credentials.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNyZWRlbnRpYWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx5QkFBeUIsR0FBRyxLQUFLO0FBQ2pDLE1BQU1HLGdCQUFnQkMsbUJBQU9BLENBQUMsa0ZBQWU7QUFDN0MsTUFBTUY7SUFDRixPQUFPRyxpQkFBaUI7UUFDcEIsT0FBTyxJQUFJQztJQUNmO0lBQ0EsT0FBT0MsVUFBVUMsU0FBUyxFQUFFQyxZQUFZLEVBQUVDLHlCQUF5QixLQUFLLEVBQUU7UUFDdEUsSUFBSUYsY0FBYyxRQUFRLENBQUNHLE9BQU9DLFFBQVEsQ0FBQ0osWUFBWTtZQUNuRCxNQUFNLElBQUlLLFVBQVU7UUFDeEI7UUFDQSxJQUFJLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ04sZUFBZTtZQUM5QixNQUFNLElBQUlJLFVBQVU7UUFDeEI7UUFDQSxJQUFJLE9BQU9ILDJCQUEyQixXQUFXO1lBQzdDLE1BQU0sSUFBSUcsVUFBVTtRQUN4QjtRQUNBLE1BQU1HLE9BQU8sRUFBRTtRQUNmLE1BQU1DLE1BQU0sRUFBRTtRQUNkLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJVCxhQUFhVSxNQUFNLEVBQUVELElBQUs7WUFDMUMsTUFBTUUsT0FBT1gsWUFBWSxDQUFDUyxFQUFFO1lBQzVCLElBQUlFLFNBQVMsUUFBUSxPQUFPQSxTQUFTLFVBQVU7Z0JBQzNDLE1BQU0sSUFBSVAsVUFBVSxDQUFDLFlBQVksRUFBRUssRUFBRSxtQkFBbUIsQ0FBQztZQUM3RDtZQUNBLElBQUksQ0FBQ1AsT0FBT0MsUUFBUSxDQUFDUSxLQUFLQyxXQUFXLEdBQUc7Z0JBQ3BDLE1BQU0sSUFBSVIsVUFBVSxDQUFDLFlBQVksRUFBRUssRUFBRSw4QkFBOEIsQ0FBQztZQUN4RTtZQUNBLElBQUksQ0FBQ1AsT0FBT0MsUUFBUSxDQUFDUSxLQUFLRSxVQUFVLEdBQUc7Z0JBQ25DLE1BQU0sSUFBSVQsVUFBVSxDQUFDLFlBQVksRUFBRUssRUFBRSw2QkFBNkIsQ0FBQztZQUN2RTtZQUNBRixLQUFLTyxJQUFJLENBQUNILEtBQUtFLFVBQVU7WUFDekJMLElBQUlNLElBQUksQ0FBQ0gsS0FBS0MsV0FBVztRQUM3QjtRQUNBLE9BQU8sSUFBSUcsd0JBQXdCO1lBQy9CQyxJQUFJakIsYUFBYUwsY0FBY3VCLG1CQUFtQixNQUFNQztZQUN4RFg7WUFDQUM7WUFDQVcsYUFBYWxCO1lBQ2JtQixTQUFTMUIsY0FBYzJCLGFBQWE7UUFDeEM7SUFDSjtBQUNKO0FBQ0E5Qix5QkFBeUIsR0FBR0U7QUFDNUIsTUFBTUksa0NBQWtDSjtJQUNwQzZCLFlBQVk7UUFDUixPQUFPO0lBQ1g7SUFDQUMsZUFBZTtRQUNYLE9BQU87SUFDWDtBQUNKO0FBQ0EsTUFBTVIsZ0NBQWdDdEI7SUFDbEMrQixZQUFZQyxPQUFPLENBQUU7UUFDakIsS0FBSztRQUNMLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNuQjtJQUNBSCxZQUFZO1FBQ1IsT0FBTztJQUNYO0lBQ0FDLGVBQWU7UUFDWCxPQUFPLElBQUksQ0FBQ0UsT0FBTztJQUN2QjtBQUNKLEVBQ0EsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNobWl0dC1ndXB0YS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2ZXItY3JlZGVudGlhbHMuanM/ZGM3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXJ2ZXJDcmVkZW50aWFscyA9IHZvaWQgMDtcbmNvbnN0IHRsc19oZWxwZXJzXzEgPSByZXF1aXJlKFwiLi90bHMtaGVscGVyc1wiKTtcbmNsYXNzIFNlcnZlckNyZWRlbnRpYWxzIHtcbiAgICBzdGF0aWMgY3JlYXRlSW5zZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5zZWN1cmVTZXJ2ZXJDcmVkZW50aWFscygpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlU3NsKHJvb3RDZXJ0cywga2V5Q2VydFBhaXJzLCBjaGVja0NsaWVudENlcnRpZmljYXRlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHJvb3RDZXJ0cyAhPT0gbnVsbCAmJiAhQnVmZmVyLmlzQnVmZmVyKHJvb3RDZXJ0cykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Jvb3RDZXJ0cyBtdXN0IGJlIG51bGwgb3IgYSBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5Q2VydFBhaXJzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigna2V5Q2VydFBhaXJzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNoZWNrQ2xpZW50Q2VydGlmaWNhdGUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2hlY2tDbGllbnRDZXJ0aWZpY2F0ZSBtdXN0IGJlIGEgYm9vbGVhbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlcnQgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5Q2VydFBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYWlyID0ga2V5Q2VydFBhaXJzW2ldO1xuICAgICAgICAgICAgaWYgKHBhaXIgPT09IG51bGwgfHwgdHlwZW9mIHBhaXIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihga2V5Q2VydFBhaXJbJHtpfV0gbXVzdCBiZSBhbiBvYmplY3RgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHBhaXIucHJpdmF0ZV9rZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihga2V5Q2VydFBhaXJbJHtpfV0ucHJpdmF0ZV9rZXkgbXVzdCBiZSBhIEJ1ZmZlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFpci5jZXJ0X2NoYWluKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGtleUNlcnRQYWlyWyR7aX1dLmNlcnRfY2hhaW4gbXVzdCBiZSBhIEJ1ZmZlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VydC5wdXNoKHBhaXIuY2VydF9jaGFpbik7XG4gICAgICAgICAgICBrZXkucHVzaChwYWlyLnByaXZhdGVfa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNlY3VyZVNlcnZlckNyZWRlbnRpYWxzKHtcbiAgICAgICAgICAgIGNhOiByb290Q2VydHMgfHwgdGxzX2hlbHBlcnNfMS5nZXREZWZhdWx0Um9vdHNEYXRhKCkgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2VydCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHJlcXVlc3RDZXJ0OiBjaGVja0NsaWVudENlcnRpZmljYXRlLFxuICAgICAgICAgICAgY2lwaGVyczogdGxzX2hlbHBlcnNfMS5DSVBIRVJfU1VJVEVTLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlckNyZWRlbnRpYWxzID0gU2VydmVyQ3JlZGVudGlhbHM7XG5jbGFzcyBJbnNlY3VyZVNlcnZlckNyZWRlbnRpYWxzIGV4dGVuZHMgU2VydmVyQ3JlZGVudGlhbHMge1xuICAgIF9pc1NlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmNsYXNzIFNlY3VyZVNlcnZlckNyZWRlbnRpYWxzIGV4dGVuZHMgU2VydmVyQ3JlZGVudGlhbHMge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgX2lzU2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX2dldFNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZlci1jcmVkZW50aWFscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTZXJ2ZXJDcmVkZW50aWFscyIsInRsc19oZWxwZXJzXzEiLCJyZXF1aXJlIiwiY3JlYXRlSW5zZWN1cmUiLCJJbnNlY3VyZVNlcnZlckNyZWRlbnRpYWxzIiwiY3JlYXRlU3NsIiwicm9vdENlcnRzIiwia2V5Q2VydFBhaXJzIiwiY2hlY2tDbGllbnRDZXJ0aWZpY2F0ZSIsIkJ1ZmZlciIsImlzQnVmZmVyIiwiVHlwZUVycm9yIiwiQXJyYXkiLCJpc0FycmF5IiwiY2VydCIsImtleSIsImkiLCJsZW5ndGgiLCJwYWlyIiwicHJpdmF0ZV9rZXkiLCJjZXJ0X2NoYWluIiwicHVzaCIsIlNlY3VyZVNlcnZlckNyZWRlbnRpYWxzIiwiY2EiLCJnZXREZWZhdWx0Um9vdHNEYXRhIiwidW5kZWZpbmVkIiwicmVxdWVzdENlcnQiLCJjaXBoZXJzIiwiQ0lQSEVSX1NVSVRFUyIsIl9pc1NlY3VyZSIsIl9nZXRTZXR0aW5ncyIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/server.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Server = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst server_call_1 = __webpack_require__(/*! ./server-call */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/server-call.js\");\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst { HTTP2_HEADER_PATH } = http2.constants;\nconst TRACER_NAME = \"server\";\nfunction noop() {}\nfunction getUnimplementedStatusResponse(methodName) {\n    return {\n        code: constants_1.Status.UNIMPLEMENTED,\n        details: `The server does not implement the method ${methodName}`\n    };\n}\nfunction getDefaultHandler(handlerType, methodName) {\n    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n    switch(handlerType){\n        case \"unary\":\n            return (call, callback)=>{\n                callback(unimplementedStatusResponse, null);\n            };\n        case \"clientStream\":\n            return (call, callback)=>{\n                callback(unimplementedStatusResponse, null);\n            };\n        case \"serverStream\":\n            return (call)=>{\n                call.emit(\"error\", unimplementedStatusResponse);\n            };\n        case \"bidi\":\n            return (call)=>{\n                call.emit(\"error\", unimplementedStatusResponse);\n            };\n        default:\n            throw new Error(`Invalid handlerType ${handlerType}`);\n    }\n}\nclass Server {\n    constructor(options){\n        this.http2ServerList = [];\n        this.handlers = new Map();\n        this.sessions = new Map();\n        this.started = false;\n        this.serverAddressString = \"null\";\n        // Channelz Info\n        this.channelzEnabled = true;\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.options = options !== null && options !== void 0 ? options : {};\n        if (this.options[\"grpc.enable_channelz\"] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzRef = channelz_1.registerChannelzServer(()=>this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Server created\");\n        }\n        this.trace(\"Server constructed\");\n    }\n    getChannelzInfo() {\n        return {\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            listenerChildren: this.listenerChildrenTracker.getChildLists(),\n            sessionChildren: this.sessionChildrenTracker.getChildLists()\n        };\n    }\n    getChannelzSessionInfoGetter(session) {\n        return ()=>{\n            var _a, _b, _c;\n            const sessionInfo = this.sessions.get(session);\n            const sessionSocket = session.socket;\n            const remoteAddress = sessionSocket.remoteAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n            const localAddress = sessionSocket.localAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n            let tlsInfo;\n            if (session.encrypted) {\n                const tlsSocket = sessionSocket;\n                const cipherInfo = tlsSocket.getCipher();\n                const certificate = tlsSocket.getCertificate();\n                const peerCertificate = tlsSocket.getPeerCertificate();\n                tlsInfo = {\n                    cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n                    cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n                    localCertificate: certificate && \"raw\" in certificate ? certificate.raw : null,\n                    remoteCertificate: peerCertificate && \"raw\" in peerCertificate ? peerCertificate.raw : null\n                };\n            } else {\n                tlsInfo = null;\n            }\n            const socketInfo = {\n                remoteAddress: remoteAddress,\n                localAddress: localAddress,\n                security: tlsInfo,\n                remoteName: null,\n                streamsStarted: sessionInfo.streamTracker.callsStarted,\n                streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n                streamsFailed: sessionInfo.streamTracker.callsFailed,\n                messagesSent: sessionInfo.messagesSent,\n                messagesReceived: sessionInfo.messagesReceived,\n                keepAlivesSent: 0,\n                lastLocalStreamCreatedTimestamp: null,\n                lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,\n                lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n                lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n                localFlowControlWindow: (_b = session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n                remoteFlowControlWindow: (_c = session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n            };\n            return socketInfo;\n        };\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"(\" + this.channelzRef.id + \") \" + text);\n    }\n    addProtoService() {\n        throw new Error(\"Not implemented. Use addService() instead\");\n    }\n    addService(service, implementation) {\n        if (service === null || typeof service !== \"object\" || implementation === null || typeof implementation !== \"object\") {\n            throw new Error(\"addService() requires two objects as arguments\");\n        }\n        const serviceKeys = Object.keys(service);\n        if (serviceKeys.length === 0) {\n            throw new Error(\"Cannot add an empty service to a server\");\n        }\n        serviceKeys.forEach((name)=>{\n            const attrs = service[name];\n            let methodType;\n            if (attrs.requestStream) {\n                if (attrs.responseStream) {\n                    methodType = \"bidi\";\n                } else {\n                    methodType = \"clientStream\";\n                }\n            } else {\n                if (attrs.responseStream) {\n                    methodType = \"serverStream\";\n                } else {\n                    methodType = \"unary\";\n                }\n            }\n            let implFn = implementation[name];\n            let impl;\n            if (implFn === undefined && typeof attrs.originalName === \"string\") {\n                implFn = implementation[attrs.originalName];\n            }\n            if (implFn !== undefined) {\n                impl = implFn.bind(implementation);\n            } else {\n                impl = getDefaultHandler(methodType, name);\n            }\n            const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n            if (success === false) {\n                throw new Error(`Method handler for ${attrs.path} already provided.`);\n            }\n        });\n    }\n    removeService(service) {\n        if (service === null || typeof service !== \"object\") {\n            throw new Error(\"removeService() requires object as argument\");\n        }\n        const serviceKeys = Object.keys(service);\n        serviceKeys.forEach((name)=>{\n            const attrs = service[name];\n            this.unregister(attrs.path);\n        });\n    }\n    bind(port, creds) {\n        throw new Error(\"Not implemented. Use bindAsync() instead\");\n    }\n    bindAsync(port, creds, callback) {\n        if (this.started === true) {\n            throw new Error(\"server is already started\");\n        }\n        if (typeof port !== \"string\") {\n            throw new TypeError(\"port must be a string\");\n        }\n        if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {\n            throw new TypeError(\"creds must be a ServerCredentials object\");\n        }\n        if (typeof callback !== \"function\") {\n            throw new TypeError(\"callback must be a function\");\n        }\n        const initialPortUri = uri_parser_1.parseUri(port);\n        if (initialPortUri === null) {\n            throw new Error(`Could not parse port \"${port}\"`);\n        }\n        const portUri = resolver_1.mapUriDefaultScheme(initialPortUri);\n        if (portUri === null) {\n            throw new Error(`Could not get a default scheme for port \"${port}\"`);\n        }\n        const serverOptions = {\n            maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER\n        };\n        if (\"grpc-node.max_session_memory\" in this.options) {\n            serverOptions.maxSessionMemory = this.options[\"grpc-node.max_session_memory\"];\n        } else {\n            /* By default, set a very large max session memory limit, to effectively\n             * disable enforcement of the limit. Some testing indicates that Node's\n             * behavior degrades badly when this limit is reached, so we solve that\n             * by disabling the check entirely. */ serverOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n        }\n        if (\"grpc.max_concurrent_streams\" in this.options) {\n            serverOptions.settings = {\n                maxConcurrentStreams: this.options[\"grpc.max_concurrent_streams\"]\n            };\n        }\n        const deferredCallback = (error, port)=>{\n            process.nextTick(()=>callback(error, port));\n        };\n        const setupServer = ()=>{\n            let http2Server;\n            if (creds._isSecure()) {\n                const secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n                http2Server = http2.createSecureServer(secureServerOptions);\n                http2Server.on(\"secureConnection\", (socket)=>{\n                    /* These errors need to be handled by the user of Http2SecureServer,\n                     * according to https://github.com/nodejs/node/issues/35824 */ socket.on(\"error\", (e)=>{\n                        this.trace(\"An incoming TLS connection closed with error: \" + e.message);\n                    });\n                });\n            } else {\n                http2Server = http2.createServer(serverOptions);\n            }\n            http2Server.setTimeout(0, noop);\n            this._setupHandlers(http2Server);\n            return http2Server;\n        };\n        const bindSpecificPort = (addressList, portNum, previousCount)=>{\n            if (addressList.length === 0) {\n                return Promise.resolve({\n                    port: portNum,\n                    count: previousCount\n                });\n            }\n            return Promise.all(addressList.map((address)=>{\n                this.trace(\"Attempting to bind \" + subchannel_address_1.subchannelAddressToString(address));\n                let addr;\n                if (subchannel_address_1.isTcpSubchannelAddress(address)) {\n                    addr = {\n                        host: address.host,\n                        port: portNum\n                    };\n                } else {\n                    addr = address;\n                }\n                const http2Server = setupServer();\n                return new Promise((resolve, reject)=>{\n                    const onError = (err)=>{\n                        this.trace(\"Failed to bind \" + subchannel_address_1.subchannelAddressToString(address) + \" with error \" + err.message);\n                        resolve(err);\n                    };\n                    http2Server.once(\"error\", onError);\n                    http2Server.listen(addr, ()=>{\n                        const boundAddress = http2Server.address();\n                        let boundSubchannelAddress;\n                        if (typeof boundAddress === \"string\") {\n                            boundSubchannelAddress = {\n                                path: boundAddress\n                            };\n                        } else {\n                            boundSubchannelAddress = {\n                                host: boundAddress.address,\n                                port: boundAddress.port\n                            };\n                        }\n                        let channelzRef;\n                        channelzRef = channelz_1.registerChannelzSocket(subchannel_address_1.subchannelAddressToString(boundSubchannelAddress), ()=>{\n                            return {\n                                localAddress: boundSubchannelAddress,\n                                remoteAddress: null,\n                                security: null,\n                                remoteName: null,\n                                streamsStarted: 0,\n                                streamsSucceeded: 0,\n                                streamsFailed: 0,\n                                messagesSent: 0,\n                                messagesReceived: 0,\n                                keepAlivesSent: 0,\n                                lastLocalStreamCreatedTimestamp: null,\n                                lastRemoteStreamCreatedTimestamp: null,\n                                lastMessageSentTimestamp: null,\n                                lastMessageReceivedTimestamp: null,\n                                localFlowControlWindow: null,\n                                remoteFlowControlWindow: null\n                            };\n                        }, this.channelzEnabled);\n                        if (this.channelzEnabled) {\n                            this.listenerChildrenTracker.refChild(channelzRef);\n                        }\n                        this.http2ServerList.push({\n                            server: http2Server,\n                            channelzRef: channelzRef\n                        });\n                        this.trace(\"Successfully bound \" + subchannel_address_1.subchannelAddressToString(boundSubchannelAddress));\n                        resolve(\"port\" in boundSubchannelAddress ? boundSubchannelAddress.port : portNum);\n                        http2Server.removeListener(\"error\", onError);\n                    });\n                });\n            })).then((results)=>{\n                let count = 0;\n                for (const result of results){\n                    if (typeof result === \"number\") {\n                        count += 1;\n                        if (result !== portNum) {\n                            throw new Error(\"Invalid state: multiple port numbers added from single address\");\n                        }\n                    }\n                }\n                return {\n                    port: portNum,\n                    count: count + previousCount\n                };\n            });\n        };\n        const bindWildcardPort = (addressList)=>{\n            if (addressList.length === 0) {\n                return Promise.resolve({\n                    port: 0,\n                    count: 0\n                });\n            }\n            const address = addressList[0];\n            const http2Server = setupServer();\n            return new Promise((resolve, reject)=>{\n                const onError = (err)=>{\n                    this.trace(\"Failed to bind \" + subchannel_address_1.subchannelAddressToString(address) + \" with error \" + err.message);\n                    resolve(bindWildcardPort(addressList.slice(1)));\n                };\n                http2Server.once(\"error\", onError);\n                http2Server.listen(address, ()=>{\n                    const boundAddress = http2Server.address();\n                    const boundSubchannelAddress = {\n                        host: boundAddress.address,\n                        port: boundAddress.port\n                    };\n                    let channelzRef;\n                    channelzRef = channelz_1.registerChannelzSocket(subchannel_address_1.subchannelAddressToString(boundSubchannelAddress), ()=>{\n                        return {\n                            localAddress: boundSubchannelAddress,\n                            remoteAddress: null,\n                            security: null,\n                            remoteName: null,\n                            streamsStarted: 0,\n                            streamsSucceeded: 0,\n                            streamsFailed: 0,\n                            messagesSent: 0,\n                            messagesReceived: 0,\n                            keepAlivesSent: 0,\n                            lastLocalStreamCreatedTimestamp: null,\n                            lastRemoteStreamCreatedTimestamp: null,\n                            lastMessageSentTimestamp: null,\n                            lastMessageReceivedTimestamp: null,\n                            localFlowControlWindow: null,\n                            remoteFlowControlWindow: null\n                        };\n                    }, this.channelzEnabled);\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.refChild(channelzRef);\n                    }\n                    this.http2ServerList.push({\n                        server: http2Server,\n                        channelzRef: channelzRef\n                    });\n                    this.trace(\"Successfully bound \" + subchannel_address_1.subchannelAddressToString(boundSubchannelAddress));\n                    resolve(bindSpecificPort(addressList.slice(1), boundAddress.port, 1));\n                    http2Server.removeListener(\"error\", onError);\n                });\n            });\n        };\n        const resolverListener = {\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError)=>{\n                // We only want one resolution result. Discard all future results\n                resolverListener.onSuccessfulResolution = ()=>{};\n                if (addressList.length === 0) {\n                    deferredCallback(new Error(`No addresses resolved for port ${port}`), 0);\n                    return;\n                }\n                let bindResultPromise;\n                if (subchannel_address_1.isTcpSubchannelAddress(addressList[0])) {\n                    if (addressList[0].port === 0) {\n                        bindResultPromise = bindWildcardPort(addressList);\n                    } else {\n                        bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);\n                    }\n                } else {\n                    // Use an arbitrary non-zero port for non-TCP addresses\n                    bindResultPromise = bindSpecificPort(addressList, 1, 0);\n                }\n                bindResultPromise.then((bindResult)=>{\n                    if (bindResult.count === 0) {\n                        const errorString = `No address added out of total ${addressList.length} resolved`;\n                        logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                        deferredCallback(new Error(errorString), 0);\n                    } else {\n                        if (bindResult.count < addressList.length) {\n                            logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n                        }\n                        deferredCallback(null, bindResult.port);\n                    }\n                }, (error)=>{\n                    const errorString = `No address added out of total ${addressList.length} resolved`;\n                    logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                    deferredCallback(new Error(errorString), 0);\n                });\n            },\n            onError: (error)=>{\n                deferredCallback(new Error(error.details), 0);\n            }\n        };\n        const resolver = resolver_1.createResolver(portUri, resolverListener, this.options);\n        resolver.updateResolution();\n    }\n    forceShutdown() {\n        // Close the server if it is still running.\n        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList){\n            if (http2Server.listening) {\n                http2Server.close(()=>{\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.unrefChild(ref);\n                        channelz_1.unregisterChannelzRef(ref);\n                    }\n                });\n            }\n        }\n        this.started = false;\n        // Always destroy any available sessions. It's possible that one or more\n        // tryShutdown() calls are in progress. Don't wait on them to finish.\n        this.sessions.forEach((channelzInfo, session)=>{\n            // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n            // recognize destroy(code) as a valid signature.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            session.destroy(http2.constants.NGHTTP2_CANCEL);\n        });\n        this.sessions.clear();\n        if (this.channelzEnabled) {\n            channelz_1.unregisterChannelzRef(this.channelzRef);\n        }\n    }\n    register(name, handler, serialize, deserialize, type) {\n        if (this.handlers.has(name)) {\n            return false;\n        }\n        this.handlers.set(name, {\n            func: handler,\n            serialize,\n            deserialize,\n            type,\n            path: name\n        });\n        return true;\n    }\n    unregister(name) {\n        return this.handlers.delete(name);\n    }\n    start() {\n        if (this.http2ServerList.length === 0 || this.http2ServerList.every(({ server: http2Server })=>http2Server.listening !== true)) {\n            throw new Error(\"server must be bound in order to start\");\n        }\n        if (this.started === true) {\n            throw new Error(\"server is already started\");\n        }\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Starting\");\n        }\n        this.started = true;\n    }\n    tryShutdown(callback) {\n        const wrappedCallback = (error)=>{\n            if (this.channelzEnabled) {\n                channelz_1.unregisterChannelzRef(this.channelzRef);\n            }\n            callback(error);\n        };\n        let pendingChecks = 0;\n        function maybeCallback() {\n            pendingChecks--;\n            if (pendingChecks === 0) {\n                wrappedCallback();\n            }\n        }\n        // Close the server if necessary.\n        this.started = false;\n        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList){\n            if (http2Server.listening) {\n                pendingChecks++;\n                http2Server.close(()=>{\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.unrefChild(ref);\n                        channelz_1.unregisterChannelzRef(ref);\n                    }\n                    maybeCallback();\n                });\n            }\n        }\n        this.sessions.forEach((channelzInfo, session)=>{\n            if (!session.closed) {\n                pendingChecks += 1;\n                session.close(maybeCallback);\n            }\n        });\n        if (pendingChecks === 0) {\n            wrappedCallback();\n        }\n    }\n    addHttp2Port() {\n        throw new Error(\"Not yet implemented\");\n    }\n    /**\n     * Get the channelz reference object for this server. The returned value is\n     * garbage if channelz is disabled for this server.\n     * @returns\n     */ getChannelzRef() {\n        return this.channelzRef;\n    }\n    _verifyContentType(stream, headers) {\n        const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n        if (typeof contentType !== \"string\" || !contentType.startsWith(\"application/grpc\")) {\n            stream.respond({\n                [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE\n            }, {\n                endStream: true\n            });\n            return false;\n        }\n        return true;\n    }\n    _retrieveHandler(headers) {\n        const path = headers[HTTP2_HEADER_PATH];\n        this.trace(\"Received call to method \" + path + \" at address \" + this.serverAddressString);\n        const handler = this.handlers.get(path);\n        if (handler === undefined) {\n            this.trace(\"No handler registered for method \" + path + \". Sending UNIMPLEMENTED status.\");\n            throw getUnimplementedStatusResponse(path);\n        }\n        return handler;\n    }\n    _respondWithError(err, stream, channelzSessionInfo = null) {\n        const call = new server_call_1.Http2ServerCallStream(stream, null, this.options);\n        if (err.code === undefined) {\n            err.code = constants_1.Status.INTERNAL;\n        }\n        if (this.channelzEnabled) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n        }\n        call.sendError(err);\n    }\n    _channelzHandler(stream, headers) {\n        const channelzSessionInfo = this.sessions.get(stream.session);\n        this.callTracker.addCallStarted();\n        channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();\n        if (!this._verifyContentType(stream, headers)) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n            return;\n        }\n        let handler;\n        try {\n            handler = this._retrieveHandler(headers);\n        } catch (err) {\n            this._respondWithError(err, stream, channelzSessionInfo);\n            return;\n        }\n        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n        call.once(\"callEnd\", (code)=>{\n            if (code === constants_1.Status.OK) {\n                this.callTracker.addCallSucceeded();\n            } else {\n                this.callTracker.addCallFailed();\n            }\n        });\n        if (channelzSessionInfo) {\n            call.once(\"streamEnd\", (success)=>{\n                if (success) {\n                    channelzSessionInfo.streamTracker.addCallSucceeded();\n                } else {\n                    channelzSessionInfo.streamTracker.addCallFailed();\n                }\n            });\n            call.on(\"sendMessage\", ()=>{\n                channelzSessionInfo.messagesSent += 1;\n                channelzSessionInfo.lastMessageSentTimestamp = new Date();\n            });\n            call.on(\"receiveMessage\", ()=>{\n                channelzSessionInfo.messagesReceived += 1;\n                channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n            });\n        }\n        if (!this._runHandlerForCall(call, handler, headers)) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n            call.sendError({\n                code: constants_1.Status.INTERNAL,\n                details: `Unknown handler type: ${handler.type}`\n            });\n        }\n    }\n    _streamHandler(stream, headers) {\n        if (this._verifyContentType(stream, headers) !== true) {\n            return;\n        }\n        let handler;\n        try {\n            handler = this._retrieveHandler(headers);\n        } catch (err) {\n            this._respondWithError(err, stream, null);\n            return;\n        }\n        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n        if (!this._runHandlerForCall(call, handler, headers)) {\n            call.sendError({\n                code: constants_1.Status.INTERNAL,\n                details: `Unknown handler type: ${handler.type}`\n            });\n        }\n    }\n    _runHandlerForCall(call, handler, headers) {\n        var _a;\n        const metadata = call.receiveMetadata(headers);\n        const encoding = (_a = metadata.get(\"grpc-encoding\")[0]) !== null && _a !== void 0 ? _a : \"identity\";\n        metadata.remove(\"grpc-encoding\");\n        const { type } = handler;\n        if (type === \"unary\") {\n            handleUnary(call, handler, metadata, encoding);\n        } else if (type === \"clientStream\") {\n            handleClientStreaming(call, handler, metadata, encoding);\n        } else if (type === \"serverStream\") {\n            handleServerStreaming(call, handler, metadata, encoding);\n        } else if (type === \"bidi\") {\n            handleBidiStreaming(call, handler, metadata, encoding);\n        } else {\n            return false;\n        }\n        return true;\n    }\n    _setupHandlers(http2Server) {\n        if (http2Server === null) {\n            return;\n        }\n        const serverAddress = http2Server.address();\n        let serverAddressString = \"null\";\n        if (serverAddress) {\n            if (typeof serverAddress === \"string\") {\n                serverAddressString = serverAddress;\n            } else {\n                serverAddressString = serverAddress.address + \":\" + serverAddress.port;\n            }\n        }\n        this.serverAddressString = serverAddressString;\n        const handler = this.channelzEnabled ? this._channelzHandler : this._streamHandler;\n        http2Server.on(\"stream\", handler.bind(this));\n        http2Server.on(\"session\", (session)=>{\n            var _a;\n            if (!this.started) {\n                session.destroy();\n                return;\n            }\n            let channelzRef;\n            channelzRef = channelz_1.registerChannelzSocket((_a = session.socket.remoteAddress) !== null && _a !== void 0 ? _a : \"unknown\", this.getChannelzSessionInfoGetter(session), this.channelzEnabled);\n            const channelzSessionInfo = {\n                ref: channelzRef,\n                streamTracker: new channelz_1.ChannelzCallTracker(),\n                messagesSent: 0,\n                messagesReceived: 0,\n                lastMessageSentTimestamp: null,\n                lastMessageReceivedTimestamp: null\n            };\n            this.sessions.set(session, channelzSessionInfo);\n            const clientAddress = session.socket.remoteAddress;\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace(\"CT_INFO\", \"Connection established by client \" + clientAddress);\n                this.sessionChildrenTracker.refChild(channelzRef);\n            }\n            session.on(\"close\", ()=>{\n                if (this.channelzEnabled) {\n                    this.channelzTrace.addTrace(\"CT_INFO\", \"Connection dropped by client \" + clientAddress);\n                    this.sessionChildrenTracker.unrefChild(channelzRef);\n                    channelz_1.unregisterChannelzRef(channelzRef);\n                }\n                this.sessions.delete(session);\n            });\n        });\n    }\n}\nexports.Server = Server;\nfunction handleUnary(call, handler, metadata, encoding) {\n    call.receiveUnaryMessage(encoding, (err, request)=>{\n        if (err) {\n            call.sendError(err);\n            return;\n        }\n        if (request === undefined || call.cancelled) {\n            return;\n        }\n        const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);\n        handler.func(emitter, (err, value, trailer, flags)=>{\n            call.sendUnaryMessage(err, value, trailer, flags);\n        });\n    });\n}\nfunction handleClientStreaming(call, handler, metadata, encoding) {\n    const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize, encoding);\n    function respond(err, value, trailer, flags) {\n        stream.destroy();\n        call.sendUnaryMessage(err, value, trailer, flags);\n    }\n    if (call.cancelled) {\n        return;\n    }\n    stream.on(\"error\", respond);\n    handler.func(stream, respond);\n}\nfunction handleServerStreaming(call, handler, metadata, encoding) {\n    call.receiveUnaryMessage(encoding, (err, request)=>{\n        if (err) {\n            call.sendError(err);\n            return;\n        }\n        if (request === undefined || call.cancelled) {\n            return;\n        }\n        const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize, request);\n        handler.func(stream);\n    });\n}\nfunction handleBidiStreaming(call, handler, metadata, encoding) {\n    const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize, encoding);\n    if (call.cancelled) {\n        return;\n    }\n    handler.func(stream);\n} //# sourceMappingURL=server.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixNQUFNRyxRQUFRQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUM3QixNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRSxnQkFBZ0JGLG1CQUFPQSxDQUFDLGtGQUFlO0FBQzdDLE1BQU1HLHVCQUF1QkgsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1JLGFBQWFKLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1LLFVBQVVMLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1NLHVCQUF1Qk4sbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1PLGVBQWVQLG1CQUFPQSxDQUFDLGdGQUFjO0FBQzNDLE1BQU1RLGFBQWFSLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU0sRUFBRVMsaUJBQWlCLEVBQUUsR0FBR1YsTUFBTVcsU0FBUztBQUM3QyxNQUFNQyxjQUFjO0FBQ3BCLFNBQVNDLFFBQVM7QUFDbEIsU0FBU0MsK0JBQStCQyxVQUFVO0lBQzlDLE9BQU87UUFDSEMsTUFBTWQsWUFBWWUsTUFBTSxDQUFDQyxhQUFhO1FBQ3RDQyxTQUFTLENBQUMseUNBQXlDLEVBQUVKLFdBQVcsQ0FBQztJQUNyRTtBQUNKO0FBQ0EsU0FBU0ssa0JBQWtCQyxXQUFXLEVBQUVOLFVBQVU7SUFDOUMsTUFBTU8sOEJBQThCUiwrQkFBK0JDO0lBQ25FLE9BQVFNO1FBQ0osS0FBSztZQUNELE9BQU8sQ0FBQ0UsTUFBTUM7Z0JBQ1ZBLFNBQVNGLDZCQUE2QjtZQUMxQztRQUNKLEtBQUs7WUFDRCxPQUFPLENBQUNDLE1BQU1DO2dCQUNWQSxTQUFTRiw2QkFBNkI7WUFDMUM7UUFDSixLQUFLO1lBQ0QsT0FBTyxDQUFDQztnQkFDSkEsS0FBS0UsSUFBSSxDQUFDLFNBQVNIO1lBQ3ZCO1FBQ0osS0FBSztZQUNELE9BQU8sQ0FBQ0M7Z0JBQ0pBLEtBQUtFLElBQUksQ0FBQyxTQUFTSDtZQUN2QjtRQUNKO1lBQ0ksTUFBTSxJQUFJSSxNQUFNLENBQUMsb0JBQW9CLEVBQUVMLFlBQVksQ0FBQztJQUM1RDtBQUNKO0FBQ0EsTUFBTXRCO0lBQ0Y0QixZQUFZQyxPQUFPLENBQUU7UUFDakIsSUFBSSxDQUFDQyxlQUFlLEdBQUcsRUFBRTtRQUN6QixJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJQztRQUNwQixJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJRDtRQUNwQixJQUFJLENBQUNFLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsbUJBQW1CLEdBQUc7UUFDM0IsZ0JBQWdCO1FBQ2hCLElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0MsYUFBYSxHQUFHLElBQUkzQixXQUFXNEIsYUFBYTtRQUNqRCxJQUFJLENBQUNDLFdBQVcsR0FBRyxJQUFJN0IsV0FBVzhCLG1CQUFtQjtRQUNyRCxJQUFJLENBQUNDLHVCQUF1QixHQUFHLElBQUkvQixXQUFXZ0MsdUJBQXVCO1FBQ3JFLElBQUksQ0FBQ0Msc0JBQXNCLEdBQUcsSUFBSWpDLFdBQVdnQyx1QkFBdUI7UUFDcEUsSUFBSSxDQUFDYixPQUFPLEdBQUdBLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUlBLFVBQVUsQ0FBQztRQUNuRSxJQUFJLElBQUksQ0FBQ0EsT0FBTyxDQUFDLHVCQUF1QixLQUFLLEdBQUc7WUFDNUMsSUFBSSxDQUFDTyxlQUFlLEdBQUc7UUFDM0I7UUFDQSxJQUFJLENBQUNRLFdBQVcsR0FBR2xDLFdBQVdtQyxzQkFBc0IsQ0FBQyxJQUFNLElBQUksQ0FBQ0MsZUFBZSxJQUFJLElBQUksQ0FBQ1YsZUFBZTtRQUN2RyxJQUFJLElBQUksQ0FBQ0EsZUFBZSxFQUFFO1lBQ3RCLElBQUksQ0FBQ0MsYUFBYSxDQUFDVSxRQUFRLENBQUMsV0FBVztRQUMzQztRQUNBLElBQUksQ0FBQ0MsS0FBSyxDQUFDO0lBQ2Y7SUFDQUYsa0JBQWtCO1FBQ2QsT0FBTztZQUNIRSxPQUFPLElBQUksQ0FBQ1gsYUFBYTtZQUN6QkUsYUFBYSxJQUFJLENBQUNBLFdBQVc7WUFDN0JVLGtCQUFrQixJQUFJLENBQUNSLHVCQUF1QixDQUFDUyxhQUFhO1lBQzVEQyxpQkFBaUIsSUFBSSxDQUFDUixzQkFBc0IsQ0FBQ08sYUFBYTtRQUM5RDtJQUNKO0lBQ0FFLDZCQUE2QkMsT0FBTyxFQUFFO1FBQ2xDLE9BQU87WUFDSCxJQUFJQyxJQUFJQyxJQUFJQztZQUNaLE1BQU1DLGNBQWMsSUFBSSxDQUFDeEIsUUFBUSxDQUFDeUIsR0FBRyxDQUFDTDtZQUN0QyxNQUFNTSxnQkFBZ0JOLFFBQVFPLE1BQU07WUFDcEMsTUFBTUMsZ0JBQWdCRixjQUFjRSxhQUFhLEdBQUdyRCxxQkFBcUJzRCx5QkFBeUIsQ0FBQ0gsY0FBY0UsYUFBYSxFQUFFRixjQUFjSSxVQUFVLElBQUk7WUFDNUosTUFBTUMsZUFBZUwsY0FBY0ssWUFBWSxHQUFHeEQscUJBQXFCc0QseUJBQXlCLENBQUNILGNBQWNLLFlBQVksRUFBRUwsY0FBY00sU0FBUyxJQUFJO1lBQ3hKLElBQUlDO1lBQ0osSUFBSWIsUUFBUWMsU0FBUyxFQUFFO2dCQUNuQixNQUFNQyxZQUFZVDtnQkFDbEIsTUFBTVUsYUFBYUQsVUFBVUUsU0FBUztnQkFDdEMsTUFBTUMsY0FBY0gsVUFBVUksY0FBYztnQkFDNUMsTUFBTUMsa0JBQWtCTCxVQUFVTSxrQkFBa0I7Z0JBQ3BEUixVQUFVO29CQUNOUyx5QkFBeUIsQ0FBQ3JCLEtBQUtlLFdBQVdPLFlBQVksTUFBTSxRQUFRdEIsT0FBTyxLQUFLLElBQUlBLEtBQUs7b0JBQ3pGdUIsc0JBQXNCUixXQUFXTyxZQUFZLEdBQUcsT0FBT1AsV0FBV1MsSUFBSTtvQkFDdEVDLGtCQUFrQixlQUFnQixTQUFTUixjQUFlQSxZQUFZUyxHQUFHLEdBQUc7b0JBQzVFQyxtQkFBbUIsbUJBQW9CLFNBQVNSLGtCQUFtQkEsZ0JBQWdCTyxHQUFHLEdBQUc7Z0JBQzdGO1lBQ0osT0FDSztnQkFDRGQsVUFBVTtZQUNkO1lBQ0EsTUFBTWdCLGFBQWE7Z0JBQ2ZyQixlQUFlQTtnQkFDZkcsY0FBY0E7Z0JBQ2RtQixVQUFVakI7Z0JBQ1ZrQixZQUFZO2dCQUNaQyxnQkFBZ0I1QixZQUFZNkIsYUFBYSxDQUFDQyxZQUFZO2dCQUN0REMsa0JBQWtCL0IsWUFBWTZCLGFBQWEsQ0FBQ0csY0FBYztnQkFDMURDLGVBQWVqQyxZQUFZNkIsYUFBYSxDQUFDSyxXQUFXO2dCQUNwREMsY0FBY25DLFlBQVltQyxZQUFZO2dCQUN0Q0Msa0JBQWtCcEMsWUFBWW9DLGdCQUFnQjtnQkFDOUNDLGdCQUFnQjtnQkFDaEJDLGlDQUFpQztnQkFDakNDLGtDQUFrQ3ZDLFlBQVk2QixhQUFhLENBQUNXLHdCQUF3QjtnQkFDcEZDLDBCQUEwQnpDLFlBQVl5Qyx3QkFBd0I7Z0JBQzlEQyw4QkFBOEIxQyxZQUFZMEMsNEJBQTRCO2dCQUN0RUMsd0JBQXdCLENBQUM3QyxLQUFLRixRQUFRZ0QsS0FBSyxDQUFDQyxlQUFlLE1BQU0sUUFBUS9DLE9BQU8sS0FBSyxJQUFJQSxLQUFLO2dCQUM5RmdELHlCQUF5QixDQUFDL0MsS0FBS0gsUUFBUWdELEtBQUssQ0FBQ0csZ0JBQWdCLE1BQU0sUUFBUWhELE9BQU8sS0FBSyxJQUFJQSxLQUFLO1lBQ3BHO1lBQ0EsT0FBTzBCO1FBQ1g7SUFDSjtJQUNBbEMsTUFBTXlELElBQUksRUFBRTtRQUNSbEcsUUFBUXlDLEtBQUssQ0FBQzdDLFlBQVl1RyxZQUFZLENBQUNDLEtBQUssRUFBRTlGLGFBQWEsTUFBTSxJQUFJLENBQUMrQixXQUFXLENBQUNnRSxFQUFFLEdBQUcsT0FBT0g7SUFDbEc7SUFDQUksa0JBQWtCO1FBQ2QsTUFBTSxJQUFJbEYsTUFBTTtJQUNwQjtJQUNBbUYsV0FBV0MsT0FBTyxFQUFFQyxjQUFjLEVBQUU7UUFDaEMsSUFBSUQsWUFBWSxRQUNaLE9BQU9BLFlBQVksWUFDbkJDLG1CQUFtQixRQUNuQixPQUFPQSxtQkFBbUIsVUFBVTtZQUNwQyxNQUFNLElBQUlyRixNQUFNO1FBQ3BCO1FBQ0EsTUFBTXNGLGNBQWNySCxPQUFPc0gsSUFBSSxDQUFDSDtRQUNoQyxJQUFJRSxZQUFZRSxNQUFNLEtBQUssR0FBRztZQUMxQixNQUFNLElBQUl4RixNQUFNO1FBQ3BCO1FBQ0FzRixZQUFZRyxPQUFPLENBQUMsQ0FBQ3RDO1lBQ2pCLE1BQU11QyxRQUFRTixPQUFPLENBQUNqQyxLQUFLO1lBQzNCLElBQUl3QztZQUNKLElBQUlELE1BQU1FLGFBQWEsRUFBRTtnQkFDckIsSUFBSUYsTUFBTUcsY0FBYyxFQUFFO29CQUN0QkYsYUFBYTtnQkFDakIsT0FDSztvQkFDREEsYUFBYTtnQkFDakI7WUFDSixPQUNLO2dCQUNELElBQUlELE1BQU1HLGNBQWMsRUFBRTtvQkFDdEJGLGFBQWE7Z0JBQ2pCLE9BQ0s7b0JBQ0RBLGFBQWE7Z0JBQ2pCO1lBQ0o7WUFDQSxJQUFJRyxTQUFTVCxjQUFjLENBQUNsQyxLQUFLO1lBQ2pDLElBQUk0QztZQUNKLElBQUlELFdBQVdFLGFBQWEsT0FBT04sTUFBTU8sWUFBWSxLQUFLLFVBQVU7Z0JBQ2hFSCxTQUFTVCxjQUFjLENBQUNLLE1BQU1PLFlBQVksQ0FBQztZQUMvQztZQUNBLElBQUlILFdBQVdFLFdBQVc7Z0JBQ3RCRCxPQUFPRCxPQUFPSSxJQUFJLENBQUNiO1lBQ3ZCLE9BQ0s7Z0JBQ0RVLE9BQU9yRyxrQkFBa0JpRyxZQUFZeEM7WUFDekM7WUFDQSxNQUFNZ0QsVUFBVSxJQUFJLENBQUNDLFFBQVEsQ0FBQ1YsTUFBTVcsSUFBSSxFQUFFTixNQUFNTCxNQUFNWSxpQkFBaUIsRUFBRVosTUFBTWEsa0JBQWtCLEVBQUVaO1lBQ25HLElBQUlRLFlBQVksT0FBTztnQkFDbkIsTUFBTSxJQUFJbkcsTUFBTSxDQUFDLG1CQUFtQixFQUFFMEYsTUFBTVcsSUFBSSxDQUFDLGtCQUFrQixDQUFDO1lBQ3hFO1FBQ0o7SUFDSjtJQUNBRyxjQUFjcEIsT0FBTyxFQUFFO1FBQ25CLElBQUlBLFlBQVksUUFBUSxPQUFPQSxZQUFZLFVBQVU7WUFDakQsTUFBTSxJQUFJcEYsTUFBTTtRQUNwQjtRQUNBLE1BQU1zRixjQUFjckgsT0FBT3NILElBQUksQ0FBQ0g7UUFDaENFLFlBQVlHLE9BQU8sQ0FBQyxDQUFDdEM7WUFDakIsTUFBTXVDLFFBQVFOLE9BQU8sQ0FBQ2pDLEtBQUs7WUFDM0IsSUFBSSxDQUFDc0QsVUFBVSxDQUFDZixNQUFNVyxJQUFJO1FBQzlCO0lBQ0o7SUFDQUgsS0FBS1EsSUFBSSxFQUFFQyxLQUFLLEVBQUU7UUFDZCxNQUFNLElBQUkzRyxNQUFNO0lBQ3BCO0lBQ0E0RyxVQUFVRixJQUFJLEVBQUVDLEtBQUssRUFBRTdHLFFBQVEsRUFBRTtRQUM3QixJQUFJLElBQUksQ0FBQ1MsT0FBTyxLQUFLLE1BQU07WUFDdkIsTUFBTSxJQUFJUCxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxPQUFPMEcsU0FBUyxVQUFVO1lBQzFCLE1BQU0sSUFBSUcsVUFBVTtRQUN4QjtRQUNBLElBQUlGLFVBQVUsUUFBUSxDQUFFQSxDQUFBQSxpQkFBaUJqSSxxQkFBcUJvSSxpQkFBaUIsR0FBRztZQUM5RSxNQUFNLElBQUlELFVBQVU7UUFDeEI7UUFDQSxJQUFJLE9BQU8vRyxhQUFhLFlBQVk7WUFDaEMsTUFBTSxJQUFJK0csVUFBVTtRQUN4QjtRQUNBLE1BQU1FLGlCQUFpQmpJLGFBQWFrSSxRQUFRLENBQUNOO1FBQzdDLElBQUlLLG1CQUFtQixNQUFNO1lBQ3pCLE1BQU0sSUFBSS9HLE1BQU0sQ0FBQyxzQkFBc0IsRUFBRTBHLEtBQUssQ0FBQyxDQUFDO1FBQ3BEO1FBQ0EsTUFBTU8sVUFBVXRJLFdBQVd1SSxtQkFBbUIsQ0FBQ0g7UUFDL0MsSUFBSUUsWUFBWSxNQUFNO1lBQ2xCLE1BQU0sSUFBSWpILE1BQU0sQ0FBQyx5Q0FBeUMsRUFBRTBHLEtBQUssQ0FBQyxDQUFDO1FBQ3ZFO1FBQ0EsTUFBTVMsZ0JBQWdCO1lBQ2xCQywwQkFBMEJDLE9BQU9DLGdCQUFnQjtRQUNyRDtRQUNBLElBQUksa0NBQWtDLElBQUksQ0FBQ3BILE9BQU8sRUFBRTtZQUNoRGlILGNBQWNJLGdCQUFnQixHQUFHLElBQUksQ0FBQ3JILE9BQU8sQ0FBQywrQkFBK0I7UUFDakYsT0FDSztZQUNEOzs7Z0RBR29DLEdBQ3BDaUgsY0FBY0ksZ0JBQWdCLEdBQUdGLE9BQU9DLGdCQUFnQjtRQUM1RDtRQUNBLElBQUksaUNBQWlDLElBQUksQ0FBQ3BILE9BQU8sRUFBRTtZQUMvQ2lILGNBQWNLLFFBQVEsR0FBRztnQkFDckJDLHNCQUFzQixJQUFJLENBQUN2SCxPQUFPLENBQUMsOEJBQThCO1lBQ3JFO1FBQ0o7UUFDQSxNQUFNd0gsbUJBQW1CLENBQUNDLE9BQU9qQjtZQUM3QmtCLFFBQVFDLFFBQVEsQ0FBQyxJQUFNL0gsU0FBUzZILE9BQU9qQjtRQUMzQztRQUNBLE1BQU1vQixjQUFjO1lBQ2hCLElBQUlDO1lBQ0osSUFBSXBCLE1BQU1xQixTQUFTLElBQUk7Z0JBQ25CLE1BQU1DLHNCQUFzQmhLLE9BQU9pSyxNQUFNLENBQUNmLGVBQWVSLE1BQU13QixZQUFZO2dCQUMzRUosY0FBY3pKLE1BQU04SixrQkFBa0IsQ0FBQ0g7Z0JBQ3ZDRixZQUFZTSxFQUFFLENBQUMsb0JBQW9CLENBQUNwRztvQkFDaEM7Z0ZBQzRELEdBQzVEQSxPQUFPb0csRUFBRSxDQUFDLFNBQVMsQ0FBQ0M7d0JBQ2hCLElBQUksQ0FBQ2pILEtBQUssQ0FBQyxtREFBbURpSCxFQUFFQyxPQUFPO29CQUMzRTtnQkFDSjtZQUNKLE9BQ0s7Z0JBQ0RSLGNBQWN6SixNQUFNa0ssWUFBWSxDQUFDckI7WUFDckM7WUFDQVksWUFBWVUsVUFBVSxDQUFDLEdBQUd0SjtZQUMxQixJQUFJLENBQUN1SixjQUFjLENBQUNYO1lBQ3BCLE9BQU9BO1FBQ1g7UUFDQSxNQUFNWSxtQkFBbUIsQ0FBQ0MsYUFBYUMsU0FBU0M7WUFDNUMsSUFBSUYsWUFBWXBELE1BQU0sS0FBSyxHQUFHO2dCQUMxQixPQUFPdUQsUUFBUUMsT0FBTyxDQUFDO29CQUFFdEMsTUFBTW1DO29CQUFTSSxPQUFPSDtnQkFBYztZQUNqRTtZQUNBLE9BQU9DLFFBQVFHLEdBQUcsQ0FBQ04sWUFBWU8sR0FBRyxDQUFDLENBQUNDO2dCQUNoQyxJQUFJLENBQUMvSCxLQUFLLENBQUMsd0JBQXdCeEMscUJBQXFCd0sseUJBQXlCLENBQUNEO2dCQUNsRixJQUFJRTtnQkFDSixJQUFJeksscUJBQXFCMEssc0JBQXNCLENBQUNILFVBQVU7b0JBQ3RERSxPQUFPO3dCQUNIRSxNQUFNSixRQUFRSSxJQUFJO3dCQUNsQjlDLE1BQU1tQztvQkFDVjtnQkFDSixPQUNLO29CQUNEUyxPQUFPRjtnQkFDWDtnQkFDQSxNQUFNckIsY0FBY0Q7Z0JBQ3BCLE9BQU8sSUFBSWlCLFFBQVEsQ0FBQ0MsU0FBU1M7b0JBQ3pCLE1BQU1DLFVBQVUsQ0FBQ0M7d0JBQ2IsSUFBSSxDQUFDdEksS0FBSyxDQUFDLG9CQUFvQnhDLHFCQUFxQndLLHlCQUF5QixDQUFDRCxXQUFXLGlCQUFpQk8sSUFBSXBCLE9BQU87d0JBQ3JIUyxRQUFRVztvQkFDWjtvQkFDQTVCLFlBQVk2QixJQUFJLENBQUMsU0FBU0Y7b0JBQzFCM0IsWUFBWThCLE1BQU0sQ0FBQ1AsTUFBTTt3QkFDckIsTUFBTVEsZUFBZS9CLFlBQVlxQixPQUFPO3dCQUN4QyxJQUFJVzt3QkFDSixJQUFJLE9BQU9ELGlCQUFpQixVQUFVOzRCQUNsQ0MseUJBQXlCO2dDQUNyQjFELE1BQU15RDs0QkFDVjt3QkFDSixPQUNLOzRCQUNEQyx5QkFBeUI7Z0NBQ3JCUCxNQUFNTSxhQUFhVixPQUFPO2dDQUMxQjFDLE1BQU1vRCxhQUFhcEQsSUFBSTs0QkFDM0I7d0JBQ0o7d0JBQ0EsSUFBSXpGO3dCQUNKQSxjQUFjbEMsV0FBV2lMLHNCQUFzQixDQUFDbkwscUJBQXFCd0sseUJBQXlCLENBQUNVLHlCQUF5Qjs0QkFDcEgsT0FBTztnQ0FDSDFILGNBQWMwSDtnQ0FDZDdILGVBQWU7Z0NBQ2ZzQixVQUFVO2dDQUNWQyxZQUFZO2dDQUNaQyxnQkFBZ0I7Z0NBQ2hCRyxrQkFBa0I7Z0NBQ2xCRSxlQUFlO2dDQUNmRSxjQUFjO2dDQUNkQyxrQkFBa0I7Z0NBQ2xCQyxnQkFBZ0I7Z0NBQ2hCQyxpQ0FBaUM7Z0NBQ2pDQyxrQ0FBa0M7Z0NBQ2xDRSwwQkFBMEI7Z0NBQzFCQyw4QkFBOEI7Z0NBQzlCQyx3QkFBd0I7Z0NBQ3hCRyx5QkFBeUI7NEJBQzdCO3dCQUNKLEdBQUcsSUFBSSxDQUFDbkUsZUFBZTt3QkFDdkIsSUFBSSxJQUFJLENBQUNBLGVBQWUsRUFBRTs0QkFDdEIsSUFBSSxDQUFDSyx1QkFBdUIsQ0FBQ21KLFFBQVEsQ0FBQ2hKO3dCQUMxQzt3QkFDQSxJQUFJLENBQUNkLGVBQWUsQ0FBQytKLElBQUksQ0FBQzs0QkFBRUMsUUFBUXBDOzRCQUFhOUcsYUFBYUE7d0JBQVk7d0JBQzFFLElBQUksQ0FBQ0ksS0FBSyxDQUFDLHdCQUF3QnhDLHFCQUFxQndLLHlCQUF5QixDQUFDVTt3QkFDbEZmLFFBQVEsVUFBVWUseUJBQXlCQSx1QkFBdUJyRCxJQUFJLEdBQUdtQzt3QkFDekVkLFlBQVlxQyxjQUFjLENBQUMsU0FBU1Y7b0JBQ3hDO2dCQUNKO1lBQ0osSUFBSVcsSUFBSSxDQUFDLENBQUNDO2dCQUNOLElBQUlyQixRQUFRO2dCQUNaLEtBQUssTUFBTXNCLFVBQVVELFFBQVM7b0JBQzFCLElBQUksT0FBT0MsV0FBVyxVQUFVO3dCQUM1QnRCLFNBQVM7d0JBQ1QsSUFBSXNCLFdBQVcxQixTQUFTOzRCQUNwQixNQUFNLElBQUk3SSxNQUFNO3dCQUNwQjtvQkFDSjtnQkFDSjtnQkFDQSxPQUFPO29CQUNIMEcsTUFBTW1DO29CQUNOSSxPQUFPQSxRQUFRSDtnQkFDbkI7WUFDSjtRQUNKO1FBQ0EsTUFBTTBCLG1CQUFtQixDQUFDNUI7WUFDdEIsSUFBSUEsWUFBWXBELE1BQU0sS0FBSyxHQUFHO2dCQUMxQixPQUFPdUQsUUFBUUMsT0FBTyxDQUFDO29CQUFFdEMsTUFBTTtvQkFBR3VDLE9BQU87Z0JBQUU7WUFDL0M7WUFDQSxNQUFNRyxVQUFVUixXQUFXLENBQUMsRUFBRTtZQUM5QixNQUFNYixjQUFjRDtZQUNwQixPQUFPLElBQUlpQixRQUFRLENBQUNDLFNBQVNTO2dCQUN6QixNQUFNQyxVQUFVLENBQUNDO29CQUNiLElBQUksQ0FBQ3RJLEtBQUssQ0FBQyxvQkFBb0J4QyxxQkFBcUJ3Syx5QkFBeUIsQ0FBQ0QsV0FBVyxpQkFBaUJPLElBQUlwQixPQUFPO29CQUNySFMsUUFBUXdCLGlCQUFpQjVCLFlBQVk2QixLQUFLLENBQUM7Z0JBQy9DO2dCQUNBMUMsWUFBWTZCLElBQUksQ0FBQyxTQUFTRjtnQkFDMUIzQixZQUFZOEIsTUFBTSxDQUFDVCxTQUFTO29CQUN4QixNQUFNVSxlQUFlL0IsWUFBWXFCLE9BQU87b0JBQ3hDLE1BQU1XLHlCQUF5Qjt3QkFDM0JQLE1BQU1NLGFBQWFWLE9BQU87d0JBQzFCMUMsTUFBTW9ELGFBQWFwRCxJQUFJO29CQUMzQjtvQkFDQSxJQUFJekY7b0JBQ0pBLGNBQWNsQyxXQUFXaUwsc0JBQXNCLENBQUNuTCxxQkFBcUJ3Syx5QkFBeUIsQ0FBQ1UseUJBQXlCO3dCQUNwSCxPQUFPOzRCQUNIMUgsY0FBYzBIOzRCQUNkN0gsZUFBZTs0QkFDZnNCLFVBQVU7NEJBQ1ZDLFlBQVk7NEJBQ1pDLGdCQUFnQjs0QkFDaEJHLGtCQUFrQjs0QkFDbEJFLGVBQWU7NEJBQ2ZFLGNBQWM7NEJBQ2RDLGtCQUFrQjs0QkFDbEJDLGdCQUFnQjs0QkFDaEJDLGlDQUFpQzs0QkFDakNDLGtDQUFrQzs0QkFDbENFLDBCQUEwQjs0QkFDMUJDLDhCQUE4Qjs0QkFDOUJDLHdCQUF3Qjs0QkFDeEJHLHlCQUF5Qjt3QkFDN0I7b0JBQ0osR0FBRyxJQUFJLENBQUNuRSxlQUFlO29CQUN2QixJQUFJLElBQUksQ0FBQ0EsZUFBZSxFQUFFO3dCQUN0QixJQUFJLENBQUNLLHVCQUF1QixDQUFDbUosUUFBUSxDQUFDaEo7b0JBQzFDO29CQUNBLElBQUksQ0FBQ2QsZUFBZSxDQUFDK0osSUFBSSxDQUFDO3dCQUFFQyxRQUFRcEM7d0JBQWE5RyxhQUFhQTtvQkFBWTtvQkFDMUUsSUFBSSxDQUFDSSxLQUFLLENBQUMsd0JBQXdCeEMscUJBQXFCd0sseUJBQXlCLENBQUNVO29CQUNsRmYsUUFBUUwsaUJBQWlCQyxZQUFZNkIsS0FBSyxDQUFDLElBQUlYLGFBQWFwRCxJQUFJLEVBQUU7b0JBQ2xFcUIsWUFBWXFDLGNBQWMsQ0FBQyxTQUFTVjtnQkFDeEM7WUFDSjtRQUNKO1FBQ0EsTUFBTWdCLG1CQUFtQjtZQUNyQkMsd0JBQXdCLENBQUMvQixhQUFhZ0MsZUFBZUM7Z0JBQ2pELGlFQUFpRTtnQkFDakVILGlCQUFpQkMsc0JBQXNCLEdBQUcsS0FBUTtnQkFDbEQsSUFBSS9CLFlBQVlwRCxNQUFNLEtBQUssR0FBRztvQkFDMUJrQyxpQkFBaUIsSUFBSTFILE1BQU0sQ0FBQywrQkFBK0IsRUFBRTBHLEtBQUssQ0FBQyxHQUFHO29CQUN0RTtnQkFDSjtnQkFDQSxJQUFJb0U7Z0JBQ0osSUFBSWpNLHFCQUFxQjBLLHNCQUFzQixDQUFDWCxXQUFXLENBQUMsRUFBRSxHQUFHO29CQUM3RCxJQUFJQSxXQUFXLENBQUMsRUFBRSxDQUFDbEMsSUFBSSxLQUFLLEdBQUc7d0JBQzNCb0Usb0JBQW9CTixpQkFBaUI1QjtvQkFDekMsT0FDSzt3QkFDRGtDLG9CQUFvQm5DLGlCQUFpQkMsYUFBYUEsV0FBVyxDQUFDLEVBQUUsQ0FBQ2xDLElBQUksRUFBRTtvQkFDM0U7Z0JBQ0osT0FDSztvQkFDRCx1REFBdUQ7b0JBQ3ZEb0Usb0JBQW9CbkMsaUJBQWlCQyxhQUFhLEdBQUc7Z0JBQ3pEO2dCQUNBa0Msa0JBQWtCVCxJQUFJLENBQUMsQ0FBQ1U7b0JBQ3BCLElBQUlBLFdBQVc5QixLQUFLLEtBQUssR0FBRzt3QkFDeEIsTUFBTStCLGNBQWMsQ0FBQyw4QkFBOEIsRUFBRXBDLFlBQVlwRCxNQUFNLENBQUMsU0FBUyxDQUFDO3dCQUNsRjVHLFFBQVFxTSxHQUFHLENBQUN6TSxZQUFZdUcsWUFBWSxDQUFDbUcsS0FBSyxFQUFFRjt3QkFDNUN0RCxpQkFBaUIsSUFBSTFILE1BQU1nTCxjQUFjO29CQUM3QyxPQUNLO3dCQUNELElBQUlELFdBQVc5QixLQUFLLEdBQUdMLFlBQVlwRCxNQUFNLEVBQUU7NEJBQ3ZDNUcsUUFBUXFNLEdBQUcsQ0FBQ3pNLFlBQVl1RyxZQUFZLENBQUNvRyxJQUFJLEVBQUUsQ0FBQyxhQUFhLEVBQUVKLFdBQVc5QixLQUFLLENBQUMsOEJBQThCLEVBQUVMLFlBQVlwRCxNQUFNLENBQUMsU0FBUyxDQUFDO3dCQUM3STt3QkFDQWtDLGlCQUFpQixNQUFNcUQsV0FBV3JFLElBQUk7b0JBQzFDO2dCQUNKLEdBQUcsQ0FBQ2lCO29CQUNBLE1BQU1xRCxjQUFjLENBQUMsOEJBQThCLEVBQUVwQyxZQUFZcEQsTUFBTSxDQUFDLFNBQVMsQ0FBQztvQkFDbEY1RyxRQUFRcU0sR0FBRyxDQUFDek0sWUFBWXVHLFlBQVksQ0FBQ21HLEtBQUssRUFBRUY7b0JBQzVDdEQsaUJBQWlCLElBQUkxSCxNQUFNZ0wsY0FBYztnQkFDN0M7WUFDSjtZQUNBdEIsU0FBUyxDQUFDL0I7Z0JBQ05ELGlCQUFpQixJQUFJMUgsTUFBTTJILE1BQU1sSSxPQUFPLEdBQUc7WUFDL0M7UUFDSjtRQUNBLE1BQU0yTCxXQUFXek0sV0FBVzBNLGNBQWMsQ0FBQ3BFLFNBQVN5RCxrQkFBa0IsSUFBSSxDQUFDeEssT0FBTztRQUNsRmtMLFNBQVNFLGdCQUFnQjtJQUM3QjtJQUNBQyxnQkFBZ0I7UUFDWiwyQ0FBMkM7UUFDM0MsS0FBSyxNQUFNLEVBQUVwQixRQUFRcEMsV0FBVyxFQUFFOUcsYUFBYXVLLEdBQUcsRUFBRSxJQUFJLElBQUksQ0FBQ3JMLGVBQWUsQ0FBRTtZQUMxRSxJQUFJNEgsWUFBWTBELFNBQVMsRUFBRTtnQkFDdkIxRCxZQUFZMkQsS0FBSyxDQUFDO29CQUNkLElBQUksSUFBSSxDQUFDakwsZUFBZSxFQUFFO3dCQUN0QixJQUFJLENBQUNLLHVCQUF1QixDQUFDNkssVUFBVSxDQUFDSDt3QkFDeEN6TSxXQUFXNk0scUJBQXFCLENBQUNKO29CQUNyQztnQkFDSjtZQUNKO1FBQ0o7UUFDQSxJQUFJLENBQUNqTCxPQUFPLEdBQUc7UUFDZix3RUFBd0U7UUFDeEUscUVBQXFFO1FBQ3JFLElBQUksQ0FBQ0QsUUFBUSxDQUFDbUYsT0FBTyxDQUFDLENBQUNvRyxjQUFjbks7WUFDakMsZ0VBQWdFO1lBQ2hFLGdEQUFnRDtZQUNoRCw4REFBOEQ7WUFDOURBLFFBQVFvSyxPQUFPLENBQUN4TixNQUFNVyxTQUFTLENBQUM4TSxjQUFjO1FBQ2xEO1FBQ0EsSUFBSSxDQUFDekwsUUFBUSxDQUFDMEwsS0FBSztRQUNuQixJQUFJLElBQUksQ0FBQ3ZMLGVBQWUsRUFBRTtZQUN0QjFCLFdBQVc2TSxxQkFBcUIsQ0FBQyxJQUFJLENBQUMzSyxXQUFXO1FBQ3JEO0lBQ0o7SUFDQW1GLFNBQVNqRCxJQUFJLEVBQUU4SSxPQUFPLEVBQUVDLFNBQVMsRUFBRUMsV0FBVyxFQUFFQyxJQUFJLEVBQUU7UUFDbEQsSUFBSSxJQUFJLENBQUNoTSxRQUFRLENBQUNpTSxHQUFHLENBQUNsSixPQUFPO1lBQ3pCLE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQy9DLFFBQVEsQ0FBQ2tNLEdBQUcsQ0FBQ25KLE1BQU07WUFDcEJvSixNQUFNTjtZQUNOQztZQUNBQztZQUNBQztZQUNBL0YsTUFBTWxEO1FBQ1Y7UUFDQSxPQUFPO0lBQ1g7SUFDQXNELFdBQVd0RCxJQUFJLEVBQUU7UUFDYixPQUFPLElBQUksQ0FBQy9DLFFBQVEsQ0FBQ29NLE1BQU0sQ0FBQ3JKO0lBQ2hDO0lBQ0FzSixRQUFRO1FBQ0osSUFBSSxJQUFJLENBQUN0TSxlQUFlLENBQUNxRixNQUFNLEtBQUssS0FDaEMsSUFBSSxDQUFDckYsZUFBZSxDQUFDdU0sS0FBSyxDQUFDLENBQUMsRUFBRXZDLFFBQVFwQyxXQUFXLEVBQUUsR0FBS0EsWUFBWTBELFNBQVMsS0FBSyxPQUFPO1lBQ3pGLE1BQU0sSUFBSXpMLE1BQU07UUFDcEI7UUFDQSxJQUFJLElBQUksQ0FBQ08sT0FBTyxLQUFLLE1BQU07WUFDdkIsTUFBTSxJQUFJUCxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxJQUFJLENBQUNTLGVBQWUsRUFBRTtZQUN0QixJQUFJLENBQUNDLGFBQWEsQ0FBQ1UsUUFBUSxDQUFDLFdBQVc7UUFDM0M7UUFDQSxJQUFJLENBQUNiLE9BQU8sR0FBRztJQUNuQjtJQUNBb00sWUFBWTdNLFFBQVEsRUFBRTtRQUNsQixNQUFNOE0sa0JBQWtCLENBQUNqRjtZQUNyQixJQUFJLElBQUksQ0FBQ2xILGVBQWUsRUFBRTtnQkFDdEIxQixXQUFXNk0scUJBQXFCLENBQUMsSUFBSSxDQUFDM0ssV0FBVztZQUNyRDtZQUNBbkIsU0FBUzZIO1FBQ2I7UUFDQSxJQUFJa0YsZ0JBQWdCO1FBQ3BCLFNBQVNDO1lBQ0xEO1lBQ0EsSUFBSUEsa0JBQWtCLEdBQUc7Z0JBQ3JCRDtZQUNKO1FBQ0o7UUFDQSxpQ0FBaUM7UUFDakMsSUFBSSxDQUFDck0sT0FBTyxHQUFHO1FBQ2YsS0FBSyxNQUFNLEVBQUU0SixRQUFRcEMsV0FBVyxFQUFFOUcsYUFBYXVLLEdBQUcsRUFBRSxJQUFJLElBQUksQ0FBQ3JMLGVBQWUsQ0FBRTtZQUMxRSxJQUFJNEgsWUFBWTBELFNBQVMsRUFBRTtnQkFDdkJvQjtnQkFDQTlFLFlBQVkyRCxLQUFLLENBQUM7b0JBQ2QsSUFBSSxJQUFJLENBQUNqTCxlQUFlLEVBQUU7d0JBQ3RCLElBQUksQ0FBQ0ssdUJBQXVCLENBQUM2SyxVQUFVLENBQUNIO3dCQUN4Q3pNLFdBQVc2TSxxQkFBcUIsQ0FBQ0o7b0JBQ3JDO29CQUNBc0I7Z0JBQ0o7WUFDSjtRQUNKO1FBQ0EsSUFBSSxDQUFDeE0sUUFBUSxDQUFDbUYsT0FBTyxDQUFDLENBQUNvRyxjQUFjbks7WUFDakMsSUFBSSxDQUFDQSxRQUFRcUwsTUFBTSxFQUFFO2dCQUNqQkYsaUJBQWlCO2dCQUNqQm5MLFFBQVFnSyxLQUFLLENBQUNvQjtZQUNsQjtRQUNKO1FBQ0EsSUFBSUQsa0JBQWtCLEdBQUc7WUFDckJEO1FBQ0o7SUFDSjtJQUNBSSxlQUFlO1FBQ1gsTUFBTSxJQUFJaE4sTUFBTTtJQUNwQjtJQUNBOzs7O0tBSUMsR0FDRGlOLGlCQUFpQjtRQUNiLE9BQU8sSUFBSSxDQUFDaE0sV0FBVztJQUMzQjtJQUNBaU0sbUJBQW1CQyxNQUFNLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxNQUFNQyxjQUFjRCxPQUFPLENBQUM5TyxNQUFNVyxTQUFTLENBQUNxTyx5QkFBeUIsQ0FBQztRQUN0RSxJQUFJLE9BQU9ELGdCQUFnQixZQUN2QixDQUFDQSxZQUFZRSxVQUFVLENBQUMscUJBQXFCO1lBQzdDSixPQUFPSyxPQUFPLENBQUM7Z0JBQ1gsQ0FBQ2xQLE1BQU1XLFNBQVMsQ0FBQ3dPLG1CQUFtQixDQUFDLEVBQUVuUCxNQUFNVyxTQUFTLENBQUN5TyxrQ0FBa0M7WUFDN0YsR0FBRztnQkFBRUMsV0FBVztZQUFLO1lBQ3JCLE9BQU87UUFDWDtRQUNBLE9BQU87SUFDWDtJQUNBQyxpQkFBaUJSLE9BQU8sRUFBRTtRQUN0QixNQUFNL0csT0FBTytHLE9BQU8sQ0FBQ3BPLGtCQUFrQjtRQUN2QyxJQUFJLENBQUNxQyxLQUFLLENBQUMsNkJBQ1BnRixPQUNBLGlCQUNBLElBQUksQ0FBQzdGLG1CQUFtQjtRQUM1QixNQUFNeUwsVUFBVSxJQUFJLENBQUM3TCxRQUFRLENBQUMyQixHQUFHLENBQUNzRTtRQUNsQyxJQUFJNEYsWUFBWWpHLFdBQVc7WUFDdkIsSUFBSSxDQUFDM0UsS0FBSyxDQUFDLHNDQUNQZ0YsT0FDQTtZQUNKLE1BQU1qSCwrQkFBK0JpSDtRQUN6QztRQUNBLE9BQU80RjtJQUNYO0lBQ0E0QixrQkFBa0JsRSxHQUFHLEVBQUV3RCxNQUFNLEVBQUVXLHNCQUFzQixJQUFJLEVBQUU7UUFDdkQsTUFBTWpPLE9BQU8sSUFBSXBCLGNBQWNzUCxxQkFBcUIsQ0FBQ1osUUFBUSxNQUFNLElBQUksQ0FBQ2pOLE9BQU87UUFDL0UsSUFBSXlKLElBQUlySyxJQUFJLEtBQUswRyxXQUFXO1lBQ3hCMkQsSUFBSXJLLElBQUksR0FBR2QsWUFBWWUsTUFBTSxDQUFDeU8sUUFBUTtRQUMxQztRQUNBLElBQUksSUFBSSxDQUFDdk4sZUFBZSxFQUFFO1lBQ3RCLElBQUksQ0FBQ0csV0FBVyxDQUFDcU4sYUFBYTtZQUM5Qkgsd0JBQXdCLFFBQVFBLHdCQUF3QixLQUFLLElBQUksS0FBSyxJQUFJQSxvQkFBb0JuSyxhQUFhLENBQUNzSyxhQUFhO1FBQzdIO1FBQ0FwTyxLQUFLcU8sU0FBUyxDQUFDdkU7SUFDbkI7SUFDQXdFLGlCQUFpQmhCLE1BQU0sRUFBRUMsT0FBTyxFQUFFO1FBQzlCLE1BQU1VLHNCQUFzQixJQUFJLENBQUN4TixRQUFRLENBQUN5QixHQUFHLENBQUNvTCxPQUFPekwsT0FBTztRQUM1RCxJQUFJLENBQUNkLFdBQVcsQ0FBQ3dOLGNBQWM7UUFDL0JOLHdCQUF3QixRQUFRQSx3QkFBd0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsb0JBQW9CbkssYUFBYSxDQUFDeUssY0FBYztRQUMxSCxJQUFJLENBQUMsSUFBSSxDQUFDbEIsa0JBQWtCLENBQUNDLFFBQVFDLFVBQVU7WUFDM0MsSUFBSSxDQUFDeE0sV0FBVyxDQUFDcU4sYUFBYTtZQUM5Qkgsd0JBQXdCLFFBQVFBLHdCQUF3QixLQUFLLElBQUksS0FBSyxJQUFJQSxvQkFBb0JuSyxhQUFhLENBQUNzSyxhQUFhO1lBQ3pIO1FBQ0o7UUFDQSxJQUFJaEM7UUFDSixJQUFJO1lBQ0FBLFVBQVUsSUFBSSxDQUFDMkIsZ0JBQWdCLENBQUNSO1FBQ3BDLEVBQ0EsT0FBT3pELEtBQUs7WUFDUixJQUFJLENBQUNrRSxpQkFBaUIsQ0FBQ2xFLEtBQUt3RCxRQUFRVztZQUNwQztRQUNKO1FBQ0EsTUFBTWpPLE9BQU8sSUFBSXBCLGNBQWNzUCxxQkFBcUIsQ0FBQ1osUUFBUWxCLFNBQVMsSUFBSSxDQUFDL0wsT0FBTztRQUNsRkwsS0FBSytKLElBQUksQ0FBQyxXQUFXLENBQUN0SztZQUNsQixJQUFJQSxTQUFTZCxZQUFZZSxNQUFNLENBQUM4TyxFQUFFLEVBQUU7Z0JBQ2hDLElBQUksQ0FBQ3pOLFdBQVcsQ0FBQzBOLGdCQUFnQjtZQUNyQyxPQUNLO2dCQUNELElBQUksQ0FBQzFOLFdBQVcsQ0FBQ3FOLGFBQWE7WUFDbEM7UUFDSjtRQUNBLElBQUlILHFCQUFxQjtZQUNyQmpPLEtBQUsrSixJQUFJLENBQUMsYUFBYSxDQUFDekQ7Z0JBQ3BCLElBQUlBLFNBQVM7b0JBQ1QySCxvQkFBb0JuSyxhQUFhLENBQUMySyxnQkFBZ0I7Z0JBQ3RELE9BQ0s7b0JBQ0RSLG9CQUFvQm5LLGFBQWEsQ0FBQ3NLLGFBQWE7Z0JBQ25EO1lBQ0o7WUFDQXBPLEtBQUt3SSxFQUFFLENBQUMsZUFBZTtnQkFDbkJ5RixvQkFBb0I3SixZQUFZLElBQUk7Z0JBQ3BDNkosb0JBQW9Cdkosd0JBQXdCLEdBQUcsSUFBSWdLO1lBQ3ZEO1lBQ0ExTyxLQUFLd0ksRUFBRSxDQUFDLGtCQUFrQjtnQkFDdEJ5RixvQkFBb0I1SixnQkFBZ0IsSUFBSTtnQkFDeEM0SixvQkFBb0J0Siw0QkFBNEIsR0FBRyxJQUFJK0o7WUFDM0Q7UUFDSjtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUNDLGtCQUFrQixDQUFDM08sTUFBTW9NLFNBQVNtQixVQUFVO1lBQ2xELElBQUksQ0FBQ3hNLFdBQVcsQ0FBQ3FOLGFBQWE7WUFDOUJILHdCQUF3QixRQUFRQSx3QkFBd0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsb0JBQW9CbkssYUFBYSxDQUFDc0ssYUFBYTtZQUN6SHBPLEtBQUtxTyxTQUFTLENBQUM7Z0JBQ1g1TyxNQUFNZCxZQUFZZSxNQUFNLENBQUN5TyxRQUFRO2dCQUNqQ3ZPLFNBQVMsQ0FBQyxzQkFBc0IsRUFBRXdNLFFBQVFHLElBQUksQ0FBQyxDQUFDO1lBQ3BEO1FBQ0o7SUFDSjtJQUNBcUMsZUFBZXRCLE1BQU0sRUFBRUMsT0FBTyxFQUFFO1FBQzVCLElBQUksSUFBSSxDQUFDRixrQkFBa0IsQ0FBQ0MsUUFBUUMsYUFBYSxNQUFNO1lBQ25EO1FBQ0o7UUFDQSxJQUFJbkI7UUFDSixJQUFJO1lBQ0FBLFVBQVUsSUFBSSxDQUFDMkIsZ0JBQWdCLENBQUNSO1FBQ3BDLEVBQ0EsT0FBT3pELEtBQUs7WUFDUixJQUFJLENBQUNrRSxpQkFBaUIsQ0FBQ2xFLEtBQUt3RCxRQUFRO1lBQ3BDO1FBQ0o7UUFDQSxNQUFNdE4sT0FBTyxJQUFJcEIsY0FBY3NQLHFCQUFxQixDQUFDWixRQUFRbEIsU0FBUyxJQUFJLENBQUMvTCxPQUFPO1FBQ2xGLElBQUksQ0FBQyxJQUFJLENBQUNzTyxrQkFBa0IsQ0FBQzNPLE1BQU1vTSxTQUFTbUIsVUFBVTtZQUNsRHZOLEtBQUtxTyxTQUFTLENBQUM7Z0JBQ1g1TyxNQUFNZCxZQUFZZSxNQUFNLENBQUN5TyxRQUFRO2dCQUNqQ3ZPLFNBQVMsQ0FBQyxzQkFBc0IsRUFBRXdNLFFBQVFHLElBQUksQ0FBQyxDQUFDO1lBQ3BEO1FBQ0o7SUFDSjtJQUNBb0MsbUJBQW1CM08sSUFBSSxFQUFFb00sT0FBTyxFQUFFbUIsT0FBTyxFQUFFO1FBQ3ZDLElBQUl6TDtRQUNKLE1BQU0rTSxXQUFXN08sS0FBSzhPLGVBQWUsQ0FBQ3ZCO1FBQ3RDLE1BQU13QixXQUFXLENBQUNqTixLQUFLK00sU0FBUzNNLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLE1BQU0sUUFBUUosT0FBTyxLQUFLLElBQUlBLEtBQUs7UUFDMUYrTSxTQUFTRyxNQUFNLENBQUM7UUFDaEIsTUFBTSxFQUFFekMsSUFBSSxFQUFFLEdBQUdIO1FBQ2pCLElBQUlHLFNBQVMsU0FBUztZQUNsQjBDLFlBQVlqUCxNQUFNb00sU0FBU3lDLFVBQVVFO1FBQ3pDLE9BQ0ssSUFBSXhDLFNBQVMsZ0JBQWdCO1lBQzlCMkMsc0JBQXNCbFAsTUFBTW9NLFNBQVN5QyxVQUFVRTtRQUNuRCxPQUNLLElBQUl4QyxTQUFTLGdCQUFnQjtZQUM5QjRDLHNCQUFzQm5QLE1BQU1vTSxTQUFTeUMsVUFBVUU7UUFDbkQsT0FDSyxJQUFJeEMsU0FBUyxRQUFRO1lBQ3RCNkMsb0JBQW9CcFAsTUFBTW9NLFNBQVN5QyxVQUFVRTtRQUNqRCxPQUNLO1lBQ0QsT0FBTztRQUNYO1FBQ0EsT0FBTztJQUNYO0lBQ0FsRyxlQUFlWCxXQUFXLEVBQUU7UUFDeEIsSUFBSUEsZ0JBQWdCLE1BQU07WUFDdEI7UUFDSjtRQUNBLE1BQU1tSCxnQkFBZ0JuSCxZQUFZcUIsT0FBTztRQUN6QyxJQUFJNUksc0JBQXNCO1FBQzFCLElBQUkwTyxlQUFlO1lBQ2YsSUFBSSxPQUFPQSxrQkFBa0IsVUFBVTtnQkFDbkMxTyxzQkFBc0IwTztZQUMxQixPQUNLO2dCQUNEMU8sc0JBQ0kwTyxjQUFjOUYsT0FBTyxHQUFHLE1BQU04RixjQUFjeEksSUFBSTtZQUN4RDtRQUNKO1FBQ0EsSUFBSSxDQUFDbEcsbUJBQW1CLEdBQUdBO1FBQzNCLE1BQU15TCxVQUFVLElBQUksQ0FBQ3hMLGVBQWUsR0FDOUIsSUFBSSxDQUFDME4sZ0JBQWdCLEdBQ3JCLElBQUksQ0FBQ00sY0FBYztRQUN6QjFHLFlBQVlNLEVBQUUsQ0FBQyxVQUFVNEQsUUFBUS9GLElBQUksQ0FBQyxJQUFJO1FBQzFDNkIsWUFBWU0sRUFBRSxDQUFDLFdBQVcsQ0FBQzNHO1lBQ3ZCLElBQUlDO1lBQ0osSUFBSSxDQUFDLElBQUksQ0FBQ3BCLE9BQU8sRUFBRTtnQkFDZm1CLFFBQVFvSyxPQUFPO2dCQUNmO1lBQ0o7WUFDQSxJQUFJN0s7WUFDSkEsY0FBY2xDLFdBQVdpTCxzQkFBc0IsQ0FBQyxDQUFDckksS0FBS0QsUUFBUU8sTUFBTSxDQUFDQyxhQUFhLE1BQU0sUUFBUVAsT0FBTyxLQUFLLElBQUlBLEtBQUssV0FBVyxJQUFJLENBQUNGLDRCQUE0QixDQUFDQyxVQUFVLElBQUksQ0FBQ2pCLGVBQWU7WUFDaE0sTUFBTXFOLHNCQUFzQjtnQkFDeEJ0QyxLQUFLdks7Z0JBQ0wwQyxlQUFlLElBQUk1RSxXQUFXOEIsbUJBQW1CO2dCQUNqRG9ELGNBQWM7Z0JBQ2RDLGtCQUFrQjtnQkFDbEJLLDBCQUEwQjtnQkFDMUJDLDhCQUE4QjtZQUNsQztZQUNBLElBQUksQ0FBQ2xFLFFBQVEsQ0FBQ2dNLEdBQUcsQ0FBQzVLLFNBQVNvTTtZQUMzQixNQUFNcUIsZ0JBQWdCek4sUUFBUU8sTUFBTSxDQUFDQyxhQUFhO1lBQ2xELElBQUksSUFBSSxDQUFDekIsZUFBZSxFQUFFO2dCQUN0QixJQUFJLENBQUNDLGFBQWEsQ0FBQ1UsUUFBUSxDQUFDLFdBQVcsc0NBQXNDK047Z0JBQzdFLElBQUksQ0FBQ25PLHNCQUFzQixDQUFDaUosUUFBUSxDQUFDaEo7WUFDekM7WUFDQVMsUUFBUTJHLEVBQUUsQ0FBQyxTQUFTO2dCQUNoQixJQUFJLElBQUksQ0FBQzVILGVBQWUsRUFBRTtvQkFDdEIsSUFBSSxDQUFDQyxhQUFhLENBQUNVLFFBQVEsQ0FBQyxXQUFXLGtDQUFrQytOO29CQUN6RSxJQUFJLENBQUNuTyxzQkFBc0IsQ0FBQzJLLFVBQVUsQ0FBQzFLO29CQUN2Q2xDLFdBQVc2TSxxQkFBcUIsQ0FBQzNLO2dCQUNyQztnQkFDQSxJQUFJLENBQUNYLFFBQVEsQ0FBQ2tNLE1BQU0sQ0FBQzlLO1lBQ3pCO1FBQ0o7SUFDSjtBQUNKO0FBQ0F2RCxjQUFjLEdBQUdFO0FBQ2pCLFNBQVN5USxZQUFZalAsSUFBSSxFQUFFb00sT0FBTyxFQUFFeUMsUUFBUSxFQUFFRSxRQUFRO0lBQ2xEL08sS0FBS3VQLG1CQUFtQixDQUFDUixVQUFVLENBQUNqRixLQUFLMEY7UUFDckMsSUFBSTFGLEtBQUs7WUFDTDlKLEtBQUtxTyxTQUFTLENBQUN2RTtZQUNmO1FBQ0o7UUFDQSxJQUFJMEYsWUFBWXJKLGFBQWFuRyxLQUFLeVAsU0FBUyxFQUFFO1lBQ3pDO1FBQ0o7UUFDQSxNQUFNQyxVQUFVLElBQUk5USxjQUFjK1EsbUJBQW1CLENBQUMzUCxNQUFNNk8sVUFBVVc7UUFDdEVwRCxRQUFRTSxJQUFJLENBQUNnRCxTQUFTLENBQUM1RixLQUFLdkwsT0FBT3FSLFNBQVNDO1lBQ3hDN1AsS0FBSzhQLGdCQUFnQixDQUFDaEcsS0FBS3ZMLE9BQU9xUixTQUFTQztRQUMvQztJQUNKO0FBQ0o7QUFDQSxTQUFTWCxzQkFBc0JsUCxJQUFJLEVBQUVvTSxPQUFPLEVBQUV5QyxRQUFRLEVBQUVFLFFBQVE7SUFDNUQsTUFBTXpCLFNBQVMsSUFBSTFPLGNBQWNtUix3QkFBd0IsQ0FBQy9QLE1BQU02TyxVQUFVekMsUUFBUUUsV0FBVyxFQUFFeUM7SUFDL0YsU0FBU3BCLFFBQVE3RCxHQUFHLEVBQUV2TCxLQUFLLEVBQUVxUixPQUFPLEVBQUVDLEtBQUs7UUFDdkN2QyxPQUFPckIsT0FBTztRQUNkak0sS0FBSzhQLGdCQUFnQixDQUFDaEcsS0FBS3ZMLE9BQU9xUixTQUFTQztJQUMvQztJQUNBLElBQUk3UCxLQUFLeVAsU0FBUyxFQUFFO1FBQ2hCO0lBQ0o7SUFDQW5DLE9BQU85RSxFQUFFLENBQUMsU0FBU21GO0lBQ25CdkIsUUFBUU0sSUFBSSxDQUFDWSxRQUFRSztBQUN6QjtBQUNBLFNBQVN3QixzQkFBc0JuUCxJQUFJLEVBQUVvTSxPQUFPLEVBQUV5QyxRQUFRLEVBQUVFLFFBQVE7SUFDNUQvTyxLQUFLdVAsbUJBQW1CLENBQUNSLFVBQVUsQ0FBQ2pGLEtBQUswRjtRQUNyQyxJQUFJMUYsS0FBSztZQUNMOUosS0FBS3FPLFNBQVMsQ0FBQ3ZFO1lBQ2Y7UUFDSjtRQUNBLElBQUkwRixZQUFZckosYUFBYW5HLEtBQUt5UCxTQUFTLEVBQUU7WUFDekM7UUFDSjtRQUNBLE1BQU1uQyxTQUFTLElBQUkxTyxjQUFjb1Isd0JBQXdCLENBQUNoUSxNQUFNNk8sVUFBVXpDLFFBQVFDLFNBQVMsRUFBRW1EO1FBQzdGcEQsUUFBUU0sSUFBSSxDQUFDWTtJQUNqQjtBQUNKO0FBQ0EsU0FBUzhCLG9CQUFvQnBQLElBQUksRUFBRW9NLE9BQU8sRUFBRXlDLFFBQVEsRUFBRUUsUUFBUTtJQUMxRCxNQUFNekIsU0FBUyxJQUFJMU8sY0FBY3FSLHNCQUFzQixDQUFDalEsTUFBTTZPLFVBQVV6QyxRQUFRQyxTQUFTLEVBQUVELFFBQVFFLFdBQVcsRUFBRXlDO0lBQ2hILElBQUkvTyxLQUFLeVAsU0FBUyxFQUFFO1FBQ2hCO0lBQ0o7SUFDQXJELFFBQVFNLElBQUksQ0FBQ1k7QUFDakIsRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc2htaXR0LWd1cHRhLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3NlcnZlci5qcz9hODgyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlcnZlciA9IHZvaWQgMDtcbmNvbnN0IGh0dHAyID0gcmVxdWlyZShcImh0dHAyXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBzZXJ2ZXJfY2FsbF8xID0gcmVxdWlyZShcIi4vc2VydmVyLWNhbGxcIik7XG5jb25zdCBzZXJ2ZXJfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL3NlcnZlci1jcmVkZW50aWFsc1wiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgY2hhbm5lbHpfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xuY29uc3QgeyBIVFRQMl9IRUFERVJfUEFUSCB9ID0gaHR0cDIuY29uc3RhbnRzO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnc2VydmVyJztcbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbmZ1bmN0aW9uIGdldFVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZShtZXRob2ROYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOSU1QTEVNRU5URUQsXG4gICAgICAgIGRldGFpbHM6IGBUaGUgc2VydmVyIGRvZXMgbm90IGltcGxlbWVudCB0aGUgbWV0aG9kICR7bWV0aG9kTmFtZX1gLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0SGFuZGxlcihoYW5kbGVyVHlwZSwgbWV0aG9kTmFtZSkge1xuICAgIGNvbnN0IHVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZSA9IGdldFVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZShtZXRob2ROYW1lKTtcbiAgICBzd2l0Y2ggKGhhbmRsZXJUeXBlKSB7XG4gICAgICAgIGNhc2UgJ3VuYXJ5JzpcbiAgICAgICAgICAgIHJldHVybiAoY2FsbCwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UsIG51bGwpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnY2xpZW50U3RyZWFtJzpcbiAgICAgICAgICAgIHJldHVybiAoY2FsbCwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UsIG51bGwpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnc2VydmVyU3RyZWFtJzpcbiAgICAgICAgICAgIHJldHVybiAoY2FsbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGwuZW1pdCgnZXJyb3InLCB1bmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnYmlkaSc6XG4gICAgICAgICAgICByZXR1cm4gKGNhbGwpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsLmVtaXQoJ2Vycm9yJywgdW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaGFuZGxlclR5cGUgJHtoYW5kbGVyVHlwZX1gKTtcbiAgICB9XG59XG5jbGFzcyBTZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5odHRwMlNlcnZlckxpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VydmVyQWRkcmVzc1N0cmluZyA9ICdudWxsJztcbiAgICAgICAgLy8gQ2hhbm5lbHogSW5mb1xuICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZSA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6VHJhY2UoKTtcbiAgICAgICAgdGhpcy5jYWxsVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lckNoaWxkcmVuVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbkNoaWxkcmVuVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zWydncnBjLmVuYWJsZV9jaGFubmVseiddID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbm5lbHpSZWYgPSBjaGFubmVsel8xLnJlZ2lzdGVyQ2hhbm5lbHpTZXJ2ZXIoKCkgPT4gdGhpcy5nZXRDaGFubmVsekluZm8oKSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdTZXJ2ZXIgY3JlYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2UoJ1NlcnZlciBjb25zdHJ1Y3RlZCcpO1xuICAgIH1cbiAgICBnZXRDaGFubmVsekluZm8oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFjZTogdGhpcy5jaGFubmVselRyYWNlLFxuICAgICAgICAgICAgY2FsbFRyYWNrZXI6IHRoaXMuY2FsbFRyYWNrZXIsXG4gICAgICAgICAgICBsaXN0ZW5lckNoaWxkcmVuOiB0aGlzLmxpc3RlbmVyQ2hpbGRyZW5UcmFja2VyLmdldENoaWxkTGlzdHMoKSxcbiAgICAgICAgICAgIHNlc3Npb25DaGlsZHJlbjogdGhpcy5zZXNzaW9uQ2hpbGRyZW5UcmFja2VyLmdldENoaWxkTGlzdHMoKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRDaGFubmVselNlc3Npb25JbmZvR2V0dGVyKHNlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbkluZm8gPSB0aGlzLnNlc3Npb25zLmdldChzZXNzaW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25Tb2NrZXQgPSBzZXNzaW9uLnNvY2tldDtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZUFkZHJlc3MgPSBzZXNzaW9uU29ja2V0LnJlbW90ZUFkZHJlc3MgPyBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzKHNlc3Npb25Tb2NrZXQucmVtb3RlQWRkcmVzcywgc2Vzc2lvblNvY2tldC5yZW1vdGVQb3J0KSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCBsb2NhbEFkZHJlc3MgPSBzZXNzaW9uU29ja2V0LmxvY2FsQWRkcmVzcyA/IHN1YmNoYW5uZWxfYWRkcmVzc18xLnN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3Moc2Vzc2lvblNvY2tldC5sb2NhbEFkZHJlc3MsIHNlc3Npb25Tb2NrZXQubG9jYWxQb3J0KSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgdGxzSW5mbztcbiAgICAgICAgICAgIGlmIChzZXNzaW9uLmVuY3J5cHRlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRsc1NvY2tldCA9IHNlc3Npb25Tb2NrZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgY2lwaGVySW5mbyA9IHRsc1NvY2tldC5nZXRDaXBoZXIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjZXJ0aWZpY2F0ZSA9IHRsc1NvY2tldC5nZXRDZXJ0aWZpY2F0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlZXJDZXJ0aWZpY2F0ZSA9IHRsc1NvY2tldC5nZXRQZWVyQ2VydGlmaWNhdGUoKTtcbiAgICAgICAgICAgICAgICB0bHNJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICBjaXBoZXJTdWl0ZVN0YW5kYXJkTmFtZTogKF9hID0gY2lwaGVySW5mby5zdGFuZGFyZE5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNpcGhlclN1aXRlT3RoZXJOYW1lOiBjaXBoZXJJbmZvLnN0YW5kYXJkTmFtZSA/IG51bGwgOiBjaXBoZXJJbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsQ2VydGlmaWNhdGU6IChjZXJ0aWZpY2F0ZSAmJiAncmF3JyBpbiBjZXJ0aWZpY2F0ZSkgPyBjZXJ0aWZpY2F0ZS5yYXcgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVDZXJ0aWZpY2F0ZTogKHBlZXJDZXJ0aWZpY2F0ZSAmJiAncmF3JyBpbiBwZWVyQ2VydGlmaWNhdGUpID8gcGVlckNlcnRpZmljYXRlLnJhdyA6IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGxzSW5mbyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzb2NrZXRJbmZvID0ge1xuICAgICAgICAgICAgICAgIHJlbW90ZUFkZHJlc3M6IHJlbW90ZUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgbG9jYWxBZGRyZXNzOiBsb2NhbEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgc2VjdXJpdHk6IHRsc0luZm8sXG4gICAgICAgICAgICAgICAgcmVtb3RlTmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICBzdHJlYW1zU3RhcnRlZDogc2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5jYWxsc1N0YXJ0ZWQsXG4gICAgICAgICAgICAgICAgc3RyZWFtc1N1Y2NlZWRlZDogc2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5jYWxsc1N1Y2NlZWRlZCxcbiAgICAgICAgICAgICAgICBzdHJlYW1zRmFpbGVkOiBzZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmNhbGxzRmFpbGVkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzU2VudDogc2Vzc2lvbkluZm8ubWVzc2FnZXNTZW50LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzUmVjZWl2ZWQ6IHNlc3Npb25JbmZvLm1lc3NhZ2VzUmVjZWl2ZWQsXG4gICAgICAgICAgICAgICAga2VlcEFsaXZlc1NlbnQ6IDAsXG4gICAgICAgICAgICAgICAgbGFzdExvY2FsU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICBsYXN0UmVtb3RlU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogc2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5sYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wOiBzZXNzaW9uSW5mby5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcDogc2Vzc2lvbkluZm8ubGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICBsb2NhbEZsb3dDb250cm9sV2luZG93OiAoX2IgPSBzZXNzaW9uLnN0YXRlLmxvY2FsV2luZG93U2l6ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbCxcbiAgICAgICAgICAgICAgICByZW1vdGVGbG93Q29udHJvbFdpbmRvdzogKF9jID0gc2Vzc2lvbi5zdGF0ZS5yZW1vdGVXaW5kb3dTaXplKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHNvY2tldEluZm87XG4gICAgICAgIH07XG4gICAgfVxuICAgIHRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnKCcgKyB0aGlzLmNoYW5uZWx6UmVmLmlkICsgJykgJyArIHRleHQpO1xuICAgIH1cbiAgICBhZGRQcm90b1NlcnZpY2UoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkLiBVc2UgYWRkU2VydmljZSgpIGluc3RlYWQnKTtcbiAgICB9XG4gICAgYWRkU2VydmljZShzZXJ2aWNlLCBpbXBsZW1lbnRhdGlvbikge1xuICAgICAgICBpZiAoc2VydmljZSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgdHlwZW9mIHNlcnZpY2UgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgdHlwZW9mIGltcGxlbWVudGF0aW9uICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRTZXJ2aWNlKCkgcmVxdWlyZXMgdHdvIG9iamVjdHMgYXMgYXJndW1lbnRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VydmljZUtleXMgPSBPYmplY3Qua2V5cyhzZXJ2aWNlKTtcbiAgICAgICAgaWYgKHNlcnZpY2VLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIGFuIGVtcHR5IHNlcnZpY2UgdG8gYSBzZXJ2ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBzZXJ2aWNlS2V5cy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdHRycyA9IHNlcnZpY2VbbmFtZV07XG4gICAgICAgICAgICBsZXQgbWV0aG9kVHlwZTtcbiAgICAgICAgICAgIGlmIChhdHRycy5yZXF1ZXN0U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzLnJlc3BvbnNlU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAnYmlkaSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ2NsaWVudFN0cmVhbSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzLnJlc3BvbnNlU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAnc2VydmVyU3RyZWFtJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAndW5hcnknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpbXBsRm4gPSBpbXBsZW1lbnRhdGlvbltuYW1lXTtcbiAgICAgICAgICAgIGxldCBpbXBsO1xuICAgICAgICAgICAgaWYgKGltcGxGbiA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBhdHRycy5vcmlnaW5hbE5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW1wbEZuID0gaW1wbGVtZW50YXRpb25bYXR0cnMub3JpZ2luYWxOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbXBsRm4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGltcGwgPSBpbXBsRm4uYmluZChpbXBsZW1lbnRhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbXBsID0gZ2V0RGVmYXVsdEhhbmRsZXIobWV0aG9kVHlwZSwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzID0gdGhpcy5yZWdpc3RlcihhdHRycy5wYXRoLCBpbXBsLCBhdHRycy5yZXNwb25zZVNlcmlhbGl6ZSwgYXR0cnMucmVxdWVzdERlc2VyaWFsaXplLCBtZXRob2RUeXBlKTtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWV0aG9kIGhhbmRsZXIgZm9yICR7YXR0cnMucGF0aH0gYWxyZWFkeSBwcm92aWRlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZVNlcnZpY2Uoc2VydmljZSkge1xuICAgICAgICBpZiAoc2VydmljZSA9PT0gbnVsbCB8fCB0eXBlb2Ygc2VydmljZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlU2VydmljZSgpIHJlcXVpcmVzIG9iamVjdCBhcyBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcnZpY2VLZXlzID0gT2JqZWN0LmtleXMoc2VydmljZSk7XG4gICAgICAgIHNlcnZpY2VLZXlzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gc2VydmljZVtuYW1lXTtcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3RlcihhdHRycy5wYXRoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJpbmQocG9ydCwgY3JlZHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQuIFVzZSBiaW5kQXN5bmMoKSBpbnN0ZWFkJyk7XG4gICAgfVxuICAgIGJpbmRBc3luYyhwb3J0LCBjcmVkcywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXJ2ZXIgaXMgYWxyZWFkeSBzdGFydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwb3J0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncG9ydCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNyZWRzID09PSBudWxsIHx8ICEoY3JlZHMgaW5zdGFuY2VvZiBzZXJ2ZXJfY3JlZGVudGlhbHNfMS5TZXJ2ZXJDcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NyZWRzIG11c3QgYmUgYSBTZXJ2ZXJDcmVkZW50aWFscyBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbml0aWFsUG9ydFVyaSA9IHVyaV9wYXJzZXJfMS5wYXJzZVVyaShwb3J0KTtcbiAgICAgICAgaWYgKGluaXRpYWxQb3J0VXJpID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSBwb3J0IFwiJHtwb3J0fVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9ydFVyaSA9IHJlc29sdmVyXzEubWFwVXJpRGVmYXVsdFNjaGVtZShpbml0aWFsUG9ydFVyaSk7XG4gICAgICAgIGlmIChwb3J0VXJpID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBnZXQgYSBkZWZhdWx0IHNjaGVtZSBmb3IgcG9ydCBcIiR7cG9ydH1cImApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcnZlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtYXhTZW5kSGVhZGVyQmxvY2tMZW5ndGg6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoJ2dycGMtbm9kZS5tYXhfc2Vzc2lvbl9tZW1vcnknIGluIHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgc2VydmVyT3B0aW9ucy5tYXhTZXNzaW9uTWVtb3J5ID0gdGhpcy5vcHRpb25zWydncnBjLW5vZGUubWF4X3Nlc3Npb25fbWVtb3J5J107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBCeSBkZWZhdWx0LCBzZXQgYSB2ZXJ5IGxhcmdlIG1heCBzZXNzaW9uIG1lbW9yeSBsaW1pdCwgdG8gZWZmZWN0aXZlbHlcbiAgICAgICAgICAgICAqIGRpc2FibGUgZW5mb3JjZW1lbnQgb2YgdGhlIGxpbWl0LiBTb21lIHRlc3RpbmcgaW5kaWNhdGVzIHRoYXQgTm9kZSdzXG4gICAgICAgICAgICAgKiBiZWhhdmlvciBkZWdyYWRlcyBiYWRseSB3aGVuIHRoaXMgbGltaXQgaXMgcmVhY2hlZCwgc28gd2Ugc29sdmUgdGhhdFxuICAgICAgICAgICAgICogYnkgZGlzYWJsaW5nIHRoZSBjaGVjayBlbnRpcmVseS4gKi9cbiAgICAgICAgICAgIHNlcnZlck9wdGlvbnMubWF4U2Vzc2lvbk1lbW9yeSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZ3JwYy5tYXhfY29uY3VycmVudF9zdHJlYW1zJyBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHNlcnZlck9wdGlvbnMuc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICAgICAgbWF4Q29uY3VycmVudFN0cmVhbXM6IHRoaXMub3B0aW9uc1snZ3JwYy5tYXhfY29uY3VycmVudF9zdHJlYW1zJ10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmVycmVkQ2FsbGJhY2sgPSAoZXJyb3IsIHBvcnQpID0+IHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4gY2FsbGJhY2soZXJyb3IsIHBvcnQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2V0dXBTZXJ2ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgaHR0cDJTZXJ2ZXI7XG4gICAgICAgICAgICBpZiAoY3JlZHMuX2lzU2VjdXJlKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWN1cmVTZXJ2ZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbihzZXJ2ZXJPcHRpb25zLCBjcmVkcy5fZ2V0U2V0dGluZ3MoKSk7XG4gICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIgPSBodHRwMi5jcmVhdGVTZWN1cmVTZXJ2ZXIoc2VjdXJlU2VydmVyT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIub24oJ3NlY3VyZUNvbm5lY3Rpb24nLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8qIFRoZXNlIGVycm9ycyBuZWVkIHRvIGJlIGhhbmRsZWQgYnkgdGhlIHVzZXIgb2YgSHR0cDJTZWN1cmVTZXJ2ZXIsXG4gICAgICAgICAgICAgICAgICAgICAqIGFjY29yZGluZyB0byBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzM1ODI0ICovXG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbignZXJyb3InLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnQW4gaW5jb21pbmcgVExTIGNvbm5lY3Rpb24gY2xvc2VkIHdpdGggZXJyb3I6ICcgKyBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyID0gaHR0cDIuY3JlYXRlU2VydmVyKHNlcnZlck9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHR0cDJTZXJ2ZXIuc2V0VGltZW91dCgwLCBub29wKTtcbiAgICAgICAgICAgIHRoaXMuX3NldHVwSGFuZGxlcnMoaHR0cDJTZXJ2ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGh0dHAyU2VydmVyO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBiaW5kU3BlY2lmaWNQb3J0ID0gKGFkZHJlc3NMaXN0LCBwb3J0TnVtLCBwcmV2aW91c0NvdW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoYWRkcmVzc0xpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHBvcnQ6IHBvcnROdW0sIGNvdW50OiBwcmV2aW91c0NvdW50IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGFkZHJlc3NMaXN0Lm1hcCgoYWRkcmVzcykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0F0dGVtcHRpbmcgdG8gYmluZCAnICsgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyhhZGRyZXNzKSk7XG4gICAgICAgICAgICAgICAgbGV0IGFkZHI7XG4gICAgICAgICAgICAgICAgaWYgKHN1YmNoYW5uZWxfYWRkcmVzc18xLmlzVGNwU3ViY2hhbm5lbEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IGFkZHJlc3MuaG9zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6IHBvcnROdW0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGRyID0gYWRkcmVzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaHR0cDJTZXJ2ZXIgPSBzZXR1cFNlcnZlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdGYWlsZWQgdG8gYmluZCAnICsgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyhhZGRyZXNzKSArICcgd2l0aCBlcnJvciAnICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5vbmNlKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5saXN0ZW4oYWRkciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYm91bmRBZGRyZXNzID0gaHR0cDJTZXJ2ZXIuYWRkcmVzcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJvdW5kU3ViY2hhbm5lbEFkZHJlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJvdW5kQWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZFN1YmNoYW5uZWxBZGRyZXNzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBib3VuZEFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRTdWJjaGFubmVsQWRkcmVzcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogYm91bmRBZGRyZXNzLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6IGJvdW5kQWRkcmVzcy5wb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaGFubmVselJlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWx6UmVmID0gY2hhbm5lbHpfMS5yZWdpc3RlckNoYW5uZWx6U29ja2V0KHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcoYm91bmRTdWJjaGFubmVsQWRkcmVzcyksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEFkZHJlc3M6IGJvdW5kU3ViY2hhbm5lbEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUFkZHJlc3M6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY3VyaXR5OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVOYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1zU3RhcnRlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtc1N1Y2NlZWRlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtc0ZhaWxlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNTZW50OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1JlY2VpdmVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZWVwQWxpdmVzU2VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdExvY2FsU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFJlbW90ZVN0cmVhbUNyZWF0ZWRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxGbG93Q29udHJvbFdpbmRvdzogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlRmxvd0NvbnRyb2xXaW5kb3c6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lckNoaWxkcmVuVHJhY2tlci5yZWZDaGlsZChjaGFubmVselJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmh0dHAyU2VydmVyTGlzdC5wdXNoKHsgc2VydmVyOiBodHRwMlNlcnZlciwgY2hhbm5lbHpSZWY6IGNoYW5uZWx6UmVmIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnU3VjY2Vzc2Z1bGx5IGJvdW5kICcgKyBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKGJvdW5kU3ViY2hhbm5lbEFkZHJlc3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoJ3BvcnQnIGluIGJvdW5kU3ViY2hhbm5lbEFkZHJlc3MgPyBib3VuZFN1YmNoYW5uZWxBZGRyZXNzLnBvcnQgOiBwb3J0TnVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHBvcnROdW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGU6IG11bHRpcGxlIHBvcnQgbnVtYmVycyBhZGRlZCBmcm9tIHNpbmdsZSBhZGRyZXNzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcG9ydDogcG9ydE51bSxcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IGNvdW50ICsgcHJldmlvdXNDb3VudCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJpbmRXaWxkY2FyZFBvcnQgPSAoYWRkcmVzc0xpc3QpID0+IHtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgcG9ydDogMCwgY291bnQ6IDAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gYWRkcmVzc0xpc3RbMF07XG4gICAgICAgICAgICBjb25zdCBodHRwMlNlcnZlciA9IHNldHVwU2VydmVyKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0ZhaWxlZCB0byBiaW5kICcgKyBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKGFkZHJlc3MpICsgJyB3aXRoIGVycm9yICcgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYmluZFdpbGRjYXJkUG9ydChhZGRyZXNzTGlzdC5zbGljZSgxKSkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIub25jZSgnZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5saXN0ZW4oYWRkcmVzcywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib3VuZEFkZHJlc3MgPSBodHRwMlNlcnZlci5hZGRyZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kU3ViY2hhbm5lbEFkZHJlc3MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBib3VuZEFkZHJlc3MuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6IGJvdW5kQWRkcmVzcy5wb3J0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGFubmVselJlZjtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpSZWYgPSBjaGFubmVsel8xLnJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQoc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyhib3VuZFN1YmNoYW5uZWxBZGRyZXNzKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEFkZHJlc3M6IGJvdW5kU3ViY2hhbm5lbEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlQWRkcmVzczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWN1cml0eTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVOYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbXNTdGFydGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbXNTdWNjZWVkZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtc0ZhaWxlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1NlbnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNSZWNlaXZlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZWVwQWxpdmVzU2VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsRmxvd0NvbnRyb2xXaW5kb3c6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlRmxvd0NvbnRyb2xXaW5kb3c6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMuY2hhbm5lbHpFbmFibGVkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyQ2hpbGRyZW5UcmFja2VyLnJlZkNoaWxkKGNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmh0dHAyU2VydmVyTGlzdC5wdXNoKHsgc2VydmVyOiBodHRwMlNlcnZlciwgY2hhbm5lbHpSZWY6IGNoYW5uZWx6UmVmIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdTdWNjZXNzZnVsbHkgYm91bmQgJyArIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcoYm91bmRTdWJjaGFubmVsQWRkcmVzcykpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGJpbmRTcGVjaWZpY1BvcnQoYWRkcmVzc0xpc3Quc2xpY2UoMSksIGJvdW5kQWRkcmVzcy5wb3J0LCAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc29sdmVyTGlzdGVuZXIgPSB7XG4gICAgICAgICAgICBvblN1Y2Nlc3NmdWxSZXNvbHV0aW9uOiAoYWRkcmVzc0xpc3QsIHNlcnZpY2VDb25maWcsIHNlcnZpY2VDb25maWdFcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCBvbmUgcmVzb2x1dGlvbiByZXN1bHQuIERpc2NhcmQgYWxsIGZ1dHVyZSByZXN1bHRzXG4gICAgICAgICAgICAgICAgcmVzb2x2ZXJMaXN0ZW5lci5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uID0gKCkgPT4geyB9O1xuICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRDYWxsYmFjayhuZXcgRXJyb3IoYE5vIGFkZHJlc3NlcyByZXNvbHZlZCBmb3IgcG9ydCAke3BvcnR9YCksIDApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBiaW5kUmVzdWx0UHJvbWlzZTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViY2hhbm5lbF9hZGRyZXNzXzEuaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzTGlzdFswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3NMaXN0WzBdLnBvcnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRSZXN1bHRQcm9taXNlID0gYmluZFdpbGRjYXJkUG9ydChhZGRyZXNzTGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5kUmVzdWx0UHJvbWlzZSA9IGJpbmRTcGVjaWZpY1BvcnQoYWRkcmVzc0xpc3QsIGFkZHJlc3NMaXN0WzBdLnBvcnQsIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYW4gYXJiaXRyYXJ5IG5vbi16ZXJvIHBvcnQgZm9yIG5vbi1UQ1AgYWRkcmVzc2VzXG4gICAgICAgICAgICAgICAgICAgIGJpbmRSZXN1bHRQcm9taXNlID0gYmluZFNwZWNpZmljUG9ydChhZGRyZXNzTGlzdCwgMSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJpbmRSZXN1bHRQcm9taXNlLnRoZW4oKGJpbmRSZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmRSZXN1bHQuY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yU3RyaW5nID0gYE5vIGFkZHJlc3MgYWRkZWQgb3V0IG9mIHRvdGFsICR7YWRkcmVzc0xpc3QubGVuZ3RofSByZXNvbHZlZGA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnaW5nLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGVycm9yU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkQ2FsbGJhY2sobmV3IEVycm9yKGVycm9yU3RyaW5nKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmluZFJlc3VsdC5jb3VudCA8IGFkZHJlc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dpbmcubG9nKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5JTkZPLCBgV0FSTklORyBPbmx5ICR7YmluZFJlc3VsdC5jb3VudH0gYWRkcmVzc2VzIGFkZGVkIG91dCBvZiB0b3RhbCAke2FkZHJlc3NMaXN0Lmxlbmd0aH0gcmVzb2x2ZWRgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkQ2FsbGJhY2sobnVsbCwgYmluZFJlc3VsdC5wb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvclN0cmluZyA9IGBObyBhZGRyZXNzIGFkZGVkIG91dCBvZiB0b3RhbCAke2FkZHJlc3NMaXN0Lmxlbmd0aH0gcmVzb2x2ZWRgO1xuICAgICAgICAgICAgICAgICAgICBsb2dnaW5nLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGVycm9yU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRDYWxsYmFjayhuZXcgRXJyb3IoZXJyb3JTdHJpbmcpLCAwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZENhbGxiYWNrKG5ldyBFcnJvcihlcnJvci5kZXRhaWxzKSwgMCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IHJlc29sdmVyXzEuY3JlYXRlUmVzb2x2ZXIocG9ydFVyaSwgcmVzb2x2ZXJMaXN0ZW5lciwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgcmVzb2x2ZXIudXBkYXRlUmVzb2x1dGlvbigpO1xuICAgIH1cbiAgICBmb3JjZVNodXRkb3duKCkge1xuICAgICAgICAvLyBDbG9zZSB0aGUgc2VydmVyIGlmIGl0IGlzIHN0aWxsIHJ1bm5pbmcuXG4gICAgICAgIGZvciAoY29uc3QgeyBzZXJ2ZXI6IGh0dHAyU2VydmVyLCBjaGFubmVselJlZjogcmVmIH0gb2YgdGhpcy5odHRwMlNlcnZlckxpc3QpIHtcbiAgICAgICAgICAgIGlmIChodHRwMlNlcnZlci5saXN0ZW5pbmcpIHtcbiAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5jbG9zZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lckNoaWxkcmVuVHJhY2tlci51bnJlZkNoaWxkKHJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZihyZWYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIC8vIEFsd2F5cyBkZXN0cm95IGFueSBhdmFpbGFibGUgc2Vzc2lvbnMuIEl0J3MgcG9zc2libGUgdGhhdCBvbmUgb3IgbW9yZVxuICAgICAgICAvLyB0cnlTaHV0ZG93bigpIGNhbGxzIGFyZSBpbiBwcm9ncmVzcy4gRG9uJ3Qgd2FpdCBvbiB0aGVtIHRvIGZpbmlzaC5cbiAgICAgICAgdGhpcy5zZXNzaW9ucy5mb3JFYWNoKChjaGFubmVsekluZm8sIHNlc3Npb24pID0+IHtcbiAgICAgICAgICAgIC8vIENhc3QgTkdIVFRQMl9DQU5DRUwgdG8gYW55IGJlY2F1c2UgVHlwZVNjcmlwdCBkb2Vzbid0IHNlZW0gdG9cbiAgICAgICAgICAgIC8vIHJlY29nbml6ZSBkZXN0cm95KGNvZGUpIGFzIGEgdmFsaWQgc2lnbmF0dXJlLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHNlc3Npb24uZGVzdHJveShodHRwMi5jb25zdGFudHMuTkdIVFRQMl9DQU5DRUwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXNzaW9ucy5jbGVhcigpO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKHRoaXMuY2hhbm5lbHpSZWYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZ2lzdGVyKG5hbWUsIGhhbmRsZXIsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlcnMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGVycy5zZXQobmFtZSwge1xuICAgICAgICAgICAgZnVuYzogaGFuZGxlcixcbiAgICAgICAgICAgIHNlcmlhbGl6ZSxcbiAgICAgICAgICAgIGRlc2VyaWFsaXplLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHBhdGg6IG5hbWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdW5yZWdpc3RlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXJzLmRlbGV0ZShuYW1lKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmh0dHAyU2VydmVyTGlzdC5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgICAgIHRoaXMuaHR0cDJTZXJ2ZXJMaXN0LmV2ZXJ5KCh7IHNlcnZlcjogaHR0cDJTZXJ2ZXIgfSkgPT4gaHR0cDJTZXJ2ZXIubGlzdGVuaW5nICE9PSB0cnVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXJ2ZXIgbXVzdCBiZSBib3VuZCBpbiBvcmRlciB0byBzdGFydCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2VydmVyIGlzIGFscmVhZHkgc3RhcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ1N0YXJ0aW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgdHJ5U2h1dGRvd24oY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlZENhbGxiYWNrID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZih0aGlzLmNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHBlbmRpbmdDaGVja3MgPSAwO1xuICAgICAgICBmdW5jdGlvbiBtYXliZUNhbGxiYWNrKCkge1xuICAgICAgICAgICAgcGVuZGluZ0NoZWNrcy0tO1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdDaGVja3MgPT09IDApIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDbG9zZSB0aGUgc2VydmVyIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgeyBzZXJ2ZXI6IGh0dHAyU2VydmVyLCBjaGFubmVselJlZjogcmVmIH0gb2YgdGhpcy5odHRwMlNlcnZlckxpc3QpIHtcbiAgICAgICAgICAgIGlmIChodHRwMlNlcnZlci5saXN0ZW5pbmcpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nQ2hlY2tzKys7XG4gICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIuY2xvc2UoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJDaGlsZHJlblRyYWNrZXIudW5yZWZDaGlsZChyZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXliZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXNzaW9ucy5mb3JFYWNoKChjaGFubmVsekluZm8sIHNlc3Npb24pID0+IHtcbiAgICAgICAgICAgIGlmICghc2Vzc2lvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nQ2hlY2tzICs9IDE7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZShtYXliZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwZW5kaW5nQ2hlY2tzID09PSAwKSB7XG4gICAgICAgICAgICB3cmFwcGVkQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRIdHRwMlBvcnQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNoYW5uZWx6IHJlZmVyZW5jZSBvYmplY3QgZm9yIHRoaXMgc2VydmVyLiBUaGUgcmV0dXJuZWQgdmFsdWUgaXNcbiAgICAgKiBnYXJiYWdlIGlmIGNoYW5uZWx6IGlzIGRpc2FibGVkIGZvciB0aGlzIHNlcnZlci5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGdldENoYW5uZWx6UmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVselJlZjtcbiAgICB9XG4gICAgX3ZlcmlmeUNvbnRlbnRUeXBlKHN0cmVhbSwgaGVhZGVycykge1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGhlYWRlcnNbaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEVdO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnRUeXBlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgIWNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoJ2FwcGxpY2F0aW9uL2dycGMnKSkge1xuICAgICAgICAgICAgc3RyZWFtLnJlc3BvbmQoe1xuICAgICAgICAgICAgICAgIFtodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX1NUQVRVU106IGh0dHAyLmNvbnN0YW50cy5IVFRQX1NUQVRVU19VTlNVUFBPUlRFRF9NRURJQV9UWVBFLFxuICAgICAgICAgICAgfSwgeyBlbmRTdHJlYW06IHRydWUgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9yZXRyaWV2ZUhhbmRsZXIoaGVhZGVycykge1xuICAgICAgICBjb25zdCBwYXRoID0gaGVhZGVyc1tIVFRQMl9IRUFERVJfUEFUSF07XG4gICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIGNhbGwgdG8gbWV0aG9kICcgK1xuICAgICAgICAgICAgcGF0aCArXG4gICAgICAgICAgICAnIGF0IGFkZHJlc3MgJyArXG4gICAgICAgICAgICB0aGlzLnNlcnZlckFkZHJlc3NTdHJpbmcpO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5oYW5kbGVycy5nZXQocGF0aCk7XG4gICAgICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ05vIGhhbmRsZXIgcmVnaXN0ZXJlZCBmb3IgbWV0aG9kICcgK1xuICAgICAgICAgICAgICAgIHBhdGggK1xuICAgICAgICAgICAgICAgICcuIFNlbmRpbmcgVU5JTVBMRU1FTlRFRCBzdGF0dXMuJyk7XG4gICAgICAgICAgICB0aHJvdyBnZXRVbmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgfVxuICAgIF9yZXNwb25kV2l0aEVycm9yKGVyciwgc3RyZWFtLCBjaGFubmVselNlc3Npb25JbmZvID0gbnVsbCkge1xuICAgICAgICBjb25zdCBjYWxsID0gbmV3IHNlcnZlcl9jYWxsXzEuSHR0cDJTZXJ2ZXJDYWxsU3RyZWFtKHN0cmVhbSwgbnVsbCwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVyci5jb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvID09PSBudWxsIHx8IGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5uZWx6U2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbC5zZW5kRXJyb3IoZXJyKTtcbiAgICB9XG4gICAgX2NoYW5uZWx6SGFuZGxlcihzdHJlYW0sIGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbHpTZXNzaW9uSW5mbyA9IHRoaXMuc2Vzc2lvbnMuZ2V0KHN0cmVhbS5zZXNzaW9uKTtcbiAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xuICAgICAgICBjaGFubmVselNlc3Npb25JbmZvID09PSBudWxsIHx8IGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5uZWx6U2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUNvbnRlbnRUeXBlKHN0cmVhbSwgaGVhZGVycykpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mbyA9PT0gbnVsbCB8fCBjaGFubmVselNlc3Npb25JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGFubmVselNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBoYW5kbGVyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaGFuZGxlciA9IHRoaXMuX3JldHJpZXZlSGFuZGxlcihoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNwb25kV2l0aEVycm9yKGVyciwgc3RyZWFtLCBjaGFubmVselNlc3Npb25JbmZvKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWxsID0gbmV3IHNlcnZlcl9jYWxsXzEuSHR0cDJTZXJ2ZXJDYWxsU3RyZWFtKHN0cmVhbSwgaGFuZGxlciwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgY2FsbC5vbmNlKCdjYWxsRW5kJywgKGNvZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxTdWNjZWVkZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNoYW5uZWx6U2Vzc2lvbkluZm8pIHtcbiAgICAgICAgICAgIGNhbGwub25jZSgnc3RyZWFtRW5kJywgKHN1Y2Nlc3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbFN1Y2NlZWRlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhbGwub24oJ3NlbmRNZXNzYWdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8ubWVzc2FnZXNTZW50ICs9IDE7XG4gICAgICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mby5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYWxsLm9uKCdyZWNlaXZlTWVzc2FnZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvLm1lc3NhZ2VzUmVjZWl2ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvLmxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9ydW5IYW5kbGVyRm9yQ2FsbChjYWxsLCBoYW5kbGVyLCBoZWFkZXJzKSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvID09PSBudWxsIHx8IGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5uZWx6U2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICBjYWxsLnNlbmRFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGBVbmtub3duIGhhbmRsZXIgdHlwZTogJHtoYW5kbGVyLnR5cGV9YFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3N0cmVhbUhhbmRsZXIoc3RyZWFtLCBoZWFkZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLl92ZXJpZnlDb250ZW50VHlwZShzdHJlYW0sIGhlYWRlcnMpICE9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhhbmRsZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBoYW5kbGVyID0gdGhpcy5fcmV0cmlldmVIYW5kbGVyKGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRXaXRoRXJyb3IoZXJyLCBzdHJlYW0sIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGwgPSBuZXcgc2VydmVyX2NhbGxfMS5IdHRwMlNlcnZlckNhbGxTdHJlYW0oc3RyZWFtLCBoYW5kbGVyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBpZiAoIXRoaXMuX3J1bkhhbmRsZXJGb3JDYWxsKGNhbGwsIGhhbmRsZXIsIGhlYWRlcnMpKSB7XG4gICAgICAgICAgICBjYWxsLnNlbmRFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGBVbmtub3duIGhhbmRsZXIgdHlwZTogJHtoYW5kbGVyLnR5cGV9YFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3J1bkhhbmRsZXJGb3JDYWxsKGNhbGwsIGhhbmRsZXIsIGhlYWRlcnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGNhbGwucmVjZWl2ZU1ldGFkYXRhKGhlYWRlcnMpO1xuICAgICAgICBjb25zdCBlbmNvZGluZyA9IChfYSA9IG1ldGFkYXRhLmdldCgnZ3JwYy1lbmNvZGluZycpWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnaWRlbnRpdHknO1xuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoJ2dycGMtZW5jb2RpbmcnKTtcbiAgICAgICAgY29uc3QgeyB0eXBlIH0gPSBoYW5kbGVyO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3VuYXJ5Jykge1xuICAgICAgICAgICAgaGFuZGxlVW5hcnkoY2FsbCwgaGFuZGxlciwgbWV0YWRhdGEsIGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnY2xpZW50U3RyZWFtJykge1xuICAgICAgICAgICAgaGFuZGxlQ2xpZW50U3RyZWFtaW5nKGNhbGwsIGhhbmRsZXIsIG1ldGFkYXRhLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3NlcnZlclN0cmVhbScpIHtcbiAgICAgICAgICAgIGhhbmRsZVNlcnZlclN0cmVhbWluZyhjYWxsLCBoYW5kbGVyLCBtZXRhZGF0YSwgZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdiaWRpJykge1xuICAgICAgICAgICAgaGFuZGxlQmlkaVN0cmVhbWluZyhjYWxsLCBoYW5kbGVyLCBtZXRhZGF0YSwgZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfc2V0dXBIYW5kbGVycyhodHRwMlNlcnZlcikge1xuICAgICAgICBpZiAoaHR0cDJTZXJ2ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJ2ZXJBZGRyZXNzID0gaHR0cDJTZXJ2ZXIuYWRkcmVzcygpO1xuICAgICAgICBsZXQgc2VydmVyQWRkcmVzc1N0cmluZyA9ICdudWxsJztcbiAgICAgICAgaWYgKHNlcnZlckFkZHJlc3MpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VydmVyQWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJBZGRyZXNzU3RyaW5nID0gc2VydmVyQWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlcnZlckFkZHJlc3NTdHJpbmcgPVxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJBZGRyZXNzLmFkZHJlc3MgKyAnOicgKyBzZXJ2ZXJBZGRyZXNzLnBvcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJ2ZXJBZGRyZXNzU3RyaW5nID0gc2VydmVyQWRkcmVzc1N0cmluZztcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuY2hhbm5lbHpFbmFibGVkXG4gICAgICAgICAgICA/IHRoaXMuX2NoYW5uZWx6SGFuZGxlclxuICAgICAgICAgICAgOiB0aGlzLl9zdHJlYW1IYW5kbGVyO1xuICAgICAgICBodHRwMlNlcnZlci5vbignc3RyZWFtJywgaGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgaHR0cDJTZXJ2ZXIub24oJ3Nlc3Npb24nLCAoc2Vzc2lvbikgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2hhbm5lbHpSZWY7XG4gICAgICAgICAgICBjaGFubmVselJlZiA9IGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselNvY2tldCgoX2EgPSBzZXNzaW9uLnNvY2tldC5yZW1vdGVBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAndW5rbm93bicsIHRoaXMuZ2V0Q2hhbm5lbHpTZXNzaW9uSW5mb0dldHRlcihzZXNzaW9uKSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbHpTZXNzaW9uSW5mbyA9IHtcbiAgICAgICAgICAgICAgICByZWY6IGNoYW5uZWx6UmVmLFxuICAgICAgICAgICAgICAgIHN0cmVhbVRyYWNrZXI6IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlc1NlbnQ6IDAsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXNSZWNlaXZlZDogMCxcbiAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbnMuc2V0KHNlc3Npb24sIGNoYW5uZWx6U2Vzc2lvbkluZm8pO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50QWRkcmVzcyA9IHNlc3Npb24uc29ja2V0LnJlbW90ZUFkZHJlc3M7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQ29ubmVjdGlvbiBlc3RhYmxpc2hlZCBieSBjbGllbnQgJyArIGNsaWVudEFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbkNoaWxkcmVuVHJhY2tlci5yZWZDaGlsZChjaGFubmVselJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXNzaW9uLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0Nvbm5lY3Rpb24gZHJvcHBlZCBieSBjbGllbnQgJyArIGNsaWVudEFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25DaGlsZHJlblRyYWNrZXIudW5yZWZDaGlsZChjaGFubmVselJlZik7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKGNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9ucy5kZWxldGUoc2Vzc2lvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXIgPSBTZXJ2ZXI7XG5mdW5jdGlvbiBoYW5kbGVVbmFyeShjYWxsLCBoYW5kbGVyLCBtZXRhZGF0YSwgZW5jb2RpbmcpIHtcbiAgICBjYWxsLnJlY2VpdmVVbmFyeU1lc3NhZ2UoZW5jb2RpbmcsIChlcnIsIHJlcXVlc3QpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY2FsbC5zZW5kRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdCA9PT0gdW5kZWZpbmVkIHx8IGNhbGwuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW1pdHRlciA9IG5ldyBzZXJ2ZXJfY2FsbF8xLlNlcnZlclVuYXJ5Q2FsbEltcGwoY2FsbCwgbWV0YWRhdGEsIHJlcXVlc3QpO1xuICAgICAgICBoYW5kbGVyLmZ1bmMoZW1pdHRlciwgKGVyciwgdmFsdWUsIHRyYWlsZXIsIGZsYWdzKSA9PiB7XG4gICAgICAgICAgICBjYWxsLnNlbmRVbmFyeU1lc3NhZ2UoZXJyLCB2YWx1ZSwgdHJhaWxlciwgZmxhZ3MpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNsaWVudFN0cmVhbWluZyhjYWxsLCBoYW5kbGVyLCBtZXRhZGF0YSwgZW5jb2RpbmcpIHtcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgc2VydmVyX2NhbGxfMS5TZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwoY2FsbCwgbWV0YWRhdGEsIGhhbmRsZXIuZGVzZXJpYWxpemUsIGVuY29kaW5nKTtcbiAgICBmdW5jdGlvbiByZXNwb25kKGVyciwgdmFsdWUsIHRyYWlsZXIsIGZsYWdzKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgIGNhbGwuc2VuZFVuYXJ5TWVzc2FnZShlcnIsIHZhbHVlLCB0cmFpbGVyLCBmbGFncyk7XG4gICAgfVxuICAgIGlmIChjYWxsLmNhbmNlbGxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0cmVhbS5vbignZXJyb3InLCByZXNwb25kKTtcbiAgICBoYW5kbGVyLmZ1bmMoc3RyZWFtLCByZXNwb25kKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVNlcnZlclN0cmVhbWluZyhjYWxsLCBoYW5kbGVyLCBtZXRhZGF0YSwgZW5jb2RpbmcpIHtcbiAgICBjYWxsLnJlY2VpdmVVbmFyeU1lc3NhZ2UoZW5jb2RpbmcsIChlcnIsIHJlcXVlc3QpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY2FsbC5zZW5kRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdCA9PT0gdW5kZWZpbmVkIHx8IGNhbGwuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IHNlcnZlcl9jYWxsXzEuU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsKGNhbGwsIG1ldGFkYXRhLCBoYW5kbGVyLnNlcmlhbGl6ZSwgcmVxdWVzdCk7XG4gICAgICAgIGhhbmRsZXIuZnVuYyhzdHJlYW0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlQmlkaVN0cmVhbWluZyhjYWxsLCBoYW5kbGVyLCBtZXRhZGF0YSwgZW5jb2RpbmcpIHtcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgc2VydmVyX2NhbGxfMS5TZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsKGNhbGwsIG1ldGFkYXRhLCBoYW5kbGVyLnNlcmlhbGl6ZSwgaGFuZGxlci5kZXNlcmlhbGl6ZSwgZW5jb2RpbmcpO1xuICAgIGlmIChjYWxsLmNhbmNlbGxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhbmRsZXIuZnVuYyhzdHJlYW0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNlcnZlciIsImh0dHAyIiwicmVxdWlyZSIsImNvbnN0YW50c18xIiwic2VydmVyX2NhbGxfMSIsInNlcnZlcl9jcmVkZW50aWFsc18xIiwicmVzb2x2ZXJfMSIsImxvZ2dpbmciLCJzdWJjaGFubmVsX2FkZHJlc3NfMSIsInVyaV9wYXJzZXJfMSIsImNoYW5uZWx6XzEiLCJIVFRQMl9IRUFERVJfUEFUSCIsImNvbnN0YW50cyIsIlRSQUNFUl9OQU1FIiwibm9vcCIsImdldFVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZSIsIm1ldGhvZE5hbWUiLCJjb2RlIiwiU3RhdHVzIiwiVU5JTVBMRU1FTlRFRCIsImRldGFpbHMiLCJnZXREZWZhdWx0SGFuZGxlciIsImhhbmRsZXJUeXBlIiwidW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlIiwiY2FsbCIsImNhbGxiYWNrIiwiZW1pdCIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiaHR0cDJTZXJ2ZXJMaXN0IiwiaGFuZGxlcnMiLCJNYXAiLCJzZXNzaW9ucyIsInN0YXJ0ZWQiLCJzZXJ2ZXJBZGRyZXNzU3RyaW5nIiwiY2hhbm5lbHpFbmFibGVkIiwiY2hhbm5lbHpUcmFjZSIsIkNoYW5uZWx6VHJhY2UiLCJjYWxsVHJhY2tlciIsIkNoYW5uZWx6Q2FsbFRyYWNrZXIiLCJsaXN0ZW5lckNoaWxkcmVuVHJhY2tlciIsIkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyIiwic2Vzc2lvbkNoaWxkcmVuVHJhY2tlciIsImNoYW5uZWx6UmVmIiwicmVnaXN0ZXJDaGFubmVselNlcnZlciIsImdldENoYW5uZWx6SW5mbyIsImFkZFRyYWNlIiwidHJhY2UiLCJsaXN0ZW5lckNoaWxkcmVuIiwiZ2V0Q2hpbGRMaXN0cyIsInNlc3Npb25DaGlsZHJlbiIsImdldENoYW5uZWx6U2Vzc2lvbkluZm9HZXR0ZXIiLCJzZXNzaW9uIiwiX2EiLCJfYiIsIl9jIiwic2Vzc2lvbkluZm8iLCJnZXQiLCJzZXNzaW9uU29ja2V0Iiwic29ja2V0IiwicmVtb3RlQWRkcmVzcyIsInN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3MiLCJyZW1vdGVQb3J0IiwibG9jYWxBZGRyZXNzIiwibG9jYWxQb3J0IiwidGxzSW5mbyIsImVuY3J5cHRlZCIsInRsc1NvY2tldCIsImNpcGhlckluZm8iLCJnZXRDaXBoZXIiLCJjZXJ0aWZpY2F0ZSIsImdldENlcnRpZmljYXRlIiwicGVlckNlcnRpZmljYXRlIiwiZ2V0UGVlckNlcnRpZmljYXRlIiwiY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWUiLCJzdGFuZGFyZE5hbWUiLCJjaXBoZXJTdWl0ZU90aGVyTmFtZSIsIm5hbWUiLCJsb2NhbENlcnRpZmljYXRlIiwicmF3IiwicmVtb3RlQ2VydGlmaWNhdGUiLCJzb2NrZXRJbmZvIiwic2VjdXJpdHkiLCJyZW1vdGVOYW1lIiwic3RyZWFtc1N0YXJ0ZWQiLCJzdHJlYW1UcmFja2VyIiwiY2FsbHNTdGFydGVkIiwic3RyZWFtc1N1Y2NlZWRlZCIsImNhbGxzU3VjY2VlZGVkIiwic3RyZWFtc0ZhaWxlZCIsImNhbGxzRmFpbGVkIiwibWVzc2FnZXNTZW50IiwibWVzc2FnZXNSZWNlaXZlZCIsImtlZXBBbGl2ZXNTZW50IiwibGFzdExvY2FsU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcCIsImxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wIiwibGFzdENhbGxTdGFydGVkVGltZXN0YW1wIiwibGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wIiwibGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCIsImxvY2FsRmxvd0NvbnRyb2xXaW5kb3ciLCJzdGF0ZSIsImxvY2FsV2luZG93U2l6ZSIsInJlbW90ZUZsb3dDb250cm9sV2luZG93IiwicmVtb3RlV2luZG93U2l6ZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsImlkIiwiYWRkUHJvdG9TZXJ2aWNlIiwiYWRkU2VydmljZSIsInNlcnZpY2UiLCJpbXBsZW1lbnRhdGlvbiIsInNlcnZpY2VLZXlzIiwia2V5cyIsImxlbmd0aCIsImZvckVhY2giLCJhdHRycyIsIm1ldGhvZFR5cGUiLCJyZXF1ZXN0U3RyZWFtIiwicmVzcG9uc2VTdHJlYW0iLCJpbXBsRm4iLCJpbXBsIiwidW5kZWZpbmVkIiwib3JpZ2luYWxOYW1lIiwiYmluZCIsInN1Y2Nlc3MiLCJyZWdpc3RlciIsInBhdGgiLCJyZXNwb25zZVNlcmlhbGl6ZSIsInJlcXVlc3REZXNlcmlhbGl6ZSIsInJlbW92ZVNlcnZpY2UiLCJ1bnJlZ2lzdGVyIiwicG9ydCIsImNyZWRzIiwiYmluZEFzeW5jIiwiVHlwZUVycm9yIiwiU2VydmVyQ3JlZGVudGlhbHMiLCJpbml0aWFsUG9ydFVyaSIsInBhcnNlVXJpIiwicG9ydFVyaSIsIm1hcFVyaURlZmF1bHRTY2hlbWUiLCJzZXJ2ZXJPcHRpb25zIiwibWF4U2VuZEhlYWRlckJsb2NrTGVuZ3RoIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsIm1heFNlc3Npb25NZW1vcnkiLCJzZXR0aW5ncyIsIm1heENvbmN1cnJlbnRTdHJlYW1zIiwiZGVmZXJyZWRDYWxsYmFjayIsImVycm9yIiwicHJvY2VzcyIsIm5leHRUaWNrIiwic2V0dXBTZXJ2ZXIiLCJodHRwMlNlcnZlciIsIl9pc1NlY3VyZSIsInNlY3VyZVNlcnZlck9wdGlvbnMiLCJhc3NpZ24iLCJfZ2V0U2V0dGluZ3MiLCJjcmVhdGVTZWN1cmVTZXJ2ZXIiLCJvbiIsImUiLCJtZXNzYWdlIiwiY3JlYXRlU2VydmVyIiwic2V0VGltZW91dCIsIl9zZXR1cEhhbmRsZXJzIiwiYmluZFNwZWNpZmljUG9ydCIsImFkZHJlc3NMaXN0IiwicG9ydE51bSIsInByZXZpb3VzQ291bnQiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNvdW50IiwiYWxsIiwibWFwIiwiYWRkcmVzcyIsInN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmciLCJhZGRyIiwiaXNUY3BTdWJjaGFubmVsQWRkcmVzcyIsImhvc3QiLCJyZWplY3QiLCJvbkVycm9yIiwiZXJyIiwib25jZSIsImxpc3RlbiIsImJvdW5kQWRkcmVzcyIsImJvdW5kU3ViY2hhbm5lbEFkZHJlc3MiLCJyZWdpc3RlckNoYW5uZWx6U29ja2V0IiwicmVmQ2hpbGQiLCJwdXNoIiwic2VydmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJ0aGVuIiwicmVzdWx0cyIsInJlc3VsdCIsImJpbmRXaWxkY2FyZFBvcnQiLCJzbGljZSIsInJlc29sdmVyTGlzdGVuZXIiLCJvblN1Y2Nlc3NmdWxSZXNvbHV0aW9uIiwic2VydmljZUNvbmZpZyIsInNlcnZpY2VDb25maWdFcnJvciIsImJpbmRSZXN1bHRQcm9taXNlIiwiYmluZFJlc3VsdCIsImVycm9yU3RyaW5nIiwibG9nIiwiRVJST1IiLCJJTkZPIiwicmVzb2x2ZXIiLCJjcmVhdGVSZXNvbHZlciIsInVwZGF0ZVJlc29sdXRpb24iLCJmb3JjZVNodXRkb3duIiwicmVmIiwibGlzdGVuaW5nIiwiY2xvc2UiLCJ1bnJlZkNoaWxkIiwidW5yZWdpc3RlckNoYW5uZWx6UmVmIiwiY2hhbm5lbHpJbmZvIiwiZGVzdHJveSIsIk5HSFRUUDJfQ0FOQ0VMIiwiY2xlYXIiLCJoYW5kbGVyIiwic2VyaWFsaXplIiwiZGVzZXJpYWxpemUiLCJ0eXBlIiwiaGFzIiwic2V0IiwiZnVuYyIsImRlbGV0ZSIsInN0YXJ0IiwiZXZlcnkiLCJ0cnlTaHV0ZG93biIsIndyYXBwZWRDYWxsYmFjayIsInBlbmRpbmdDaGVja3MiLCJtYXliZUNhbGxiYWNrIiwiY2xvc2VkIiwiYWRkSHR0cDJQb3J0IiwiZ2V0Q2hhbm5lbHpSZWYiLCJfdmVyaWZ5Q29udGVudFR5cGUiLCJzdHJlYW0iLCJoZWFkZXJzIiwiY29udGVudFR5cGUiLCJIVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFIiwic3RhcnRzV2l0aCIsInJlc3BvbmQiLCJIVFRQMl9IRUFERVJfU1RBVFVTIiwiSFRUUF9TVEFUVVNfVU5TVVBQT1JURURfTUVESUFfVFlQRSIsImVuZFN0cmVhbSIsIl9yZXRyaWV2ZUhhbmRsZXIiLCJfcmVzcG9uZFdpdGhFcnJvciIsImNoYW5uZWx6U2Vzc2lvbkluZm8iLCJIdHRwMlNlcnZlckNhbGxTdHJlYW0iLCJJTlRFUk5BTCIsImFkZENhbGxGYWlsZWQiLCJzZW5kRXJyb3IiLCJfY2hhbm5lbHpIYW5kbGVyIiwiYWRkQ2FsbFN0YXJ0ZWQiLCJPSyIsImFkZENhbGxTdWNjZWVkZWQiLCJEYXRlIiwiX3J1bkhhbmRsZXJGb3JDYWxsIiwiX3N0cmVhbUhhbmRsZXIiLCJtZXRhZGF0YSIsInJlY2VpdmVNZXRhZGF0YSIsImVuY29kaW5nIiwicmVtb3ZlIiwiaGFuZGxlVW5hcnkiLCJoYW5kbGVDbGllbnRTdHJlYW1pbmciLCJoYW5kbGVTZXJ2ZXJTdHJlYW1pbmciLCJoYW5kbGVCaWRpU3RyZWFtaW5nIiwic2VydmVyQWRkcmVzcyIsImNsaWVudEFkZHJlc3MiLCJyZWNlaXZlVW5hcnlNZXNzYWdlIiwicmVxdWVzdCIsImNhbmNlbGxlZCIsImVtaXR0ZXIiLCJTZXJ2ZXJVbmFyeUNhbGxJbXBsIiwidHJhaWxlciIsImZsYWdzIiwic2VuZFVuYXJ5TWVzc2FnZSIsIlNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbCIsIlNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbCIsIlNlcnZlckR1cGxleFN0cmVhbUltcGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/server.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/service-config.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/service-config.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.extractAndSelectServiceConfig = exports.validateServiceConfig = void 0;\n/* This file implements gRFC A2 and the service config spec:\n * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md\n * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each\n * function here takes an object with unknown structure and returns its\n * specific object type if the input has the right structure, and throws an\n * error otherwise. */ /* The any type is purposely used here. All functions validate their input at\n * runtime */ /* eslint-disable @typescript-eslint/no-explicit-any */ const os = __webpack_require__(/*! os */ \"os\");\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\n/**\n * Recognizes a number with up to 9 digits after the decimal point, followed by\n * an \"s\", representing a number of seconds.\n */ const TIMEOUT_REGEX = /^\\d+(\\.\\d{1,9})?s$/;\n/**\n * Client language name used for determining whether this client matches a\n * `ServiceConfigCanaryConfig`'s `clientLanguage` list.\n */ const CLIENT_LANGUAGE_STRING = \"node\";\nfunction validateName(obj) {\n    if (!(\"service\" in obj) || typeof obj.service !== \"string\") {\n        throw new Error(\"Invalid method config name: invalid service\");\n    }\n    const result = {\n        service: obj.service\n    };\n    if (\"method\" in obj) {\n        if (typeof obj.method === \"string\") {\n            result.method = obj.method;\n        } else {\n            throw new Error(\"Invalid method config name: invalid method\");\n        }\n    }\n    return result;\n}\nfunction validateMethodConfig(obj) {\n    var _a;\n    const result = {\n        name: []\n    };\n    if (!(\"name\" in obj) || !Array.isArray(obj.name)) {\n        throw new Error(\"Invalid method config: invalid name array\");\n    }\n    for (const name of obj.name){\n        result.name.push(validateName(name));\n    }\n    if (\"waitForReady\" in obj) {\n        if (typeof obj.waitForReady !== \"boolean\") {\n            throw new Error(\"Invalid method config: invalid waitForReady\");\n        }\n        result.waitForReady = obj.waitForReady;\n    }\n    if (\"timeout\" in obj) {\n        if (typeof obj.timeout === \"object\") {\n            if (!(\"seconds\" in obj.timeout) || !(typeof obj.timeout.seconds === \"number\")) {\n                throw new Error(\"Invalid method config: invalid timeout.seconds\");\n            }\n            if (!(\"nanos\" in obj.timeout) || !(typeof obj.timeout.nanos === \"number\")) {\n                throw new Error(\"Invalid method config: invalid timeout.nanos\");\n            }\n            result.timeout = obj.timeout;\n        } else if (typeof obj.timeout === \"string\" && TIMEOUT_REGEX.test(obj.timeout)) {\n            const timeoutParts = obj.timeout.substring(0, obj.timeout.length - 1).split(\".\");\n            result.timeout = {\n                seconds: timeoutParts[0] | 0,\n                nanos: ((_a = timeoutParts[1]) !== null && _a !== void 0 ? _a : 0) | 0\n            };\n        } else {\n            throw new Error(\"Invalid method config: invalid timeout\");\n        }\n    }\n    if (\"maxRequestBytes\" in obj) {\n        if (typeof obj.maxRequestBytes !== \"number\") {\n            throw new Error(\"Invalid method config: invalid maxRequestBytes\");\n        }\n        result.maxRequestBytes = obj.maxRequestBytes;\n    }\n    if (\"maxResponseBytes\" in obj) {\n        if (typeof obj.maxResponseBytes !== \"number\") {\n            throw new Error(\"Invalid method config: invalid maxRequestBytes\");\n        }\n        result.maxResponseBytes = obj.maxResponseBytes;\n    }\n    return result;\n}\nfunction validateServiceConfig(obj) {\n    const result = {\n        loadBalancingConfig: [],\n        methodConfig: []\n    };\n    if (\"loadBalancingPolicy\" in obj) {\n        if (typeof obj.loadBalancingPolicy === \"string\") {\n            result.loadBalancingPolicy = obj.loadBalancingPolicy;\n        } else {\n            throw new Error(\"Invalid service config: invalid loadBalancingPolicy\");\n        }\n    }\n    if (\"loadBalancingConfig\" in obj) {\n        if (Array.isArray(obj.loadBalancingConfig)) {\n            for (const config of obj.loadBalancingConfig){\n                result.loadBalancingConfig.push(load_balancer_1.validateLoadBalancingConfig(config));\n            }\n        } else {\n            throw new Error(\"Invalid service config: invalid loadBalancingConfig\");\n        }\n    }\n    if (\"methodConfig\" in obj) {\n        if (Array.isArray(obj.methodConfig)) {\n            for (const methodConfig of obj.methodConfig){\n                result.methodConfig.push(validateMethodConfig(methodConfig));\n            }\n        }\n    }\n    // Validate method name uniqueness\n    const seenMethodNames = [];\n    for (const methodConfig of result.methodConfig){\n        for (const name of methodConfig.name){\n            for (const seenName of seenMethodNames){\n                if (name.service === seenName.service && name.method === seenName.method) {\n                    throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);\n                }\n            }\n            seenMethodNames.push(name);\n        }\n    }\n    return result;\n}\nexports.validateServiceConfig = validateServiceConfig;\nfunction validateCanaryConfig(obj) {\n    if (!(\"serviceConfig\" in obj)) {\n        throw new Error(\"Invalid service config choice: missing service config\");\n    }\n    const result = {\n        serviceConfig: validateServiceConfig(obj.serviceConfig)\n    };\n    if (\"clientLanguage\" in obj) {\n        if (Array.isArray(obj.clientLanguage)) {\n            result.clientLanguage = [];\n            for (const lang of obj.clientLanguage){\n                if (typeof lang === \"string\") {\n                    result.clientLanguage.push(lang);\n                } else {\n                    throw new Error(\"Invalid service config choice: invalid clientLanguage\");\n                }\n            }\n        } else {\n            throw new Error(\"Invalid service config choice: invalid clientLanguage\");\n        }\n    }\n    if (\"clientHostname\" in obj) {\n        if (Array.isArray(obj.clientHostname)) {\n            result.clientHostname = [];\n            for (const lang of obj.clientHostname){\n                if (typeof lang === \"string\") {\n                    result.clientHostname.push(lang);\n                } else {\n                    throw new Error(\"Invalid service config choice: invalid clientHostname\");\n                }\n            }\n        } else {\n            throw new Error(\"Invalid service config choice: invalid clientHostname\");\n        }\n    }\n    if (\"percentage\" in obj) {\n        if (typeof obj.percentage === \"number\" && 0 <= obj.percentage && obj.percentage <= 100) {\n            result.percentage = obj.percentage;\n        } else {\n            throw new Error(\"Invalid service config choice: invalid percentage\");\n        }\n    }\n    // Validate that no unexpected fields are present\n    const allowedFields = [\n        \"clientLanguage\",\n        \"percentage\",\n        \"clientHostname\",\n        \"serviceConfig\"\n    ];\n    for(const field in obj){\n        if (!allowedFields.includes(field)) {\n            throw new Error(`Invalid service config choice: unexpected field ${field}`);\n        }\n    }\n    return result;\n}\nfunction validateAndSelectCanaryConfig(obj, percentage) {\n    if (!Array.isArray(obj)) {\n        throw new Error(\"Invalid service config list\");\n    }\n    for (const config of obj){\n        const validatedConfig = validateCanaryConfig(config);\n        /* For each field, we check if it is present, then only discard the\n         * config if the field value does not match the current client */ if (typeof validatedConfig.percentage === \"number\" && percentage > validatedConfig.percentage) {\n            continue;\n        }\n        if (Array.isArray(validatedConfig.clientHostname)) {\n            let hostnameMatched = false;\n            for (const hostname of validatedConfig.clientHostname){\n                if (hostname === os.hostname()) {\n                    hostnameMatched = true;\n                }\n            }\n            if (!hostnameMatched) {\n                continue;\n            }\n        }\n        if (Array.isArray(validatedConfig.clientLanguage)) {\n            let languageMatched = false;\n            for (const language of validatedConfig.clientLanguage){\n                if (language === CLIENT_LANGUAGE_STRING) {\n                    languageMatched = true;\n                }\n            }\n            if (!languageMatched) {\n                continue;\n            }\n        }\n        return validatedConfig.serviceConfig;\n    }\n    throw new Error(\"No matching service config found\");\n}\n/**\n * Find the \"grpc_config\" record among the TXT records, parse its value as JSON, validate its contents,\n * and select a service config with selection fields that all match this client. Most of these steps\n * can fail with an error; the caller must handle any errors thrown this way.\n * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt\n * @param percentage A number chosen from the range [0, 100) that is used to select which config to use\n * @return The service configuration to use, given the percentage value, or null if the service config\n *     data has a valid format but none of the options match the current client.\n */ function extractAndSelectServiceConfig(txtRecord, percentage) {\n    for (const record of txtRecord){\n        if (record.length > 0 && record[0].startsWith(\"grpc_config=\")) {\n            /* Treat the list of strings in this record as a single string and remove\n             * \"grpc_config=\" from the beginning. The rest should be a JSON string */ const recordString = record.join(\"\").substring(\"grpc_config=\".length);\n            const recordJson = JSON.parse(recordString);\n            return validateAndSelectCanaryConfig(recordJson, percentage);\n        }\n    }\n    return null;\n}\nexports.extractAndSelectServiceConfig = extractAndSelectServiceConfig; //# sourceMappingURL=service-config.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmljZS1jb25maWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFDQUFxQyxHQUFHQSw2QkFBNkIsR0FBRyxLQUFLO0FBQzdFOzs7OztvQkFLb0IsR0FDcEI7V0FDVyxHQUNYLHFEQUFxRCxHQUNyRCxNQUFNSSxLQUFLQyxtQkFBT0EsQ0FBQyxjQUFJO0FBQ3ZCLE1BQU1DLGtCQUFrQkQsbUJBQU9BLENBQUMsc0ZBQWlCO0FBQ2pEOzs7Q0FHQyxHQUNELE1BQU1FLGdCQUFnQjtBQUN0Qjs7O0NBR0MsR0FDRCxNQUFNQyx5QkFBeUI7QUFDL0IsU0FBU0MsYUFBYUMsR0FBRztJQUNyQixJQUFJLENBQUUsY0FBYUEsR0FBRSxLQUFNLE9BQU9BLElBQUlDLE9BQU8sS0FBSyxVQUFVO1FBQ3hELE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtJQUNBLE1BQU1DLFNBQVM7UUFDWEYsU0FBU0QsSUFBSUMsT0FBTztJQUN4QjtJQUNBLElBQUksWUFBWUQsS0FBSztRQUNqQixJQUFJLE9BQU9BLElBQUlJLE1BQU0sS0FBSyxVQUFVO1lBQ2hDRCxPQUFPQyxNQUFNLEdBQUdKLElBQUlJLE1BQU07UUFDOUIsT0FDSztZQUNELE1BQU0sSUFBSUYsTUFBTTtRQUNwQjtJQUNKO0lBQ0EsT0FBT0M7QUFDWDtBQUNBLFNBQVNFLHFCQUFxQkwsR0FBRztJQUM3QixJQUFJTTtJQUNKLE1BQU1ILFNBQVM7UUFDWEksTUFBTSxFQUFFO0lBQ1o7SUFDQSxJQUFJLENBQUUsV0FBVVAsR0FBRSxLQUFNLENBQUNRLE1BQU1DLE9BQU8sQ0FBQ1QsSUFBSU8sSUFBSSxHQUFHO1FBQzlDLE1BQU0sSUFBSUwsTUFBTTtJQUNwQjtJQUNBLEtBQUssTUFBTUssUUFBUVAsSUFBSU8sSUFBSSxDQUFFO1FBQ3pC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STFCLE1BQU1DLE9BQU8sQ0FBQzhCLGdCQUFnQk4sY0FBYyxHQUFHO1lBQy9DLElBQUlPLGtCQUFrQjtZQUN0QixLQUFLLE1BQU1DLFlBQVlGLGdCQUFnQk4sY0FBYyxDQUFFO2dCQUNuRCxJQUFJUSxhQUFhL0MsR0FBRytDLFFBQVEsSUFBSTtvQkFDNUJELGtCQUFrQjtnQkFDdEI7WUFDSjtZQUNBLElBQUksQ0FBQ0EsaUJBQWlCO2dCQUNsQjtZQUNKO1FBQ0o7UUFDQSxJQUFJaEMsTUFBTUMsT0FBTyxDQUFDOEIsZ0JBQWdCUixjQUFjLEdBQUc7WUFDL0MsSUFBSVcsa0JBQWtCO1lBQ3RCLEtBQUssTUFBTUMsWUFBWUosZ0JBQWdCUixjQUFjLENBQUU7Z0JBQ25ELElBQUlZLGFBQWE3Qyx3QkFBd0I7b0JBQ3JDNEMsa0JBQWtCO2dCQUN0QjtZQUNKO1lBQ0EsSUFBSSxDQUFDQSxpQkFBaUI7Z0JBQ2xCO1lBQ0o7UUFDSjtRQUNBLE9BQU9ILGdCQUFnQlQsYUFBYTtJQUN4QztJQUNBLE1BQU0sSUFBSTVCLE1BQU07QUFDcEI7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNWLDhCQUE4Qm9ELFNBQVMsRUFBRVYsVUFBVTtJQUN4RCxLQUFLLE1BQU1XLFVBQVVELFVBQVc7UUFDNUIsSUFBSUMsT0FBTzNCLE1BQU0sR0FBRyxLQUFLMkIsTUFBTSxDQUFDLEVBQUUsQ0FBQ0MsVUFBVSxDQUFDLGlCQUFpQjtZQUMzRDttRkFDdUUsR0FDdkUsTUFBTUMsZUFBZUYsT0FBT0csSUFBSSxDQUFDLElBQUkvQixTQUFTLENBQUMsZUFBZUMsTUFBTTtZQUNwRSxNQUFNK0IsYUFBYUMsS0FBS0MsS0FBSyxDQUFDSjtZQUM5QixPQUFPVCw4QkFBOEJXLFlBQVlmO1FBQ3JEO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFDQTVDLHFDQUFxQyxHQUFHRSwrQkFDeEMsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNobWl0dC1ndXB0YS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2aWNlLWNvbmZpZy5qcz82YzQ4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dHJhY3RBbmRTZWxlY3RTZXJ2aWNlQ29uZmlnID0gZXhwb3J0cy52YWxpZGF0ZVNlcnZpY2VDb25maWcgPSB2b2lkIDA7XG4vKiBUaGlzIGZpbGUgaW1wbGVtZW50cyBnUkZDIEEyIGFuZCB0aGUgc2VydmljZSBjb25maWcgc3BlYzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL3Byb3Bvc2FsL2Jsb2IvbWFzdGVyL0EyLXNlcnZpY2UtY29uZmlncy1pbi1kbnMubWRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMvYmxvYi9tYXN0ZXIvZG9jL3NlcnZpY2VfY29uZmlnLm1kLiBFYWNoXG4gKiBmdW5jdGlvbiBoZXJlIHRha2VzIGFuIG9iamVjdCB3aXRoIHVua25vd24gc3RydWN0dXJlIGFuZCByZXR1cm5zIGl0c1xuICogc3BlY2lmaWMgb2JqZWN0IHR5cGUgaWYgdGhlIGlucHV0IGhhcyB0aGUgcmlnaHQgc3RydWN0dXJlLCBhbmQgdGhyb3dzIGFuXG4gKiBlcnJvciBvdGhlcndpc2UuICovXG4vKiBUaGUgYW55IHR5cGUgaXMgcHVycG9zZWx5IHVzZWQgaGVyZS4gQWxsIGZ1bmN0aW9ucyB2YWxpZGF0ZSB0aGVpciBpbnB1dCBhdFxuICogcnVudGltZSAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xuLyoqXG4gKiBSZWNvZ25pemVzIGEgbnVtYmVyIHdpdGggdXAgdG8gOSBkaWdpdHMgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQsIGZvbGxvd2VkIGJ5XG4gKiBhbiBcInNcIiwgcmVwcmVzZW50aW5nIGEgbnVtYmVyIG9mIHNlY29uZHMuXG4gKi9cbmNvbnN0IFRJTUVPVVRfUkVHRVggPSAvXlxcZCsoXFwuXFxkezEsOX0pP3MkLztcbi8qKlxuICogQ2xpZW50IGxhbmd1YWdlIG5hbWUgdXNlZCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGlzIGNsaWVudCBtYXRjaGVzIGFcbiAqIGBTZXJ2aWNlQ29uZmlnQ2FuYXJ5Q29uZmlnYCdzIGBjbGllbnRMYW5ndWFnZWAgbGlzdC5cbiAqL1xuY29uc3QgQ0xJRU5UX0xBTkdVQUdFX1NUUklORyA9ICdub2RlJztcbmZ1bmN0aW9uIHZhbGlkYXRlTmFtZShvYmopIHtcbiAgICBpZiAoISgnc2VydmljZScgaW4gb2JqKSB8fCB0eXBlb2Ygb2JqLnNlcnZpY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIG5hbWU6IGludmFsaWQgc2VydmljZScpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHNlcnZpY2U6IG9iai5zZXJ2aWNlLFxuICAgIH07XG4gICAgaWYgKCdtZXRob2QnIGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iai5tZXRob2QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXN1bHQubWV0aG9kID0gb2JqLm1ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIG5hbWU6IGludmFsaWQgbWV0aG9kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kQ29uZmlnKG9iaikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6IFtdLFxuICAgIH07XG4gICAgaWYgKCEoJ25hbWUnIGluIG9iaikgfHwgIUFycmF5LmlzQXJyYXkob2JqLm5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIG5hbWUgYXJyYXknKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIG9iai5uYW1lKSB7XG4gICAgICAgIHJlc3VsdC5uYW1lLnB1c2godmFsaWRhdGVOYW1lKG5hbWUpKTtcbiAgICB9XG4gICAgaWYgKCd3YWl0Rm9yUmVhZHknIGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iai53YWl0Rm9yUmVhZHkgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgd2FpdEZvclJlYWR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LndhaXRGb3JSZWFkeSA9IG9iai53YWl0Rm9yUmVhZHk7XG4gICAgfVxuICAgIGlmICgndGltZW91dCcgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLnRpbWVvdXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoISgnc2Vjb25kcycgaW4gb2JqLnRpbWVvdXQpIHx8XG4gICAgICAgICAgICAgICAgISh0eXBlb2Ygb2JqLnRpbWVvdXQuc2Vjb25kcyA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgdGltZW91dC5zZWNvbmRzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISgnbmFub3MnIGluIG9iai50aW1lb3V0KSB8fFxuICAgICAgICAgICAgICAgICEodHlwZW9mIG9iai50aW1lb3V0Lm5hbm9zID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCB0aW1lb3V0Lm5hbm9zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQudGltZW91dCA9IG9iai50aW1lb3V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmoudGltZW91dCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIFRJTUVPVVRfUkVHRVgudGVzdChvYmoudGltZW91dCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRQYXJ0cyA9IG9iai50aW1lb3V0XG4gICAgICAgICAgICAgICAgLnN1YnN0cmluZygwLCBvYmoudGltZW91dC5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgIC5zcGxpdCgnLicpO1xuICAgICAgICAgICAgcmVzdWx0LnRpbWVvdXQgPSB7XG4gICAgICAgICAgICAgICAgc2Vjb25kczogdGltZW91dFBhcnRzWzBdIHwgMCxcbiAgICAgICAgICAgICAgICBuYW5vczogKChfYSA9IHRpbWVvdXRQYXJ0c1sxXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgfCAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIHRpbWVvdXQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ21heFJlcXVlc3RCeXRlcycgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLm1heFJlcXVlc3RCeXRlcyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIG1heFJlcXVlc3RCeXRlcycpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5tYXhSZXF1ZXN0Qnl0ZXMgPSBvYmoubWF4UmVxdWVzdEJ5dGVzO1xuICAgIH1cbiAgICBpZiAoJ21heFJlc3BvbnNlQnl0ZXMnIGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iai5tYXhSZXNwb25zZUJ5dGVzICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgbWF4UmVxdWVzdEJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Lm1heFJlc3BvbnNlQnl0ZXMgPSBvYmoubWF4UmVzcG9uc2VCeXRlcztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU2VydmljZUNvbmZpZyhvYmopIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGxvYWRCYWxhbmNpbmdDb25maWc6IFtdLFxuICAgICAgICBtZXRob2RDb25maWc6IFtdLFxuICAgIH07XG4gICAgaWYgKCdsb2FkQmFsYW5jaW5nUG9saWN5JyBpbiBvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoubG9hZEJhbGFuY2luZ1BvbGljeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlc3VsdC5sb2FkQmFsYW5jaW5nUG9saWN5ID0gb2JqLmxvYWRCYWxhbmNpbmdQb2xpY3k7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWc6IGludmFsaWQgbG9hZEJhbGFuY2luZ1BvbGljeScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgnbG9hZEJhbGFuY2luZ0NvbmZpZycgaW4gb2JqKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iai5sb2FkQmFsYW5jaW5nQ29uZmlnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb25maWcgb2Ygb2JqLmxvYWRCYWxhbmNpbmdDb25maWcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubG9hZEJhbGFuY2luZ0NvbmZpZy5wdXNoKGxvYWRfYmFsYW5jZXJfMS52YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWcoY29uZmlnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWc6IGludmFsaWQgbG9hZEJhbGFuY2luZ0NvbmZpZycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgnbWV0aG9kQ29uZmlnJyBpbiBvYmopIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLm1ldGhvZENvbmZpZykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWV0aG9kQ29uZmlnIG9mIG9iai5tZXRob2RDb25maWcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubWV0aG9kQ29uZmlnLnB1c2godmFsaWRhdGVNZXRob2RDb25maWcobWV0aG9kQ29uZmlnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgbWV0aG9kIG5hbWUgdW5pcXVlbmVzc1xuICAgIGNvbnN0IHNlZW5NZXRob2ROYW1lcyA9IFtdO1xuICAgIGZvciAoY29uc3QgbWV0aG9kQ29uZmlnIG9mIHJlc3VsdC5tZXRob2RDb25maWcpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG1ldGhvZENvbmZpZy5uYW1lKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlZW5OYW1lIG9mIHNlZW5NZXRob2ROYW1lcykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNlcnZpY2UgPT09IHNlZW5OYW1lLnNlcnZpY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgbmFtZS5tZXRob2QgPT09IHNlZW5OYW1lLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2VydmljZSBjb25maWc6IGR1cGxpY2F0ZSBuYW1lICR7bmFtZS5zZXJ2aWNlfS8ke25hbWUubWV0aG9kfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW5NZXRob2ROYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnZhbGlkYXRlU2VydmljZUNvbmZpZyA9IHZhbGlkYXRlU2VydmljZUNvbmZpZztcbmZ1bmN0aW9uIHZhbGlkYXRlQ2FuYXJ5Q29uZmlnKG9iaikge1xuICAgIGlmICghKCdzZXJ2aWNlQ29uZmlnJyBpbiBvYmopKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBjaG9pY2U6IG1pc3Npbmcgc2VydmljZSBjb25maWcnKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBzZXJ2aWNlQ29uZmlnOiB2YWxpZGF0ZVNlcnZpY2VDb25maWcob2JqLnNlcnZpY2VDb25maWcpLFxuICAgIH07XG4gICAgaWYgKCdjbGllbnRMYW5ndWFnZScgaW4gb2JqKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iai5jbGllbnRMYW5ndWFnZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jbGllbnRMYW5ndWFnZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsYW5nIG9mIG9iai5jbGllbnRMYW5ndWFnZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGFuZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNsaWVudExhbmd1YWdlLnB1c2gobGFuZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiBpbnZhbGlkIGNsaWVudExhbmd1YWdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBjbGllbnRMYW5ndWFnZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgnY2xpZW50SG9zdG5hbWUnIGluIG9iaikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmouY2xpZW50SG9zdG5hbWUpKSB7XG4gICAgICAgICAgICByZXN1bHQuY2xpZW50SG9zdG5hbWUgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGFuZyBvZiBvYmouY2xpZW50SG9zdG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jbGllbnRIb3N0bmFtZS5wdXNoKGxhbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBjbGllbnRIb3N0bmFtZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBjaG9pY2U6IGludmFsaWQgY2xpZW50SG9zdG5hbWUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ3BlcmNlbnRhZ2UnIGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iai5wZXJjZW50YWdlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgMCA8PSBvYmoucGVyY2VudGFnZSAmJlxuICAgICAgICAgICAgb2JqLnBlcmNlbnRhZ2UgPD0gMTAwKSB7XG4gICAgICAgICAgICByZXN1bHQucGVyY2VudGFnZSA9IG9iai5wZXJjZW50YWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBwZXJjZW50YWdlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgdGhhdCBubyB1bmV4cGVjdGVkIGZpZWxkcyBhcmUgcHJlc2VudFxuICAgIGNvbnN0IGFsbG93ZWRGaWVsZHMgPSBbXG4gICAgICAgICdjbGllbnRMYW5ndWFnZScsXG4gICAgICAgICdwZXJjZW50YWdlJyxcbiAgICAgICAgJ2NsaWVudEhvc3RuYW1lJyxcbiAgICAgICAgJ3NlcnZpY2VDb25maWcnLFxuICAgIF07XG4gICAgZm9yIChjb25zdCBmaWVsZCBpbiBvYmopIHtcbiAgICAgICAgaWYgKCFhbGxvd2VkRmllbGRzLmluY2x1ZGVzKGZpZWxkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogdW5leHBlY3RlZCBmaWVsZCAke2ZpZWxkfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFuZFNlbGVjdENhbmFyeUNvbmZpZyhvYmosIHBlcmNlbnRhZ2UpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgbGlzdCcpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBvYmopIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkQ29uZmlnID0gdmFsaWRhdGVDYW5hcnlDb25maWcoY29uZmlnKTtcbiAgICAgICAgLyogRm9yIGVhY2ggZmllbGQsIHdlIGNoZWNrIGlmIGl0IGlzIHByZXNlbnQsIHRoZW4gb25seSBkaXNjYXJkIHRoZVxuICAgICAgICAgKiBjb25maWcgaWYgdGhlIGZpZWxkIHZhbHVlIGRvZXMgbm90IG1hdGNoIHRoZSBjdXJyZW50IGNsaWVudCAqL1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRlZENvbmZpZy5wZXJjZW50YWdlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgcGVyY2VudGFnZSA+IHZhbGlkYXRlZENvbmZpZy5wZXJjZW50YWdlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWxpZGF0ZWRDb25maWcuY2xpZW50SG9zdG5hbWUpKSB7XG4gICAgICAgICAgICBsZXQgaG9zdG5hbWVNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhvc3RuYW1lIG9mIHZhbGlkYXRlZENvbmZpZy5jbGllbnRIb3N0bmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChob3N0bmFtZSA9PT0gb3MuaG9zdG5hbWUoKSkge1xuICAgICAgICAgICAgICAgICAgICBob3N0bmFtZU1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaG9zdG5hbWVNYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsaWRhdGVkQ29uZmlnLmNsaWVudExhbmd1YWdlKSkge1xuICAgICAgICAgICAgbGV0IGxhbmd1YWdlTWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsYW5ndWFnZSBvZiB2YWxpZGF0ZWRDb25maWcuY2xpZW50TGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFuZ3VhZ2UgPT09IENMSUVOVF9MQU5HVUFHRV9TVFJJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxhbmd1YWdlTWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRDb25maWcuc2VydmljZUNvbmZpZztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBtYXRjaGluZyBzZXJ2aWNlIGNvbmZpZyBmb3VuZCcpO1xufVxuLyoqXG4gKiBGaW5kIHRoZSBcImdycGNfY29uZmlnXCIgcmVjb3JkIGFtb25nIHRoZSBUWFQgcmVjb3JkcywgcGFyc2UgaXRzIHZhbHVlIGFzIEpTT04sIHZhbGlkYXRlIGl0cyBjb250ZW50cyxcbiAqIGFuZCBzZWxlY3QgYSBzZXJ2aWNlIGNvbmZpZyB3aXRoIHNlbGVjdGlvbiBmaWVsZHMgdGhhdCBhbGwgbWF0Y2ggdGhpcyBjbGllbnQuIE1vc3Qgb2YgdGhlc2Ugc3RlcHNcbiAqIGNhbiBmYWlsIHdpdGggYW4gZXJyb3I7IHRoZSBjYWxsZXIgbXVzdCBoYW5kbGUgYW55IGVycm9ycyB0aHJvd24gdGhpcyB3YXkuXG4gKiBAcGFyYW0gdHh0UmVjb3JkIFRoZSBUWFQgcmVjb3JkIGFycmF5IHRoYXQgaXMgb3V0cHV0IGZyb20gYSBzdWNjZXNzZnVsIGNhbGwgdG8gZG5zLnJlc29sdmVUeHRcbiAqIEBwYXJhbSBwZXJjZW50YWdlIEEgbnVtYmVyIGNob3NlbiBmcm9tIHRoZSByYW5nZSBbMCwgMTAwKSB0aGF0IGlzIHVzZWQgdG8gc2VsZWN0IHdoaWNoIGNvbmZpZyB0byB1c2VcbiAqIEByZXR1cm4gVGhlIHNlcnZpY2UgY29uZmlndXJhdGlvbiB0byB1c2UsIGdpdmVuIHRoZSBwZXJjZW50YWdlIHZhbHVlLCBvciBudWxsIGlmIHRoZSBzZXJ2aWNlIGNvbmZpZ1xuICogICAgIGRhdGEgaGFzIGEgdmFsaWQgZm9ybWF0IGJ1dCBub25lIG9mIHRoZSBvcHRpb25zIG1hdGNoIHRoZSBjdXJyZW50IGNsaWVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEFuZFNlbGVjdFNlcnZpY2VDb25maWcodHh0UmVjb3JkLCBwZXJjZW50YWdlKSB7XG4gICAgZm9yIChjb25zdCByZWNvcmQgb2YgdHh0UmVjb3JkKSB7XG4gICAgICAgIGlmIChyZWNvcmQubGVuZ3RoID4gMCAmJiByZWNvcmRbMF0uc3RhcnRzV2l0aCgnZ3JwY19jb25maWc9JykpIHtcbiAgICAgICAgICAgIC8qIFRyZWF0IHRoZSBsaXN0IG9mIHN0cmluZ3MgaW4gdGhpcyByZWNvcmQgYXMgYSBzaW5nbGUgc3RyaW5nIGFuZCByZW1vdmVcbiAgICAgICAgICAgICAqIFwiZ3JwY19jb25maWc9XCIgZnJvbSB0aGUgYmVnaW5uaW5nLiBUaGUgcmVzdCBzaG91bGQgYmUgYSBKU09OIHN0cmluZyAqL1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkU3RyaW5nID0gcmVjb3JkLmpvaW4oJycpLnN1YnN0cmluZygnZ3JwY19jb25maWc9Jy5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkSnNvbiA9IEpTT04ucGFyc2UocmVjb3JkU3RyaW5nKTtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZUFuZFNlbGVjdENhbmFyeUNvbmZpZyhyZWNvcmRKc29uLCBwZXJjZW50YWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuZXh0cmFjdEFuZFNlbGVjdFNlcnZpY2VDb25maWcgPSBleHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZpY2UtY29uZmlnLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImV4dHJhY3RBbmRTZWxlY3RTZXJ2aWNlQ29uZmlnIiwidmFsaWRhdGVTZXJ2aWNlQ29uZmlnIiwib3MiLCJyZXF1aXJlIiwibG9hZF9iYWxhbmNlcl8xIiwiVElNRU9VVF9SRUdFWCIsIkNMSUVOVF9MQU5HVUFHRV9TVFJJTkciLCJ2YWxpZGF0ZU5hbWUiLCJvYmoiLCJzZXJ2aWNlIiwiRXJyb3IiLCJyZXN1bHQiLCJtZXRob2QiLCJ2YWxpZGF0ZU1ldGhvZENvbmZpZyIsIl9hIiwibmFtZSIsIkFycmF5IiwiaXNBcnJheSIsInB1c2giLCJ3YWl0Rm9yUmVhZHkiLCJ0aW1lb3V0Iiwic2Vjb25kcyIsIm5hbm9zIiwidGVzdCIsInRpbWVvdXRQYXJ0cyIsInN1YnN0cmluZyIsImxlbmd0aCIsInNwbGl0IiwibWF4UmVxdWVzdEJ5dGVzIiwibWF4UmVzcG9uc2VCeXRlcyIsImxvYWRCYWxhbmNpbmdDb25maWciLCJtZXRob2RDb25maWciLCJsb2FkQmFsYW5jaW5nUG9saWN5IiwiY29uZmlnIiwidmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnIiwic2Vlbk1ldGhvZE5hbWVzIiwic2Vlbk5hbWUiLCJ2YWxpZGF0ZUNhbmFyeUNvbmZpZyIsInNlcnZpY2VDb25maWciLCJjbGllbnRMYW5ndWFnZSIsImxhbmciLCJjbGllbnRIb3N0bmFtZSIsInBlcmNlbnRhZ2UiLCJhbGxvd2VkRmllbGRzIiwiZmllbGQiLCJpbmNsdWRlcyIsInZhbGlkYXRlQW5kU2VsZWN0Q2FuYXJ5Q29uZmlnIiwidmFsaWRhdGVkQ29uZmlnIiwiaG9zdG5hbWVNYXRjaGVkIiwiaG9zdG5hbWUiLCJsYW5ndWFnZU1hdGNoZWQiLCJsYW5ndWFnZSIsInR4dFJlY29yZCIsInJlY29yZCIsInN0YXJ0c1dpdGgiLCJyZWNvcmRTdHJpbmciLCJqb2luIiwicmVjb3JkSnNvbiIsIkpTT04iLCJwYXJzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/service-config.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/status-builder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/status-builder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.StatusBuilder = void 0;\n/**\n * A builder for gRPC status objects.\n */ class StatusBuilder {\n    constructor(){\n        this.code = null;\n        this.details = null;\n        this.metadata = null;\n    }\n    /**\n     * Adds a status code to the builder.\n     */ withCode(code) {\n        this.code = code;\n        return this;\n    }\n    /**\n     * Adds details to the builder.\n     */ withDetails(details) {\n        this.details = details;\n        return this;\n    }\n    /**\n     * Adds metadata to the builder.\n     */ withMetadata(metadata) {\n        this.metadata = metadata;\n        return this;\n    }\n    /**\n     * Builds the status object.\n     */ build() {\n        const status = {};\n        if (this.code !== null) {\n            status.code = this.code;\n        }\n        if (this.details !== null) {\n            status.details = this.details;\n        }\n        if (this.metadata !== null) {\n            status.metadata = this.metadata;\n        }\n        return status;\n    }\n}\nexports.StatusBuilder = StatusBuilder; //# sourceMappingURL=status-builder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RhdHVzLWJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHLEtBQUs7QUFDN0I7O0NBRUMsR0FDRCxNQUFNRTtJQUNGQyxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ3BCO0lBQ0E7O0tBRUMsR0FDREMsU0FBU0gsSUFBSSxFQUFFO1FBQ1gsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1osT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7S0FFQyxHQUNESSxZQUFZSCxPQUFPLEVBQUU7UUFDakIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO1FBQ2YsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7S0FFQyxHQUNESSxhQUFhSCxRQUFRLEVBQUU7UUFDbkIsSUFBSSxDQUFDQSxRQUFRLEdBQUdBO1FBQ2hCLE9BQU8sSUFBSTtJQUNmO0lBQ0E7O0tBRUMsR0FDREksUUFBUTtRQUNKLE1BQU1DLFNBQVMsQ0FBQztRQUNoQixJQUFJLElBQUksQ0FBQ1AsSUFBSSxLQUFLLE1BQU07WUFDcEJPLE9BQU9QLElBQUksR0FBRyxJQUFJLENBQUNBLElBQUk7UUFDM0I7UUFDQSxJQUFJLElBQUksQ0FBQ0MsT0FBTyxLQUFLLE1BQU07WUFDdkJNLE9BQU9OLE9BQU8sR0FBRyxJQUFJLENBQUNBLE9BQU87UUFDakM7UUFDQSxJQUFJLElBQUksQ0FBQ0MsUUFBUSxLQUFLLE1BQU07WUFDeEJLLE9BQU9MLFFBQVEsR0FBRyxJQUFJLENBQUNBLFFBQVE7UUFDbkM7UUFDQSxPQUFPSztJQUNYO0FBQ0o7QUFDQVgscUJBQXFCLEdBQUdFLGVBQ3hCLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FzaG1pdHQtZ3VwdGEvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RhdHVzLWJ1aWxkZXIuanM/ZDI5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdGF0dXNCdWlsZGVyID0gdm9pZCAwO1xuLyoqXG4gKiBBIGJ1aWxkZXIgZm9yIGdSUEMgc3RhdHVzIG9iamVjdHMuXG4gKi9cbmNsYXNzIFN0YXR1c0J1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHN0YXR1cyBjb2RlIHRvIHRoZSBidWlsZGVyLlxuICAgICAqL1xuICAgIHdpdGhDb2RlKGNvZGUpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgZGV0YWlscyB0byB0aGUgYnVpbGRlci5cbiAgICAgKi9cbiAgICB3aXRoRGV0YWlscyhkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIG1ldGFkYXRhIHRvIHRoZSBidWlsZGVyLlxuICAgICAqL1xuICAgIHdpdGhNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgdGhlIHN0YXR1cyBvYmplY3QuXG4gICAgICovXG4gICAgYnVpbGQoKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5jb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0dXMuY29kZSA9IHRoaXMuY29kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZXRhaWxzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0dXMuZGV0YWlscyA9IHRoaXMuZGV0YWlscztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdHVzLm1ldGFkYXRhID0gdGhpcy5tZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RhdHVzQnVpbGRlciA9IFN0YXR1c0J1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0dXMtYnVpbGRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTdGF0dXNCdWlsZGVyIiwiY29uc3RydWN0b3IiLCJjb2RlIiwiZGV0YWlscyIsIm1ldGFkYXRhIiwid2l0aENvZGUiLCJ3aXRoRGV0YWlscyIsIndpdGhNZXRhZGF0YSIsImJ1aWxkIiwic3RhdHVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/stream-decoder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.StreamDecoder = void 0;\nvar ReadState;\n(function(ReadState) {\n    ReadState[ReadState[\"NO_DATA\"] = 0] = \"NO_DATA\";\n    ReadState[ReadState[\"READING_SIZE\"] = 1] = \"READING_SIZE\";\n    ReadState[ReadState[\"READING_MESSAGE\"] = 2] = \"READING_MESSAGE\";\n})(ReadState || (ReadState = {}));\nclass StreamDecoder {\n    constructor(){\n        this.readState = ReadState.NO_DATA;\n        this.readCompressFlag = Buffer.alloc(1);\n        this.readPartialSize = Buffer.alloc(4);\n        this.readSizeRemaining = 4;\n        this.readMessageSize = 0;\n        this.readPartialMessage = [];\n        this.readMessageRemaining = 0;\n    }\n    write(data) {\n        let readHead = 0;\n        let toRead;\n        const result = [];\n        while(readHead < data.length){\n            switch(this.readState){\n                case ReadState.NO_DATA:\n                    this.readCompressFlag = data.slice(readHead, readHead + 1);\n                    readHead += 1;\n                    this.readState = ReadState.READING_SIZE;\n                    this.readPartialSize.fill(0);\n                    this.readSizeRemaining = 4;\n                    this.readMessageSize = 0;\n                    this.readMessageRemaining = 0;\n                    this.readPartialMessage = [];\n                    break;\n                case ReadState.READING_SIZE:\n                    toRead = Math.min(data.length - readHead, this.readSizeRemaining);\n                    data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);\n                    this.readSizeRemaining -= toRead;\n                    readHead += toRead;\n                    // readSizeRemaining >=0 here\n                    if (this.readSizeRemaining === 0) {\n                        this.readMessageSize = this.readPartialSize.readUInt32BE(0);\n                        this.readMessageRemaining = this.readMessageSize;\n                        if (this.readMessageRemaining > 0) {\n                            this.readState = ReadState.READING_MESSAGE;\n                        } else {\n                            const message = Buffer.concat([\n                                this.readCompressFlag,\n                                this.readPartialSize\n                            ], 5);\n                            this.readState = ReadState.NO_DATA;\n                            result.push(message);\n                        }\n                    }\n                    break;\n                case ReadState.READING_MESSAGE:\n                    toRead = Math.min(data.length - readHead, this.readMessageRemaining);\n                    this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\n                    this.readMessageRemaining -= toRead;\n                    readHead += toRead;\n                    // readMessageRemaining >=0 here\n                    if (this.readMessageRemaining === 0) {\n                        // At this point, we have read a full message\n                        const framedMessageBuffers = [\n                            this.readCompressFlag,\n                            this.readPartialSize\n                        ].concat(this.readPartialMessage);\n                        const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);\n                        this.readState = ReadState.NO_DATA;\n                        result.push(framedMessage);\n                    }\n                    break;\n                default:\n                    throw new Error(\"Unexpected read state\");\n            }\n        }\n        return result;\n    }\n}\nexports.StreamDecoder = StreamDecoder; //# sourceMappingURL=stream-decoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RyZWFtLWRlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHLEtBQUs7QUFDN0IsSUFBSUc7QUFDSCxVQUFVQSxTQUFTO0lBQ2hCQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQ3RDQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxlQUFlLEdBQUcsRUFBRSxHQUFHO0lBQzNDQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxrQkFBa0IsR0FBRyxFQUFFLEdBQUc7QUFDbEQsR0FBR0EsYUFBY0EsQ0FBQUEsWUFBWSxDQUFDO0FBQzlCLE1BQU1EO0lBQ0ZFLGFBQWM7UUFDVixJQUFJLENBQUNDLFNBQVMsR0FBR0YsVUFBVUcsT0FBTztRQUNsQyxJQUFJLENBQUNDLGdCQUFnQixHQUFHQyxPQUFPQyxLQUFLLENBQUM7UUFDckMsSUFBSSxDQUFDQyxlQUFlLEdBQUdGLE9BQU9DLEtBQUssQ0FBQztRQUNwQyxJQUFJLENBQUNFLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUcsRUFBRTtRQUM1QixJQUFJLENBQUNDLG9CQUFvQixHQUFHO0lBQ2hDO0lBQ0FDLE1BQU1DLElBQUksRUFBRTtRQUNSLElBQUlDLFdBQVc7UUFDZixJQUFJQztRQUNKLE1BQU1DLFNBQVMsRUFBRTtRQUNqQixNQUFPRixXQUFXRCxLQUFLSSxNQUFNLENBQUU7WUFDM0IsT0FBUSxJQUFJLENBQUNmLFNBQVM7Z0JBQ2xCLEtBQUtGLFVBQVVHLE9BQU87b0JBQ2xCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUdTLEtBQUtLLEtBQUssQ0FBQ0osVUFBVUEsV0FBVztvQkFDeERBLFlBQVk7b0JBQ1osSUFBSSxDQUFDWixTQUFTLEdBQUdGLFVBQVVtQixZQUFZO29CQUN2QyxJQUFJLENBQUNaLGVBQWUsQ0FBQ2EsSUFBSSxDQUFDO29CQUMxQixJQUFJLENBQUNaLGlCQUFpQixHQUFHO29CQUN6QixJQUFJLENBQUNDLGVBQWUsR0FBRztvQkFDdkIsSUFBSSxDQUFDRSxvQkFBb0IsR0FBRztvQkFDNUIsSUFBSSxDQUFDRCxrQkFBa0IsR0FBRyxFQUFFO29CQUM1QjtnQkFDSixLQUFLVixVQUFVbUIsWUFBWTtvQkFDdkJKLFNBQVNNLEtBQUtDLEdBQUcsQ0FBQ1QsS0FBS0ksTUFBTSxHQUFHSCxVQUFVLElBQUksQ0FBQ04saUJBQWlCO29CQUNoRUssS0FBS1UsSUFBSSxDQUFDLElBQUksQ0FBQ2hCLGVBQWUsRUFBRSxJQUFJLElBQUksQ0FBQ0MsaUJBQWlCLEVBQUVNLFVBQVVBLFdBQVdDO29CQUNqRixJQUFJLENBQUNQLGlCQUFpQixJQUFJTztvQkFDMUJELFlBQVlDO29CQUNaLDZCQUE2QjtvQkFDN0IsSUFBSSxJQUFJLENBQUNQLGlCQUFpQixLQUFLLEdBQUc7d0JBQzlCLElBQUksQ0FBQ0MsZUFBZSxHQUFHLElBQUksQ0FBQ0YsZUFBZSxDQUFDaUIsWUFBWSxDQUFDO3dCQUN6RCxJQUFJLENBQUNiLG9CQUFvQixHQUFHLElBQUksQ0FBQ0YsZUFBZTt3QkFDaEQsSUFBSSxJQUFJLENBQUNFLG9CQUFvQixHQUFHLEdBQUc7NEJBQy9CLElBQUksQ0FBQ1QsU0FBUyxHQUFHRixVQUFVeUIsZUFBZTt3QkFDOUMsT0FDSzs0QkFDRCxNQUFNQyxVQUFVckIsT0FBT3NCLE1BQU0sQ0FBQztnQ0FBQyxJQUFJLENBQUN2QixnQkFBZ0I7Z0NBQUUsSUFBSSxDQUFDRyxlQUFlOzZCQUFDLEVBQUU7NEJBQzdFLElBQUksQ0FBQ0wsU0FBUyxHQUFHRixVQUFVRyxPQUFPOzRCQUNsQ2EsT0FBT1ksSUFBSSxDQUFDRjt3QkFDaEI7b0JBQ0o7b0JBQ0E7Z0JBQ0osS0FBSzFCLFVBQVV5QixlQUFlO29CQUMxQlYsU0FBU00sS0FBS0MsR0FBRyxDQUFDVCxLQUFLSSxNQUFNLEdBQUdILFVBQVUsSUFBSSxDQUFDSCxvQkFBb0I7b0JBQ25FLElBQUksQ0FBQ0Qsa0JBQWtCLENBQUNrQixJQUFJLENBQUNmLEtBQUtLLEtBQUssQ0FBQ0osVUFBVUEsV0FBV0M7b0JBQzdELElBQUksQ0FBQ0osb0JBQW9CLElBQUlJO29CQUM3QkQsWUFBWUM7b0JBQ1osZ0NBQWdDO29CQUNoQyxJQUFJLElBQUksQ0FBQ0osb0JBQW9CLEtBQUssR0FBRzt3QkFDakMsNkNBQTZDO3dCQUM3QyxNQUFNa0IsdUJBQXVCOzRCQUN6QixJQUFJLENBQUN6QixnQkFBZ0I7NEJBQ3JCLElBQUksQ0FBQ0csZUFBZTt5QkFDdkIsQ0FBQ29CLE1BQU0sQ0FBQyxJQUFJLENBQUNqQixrQkFBa0I7d0JBQ2hDLE1BQU1vQixnQkFBZ0J6QixPQUFPc0IsTUFBTSxDQUFDRSxzQkFBc0IsSUFBSSxDQUFDcEIsZUFBZSxHQUFHO3dCQUNqRixJQUFJLENBQUNQLFNBQVMsR0FBR0YsVUFBVUcsT0FBTzt3QkFDbENhLE9BQU9ZLElBQUksQ0FBQ0U7b0JBQ2hCO29CQUNBO2dCQUNKO29CQUNJLE1BQU0sSUFBSUMsTUFBTTtZQUN4QjtRQUNKO1FBQ0EsT0FBT2Y7SUFDWDtBQUNKO0FBQ0FuQixxQkFBcUIsR0FBR0UsZUFDeEIsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNobWl0dC1ndXB0YS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdHJlYW0tZGVjb2Rlci5qcz82Y2I2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0cmVhbURlY29kZXIgPSB2b2lkIDA7XG52YXIgUmVhZFN0YXRlO1xuKGZ1bmN0aW9uIChSZWFkU3RhdGUpIHtcbiAgICBSZWFkU3RhdGVbUmVhZFN0YXRlW1wiTk9fREFUQVwiXSA9IDBdID0gXCJOT19EQVRBXCI7XG4gICAgUmVhZFN0YXRlW1JlYWRTdGF0ZVtcIlJFQURJTkdfU0laRVwiXSA9IDFdID0gXCJSRUFESU5HX1NJWkVcIjtcbiAgICBSZWFkU3RhdGVbUmVhZFN0YXRlW1wiUkVBRElOR19NRVNTQUdFXCJdID0gMl0gPSBcIlJFQURJTkdfTUVTU0FHRVwiO1xufSkoUmVhZFN0YXRlIHx8IChSZWFkU3RhdGUgPSB7fSkpO1xuY2xhc3MgU3RyZWFtRGVjb2RlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLk5PX0RBVEE7XG4gICAgICAgIHRoaXMucmVhZENvbXByZXNzRmxhZyA9IEJ1ZmZlci5hbGxvYygxKTtcbiAgICAgICAgdGhpcy5yZWFkUGFydGlhbFNpemUgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgICAgIHRoaXMucmVhZFNpemVSZW1haW5pbmcgPSA0O1xuICAgICAgICB0aGlzLnJlYWRNZXNzYWdlU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMucmVhZFBhcnRpYWxNZXNzYWdlID0gW107XG4gICAgICAgIHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgPSAwO1xuICAgIH1cbiAgICB3cml0ZShkYXRhKSB7XG4gICAgICAgIGxldCByZWFkSGVhZCA9IDA7XG4gICAgICAgIGxldCB0b1JlYWQ7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAocmVhZEhlYWQgPCBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnJlYWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgUmVhZFN0YXRlLk5PX0RBVEE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZENvbXByZXNzRmxhZyA9IGRhdGEuc2xpY2UocmVhZEhlYWQsIHJlYWRIZWFkICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRIZWFkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLlJFQURJTkdfU0laRTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkUGFydGlhbFNpemUuZmlsbCgwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU2l6ZVJlbWFpbmluZyA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZE1lc3NhZ2VTaXplID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFBhcnRpYWxNZXNzYWdlID0gW107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUmVhZFN0YXRlLlJFQURJTkdfU0laRTpcbiAgICAgICAgICAgICAgICAgICAgdG9SZWFkID0gTWF0aC5taW4oZGF0YS5sZW5ndGggLSByZWFkSGVhZCwgdGhpcy5yZWFkU2l6ZVJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuY29weSh0aGlzLnJlYWRQYXJ0aWFsU2l6ZSwgNCAtIHRoaXMucmVhZFNpemVSZW1haW5pbmcsIHJlYWRIZWFkLCByZWFkSGVhZCArIHRvUmVhZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFNpemVSZW1haW5pbmcgLT0gdG9SZWFkO1xuICAgICAgICAgICAgICAgICAgICByZWFkSGVhZCArPSB0b1JlYWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWRTaXplUmVtYWluaW5nID49MCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRTaXplUmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRNZXNzYWdlU2l6ZSA9IHRoaXMucmVhZFBhcnRpYWxTaXplLnJlYWRVSW50MzJCRSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgPSB0aGlzLnJlYWRNZXNzYWdlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLlJFQURJTkdfTUVTU0FHRTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBCdWZmZXIuY29uY2F0KFt0aGlzLnJlYWRDb21wcmVzc0ZsYWcsIHRoaXMucmVhZFBhcnRpYWxTaXplXSwgNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuTk9fREFUQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFJlYWRTdGF0ZS5SRUFESU5HX01FU1NBR0U6XG4gICAgICAgICAgICAgICAgICAgIHRvUmVhZCA9IE1hdGgubWluKGRhdGEubGVuZ3RoIC0gcmVhZEhlYWQsIHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsTWVzc2FnZS5wdXNoKGRhdGEuc2xpY2UocmVhZEhlYWQsIHJlYWRIZWFkICsgdG9SZWFkKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgLT0gdG9SZWFkO1xuICAgICAgICAgICAgICAgICAgICByZWFkSGVhZCArPSB0b1JlYWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWRNZXNzYWdlUmVtYWluaW5nID49MCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIHJlYWQgYSBmdWxsIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lZE1lc3NhZ2VCdWZmZXJzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZENvbXByZXNzRmxhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0uY29uY2F0KHRoaXMucmVhZFBhcnRpYWxNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lZE1lc3NhZ2UgPSBCdWZmZXIuY29uY2F0KGZyYW1lZE1lc3NhZ2VCdWZmZXJzLCB0aGlzLnJlYWRNZXNzYWdlU2l6ZSArIDUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuTk9fREFUQTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYW1lZE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCByZWFkIHN0YXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLlN0cmVhbURlY29kZXIgPSBTdHJlYW1EZWNvZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyZWFtLWRlY29kZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU3RyZWFtRGVjb2RlciIsIlJlYWRTdGF0ZSIsImNvbnN0cnVjdG9yIiwicmVhZFN0YXRlIiwiTk9fREFUQSIsInJlYWRDb21wcmVzc0ZsYWciLCJCdWZmZXIiLCJhbGxvYyIsInJlYWRQYXJ0aWFsU2l6ZSIsInJlYWRTaXplUmVtYWluaW5nIiwicmVhZE1lc3NhZ2VTaXplIiwicmVhZFBhcnRpYWxNZXNzYWdlIiwicmVhZE1lc3NhZ2VSZW1haW5pbmciLCJ3cml0ZSIsImRhdGEiLCJyZWFkSGVhZCIsInRvUmVhZCIsInJlc3VsdCIsImxlbmd0aCIsInNsaWNlIiwiUkVBRElOR19TSVpFIiwiZmlsbCIsIk1hdGgiLCJtaW4iLCJjb3B5IiwicmVhZFVJbnQzMkJFIiwiUkVBRElOR19NRVNTQUdFIiwibWVzc2FnZSIsImNvbmNhdCIsInB1c2giLCJmcmFtZWRNZXNzYWdlQnVmZmVycyIsImZyYW1lZE1lc3NhZ2UiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-address.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.stringToSubchannelAddress = exports.subchannelAddressToString = exports.subchannelAddressEqual = exports.isTcpSubchannelAddress = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nfunction isTcpSubchannelAddress(address) {\n    return \"port\" in address;\n}\nexports.isTcpSubchannelAddress = isTcpSubchannelAddress;\nfunction subchannelAddressEqual(address1, address2) {\n    if (isTcpSubchannelAddress(address1)) {\n        return isTcpSubchannelAddress(address2) && address1.host === address2.host && address1.port === address2.port;\n    } else {\n        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;\n    }\n}\nexports.subchannelAddressEqual = subchannelAddressEqual;\nfunction subchannelAddressToString(address) {\n    if (isTcpSubchannelAddress(address)) {\n        return address.host + \":\" + address.port;\n    } else {\n        return address.path;\n    }\n}\nexports.subchannelAddressToString = subchannelAddressToString;\nconst DEFAULT_PORT = 443;\nfunction stringToSubchannelAddress(addressString, port) {\n    if (net_1.isIP(addressString)) {\n        return {\n            host: addressString,\n            port: port !== null && port !== void 0 ? port : DEFAULT_PORT\n        };\n    } else {\n        return {\n            path: addressString\n        };\n    }\n}\nexports.stringToSubchannelAddress = stringToSubchannelAddress; //# sourceMappingURL=subchannel-address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQ0FBaUMsR0FBR0EsaUNBQWlDLEdBQUdBLDhCQUE4QixHQUFHQSw4QkFBOEIsR0FBRyxLQUFLO0FBQy9JLE1BQU1NLFFBQVFDLG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCLFNBQVNGLHVCQUF1QkcsT0FBTztJQUNuQyxPQUFPLFVBQVVBO0FBQ3JCO0FBQ0FSLDhCQUE4QixHQUFHSztBQUNqQyxTQUFTRCx1QkFBdUJLLFFBQVEsRUFBRUMsUUFBUTtJQUM5QyxJQUFJTCx1QkFBdUJJLFdBQVc7UUFDbEMsT0FBUUosdUJBQXVCSyxhQUMzQkQsU0FBU0UsSUFBSSxLQUFLRCxTQUFTQyxJQUFJLElBQy9CRixTQUFTRyxJQUFJLEtBQUtGLFNBQVNFLElBQUk7SUFDdkMsT0FDSztRQUNELE9BQU8sQ0FBQ1AsdUJBQXVCSyxhQUFhRCxTQUFTSSxJQUFJLEtBQUtILFNBQVNHLElBQUk7SUFDL0U7QUFDSjtBQUNBYiw4QkFBOEIsR0FBR0k7QUFDakMsU0FBU0QsMEJBQTBCSyxPQUFPO0lBQ3RDLElBQUlILHVCQUF1QkcsVUFBVTtRQUNqQyxPQUFPQSxRQUFRRyxJQUFJLEdBQUcsTUFBTUgsUUFBUUksSUFBSTtJQUM1QyxPQUNLO1FBQ0QsT0FBT0osUUFBUUssSUFBSTtJQUN2QjtBQUNKO0FBQ0FiLGlDQUFpQyxHQUFHRztBQUNwQyxNQUFNVyxlQUFlO0FBQ3JCLFNBQVNaLDBCQUEwQmEsYUFBYSxFQUFFSCxJQUFJO0lBQ2xELElBQUlOLE1BQU1VLElBQUksQ0FBQ0QsZ0JBQWdCO1FBQzNCLE9BQU87WUFDSEosTUFBTUk7WUFDTkgsTUFBTUEsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSUEsT0FBT0U7UUFDcEQ7SUFDSixPQUNLO1FBQ0QsT0FBTztZQUNIRCxNQUFNRTtRQUNWO0lBQ0o7QUFDSjtBQUNBZixpQ0FBaUMsR0FBR0UsMkJBQ3BDLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL2FzaG1pdHQtZ3VwdGEvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1hZGRyZXNzLmpzP2JhMzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyA9IGV4cG9ydHMuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyA9IGV4cG9ydHMuc3ViY2hhbm5lbEFkZHJlc3NFcXVhbCA9IGV4cG9ydHMuaXNUY3BTdWJjaGFubmVsQWRkcmVzcyA9IHZvaWQgMDtcbmNvbnN0IG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcbmZ1bmN0aW9uIGlzVGNwU3ViY2hhbm5lbEFkZHJlc3MoYWRkcmVzcykge1xuICAgIHJldHVybiAncG9ydCcgaW4gYWRkcmVzcztcbn1cbmV4cG9ydHMuaXNUY3BTdWJjaGFubmVsQWRkcmVzcyA9IGlzVGNwU3ViY2hhbm5lbEFkZHJlc3M7XG5mdW5jdGlvbiBzdWJjaGFubmVsQWRkcmVzc0VxdWFsKGFkZHJlc3MxLCBhZGRyZXNzMikge1xuICAgIGlmIChpc1RjcFN1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3MxKSkge1xuICAgICAgICByZXR1cm4gKGlzVGNwU3ViY2hhbm5lbEFkZHJlc3MoYWRkcmVzczIpICYmXG4gICAgICAgICAgICBhZGRyZXNzMS5ob3N0ID09PSBhZGRyZXNzMi5ob3N0ICYmXG4gICAgICAgICAgICBhZGRyZXNzMS5wb3J0ID09PSBhZGRyZXNzMi5wb3J0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAhaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzMikgJiYgYWRkcmVzczEucGF0aCA9PT0gYWRkcmVzczIucGF0aDtcbiAgICB9XG59XG5leHBvcnRzLnN1YmNoYW5uZWxBZGRyZXNzRXF1YWwgPSBzdWJjaGFubmVsQWRkcmVzc0VxdWFsO1xuZnVuY3Rpb24gc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyhhZGRyZXNzKSB7XG4gICAgaWYgKGlzVGNwU3ViY2hhbm5lbEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuIGFkZHJlc3MuaG9zdCArICc6JyArIGFkZHJlc3MucG9ydDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBhZGRyZXNzLnBhdGg7XG4gICAgfVxufVxuZXhwb3J0cy5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nID0gc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZztcbmNvbnN0IERFRkFVTFRfUE9SVCA9IDQ0MztcbmZ1bmN0aW9uIHN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3MoYWRkcmVzc1N0cmluZywgcG9ydCkge1xuICAgIGlmIChuZXRfMS5pc0lQKGFkZHJlc3NTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBob3N0OiBhZGRyZXNzU3RyaW5nLFxuICAgICAgICAgICAgcG9ydDogcG9ydCAhPT0gbnVsbCAmJiBwb3J0ICE9PSB2b2lkIDAgPyBwb3J0IDogREVGQVVMVF9QT1JUXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF0aDogYWRkcmVzc1N0cmluZ1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyA9IHN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJjaGFubmVsLWFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyIsInN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmciLCJzdWJjaGFubmVsQWRkcmVzc0VxdWFsIiwiaXNUY3BTdWJjaGFubmVsQWRkcmVzcyIsIm5ldF8xIiwicmVxdWlyZSIsImFkZHJlc3MiLCJhZGRyZXNzMSIsImFkZHJlc3MyIiwiaG9zdCIsInBvcnQiLCJwYXRoIiwiREVGQVVMVF9QT1JUIiwiYWRkcmVzc1N0cmluZyIsImlzSVAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BaseSubchannelWrapper = void 0;\nclass BaseSubchannelWrapper {\n    constructor(child){\n        this.child = child;\n    }\n    getConnectivityState() {\n        return this.child.getConnectivityState();\n    }\n    addConnectivityStateListener(listener) {\n        this.child.addConnectivityStateListener(listener);\n    }\n    removeConnectivityStateListener(listener) {\n        this.child.removeConnectivityStateListener(listener);\n    }\n    startConnecting() {\n        this.child.startConnecting();\n    }\n    getAddress() {\n        return this.child.getAddress();\n    }\n    ref() {\n        this.child.ref();\n    }\n    unref() {\n        this.child.unref();\n    }\n    getChannelzRef() {\n        return this.child.getChannelzRef();\n    }\n    getRealSubchannel() {\n        return this.child.getRealSubchannel();\n    }\n}\nexports.BaseSubchannelWrapper = BaseSubchannelWrapper; //# sourceMappingURL=subchannel-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHLEtBQUs7QUFDckMsTUFBTUU7SUFDRkMsWUFBWUMsS0FBSyxDQUFFO1FBQ2YsSUFBSSxDQUFDQSxLQUFLLEdBQUdBO0lBQ2pCO0lBQ0FDLHVCQUF1QjtRQUNuQixPQUFPLElBQUksQ0FBQ0QsS0FBSyxDQUFDQyxvQkFBb0I7SUFDMUM7SUFDQUMsNkJBQTZCQyxRQUFRLEVBQUU7UUFDbkMsSUFBSSxDQUFDSCxLQUFLLENBQUNFLDRCQUE0QixDQUFDQztJQUM1QztJQUNBQyxnQ0FBZ0NELFFBQVEsRUFBRTtRQUN0QyxJQUFJLENBQUNILEtBQUssQ0FBQ0ksK0JBQStCLENBQUNEO0lBQy9DO0lBQ0FFLGtCQUFrQjtRQUNkLElBQUksQ0FBQ0wsS0FBSyxDQUFDSyxlQUFlO0lBQzlCO0lBQ0FDLGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQ04sS0FBSyxDQUFDTSxVQUFVO0lBQ2hDO0lBQ0FDLE1BQU07UUFDRixJQUFJLENBQUNQLEtBQUssQ0FBQ08sR0FBRztJQUNsQjtJQUNBQyxRQUFRO1FBQ0osSUFBSSxDQUFDUixLQUFLLENBQUNRLEtBQUs7SUFDcEI7SUFDQUMsaUJBQWlCO1FBQ2IsT0FBTyxJQUFJLENBQUNULEtBQUssQ0FBQ1MsY0FBYztJQUNwQztJQUNBQyxvQkFBb0I7UUFDaEIsT0FBTyxJQUFJLENBQUNWLEtBQUssQ0FBQ1UsaUJBQWlCO0lBQ3ZDO0FBQ0o7QUFDQWQsNkJBQTZCLEdBQUdFLHVCQUNoQyxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc2htaXR0LWd1cHRhLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N1YmNoYW5uZWwtaW50ZXJmYWNlLmpzPzI4Y2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZVN1YmNoYW5uZWxXcmFwcGVyID0gdm9pZCAwO1xuY2xhc3MgQmFzZVN1YmNoYW5uZWxXcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZCkge1xuICAgICAgICB0aGlzLmNoaWxkID0gY2hpbGQ7XG4gICAgfVxuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpO1xuICAgIH1cbiAgICBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuY2hpbGQuYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5jaGlsZC5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgc3RhcnRDb25uZWN0aW5nKCkge1xuICAgICAgICB0aGlzLmNoaWxkLnN0YXJ0Q29ubmVjdGluZygpO1xuICAgIH1cbiAgICBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZC5nZXRBZGRyZXNzKCk7XG4gICAgfVxuICAgIHJlZigpIHtcbiAgICAgICAgdGhpcy5jaGlsZC5yZWYoKTtcbiAgICB9XG4gICAgdW5yZWYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQudW5yZWYoKTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbHpSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkLmdldENoYW5uZWx6UmVmKCk7XG4gICAgfVxuICAgIGdldFJlYWxTdWJjaGFubmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZC5nZXRSZWFsU3ViY2hhbm5lbCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZVN1YmNoYW5uZWxXcmFwcGVyID0gQmFzZVN1YmNoYW5uZWxXcmFwcGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ViY2hhbm5lbC1pbnRlcmZhY2UuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQmFzZVN1YmNoYW5uZWxXcmFwcGVyIiwiY29uc3RydWN0b3IiLCJjaGlsZCIsImdldENvbm5lY3Rpdml0eVN0YXRlIiwiYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lciIsImxpc3RlbmVyIiwicmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lciIsInN0YXJ0Q29ubmVjdGluZyIsImdldEFkZHJlc3MiLCJyZWYiLCJ1bnJlZiIsImdldENoYW5uZWx6UmVmIiwiZ2V0UmVhbFN1YmNoYW5uZWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getSubchannelPool = exports.SubchannelPool = void 0;\nconst channel_options_1 = __webpack_require__(/*! ./channel-options */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\");\nconst subchannel_1 = __webpack_require__(/*! ./subchannel */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\n// 10 seconds in milliseconds. This value is arbitrary.\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */ const REF_CHECK_INTERVAL = 10000;\nclass SubchannelPool {\n    /**\n     * A pool of subchannels use for making connections. Subchannels with the\n     * exact same parameters will be reused.\n     */ constructor(){\n        this.pool = Object.create(null);\n        /**\n         * A timer of a task performing a periodic subchannel cleanup.\n         */ this.cleanupTimer = null;\n    }\n    /**\n     * Unrefs all unused subchannels and cancels the cleanup task if all\n     * subchannels have been unrefed.\n     */ unrefUnusedSubchannels() {\n        let allSubchannelsUnrefed = true;\n        /* These objects are created with Object.create(null), so they do not\n         * have a prototype, which means that for (... in ...) loops over them\n         * do not need to be filtered */ // eslint-disable-disable-next-line:forin\n        for(const channelTarget in this.pool){\n            const subchannelObjArray = this.pool[channelTarget];\n            const refedSubchannels = subchannelObjArray.filter((value)=>!value.subchannel.unrefIfOneRef());\n            if (refedSubchannels.length > 0) {\n                allSubchannelsUnrefed = false;\n            }\n            /* For each subchannel in the pool, try to unref it if it has\n             * exactly one ref (which is the ref from the pool itself). If that\n             * does happen, remove the subchannel from the pool */ this.pool[channelTarget] = refedSubchannels;\n        }\n        /* Currently we do not delete keys with empty values. If that results\n         * in significant memory usage we should change it. */ // Cancel the cleanup task if all subchannels have been unrefed.\n        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n            clearInterval(this.cleanupTimer);\n            this.cleanupTimer = null;\n        }\n    }\n    /**\n     * Ensures that the cleanup task is spawned.\n     */ ensureCleanupTask() {\n        var _a, _b;\n        if (this.cleanupTimer === null) {\n            this.cleanupTimer = setInterval(()=>{\n                this.unrefUnusedSubchannels();\n            }, REF_CHECK_INTERVAL);\n            // Unref because this timer should not keep the event loop running.\n            // Call unref only if it exists to address electron/electron#21162\n            (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    /**\n     * Get a subchannel if one already exists with exactly matching parameters.\n     * Otherwise, create and save a subchannel with those parameters.\n     * @param channelTarget\n     * @param subchannelTarget\n     * @param channelArguments\n     * @param channelCredentials\n     */ getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {\n        this.ensureCleanupTask();\n        const channelTarget = uri_parser_1.uriToString(channelTargetUri);\n        if (channelTarget in this.pool) {\n            const subchannelObjArray = this.pool[channelTarget];\n            for (const subchannelObj of subchannelObjArray){\n                if (subchannel_address_1.subchannelAddressEqual(subchannelTarget, subchannelObj.subchannelAddress) && channel_options_1.channelOptionsEqual(channelArguments, subchannelObj.channelArguments) && channelCredentials._equals(subchannelObj.channelCredentials)) {\n                    return subchannelObj.subchannel;\n                }\n            }\n        }\n        // If we get here, no matching subchannel was found\n        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials);\n        if (!(channelTarget in this.pool)) {\n            this.pool[channelTarget] = [];\n        }\n        this.pool[channelTarget].push({\n            subchannelAddress: subchannelTarget,\n            channelArguments,\n            channelCredentials,\n            subchannel\n        });\n        subchannel.ref();\n        return subchannel;\n    }\n}\nexports.SubchannelPool = SubchannelPool;\nconst globalSubchannelPool = new SubchannelPool();\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */ function getSubchannelPool(global) {\n    if (global) {\n        return globalSubchannelPool;\n    } else {\n        return new SubchannelPool();\n    }\n}\nexports.getSubchannelPool = getSubchannelPool; //# sourceMappingURL=subchannel-pool.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1wb29sLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx5QkFBeUIsR0FBR0Esc0JBQXNCLEdBQUcsS0FBSztBQUMxRCxNQUFNSSxvQkFBb0JDLG1CQUFPQSxDQUFDLDBGQUFtQjtBQUNyRCxNQUFNQyxlQUFlRCxtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNRSx1QkFBdUJGLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNRyxlQUFlSCxtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyx1REFBdUQ7QUFDdkQ7OztDQUdDLEdBQ0QsTUFBTUkscUJBQXFCO0FBQzNCLE1BQU1OO0lBQ0Y7OztLQUdDLEdBQ0RPLGFBQWM7UUFDVixJQUFJLENBQUNDLElBQUksR0FBR2IsT0FBT2MsTUFBTSxDQUFDO1FBQzFCOztTQUVDLEdBQ0QsSUFBSSxDQUFDQyxZQUFZLEdBQUc7SUFDeEI7SUFDQTs7O0tBR0MsR0FDREMseUJBQXlCO1FBQ3JCLElBQUlDLHdCQUF3QjtRQUM1Qjs7c0NBRThCLEdBQzlCLHlDQUF5QztRQUN6QyxJQUFLLE1BQU1DLGlCQUFpQixJQUFJLENBQUNMLElBQUksQ0FBRTtZQUNuQyxNQUFNTSxxQkFBcUIsSUFBSSxDQUFDTixJQUFJLENBQUNLLGNBQWM7WUFDbkQsTUFBTUUsbUJBQW1CRCxtQkFBbUJFLE1BQU0sQ0FBQyxDQUFDbEIsUUFBVSxDQUFDQSxNQUFNbUIsVUFBVSxDQUFDQyxhQUFhO1lBQzdGLElBQUlILGlCQUFpQkksTUFBTSxHQUFHLEdBQUc7Z0JBQzdCUCx3QkFBd0I7WUFDNUI7WUFDQTs7Z0VBRW9ELEdBQ3BELElBQUksQ0FBQ0osSUFBSSxDQUFDSyxjQUFjLEdBQUdFO1FBQy9CO1FBQ0E7NERBQ29ELEdBQ3BELGdFQUFnRTtRQUNoRSxJQUFJSCx5QkFBeUIsSUFBSSxDQUFDRixZQUFZLEtBQUssTUFBTTtZQUNyRFUsY0FBYyxJQUFJLENBQUNWLFlBQVk7WUFDL0IsSUFBSSxDQUFDQSxZQUFZLEdBQUc7UUFDeEI7SUFDSjtJQUNBOztLQUVDLEdBQ0RXLG9CQUFvQjtRQUNoQixJQUFJQyxJQUFJQztRQUNSLElBQUksSUFBSSxDQUFDYixZQUFZLEtBQUssTUFBTTtZQUM1QixJQUFJLENBQUNBLFlBQVksR0FBR2MsWUFBWTtnQkFDNUIsSUFBSSxDQUFDYixzQkFBc0I7WUFDL0IsR0FBR0w7WUFDSCxtRUFBbUU7WUFDbkUsa0VBQWtFO1lBQ2pFaUIsQ0FBQUEsS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQ1osWUFBWSxFQUFFZSxLQUFLLE1BQU0sUUFBUUYsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHRyxJQUFJLENBQUNKO1FBQ3ZGO0lBQ0o7SUFDQTs7Ozs7OztLQU9DLEdBQ0RLLHNCQUFzQkMsZ0JBQWdCLEVBQUVDLGdCQUFnQixFQUFFQyxnQkFBZ0IsRUFBRUMsa0JBQWtCLEVBQUU7UUFDNUYsSUFBSSxDQUFDVixpQkFBaUI7UUFDdEIsTUFBTVIsZ0JBQWdCUixhQUFhMkIsV0FBVyxDQUFDSjtRQUMvQyxJQUFJZixpQkFBaUIsSUFBSSxDQUFDTCxJQUFJLEVBQUU7WUFDNUIsTUFBTU0scUJBQXFCLElBQUksQ0FBQ04sSUFBSSxDQUFDSyxjQUFjO1lBQ25ELEtBQUssTUFBTW9CLGlCQUFpQm5CLG1CQUFvQjtnQkFDNUMsSUFBSVYscUJBQXFCOEIsc0JBQXNCLENBQUNMLGtCQUFrQkksY0FBY0UsaUJBQWlCLEtBQzdGbEMsa0JBQWtCbUMsbUJBQW1CLENBQUNOLGtCQUFrQkcsY0FBY0gsZ0JBQWdCLEtBQ3RGQyxtQkFBbUJNLE9BQU8sQ0FBQ0osY0FBY0Ysa0JBQWtCLEdBQUc7b0JBQzlELE9BQU9FLGNBQWNoQixVQUFVO2dCQUNuQztZQUNKO1FBQ0o7UUFDQSxtREFBbUQ7UUFDbkQsTUFBTUEsYUFBYSxJQUFJZCxhQUFhbUMsVUFBVSxDQUFDVixrQkFBa0JDLGtCQUFrQkMsa0JBQWtCQztRQUNyRyxJQUFJLENBQUVsQixDQUFBQSxpQkFBaUIsSUFBSSxDQUFDTCxJQUFJLEdBQUc7WUFDL0IsSUFBSSxDQUFDQSxJQUFJLENBQUNLLGNBQWMsR0FBRyxFQUFFO1FBQ2pDO1FBQ0EsSUFBSSxDQUFDTCxJQUFJLENBQUNLLGNBQWMsQ0FBQzBCLElBQUksQ0FBQztZQUMxQkosbUJBQW1CTjtZQUNuQkM7WUFDQUM7WUFDQWQ7UUFDSjtRQUNBQSxXQUFXdUIsR0FBRztRQUNkLE9BQU92QjtJQUNYO0FBQ0o7QUFDQXBCLHNCQUFzQixHQUFHRztBQUN6QixNQUFNeUMsdUJBQXVCLElBQUl6QztBQUNqQzs7O0NBR0MsR0FDRCxTQUFTRCxrQkFBa0IyQyxNQUFNO0lBQzdCLElBQUlBLFFBQVE7UUFDUixPQUFPRDtJQUNYLE9BQ0s7UUFDRCxPQUFPLElBQUl6QztJQUNmO0FBQ0o7QUFDQUgseUJBQXlCLEdBQUdFLG1CQUM1QiwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc2htaXR0LWd1cHRhLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N1YmNoYW5uZWwtcG9vbC5qcz9jNTY2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFN1YmNoYW5uZWxQb29sID0gZXhwb3J0cy5TdWJjaGFubmVsUG9vbCA9IHZvaWQgMDtcbmNvbnN0IGNoYW5uZWxfb3B0aW9uc18xID0gcmVxdWlyZShcIi4vY2hhbm5lbC1vcHRpb25zXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbFwiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbi8vIDEwIHNlY29uZHMgaW4gbWlsbGlzZWNvbmRzLiBUaGlzIHZhbHVlIGlzIGFyYml0cmFyeS5cbi8qKlxuICogVGhlIGFtb3VudCBvZiB0aW1lIGluIGJldHdlZW4gY2hlY2tzIGZvciBkcm9wcGluZyBzdWJjaGFubmVscyB0aGF0IGhhdmUgbm9cbiAqIG90aGVyIHJlZmVyZW5jZXNcbiAqL1xuY29uc3QgUkVGX0NIRUNLX0lOVEVSVkFMID0gMTAwMDA7XG5jbGFzcyBTdWJjaGFubmVsUG9vbCB7XG4gICAgLyoqXG4gICAgICogQSBwb29sIG9mIHN1YmNoYW5uZWxzIHVzZSBmb3IgbWFraW5nIGNvbm5lY3Rpb25zLiBTdWJjaGFubmVscyB3aXRoIHRoZVxuICAgICAqIGV4YWN0IHNhbWUgcGFyYW1ldGVycyB3aWxsIGJlIHJldXNlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wb29sID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdGltZXIgb2YgYSB0YXNrIHBlcmZvcm1pbmcgYSBwZXJpb2RpYyBzdWJjaGFubmVsIGNsZWFudXAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsZWFudXBUaW1lciA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucmVmcyBhbGwgdW51c2VkIHN1YmNoYW5uZWxzIGFuZCBjYW5jZWxzIHRoZSBjbGVhbnVwIHRhc2sgaWYgYWxsXG4gICAgICogc3ViY2hhbm5lbHMgaGF2ZSBiZWVuIHVucmVmZWQuXG4gICAgICovXG4gICAgdW5yZWZVbnVzZWRTdWJjaGFubmVscygpIHtcbiAgICAgICAgbGV0IGFsbFN1YmNoYW5uZWxzVW5yZWZlZCA9IHRydWU7XG4gICAgICAgIC8qIFRoZXNlIG9iamVjdHMgYXJlIGNyZWF0ZWQgd2l0aCBPYmplY3QuY3JlYXRlKG51bGwpLCBzbyB0aGV5IGRvIG5vdFxuICAgICAgICAgKiBoYXZlIGEgcHJvdG90eXBlLCB3aGljaCBtZWFucyB0aGF0IGZvciAoLi4uIGluIC4uLikgbG9vcHMgb3ZlciB0aGVtXG4gICAgICAgICAqIGRvIG5vdCBuZWVkIHRvIGJlIGZpbHRlcmVkICovXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWRpc2FibGUtbmV4dC1saW5lOmZvcmluXG4gICAgICAgIGZvciAoY29uc3QgY2hhbm5lbFRhcmdldCBpbiB0aGlzLnBvb2wpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxPYmpBcnJheSA9IHRoaXMucG9vbFtjaGFubmVsVGFyZ2V0XTtcbiAgICAgICAgICAgIGNvbnN0IHJlZmVkU3ViY2hhbm5lbHMgPSBzdWJjaGFubmVsT2JqQXJyYXkuZmlsdGVyKCh2YWx1ZSkgPT4gIXZhbHVlLnN1YmNoYW5uZWwudW5yZWZJZk9uZVJlZigpKTtcbiAgICAgICAgICAgIGlmIChyZWZlZFN1YmNoYW5uZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBhbGxTdWJjaGFubmVsc1VucmVmZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIEZvciBlYWNoIHN1YmNoYW5uZWwgaW4gdGhlIHBvb2wsIHRyeSB0byB1bnJlZiBpdCBpZiBpdCBoYXNcbiAgICAgICAgICAgICAqIGV4YWN0bHkgb25lIHJlZiAod2hpY2ggaXMgdGhlIHJlZiBmcm9tIHRoZSBwb29sIGl0c2VsZikuIElmIHRoYXRcbiAgICAgICAgICAgICAqIGRvZXMgaGFwcGVuLCByZW1vdmUgdGhlIHN1YmNoYW5uZWwgZnJvbSB0aGUgcG9vbCAqL1xuICAgICAgICAgICAgdGhpcy5wb29sW2NoYW5uZWxUYXJnZXRdID0gcmVmZWRTdWJjaGFubmVscztcbiAgICAgICAgfVxuICAgICAgICAvKiBDdXJyZW50bHkgd2UgZG8gbm90IGRlbGV0ZSBrZXlzIHdpdGggZW1wdHkgdmFsdWVzLiBJZiB0aGF0IHJlc3VsdHNcbiAgICAgICAgICogaW4gc2lnbmlmaWNhbnQgbWVtb3J5IHVzYWdlIHdlIHNob3VsZCBjaGFuZ2UgaXQuICovXG4gICAgICAgIC8vIENhbmNlbCB0aGUgY2xlYW51cCB0YXNrIGlmIGFsbCBzdWJjaGFubmVscyBoYXZlIGJlZW4gdW5yZWZlZC5cbiAgICAgICAgaWYgKGFsbFN1YmNoYW5uZWxzVW5yZWZlZCAmJiB0aGlzLmNsZWFudXBUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNsZWFudXBUaW1lcik7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXBUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlcyB0aGF0IHRoZSBjbGVhbnVwIHRhc2sgaXMgc3Bhd25lZC5cbiAgICAgKi9cbiAgICBlbnN1cmVDbGVhbnVwVGFzaygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuY2xlYW51cFRpbWVyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXBUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVucmVmVW51c2VkU3ViY2hhbm5lbHMoKTtcbiAgICAgICAgICAgIH0sIFJFRl9DSEVDS19JTlRFUlZBTCk7XG4gICAgICAgICAgICAvLyBVbnJlZiBiZWNhdXNlIHRoaXMgdGltZXIgc2hvdWxkIG5vdCBrZWVwIHRoZSBldmVudCBsb29wIHJ1bm5pbmcuXG4gICAgICAgICAgICAvLyBDYWxsIHVucmVmIG9ubHkgaWYgaXQgZXhpc3RzIHRvIGFkZHJlc3MgZWxlY3Ryb24vZWxlY3Ryb24jMjExNjJcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2xlYW51cFRpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHN1YmNoYW5uZWwgaWYgb25lIGFscmVhZHkgZXhpc3RzIHdpdGggZXhhY3RseSBtYXRjaGluZyBwYXJhbWV0ZXJzLlxuICAgICAqIE90aGVyd2lzZSwgY3JlYXRlIGFuZCBzYXZlIGEgc3ViY2hhbm5lbCB3aXRoIHRob3NlIHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIGNoYW5uZWxUYXJnZXRcbiAgICAgKiBAcGFyYW0gc3ViY2hhbm5lbFRhcmdldFxuICAgICAqIEBwYXJhbSBjaGFubmVsQXJndW1lbnRzXG4gICAgICogQHBhcmFtIGNoYW5uZWxDcmVkZW50aWFsc1xuICAgICAqL1xuICAgIGdldE9yQ3JlYXRlU3ViY2hhbm5lbChjaGFubmVsVGFyZ2V0VXJpLCBzdWJjaGFubmVsVGFyZ2V0LCBjaGFubmVsQXJndW1lbnRzLCBjaGFubmVsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVDbGVhbnVwVGFzaygpO1xuICAgICAgICBjb25zdCBjaGFubmVsVGFyZ2V0ID0gdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKGNoYW5uZWxUYXJnZXRVcmkpO1xuICAgICAgICBpZiAoY2hhbm5lbFRhcmdldCBpbiB0aGlzLnBvb2wpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxPYmpBcnJheSA9IHRoaXMucG9vbFtjaGFubmVsVGFyZ2V0XTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbE9iaiBvZiBzdWJjaGFubmVsT2JqQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NFcXVhbChzdWJjaGFubmVsVGFyZ2V0LCBzdWJjaGFubmVsT2JqLnN1YmNoYW5uZWxBZGRyZXNzKSAmJlxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsX29wdGlvbnNfMS5jaGFubmVsT3B0aW9uc0VxdWFsKGNoYW5uZWxBcmd1bWVudHMsIHN1YmNoYW5uZWxPYmouY2hhbm5lbEFyZ3VtZW50cykgJiZcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENyZWRlbnRpYWxzLl9lcXVhbHMoc3ViY2hhbm5lbE9iai5jaGFubmVsQ3JlZGVudGlhbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJjaGFubmVsT2JqLnN1YmNoYW5uZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGdldCBoZXJlLCBubyBtYXRjaGluZyBzdWJjaGFubmVsIHdhcyBmb3VuZFxuICAgICAgICBjb25zdCBzdWJjaGFubmVsID0gbmV3IHN1YmNoYW5uZWxfMS5TdWJjaGFubmVsKGNoYW5uZWxUYXJnZXRVcmksIHN1YmNoYW5uZWxUYXJnZXQsIGNoYW5uZWxBcmd1bWVudHMsIGNoYW5uZWxDcmVkZW50aWFscyk7XG4gICAgICAgIGlmICghKGNoYW5uZWxUYXJnZXQgaW4gdGhpcy5wb29sKSkge1xuICAgICAgICAgICAgdGhpcy5wb29sW2NoYW5uZWxUYXJnZXRdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb29sW2NoYW5uZWxUYXJnZXRdLnB1c2goe1xuICAgICAgICAgICAgc3ViY2hhbm5lbEFkZHJlc3M6IHN1YmNoYW5uZWxUYXJnZXQsXG4gICAgICAgICAgICBjaGFubmVsQXJndW1lbnRzLFxuICAgICAgICAgICAgY2hhbm5lbENyZWRlbnRpYWxzLFxuICAgICAgICAgICAgc3ViY2hhbm5lbCxcbiAgICAgICAgfSk7XG4gICAgICAgIHN1YmNoYW5uZWwucmVmKCk7XG4gICAgICAgIHJldHVybiBzdWJjaGFubmVsO1xuICAgIH1cbn1cbmV4cG9ydHMuU3ViY2hhbm5lbFBvb2wgPSBTdWJjaGFubmVsUG9vbDtcbmNvbnN0IGdsb2JhbFN1YmNoYW5uZWxQb29sID0gbmV3IFN1YmNoYW5uZWxQb29sKCk7XG4vKipcbiAqIEdldCBlaXRoZXIgdGhlIGdsb2JhbCBzdWJjaGFubmVsIHBvb2wsIG9yIGEgbmV3IHN1YmNoYW5uZWwgcG9vbC5cbiAqIEBwYXJhbSBnbG9iYWxcbiAqL1xuZnVuY3Rpb24gZ2V0U3ViY2hhbm5lbFBvb2woZ2xvYmFsKSB7XG4gICAgaWYgKGdsb2JhbCkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsU3ViY2hhbm5lbFBvb2w7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFN1YmNoYW5uZWxQb29sKCk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRTdWJjaGFubmVsUG9vbCA9IGdldFN1YmNoYW5uZWxQb29sO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ViY2hhbm5lbC1wb29sLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldFN1YmNoYW5uZWxQb29sIiwiU3ViY2hhbm5lbFBvb2wiLCJjaGFubmVsX29wdGlvbnNfMSIsInJlcXVpcmUiLCJzdWJjaGFubmVsXzEiLCJzdWJjaGFubmVsX2FkZHJlc3NfMSIsInVyaV9wYXJzZXJfMSIsIlJFRl9DSEVDS19JTlRFUlZBTCIsImNvbnN0cnVjdG9yIiwicG9vbCIsImNyZWF0ZSIsImNsZWFudXBUaW1lciIsInVucmVmVW51c2VkU3ViY2hhbm5lbHMiLCJhbGxTdWJjaGFubmVsc1VucmVmZWQiLCJjaGFubmVsVGFyZ2V0Iiwic3ViY2hhbm5lbE9iakFycmF5IiwicmVmZWRTdWJjaGFubmVscyIsImZpbHRlciIsInN1YmNoYW5uZWwiLCJ1bnJlZklmT25lUmVmIiwibGVuZ3RoIiwiY2xlYXJJbnRlcnZhbCIsImVuc3VyZUNsZWFudXBUYXNrIiwiX2EiLCJfYiIsInNldEludGVydmFsIiwidW5yZWYiLCJjYWxsIiwiZ2V0T3JDcmVhdGVTdWJjaGFubmVsIiwiY2hhbm5lbFRhcmdldFVyaSIsInN1YmNoYW5uZWxUYXJnZXQiLCJjaGFubmVsQXJndW1lbnRzIiwiY2hhbm5lbENyZWRlbnRpYWxzIiwidXJpVG9TdHJpbmciLCJzdWJjaGFubmVsT2JqIiwic3ViY2hhbm5lbEFkZHJlc3NFcXVhbCIsInN1YmNoYW5uZWxBZGRyZXNzIiwiY2hhbm5lbE9wdGlvbnNFcXVhbCIsIl9lcXVhbHMiLCJTdWJjaGFubmVsIiwicHVzaCIsInJlZiIsImdsb2JhbFN1YmNoYW5uZWxQb29sIiwiZ2xvYmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Subchannel = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(ssr)/./node_modules/@grpc/grpc-js/package.json\").version);\nconst TRACER_NAME = \"subchannel\";\nconst FLOW_CONTROL_TRACER_NAME = \"subchannel_flowctrl\";\nconst MIN_CONNECT_TIMEOUT_MS = 20000;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */ const KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT } = http2.constants;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */ function uniformRandom(min, max) {\n    return Math.random() * (max - min) + min;\n}\nconst tooManyPingsData = Buffer.from(\"too_many_pings\", \"ascii\");\nclass Subchannel {\n    /**\n     * A class representing a connection to a single backend.\n     * @param channelTarget The target string for the channel as a whole\n     * @param subchannelAddress The address for the backend that this subchannel\n     *     will connect to\n     * @param options The channel options, plus any specific subchannel options\n     *     for this subchannel\n     * @param credentials The channel credentials used to establish this\n     *     connection\n     */ constructor(channelTarget, subchannelAddress, options, credentials){\n        this.channelTarget = channelTarget;\n        this.subchannelAddress = subchannelAddress;\n        this.options = options;\n        this.credentials = credentials;\n        /**\n         * The subchannel's current connectivity state. Invariant: `session` === `null`\n         * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n         */ this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The underlying http2 session used to make requests.\n         */ this.session = null;\n        /**\n         * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n         * CONNECTING instead of IDLE when the backoff timeout ends.\n         */ this.continueConnecting = false;\n        /**\n         * A list of listener functions that will be called whenever the connectivity\n         * state changes. Will be modified by `addConnectivityStateListener` and\n         * `removeConnectivityStateListener`\n         */ this.stateListeners = [];\n        /**\n         * A list of listener functions that will be called when the underlying\n         * socket disconnects. Used for ending active calls with an UNAVAILABLE\n         * status.\n         */ this.disconnectListeners = new Set();\n        /**\n         * The amount of time in between sending pings\n         */ this.keepaliveTimeMs = KEEPALIVE_MAX_TIME_MS;\n        /**\n         * The amount of time to wait for an acknowledgement after sending a ping\n         */ this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n        /**\n         * Indicates whether keepalive pings should be sent without any active calls\n         */ this.keepaliveWithoutCalls = false;\n        /**\n         * Tracks calls with references to this subchannel\n         */ this.callRefcount = 0;\n        /**\n         * Tracks channels and subchannel pools with references to this subchannel\n         */ this.refcount = 0;\n        // Channelz info\n        this.channelzEnabled = true;\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n        // Channelz socket info\n        this.channelzSocketRef = null;\n        /**\n         * Name of the remote server, if it is not the same as the subchannel\n         * address, i.e. if connecting through an HTTP CONNECT proxy.\n         */ this.remoteName = null;\n        this.streamTracker = new channelz_1.ChannelzCallTracker();\n        this.keepalivesSent = 0;\n        this.messagesSent = 0;\n        this.messagesReceived = 0;\n        this.lastMessageSentTimestamp = null;\n        this.lastMessageReceivedTimestamp = null;\n        // Build user-agent string.\n        this.userAgent = [\n            options[\"grpc.primary_user_agent\"],\n            `grpc-node-js/${clientVersion}`,\n            options[\"grpc.secondary_user_agent\"]\n        ].filter((e)=>e).join(\" \"); // remove falsey values first\n        if (\"grpc.keepalive_time_ms\" in options) {\n            this.keepaliveTimeMs = options[\"grpc.keepalive_time_ms\"];\n        }\n        if (\"grpc.keepalive_timeout_ms\" in options) {\n            this.keepaliveTimeoutMs = options[\"grpc.keepalive_timeout_ms\"];\n        }\n        if (\"grpc.keepalive_permit_without_calls\" in options) {\n            this.keepaliveWithoutCalls = options[\"grpc.keepalive_permit_without_calls\"] === 1;\n        } else {\n            this.keepaliveWithoutCalls = false;\n        }\n        this.keepaliveIntervalId = setTimeout(()=>{}, 0);\n        clearTimeout(this.keepaliveIntervalId);\n        this.keepaliveTimeoutId = setTimeout(()=>{}, 0);\n        clearTimeout(this.keepaliveTimeoutId);\n        const backoffOptions = {\n            initialDelay: options[\"grpc.initial_reconnect_backoff_ms\"],\n            maxDelay: options[\"grpc.max_reconnect_backoff_ms\"]\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(()=>{\n            this.handleBackoffTimer();\n        }, backoffOptions);\n        this.subchannelAddressString = subchannel_address_1.subchannelAddressToString(subchannelAddress);\n        if (options[\"grpc.enable_channelz\"] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.channelzRef = channelz_1.registerChannelzSubchannel(this.subchannelAddressString, ()=>this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Subchannel created\");\n        }\n        this.trace(\"Subchannel constructed with options \" + JSON.stringify(options, undefined, 2));\n    }\n    getChannelzInfo() {\n        return {\n            state: this.connectivityState,\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            children: this.childrenTracker.getChildLists(),\n            target: this.subchannelAddressString\n        };\n    }\n    getChannelzSocketInfo() {\n        var _a, _b, _c;\n        if (this.session === null) {\n            return null;\n        }\n        const sessionSocket = this.session.socket;\n        const remoteAddress = sessionSocket.remoteAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n        const localAddress = sessionSocket.localAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n        let tlsInfo;\n        if (this.session.encrypted) {\n            const tlsSocket = sessionSocket;\n            const cipherInfo = tlsSocket.getCipher();\n            const certificate = tlsSocket.getCertificate();\n            const peerCertificate = tlsSocket.getPeerCertificate();\n            tlsInfo = {\n                cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n                cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n                localCertificate: certificate && \"raw\" in certificate ? certificate.raw : null,\n                remoteCertificate: peerCertificate && \"raw\" in peerCertificate ? peerCertificate.raw : null\n            };\n        } else {\n            tlsInfo = null;\n        }\n        const socketInfo = {\n            remoteAddress: remoteAddress,\n            localAddress: localAddress,\n            security: tlsInfo,\n            remoteName: this.remoteName,\n            streamsStarted: this.streamTracker.callsStarted,\n            streamsSucceeded: this.streamTracker.callsSucceeded,\n            streamsFailed: this.streamTracker.callsFailed,\n            messagesSent: this.messagesSent,\n            messagesReceived: this.messagesReceived,\n            keepAlivesSent: this.keepalivesSent,\n            lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n            lastRemoteStreamCreatedTimestamp: null,\n            lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n            lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n            localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n            remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n        };\n        return socketInfo;\n    }\n    resetChannelzSocketInfo() {\n        if (!this.channelzEnabled) {\n            return;\n        }\n        if (this.channelzSocketRef) {\n            channelz_1.unregisterChannelzRef(this.channelzSocketRef);\n            this.childrenTracker.unrefChild(this.channelzSocketRef);\n            this.channelzSocketRef = null;\n        }\n        this.remoteName = null;\n        this.streamTracker = new channelz_1.ChannelzCallTracker();\n        this.keepalivesSent = 0;\n        this.messagesSent = 0;\n        this.messagesReceived = 0;\n        this.lastMessageSentTimestamp = null;\n        this.lastMessageReceivedTimestamp = null;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    refTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, \"subchannel_refcount\", \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    flowControlTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    internalsTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, \"subchannel_internals\", \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    keepaliveTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, \"keepalive\", \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    handleBackoffTimer() {\n        if (this.continueConnecting) {\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE\n            ], connectivity_state_1.ConnectivityState.CONNECTING);\n        } else {\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE\n            ], connectivity_state_1.ConnectivityState.IDLE);\n        }\n    }\n    /**\n     * Start a backoff timer with the current nextBackoff timeout\n     */ startBackoff() {\n        this.backoffTimeout.runOnce();\n    }\n    stopBackoff() {\n        this.backoffTimeout.stop();\n        this.backoffTimeout.reset();\n    }\n    sendPing() {\n        var _a, _b;\n        if (this.channelzEnabled) {\n            this.keepalivesSent += 1;\n        }\n        this.keepaliveTrace(\"Sending ping with timeout \" + this.keepaliveTimeoutMs + \"ms\");\n        this.keepaliveTimeoutId = setTimeout(()=>{\n            this.keepaliveTrace(\"Ping timeout passed without response\");\n            this.handleDisconnect();\n        }, this.keepaliveTimeoutMs);\n        (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        try {\n            this.session.ping((err, duration, payload)=>{\n                this.keepaliveTrace(\"Received ping response\");\n                clearTimeout(this.keepaliveTimeoutId);\n            });\n        } catch (e) {\n            /* If we fail to send a ping, the connection is no longer functional, so\n             * we should discard it. */ this.transitionToState([\n                connectivity_state_1.ConnectivityState.READY\n            ], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        }\n    }\n    startKeepalivePings() {\n        var _a, _b;\n        this.keepaliveIntervalId = setInterval(()=>{\n            this.sendPing();\n        }, this.keepaliveTimeMs);\n        (_b = (_a = this.keepaliveIntervalId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    /* Don't send a ping immediately because whatever caused us to start\n         * sending pings should also involve some network activity. */ }\n    /**\n     * Stop keepalive pings when terminating a connection. This discards the\n     * outstanding ping timeout, so it should not be called if the same\n     * connection will still be used.\n     */ stopKeepalivePings() {\n        clearInterval(this.keepaliveIntervalId);\n        clearTimeout(this.keepaliveTimeoutId);\n    }\n    createSession(proxyConnectionResult) {\n        var _a, _b, _c;\n        if (proxyConnectionResult.realTarget) {\n            this.remoteName = uri_parser_1.uriToString(proxyConnectionResult.realTarget);\n            this.trace(\"creating HTTP/2 session through proxy to \" + proxyConnectionResult.realTarget);\n        } else {\n            this.remoteName = null;\n            this.trace(\"creating HTTP/2 session\");\n        }\n        const targetAuthority = resolver_1.getDefaultAuthority((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);\n        let connectionOptions = this.credentials._getConnectionOptions() || {};\n        connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n        if (\"grpc-node.max_session_memory\" in this.options) {\n            connectionOptions.maxSessionMemory = this.options[\"grpc-node.max_session_memory\"];\n        } else {\n            /* By default, set a very large max session memory limit, to effectively\n             * disable enforcement of the limit. Some testing indicates that Node's\n             * behavior degrades badly when this limit is reached, so we solve that\n             * by disabling the check entirely. */ connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n        }\n        let addressScheme = \"http://\";\n        if (\"secureContext\" in connectionOptions) {\n            addressScheme = \"https://\";\n            // If provided, the value of grpc.ssl_target_name_override should be used\n            // to override the target hostname when checking server identity.\n            // This option is used for testing only.\n            if (this.options[\"grpc.ssl_target_name_override\"]) {\n                const sslTargetNameOverride = this.options[\"grpc.ssl_target_name_override\"];\n                connectionOptions.checkServerIdentity = (host, cert)=>{\n                    return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n                };\n                connectionOptions.servername = sslTargetNameOverride;\n            } else {\n                const authorityHostname = (_c = (_b = uri_parser_1.splitHostPort(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : \"localhost\";\n                // We want to always set servername to support SNI\n                connectionOptions.servername = authorityHostname;\n            }\n            if (proxyConnectionResult.socket) {\n                /* This is part of the workaround for\n                 * https://github.com/nodejs/node/issues/32922. Without that bug,\n                 * proxyConnectionResult.socket would always be a plaintext socket and\n                 * this would say\n                 * connectionOptions.socket = proxyConnectionResult.socket; */ connectionOptions.createConnection = (authority, option)=>{\n                    return proxyConnectionResult.socket;\n                };\n            }\n        } else {\n            /* In all but the most recent versions of Node, http2.connect does not use\n             * the options when establishing plaintext connections, so we need to\n             * establish that connection explicitly. */ connectionOptions.createConnection = (authority, option)=>{\n                if (proxyConnectionResult.socket) {\n                    return proxyConnectionResult.socket;\n                } else {\n                    /* net.NetConnectOpts is declared in a way that is more restrictive\n                     * than what net.connect will actually accept, so we use the type\n                     * assertion to work around that. */ return net.connect(this.subchannelAddress);\n                }\n            };\n        }\n        connectionOptions = Object.assign(Object.assign({}, connectionOptions), this.subchannelAddress);\n        /* http2.connect uses the options here:\n         * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n         * The spread operator overides earlier values with later ones, so any port\n         * or host values in the options will be used rather than any values extracted\n         * from the first argument. In addition, the path overrides the host and port,\n         * as documented for plaintext connections here:\n         * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n         * and for TLS connections here:\n         * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n         * earlier versions of Node, http2.connect passes these options to\n         * tls.connect but not net.connect, so in the insecure case we still need\n         * to set the createConnection option above to create the connection\n         * explicitly. We cannot do that in the TLS case because http2.connect\n         * passes necessary additional options to tls.connect.\n         * The first argument just needs to be parseable as a URL and the scheme\n         * determines whether the connection will be established over TLS or not.\n         */ const session = http2.connect(addressScheme + targetAuthority, connectionOptions);\n        this.session = session;\n        this.channelzSocketRef = channelz_1.registerChannelzSocket(this.subchannelAddressString, ()=>this.getChannelzSocketInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.childrenTracker.refChild(this.channelzSocketRef);\n        }\n        session.unref();\n        /* For all of these events, check if the session at the time of the event\n         * is the same one currently attached to this subchannel, to ensure that\n         * old events from previous connection attempts cannot cause invalid state\n         * transitions. */ session.once(\"connect\", ()=>{\n            if (this.session === session) {\n                this.transitionToState([\n                    connectivity_state_1.ConnectivityState.CONNECTING\n                ], connectivity_state_1.ConnectivityState.READY);\n            }\n        });\n        session.once(\"close\", ()=>{\n            if (this.session === session) {\n                this.trace(\"connection closed\");\n                this.transitionToState([\n                    connectivity_state_1.ConnectivityState.CONNECTING\n                ], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n                /* Transitioning directly to IDLE here should be OK because we are not\n                 * doing any backoff, because a connection was established at some\n                 * point */ this.transitionToState([\n                    connectivity_state_1.ConnectivityState.READY\n                ], connectivity_state_1.ConnectivityState.IDLE);\n            }\n        });\n        session.once(\"goaway\", (errorCode, lastStreamID, opaqueData)=>{\n            if (this.session === session) {\n                /* See the last paragraph of\n                 * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */ if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData.equals(tooManyPingsData)) {\n                    this.keepaliveTimeMs = Math.min(2 * this.keepaliveTimeMs, KEEPALIVE_MAX_TIME_MS);\n                    logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${uri_parser_1.uriToString(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTimeMs} ms`);\n                }\n                this.trace(\"connection closed by GOAWAY with code \" + errorCode);\n                this.transitionToState([\n                    connectivity_state_1.ConnectivityState.CONNECTING,\n                    connectivity_state_1.ConnectivityState.READY\n                ], connectivity_state_1.ConnectivityState.IDLE);\n            }\n        });\n        session.once(\"error\", (error)=>{\n            /* Do nothing here. Any error should also trigger a close event, which is\n             * where we want to handle that.  */ this.trace(\"connection closed with error \" + error.message);\n        });\n        if (logging.isTracerEnabled(TRACER_NAME)) {\n            session.on(\"remoteSettings\", (settings)=>{\n                this.trace(\"new settings received\" + (this.session !== session ? \" on the old connection\" : \"\") + \": \" + JSON.stringify(settings));\n            });\n            session.on(\"localSettings\", (settings)=>{\n                this.trace(\"local settings acknowledged by remote\" + (this.session !== session ? \" on the old connection\" : \"\") + \": \" + JSON.stringify(settings));\n            });\n        }\n    }\n    startConnectingInternal() {\n        var _a, _b;\n        /* Pass connection options through to the proxy so that it's able to\n         * upgrade it's connection to support tls if needed.\n         * This is a workaround for https://github.com/nodejs/node/issues/32922\n         * See https://github.com/grpc/grpc-node/pull/1369 for more info. */ const connectionOptions = this.credentials._getConnectionOptions() || {};\n        if (\"secureContext\" in connectionOptions) {\n            connectionOptions.ALPNProtocols = [\n                \"h2\"\n            ];\n            // If provided, the value of grpc.ssl_target_name_override should be used\n            // to override the target hostname when checking server identity.\n            // This option is used for testing only.\n            if (this.options[\"grpc.ssl_target_name_override\"]) {\n                const sslTargetNameOverride = this.options[\"grpc.ssl_target_name_override\"];\n                connectionOptions.checkServerIdentity = (host, cert)=>{\n                    return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n                };\n                connectionOptions.servername = sslTargetNameOverride;\n            } else {\n                if (\"grpc.http_connect_target\" in this.options) {\n                    /* This is more or less how servername will be set in createSession\n                     * if a connection is successfully established through the proxy.\n                     * If the proxy is not used, these connectionOptions are discarded\n                     * anyway */ const targetPath = resolver_1.getDefaultAuthority((_a = uri_parser_1.parseUri(this.options[\"grpc.http_connect_target\"])) !== null && _a !== void 0 ? _a : {\n                        path: \"localhost\"\n                    });\n                    const hostPort = uri_parser_1.splitHostPort(targetPath);\n                    connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;\n                }\n            }\n        }\n        http_proxy_1.getProxiedConnection(this.subchannelAddress, this.options, connectionOptions).then((result)=>{\n            this.createSession(result);\n        }, (reason)=>{\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.CONNECTING\n            ], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        });\n    }\n    handleDisconnect() {\n        this.transitionToState([\n            connectivity_state_1.ConnectivityState.READY\n        ], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        for (const listener of this.disconnectListeners.values()){\n            listener();\n        }\n    }\n    /**\n     * Initiate a state transition from any element of oldStates to the new\n     * state. If the current connectivityState is not in oldStates, do nothing.\n     * @param oldStates The set of states to transition from\n     * @param newState The state to transition to\n     * @returns True if the state changed, false otherwise\n     */ transitionToState(oldStates, newState) {\n        if (oldStates.indexOf(this.connectivityState) === -1) {\n            return false;\n        }\n        this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", connectivity_state_1.ConnectivityState[this.connectivityState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        }\n        const previousState = this.connectivityState;\n        this.connectivityState = newState;\n        switch(newState){\n            case connectivity_state_1.ConnectivityState.READY:\n                this.stopBackoff();\n                const session = this.session;\n                session.socket.once(\"close\", ()=>{\n                    if (this.session === session) {\n                        this.handleDisconnect();\n                    }\n                });\n                if (this.keepaliveWithoutCalls) {\n                    this.startKeepalivePings();\n                }\n                break;\n            case connectivity_state_1.ConnectivityState.CONNECTING:\n                this.startBackoff();\n                this.startConnectingInternal();\n                this.continueConnecting = false;\n                break;\n            case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n                if (this.session) {\n                    this.session.close();\n                }\n                this.session = null;\n                this.resetChannelzSocketInfo();\n                this.stopKeepalivePings();\n                /* If the backoff timer has already ended by the time we get to the\n                 * TRANSIENT_FAILURE state, we want to immediately transition out of\n                 * TRANSIENT_FAILURE as though the backoff timer is ending right now */ if (!this.backoffTimeout.isRunning()) {\n                    process.nextTick(()=>{\n                        this.handleBackoffTimer();\n                    });\n                }\n                break;\n            case connectivity_state_1.ConnectivityState.IDLE:\n                if (this.session) {\n                    this.session.close();\n                }\n                this.session = null;\n                this.resetChannelzSocketInfo();\n                this.stopKeepalivePings();\n                break;\n            default:\n                throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n        }\n        /* We use a shallow copy of the stateListeners array in case a listener\n         * is removed during this iteration */ for (const listener of [\n            ...this.stateListeners\n        ]){\n            listener(this, previousState, newState);\n        }\n        return true;\n    }\n    /**\n     * Check if the subchannel associated with zero calls and with zero channels.\n     * If so, shut it down.\n     */ checkBothRefcounts() {\n        /* If no calls, channels, or subchannel pools have any more references to\n         * this subchannel, we can be sure it will never be used again. */ if (this.callRefcount === 0 && this.refcount === 0) {\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace(\"CT_INFO\", \"Shutting down\");\n            }\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.CONNECTING,\n                connectivity_state_1.ConnectivityState.READY\n            ], connectivity_state_1.ConnectivityState.IDLE);\n            if (this.channelzEnabled) {\n                channelz_1.unregisterChannelzRef(this.channelzRef);\n            }\n        }\n    }\n    callRef() {\n        this.refTrace(\"callRefcount \" + this.callRefcount + \" -> \" + (this.callRefcount + 1));\n        if (this.callRefcount === 0) {\n            if (this.session) {\n                this.session.ref();\n            }\n            this.backoffTimeout.ref();\n            if (!this.keepaliveWithoutCalls) {\n                this.startKeepalivePings();\n            }\n        }\n        this.callRefcount += 1;\n    }\n    callUnref() {\n        this.refTrace(\"callRefcount \" + this.callRefcount + \" -> \" + (this.callRefcount - 1));\n        this.callRefcount -= 1;\n        if (this.callRefcount === 0) {\n            if (this.session) {\n                this.session.unref();\n            }\n            this.backoffTimeout.unref();\n            if (!this.keepaliveWithoutCalls) {\n                clearInterval(this.keepaliveIntervalId);\n            }\n            this.checkBothRefcounts();\n        }\n    }\n    ref() {\n        this.refTrace(\"refcount \" + this.refcount + \" -> \" + (this.refcount + 1));\n        this.refcount += 1;\n    }\n    unref() {\n        this.refTrace(\"refcount \" + this.refcount + \" -> \" + (this.refcount - 1));\n        this.refcount -= 1;\n        this.checkBothRefcounts();\n    }\n    unrefIfOneRef() {\n        if (this.refcount === 1) {\n            this.unref();\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Start a stream on the current session with the given `metadata` as headers\n     * and then attach it to the `callStream`. Must only be called if the\n     * subchannel's current connectivity state is READY.\n     * @param metadata\n     * @param callStream\n     */ startCallStream(metadata, callStream, extraFilters) {\n        const headers = metadata.toHttp2Headers();\n        headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();\n        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n        headers[HTTP2_HEADER_CONTENT_TYPE] = \"application/grpc\";\n        headers[HTTP2_HEADER_METHOD] = \"POST\";\n        headers[HTTP2_HEADER_PATH] = callStream.getMethod();\n        headers[HTTP2_HEADER_TE] = \"trailers\";\n        let http2Stream;\n        /* In theory, if an error is thrown by session.request because session has\n         * become unusable (e.g. because it has received a goaway), this subchannel\n         * should soon see the corresponding close or goaway event anyway and leave\n         * READY. But we have seen reports that this does not happen\n         * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n         * so for defense in depth, we just discard the session when we see an\n         * error here.\n         */ try {\n            http2Stream = this.session.request(headers);\n        } catch (e) {\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.READY\n            ], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n            throw e;\n        }\n        let headersString = \"\";\n        for (const header of Object.keys(headers)){\n            headersString += \"\t\t\" + header + \": \" + headers[header] + \"\\n\";\n        }\n        logging.trace(constants_1.LogVerbosity.DEBUG, \"call_stream\", \"Starting stream [\" + callStream.getCallNumber() + \"] on subchannel \" + \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" with headers\\n\" + headersString);\n        this.flowControlTrace(\"local window size: \" + this.session.state.localWindowSize + \" remote window size: \" + this.session.state.remoteWindowSize);\n        const streamSession = this.session;\n        this.internalsTrace(\"session.closed=\" + streamSession.closed + \" session.destroyed=\" + streamSession.destroyed + \" session.socket.destroyed=\" + streamSession.socket.destroyed);\n        let statsTracker;\n        if (this.channelzEnabled) {\n            this.callTracker.addCallStarted();\n            callStream.addStatusWatcher((status)=>{\n                if (status.code === constants_1.Status.OK) {\n                    this.callTracker.addCallSucceeded();\n                } else {\n                    this.callTracker.addCallFailed();\n                }\n            });\n            this.streamTracker.addCallStarted();\n            callStream.addStreamEndWatcher((success)=>{\n                if (streamSession === this.session) {\n                    if (success) {\n                        this.streamTracker.addCallSucceeded();\n                    } else {\n                        this.streamTracker.addCallFailed();\n                    }\n                }\n            });\n            statsTracker = {\n                addMessageSent: ()=>{\n                    this.messagesSent += 1;\n                    this.lastMessageSentTimestamp = new Date();\n                },\n                addMessageReceived: ()=>{\n                    this.messagesReceived += 1;\n                }\n            };\n        } else {\n            statsTracker = {\n                addMessageSent: ()=>{},\n                addMessageReceived: ()=>{}\n            };\n        }\n        callStream.attachHttp2Stream(http2Stream, this, extraFilters, statsTracker);\n    }\n    /**\n     * If the subchannel is currently IDLE, start connecting and switch to the\n     * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n     * the next time it would transition to IDLE, start connecting again instead.\n     * Otherwise, do nothing.\n     */ startConnecting() {\n        /* First, try to transition from IDLE to connecting. If that doesn't happen\n         * because the state is not currently IDLE, check if it is\n         * TRANSIENT_FAILURE, and if so indicate that it should go back to\n         * connecting after the backoff timer ends. Otherwise do nothing */ if (!this.transitionToState([\n            connectivity_state_1.ConnectivityState.IDLE\n        ], connectivity_state_1.ConnectivityState.CONNECTING)) {\n            if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                this.continueConnecting = true;\n            }\n        }\n    }\n    /**\n     * Get the subchannel's current connectivity state.\n     */ getConnectivityState() {\n        return this.connectivityState;\n    }\n    /**\n     * Add a listener function to be called whenever the subchannel's\n     * connectivity state changes.\n     * @param listener\n     */ addConnectivityStateListener(listener) {\n        this.stateListeners.push(listener);\n    }\n    /**\n     * Remove a listener previously added with `addConnectivityStateListener`\n     * @param listener A reference to a function previously passed to\n     *     `addConnectivityStateListener`\n     */ removeConnectivityStateListener(listener) {\n        const listenerIndex = this.stateListeners.indexOf(listener);\n        if (listenerIndex > -1) {\n            this.stateListeners.splice(listenerIndex, 1);\n        }\n    }\n    addDisconnectListener(listener) {\n        this.disconnectListeners.add(listener);\n    }\n    removeDisconnectListener(listener) {\n        this.disconnectListeners.delete(listener);\n    }\n    /**\n     * Reset the backoff timeout, and immediately start connecting if in backoff.\n     */ resetBackoff() {\n        this.backoffTimeout.reset();\n        this.transitionToState([\n            connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE\n        ], connectivity_state_1.ConnectivityState.CONNECTING);\n    }\n    getAddress() {\n        return this.subchannelAddressString;\n    }\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    getRealSubchannel() {\n        return this;\n    }\n}\nexports.Subchannel = Subchannel; //# sourceMappingURL=subchannel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0JBQWtCLEdBQUcsS0FBSztBQUMxQixNQUFNRyxRQUFRQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUM3QixNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQyxnQkFBSztBQUMzQixNQUFNRSx1QkFBdUJGLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNRyxvQkFBb0JILG1CQUFPQSxDQUFDLDBGQUFtQjtBQUNyRCxNQUFNSSxhQUFhSixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNSyxVQUFVTCxtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNTSxjQUFjTixtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNTyxlQUFlUCxtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNUSxNQUFNUixtQkFBT0EsQ0FBQyxnQkFBSztBQUN6QixNQUFNUyxlQUFlVCxtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNVSx1QkFBdUJWLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNVyxhQUFhWCxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNWSxnQkFBZ0JaLDBHQUFxQztBQUMzRCxNQUFNYyxjQUFjO0FBQ3BCLE1BQU1DLDJCQUEyQjtBQUNqQyxNQUFNQyx5QkFBeUI7QUFDL0IsTUFBTUMscUJBQXFCO0FBQzNCLE1BQU1DLHFCQUFxQjtBQUMzQixNQUFNQyxpQkFBaUI7QUFDdkIsTUFBTUMsaUJBQWlCO0FBQ3ZCOzttQkFFbUIsR0FDbkIsTUFBTUMsd0JBQXdCLENBQUUsTUFBSyxFQUFDO0FBQ3RDLE1BQU1DLHVCQUF1QjtBQUM3QixNQUFNLEVBQUVDLHNCQUFzQixFQUFFQyx5QkFBeUIsRUFBRUMsbUJBQW1C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SUFBSSxDQUFDaEwsY0FBYyxDQUFDbU8sSUFBSSxDQUFDbkQ7SUFDN0I7SUFDQTs7OztLQUlDLEdBQ0RvRCxnQ0FBZ0NwRCxRQUFRLEVBQUU7UUFDdEMsTUFBTXFELGdCQUFnQixJQUFJLENBQUNyTyxjQUFjLENBQUNvTCxPQUFPLENBQUNKO1FBQ2xELElBQUlxRCxnQkFBZ0IsQ0FBQyxHQUFHO1lBQ3BCLElBQUksQ0FBQ3JPLGNBQWMsQ0FBQ3NPLE1BQU0sQ0FBQ0QsZUFBZTtRQUM5QztJQUNKO0lBQ0FFLHNCQUFzQnZELFFBQVEsRUFBRTtRQUM1QixJQUFJLENBQUMvSyxtQkFBbUIsQ0FBQ3VPLEdBQUcsQ0FBQ3hEO0lBQ2pDO0lBQ0F5RCx5QkFBeUJ6RCxRQUFRLEVBQUU7UUFDL0IsSUFBSSxDQUFDL0ssbUJBQW1CLENBQUN5TyxNQUFNLENBQUMxRDtJQUNwQztJQUNBOztLQUVDLEdBQ0QyRCxlQUFlO1FBQ1gsSUFBSSxDQUFDM00sY0FBYyxDQUFDZ0YsS0FBSztRQUN6QixJQUFJLENBQUNQLGlCQUFpQixDQUFDO1lBQUN2SixxQkFBcUIwQyxpQkFBaUIsQ0FBQzhHLGlCQUFpQjtTQUFDLEVBQUV4SixxQkFBcUIwQyxpQkFBaUIsQ0FBQytHLFVBQVU7SUFDeEk7SUFDQWlJLGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQ3pNLHVCQUF1QjtJQUN2QztJQUNBME0saUJBQWlCO1FBQ2IsT0FBTyxJQUFJLENBQUN0TSxXQUFXO0lBQzNCO0lBQ0F1TSxvQkFBb0I7UUFDaEIsT0FBTyxJQUFJO0lBQ2Y7QUFDSjtBQUNBbFMsa0JBQWtCLEdBQUdFLFlBQ3JCLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FzaG1pdHQtZ3VwdGEvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC5qcz84ODc2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN1YmNoYW5uZWwgPSB2b2lkIDA7XG5jb25zdCBodHRwMiA9IHJlcXVpcmUoXCJodHRwMlwiKTtcbmNvbnN0IHRsc18xID0gcmVxdWlyZShcInRsc1wiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgYmFja29mZl90aW1lb3V0XzEgPSByZXF1aXJlKFwiLi9iYWNrb2ZmLXRpbWVvdXRcIik7XG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgaHR0cF9wcm94eV8xID0gcmVxdWlyZShcIi4vaHR0cF9wcm94eVwiKTtcbmNvbnN0IG5ldCA9IHJlcXVpcmUoXCJuZXRcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCBjaGFubmVsel8xID0gcmVxdWlyZShcIi4vY2hhbm5lbHpcIik7XG5jb25zdCBjbGllbnRWZXJzaW9uID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3N1YmNoYW5uZWwnO1xuY29uc3QgRkxPV19DT05UUk9MX1RSQUNFUl9OQU1FID0gJ3N1YmNoYW5uZWxfZmxvd2N0cmwnO1xuY29uc3QgTUlOX0NPTk5FQ1RfVElNRU9VVF9NUyA9IDIwMDAwO1xuY29uc3QgSU5JVElBTF9CQUNLT0ZGX01TID0gMTAwMDtcbmNvbnN0IEJBQ0tPRkZfTVVMVElQTElFUiA9IDEuNjtcbmNvbnN0IE1BWF9CQUNLT0ZGX01TID0gMTIwMDAwO1xuY29uc3QgQkFDS09GRl9KSVRURVIgPSAwLjI7XG4vKiBzZXRJbnRlcnZhbCBhbmQgc2V0VGltZW91dCBvbmx5IGFjY2VwdCBzaWduZWQgMzIgYml0IGludGVnZXJzLiBKUyBkb2Vzbid0XG4gKiBoYXZlIGEgY29uc3RhbnQgZm9yIHRoZSBtYXggc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLCBzbyB0aGlzIGlzIGEgc2ltcGxlIHdheVxuICogdG8gY2FsY3VsYXRlIGl0ICovXG5jb25zdCBLRUVQQUxJVkVfTUFYX1RJTUVfTVMgPSB+KDEgPDwgMzEpO1xuY29uc3QgS0VFUEFMSVZFX1RJTUVPVVRfTVMgPSAyMDAwMDtcbmNvbnN0IHsgSFRUUDJfSEVBREVSX0FVVEhPUklUWSwgSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRSwgSFRUUDJfSEVBREVSX01FVEhPRCwgSFRUUDJfSEVBREVSX1BBVEgsIEhUVFAyX0hFQURFUl9URSwgSFRUUDJfSEVBREVSX1VTRVJfQUdFTlQsIH0gPSBodHRwMi5jb25zdGFudHM7XG4vKipcbiAqIEdldCBhIG51bWJlciB1bmlmb3JtbHkgYXQgcmFuZG9tIGluIHRoZSByYW5nZSBbbWluLCBtYXgpXG4gKiBAcGFyYW0gbWluXG4gKiBAcGFyYW0gbWF4XG4gKi9cbmZ1bmN0aW9uIHVuaWZvcm1SYW5kb20obWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xufVxuY29uc3QgdG9vTWFueVBpbmdzRGF0YSA9IEJ1ZmZlci5mcm9tKCd0b29fbWFueV9waW5ncycsICdhc2NpaScpO1xuY2xhc3MgU3ViY2hhbm5lbCB7XG4gICAgLyoqXG4gICAgICogQSBjbGFzcyByZXByZXNlbnRpbmcgYSBjb25uZWN0aW9uIHRvIGEgc2luZ2xlIGJhY2tlbmQuXG4gICAgICogQHBhcmFtIGNoYW5uZWxUYXJnZXQgVGhlIHRhcmdldCBzdHJpbmcgZm9yIHRoZSBjaGFubmVsIGFzIGEgd2hvbGVcbiAgICAgKiBAcGFyYW0gc3ViY2hhbm5lbEFkZHJlc3MgVGhlIGFkZHJlc3MgZm9yIHRoZSBiYWNrZW5kIHRoYXQgdGhpcyBzdWJjaGFubmVsXG4gICAgICogICAgIHdpbGwgY29ubmVjdCB0b1xuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBjaGFubmVsIG9wdGlvbnMsIHBsdXMgYW55IHNwZWNpZmljIHN1YmNoYW5uZWwgb3B0aW9uc1xuICAgICAqICAgICBmb3IgdGhpcyBzdWJjaGFubmVsXG4gICAgICogQHBhcmFtIGNyZWRlbnRpYWxzIFRoZSBjaGFubmVsIGNyZWRlbnRpYWxzIHVzZWQgdG8gZXN0YWJsaXNoIHRoaXNcbiAgICAgKiAgICAgY29ubmVjdGlvblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxUYXJnZXQsIHN1YmNoYW5uZWxBZGRyZXNzLCBvcHRpb25zLCBjcmVkZW50aWFscykge1xuICAgICAgICB0aGlzLmNoYW5uZWxUYXJnZXQgPSBjaGFubmVsVGFyZ2V0O1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzID0gc3ViY2hhbm5lbEFkZHJlc3M7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzdWJjaGFubmVsJ3MgY3VycmVudCBjb25uZWN0aXZpdHkgc3RhdGUuIEludmFyaWFudDogYHNlc3Npb25gID09PSBgbnVsbGBcbiAgICAgICAgICogaWYgYW5kIG9ubHkgaWYgYGNvbm5lY3Rpdml0eVN0YXRlYCBpcyBJRExFIG9yIFRSQU5TSUVOVF9GQUlMVVJFLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdW5kZXJseWluZyBodHRwMiBzZXNzaW9uIHVzZWQgdG8gbWFrZSByZXF1ZXN0cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgc3ViY2hhbm5lbCBzaG91bGQgdHJhbnNpdGlvbiBmcm9tIFRSQU5TSUVOVF9GQUlMVVJFIHRvXG4gICAgICAgICAqIENPTk5FQ1RJTkcgaW5zdGVhZCBvZiBJRExFIHdoZW4gdGhlIGJhY2tvZmYgdGltZW91dCBlbmRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250aW51ZUNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgY29ubmVjdGl2aXR5XG4gICAgICAgICAqIHN0YXRlIGNoYW5nZXMuIFdpbGwgYmUgbW9kaWZpZWQgYnkgYGFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXJgIGFuZFxuICAgICAgICAgKiBgcmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSB1bmRlcmx5aW5nXG4gICAgICAgICAqIHNvY2tldCBkaXNjb25uZWN0cy4gVXNlZCBmb3IgZW5kaW5nIGFjdGl2ZSBjYWxscyB3aXRoIGFuIFVOQVZBSUxBQkxFXG4gICAgICAgICAqIHN0YXR1cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzY29ubmVjdExpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbW91bnQgb2YgdGltZSBpbiBiZXR3ZWVuIHNlbmRpbmcgcGluZ3NcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZU1zID0gS0VFUEFMSVZFX01BWF9USU1FX01TO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgZm9yIGFuIGFja25vd2xlZGdlbWVudCBhZnRlciBzZW5kaW5nIGEgcGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lb3V0TXMgPSBLRUVQQUxJVkVfVElNRU9VVF9NUztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGtlZXBhbGl2ZSBwaW5ncyBzaG91bGQgYmUgc2VudCB3aXRob3V0IGFueSBhY3RpdmUgY2FsbHNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMua2VlcGFsaXZlV2l0aG91dENhbGxzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFja3MgY2FsbHMgd2l0aCByZWZlcmVuY2VzIHRvIHRoaXMgc3ViY2hhbm5lbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWxsUmVmY291bnQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJhY2tzIGNoYW5uZWxzIGFuZCBzdWJjaGFubmVsIHBvb2xzIHdpdGggcmVmZXJlbmNlcyB0byB0aGlzIHN1YmNoYW5uZWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVmY291bnQgPSAwO1xuICAgICAgICAvLyBDaGFubmVseiBpbmZvXG4gICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYWxsVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNoaWxkcmVuVHJhY2tlcigpO1xuICAgICAgICAvLyBDaGFubmVseiBzb2NrZXQgaW5mb1xuICAgICAgICB0aGlzLmNoYW5uZWx6U29ja2V0UmVmID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhlIHJlbW90ZSBzZXJ2ZXIsIGlmIGl0IGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgc3ViY2hhbm5lbFxuICAgICAgICAgKiBhZGRyZXNzLCBpLmUuIGlmIGNvbm5lY3RpbmcgdGhyb3VnaCBhbiBIVFRQIENPTk5FQ1QgcHJveHkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbW90ZU5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyKCk7XG4gICAgICAgIHRoaXMua2VlcGFsaXZlc1NlbnQgPSAwO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzU2VudCA9IDA7XG4gICAgICAgIHRoaXMubWVzc2FnZXNSZWNlaXZlZCA9IDA7XG4gICAgICAgIHRoaXMubGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgLy8gQnVpbGQgdXNlci1hZ2VudCBzdHJpbmcuXG4gICAgICAgIHRoaXMudXNlckFnZW50ID0gW1xuICAgICAgICAgICAgb3B0aW9uc1snZ3JwYy5wcmltYXJ5X3VzZXJfYWdlbnQnXSxcbiAgICAgICAgICAgIGBncnBjLW5vZGUtanMvJHtjbGllbnRWZXJzaW9ufWAsXG4gICAgICAgICAgICBvcHRpb25zWydncnBjLnNlY29uZGFyeV91c2VyX2FnZW50J10sXG4gICAgICAgIF1cbiAgICAgICAgICAgIC5maWx0ZXIoKGUpID0+IGUpXG4gICAgICAgICAgICAuam9pbignICcpOyAvLyByZW1vdmUgZmFsc2V5IHZhbHVlcyBmaXJzdFxuICAgICAgICBpZiAoJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZU1zID0gb3B0aW9uc1snZ3JwYy5rZWVwYWxpdmVfdGltZV9tcyddO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZ3JwYy5rZWVwYWxpdmVfdGltZW91dF9tcycgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lb3V0TXMgPSBvcHRpb25zWydncnBjLmtlZXBhbGl2ZV90aW1lb3V0X21zJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdncnBjLmtlZXBhbGl2ZV9wZXJtaXRfd2l0aG91dF9jYWxscycgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMgPVxuICAgICAgICAgICAgICAgIG9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3Blcm1pdF93aXRob3V0X2NhbGxzJ10gPT09IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2VlcGFsaXZlSW50ZXJ2YWxJZCA9IHNldFRpbWVvdXQoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMua2VlcGFsaXZlSW50ZXJ2YWxJZCk7XG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7IH0sIDApO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQpO1xuICAgICAgICBjb25zdCBiYWNrb2ZmT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGluaXRpYWxEZWxheTogb3B0aW9uc1snZ3JwYy5pbml0aWFsX3JlY29ubmVjdF9iYWNrb2ZmX21zJ10sXG4gICAgICAgICAgICBtYXhEZWxheTogb3B0aW9uc1snZ3JwYy5tYXhfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dCA9IG5ldyBiYWNrb2ZmX3RpbWVvdXRfMS5CYWNrb2ZmVGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUJhY2tvZmZUaW1lcigpO1xuICAgICAgICB9LCBiYWNrb2ZmT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgPSBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKHN1YmNoYW5uZWxBZGRyZXNzKTtcbiAgICAgICAgaWYgKG9wdGlvbnNbJ2dycGMuZW5hYmxlX2NoYW5uZWx6J10gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFubmVselRyYWNlID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpUcmFjZSgpO1xuICAgICAgICB0aGlzLmNoYW5uZWx6UmVmID0gY2hhbm5lbHpfMS5yZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbCh0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nLCAoKSA9PiB0aGlzLmdldENoYW5uZWx6SW5mbygpLCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ1N1YmNoYW5uZWwgY3JlYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2UoJ1N1YmNoYW5uZWwgY29uc3RydWN0ZWQgd2l0aCBvcHRpb25zICcgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zLCB1bmRlZmluZWQsIDIpKTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbHpJbmZvKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdGU6IHRoaXMuY29ubmVjdGl2aXR5U3RhdGUsXG4gICAgICAgICAgICB0cmFjZTogdGhpcy5jaGFubmVselRyYWNlLFxuICAgICAgICAgICAgY2FsbFRyYWNrZXI6IHRoaXMuY2FsbFRyYWNrZXIsXG4gICAgICAgICAgICBjaGlsZHJlbjogdGhpcy5jaGlsZHJlblRyYWNrZXIuZ2V0Q2hpbGRMaXN0cygpLFxuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldENoYW5uZWx6U29ja2V0SW5mbygpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlc3Npb25Tb2NrZXQgPSB0aGlzLnNlc3Npb24uc29ja2V0O1xuICAgICAgICBjb25zdCByZW1vdGVBZGRyZXNzID0gc2Vzc2lvblNvY2tldC5yZW1vdGVBZGRyZXNzID8gc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyhzZXNzaW9uU29ja2V0LnJlbW90ZUFkZHJlc3MsIHNlc3Npb25Tb2NrZXQucmVtb3RlUG9ydCkgOiBudWxsO1xuICAgICAgICBjb25zdCBsb2NhbEFkZHJlc3MgPSBzZXNzaW9uU29ja2V0LmxvY2FsQWRkcmVzcyA/IHN1YmNoYW5uZWxfYWRkcmVzc18xLnN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3Moc2Vzc2lvblNvY2tldC5sb2NhbEFkZHJlc3MsIHNlc3Npb25Tb2NrZXQubG9jYWxQb3J0KSA6IG51bGw7XG4gICAgICAgIGxldCB0bHNJbmZvO1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLmVuY3J5cHRlZCkge1xuICAgICAgICAgICAgY29uc3QgdGxzU29ja2V0ID0gc2Vzc2lvblNvY2tldDtcbiAgICAgICAgICAgIGNvbnN0IGNpcGhlckluZm8gPSB0bHNTb2NrZXQuZ2V0Q2lwaGVyKCk7XG4gICAgICAgICAgICBjb25zdCBjZXJ0aWZpY2F0ZSA9IHRsc1NvY2tldC5nZXRDZXJ0aWZpY2F0ZSgpO1xuICAgICAgICAgICAgY29uc3QgcGVlckNlcnRpZmljYXRlID0gdGxzU29ja2V0LmdldFBlZXJDZXJ0aWZpY2F0ZSgpO1xuICAgICAgICAgICAgdGxzSW5mbyA9IHtcbiAgICAgICAgICAgICAgICBjaXBoZXJTdWl0ZVN0YW5kYXJkTmFtZTogKF9hID0gY2lwaGVySW5mby5zdGFuZGFyZE5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwsXG4gICAgICAgICAgICAgICAgY2lwaGVyU3VpdGVPdGhlck5hbWU6IGNpcGhlckluZm8uc3RhbmRhcmROYW1lID8gbnVsbCA6IGNpcGhlckluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICBsb2NhbENlcnRpZmljYXRlOiAoY2VydGlmaWNhdGUgJiYgJ3JhdycgaW4gY2VydGlmaWNhdGUpID8gY2VydGlmaWNhdGUucmF3IDogbnVsbCxcbiAgICAgICAgICAgICAgICByZW1vdGVDZXJ0aWZpY2F0ZTogKHBlZXJDZXJ0aWZpY2F0ZSAmJiAncmF3JyBpbiBwZWVyQ2VydGlmaWNhdGUpID8gcGVlckNlcnRpZmljYXRlLnJhdyA6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0bHNJbmZvID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb2NrZXRJbmZvID0ge1xuICAgICAgICAgICAgcmVtb3RlQWRkcmVzczogcmVtb3RlQWRkcmVzcyxcbiAgICAgICAgICAgIGxvY2FsQWRkcmVzczogbG9jYWxBZGRyZXNzLFxuICAgICAgICAgICAgc2VjdXJpdHk6IHRsc0luZm8sXG4gICAgICAgICAgICByZW1vdGVOYW1lOiB0aGlzLnJlbW90ZU5hbWUsXG4gICAgICAgICAgICBzdHJlYW1zU3RhcnRlZDogdGhpcy5zdHJlYW1UcmFja2VyLmNhbGxzU3RhcnRlZCxcbiAgICAgICAgICAgIHN0cmVhbXNTdWNjZWVkZWQ6IHRoaXMuc3RyZWFtVHJhY2tlci5jYWxsc1N1Y2NlZWRlZCxcbiAgICAgICAgICAgIHN0cmVhbXNGYWlsZWQ6IHRoaXMuc3RyZWFtVHJhY2tlci5jYWxsc0ZhaWxlZCxcbiAgICAgICAgICAgIG1lc3NhZ2VzU2VudDogdGhpcy5tZXNzYWdlc1NlbnQsXG4gICAgICAgICAgICBtZXNzYWdlc1JlY2VpdmVkOiB0aGlzLm1lc3NhZ2VzUmVjZWl2ZWQsXG4gICAgICAgICAgICBrZWVwQWxpdmVzU2VudDogdGhpcy5rZWVwYWxpdmVzU2VudCxcbiAgICAgICAgICAgIGxhc3RMb2NhbFN0cmVhbUNyZWF0ZWRUaW1lc3RhbXA6IHRoaXMuc3RyZWFtVHJhY2tlci5sYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXAsXG4gICAgICAgICAgICBsYXN0UmVtb3RlU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcDogdGhpcy5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAsXG4gICAgICAgICAgICBsYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wOiB0aGlzLmxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAsXG4gICAgICAgICAgICBsb2NhbEZsb3dDb250cm9sV2luZG93OiAoX2IgPSB0aGlzLnNlc3Npb24uc3RhdGUubG9jYWxXaW5kb3dTaXplKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsLFxuICAgICAgICAgICAgcmVtb3RlRmxvd0NvbnRyb2xXaW5kb3c6IChfYyA9IHRoaXMuc2Vzc2lvbi5zdGF0ZS5yZW1vdGVXaW5kb3dTaXplKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzb2NrZXRJbmZvO1xuICAgIH1cbiAgICByZXNldENoYW5uZWx6U29ja2V0SW5mbygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6U29ja2V0UmVmKSB7XG4gICAgICAgICAgICBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZih0aGlzLmNoYW5uZWx6U29ja2V0UmVmKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyLnVucmVmQ2hpbGQodGhpcy5jaGFubmVselNvY2tldFJlZik7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6U29ja2V0UmVmID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW90ZU5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyKCk7XG4gICAgICAgIHRoaXMua2VlcGFsaXZlc1NlbnQgPSAwO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzU2VudCA9IDA7XG4gICAgICAgIHRoaXMubWVzc2FnZXNSZWNlaXZlZCA9IDA7XG4gICAgICAgIHRoaXMubGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wID0gbnVsbDtcbiAgICB9XG4gICAgdHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICcoJyArIHRoaXMuY2hhbm5lbHpSZWYuaWQgKyAnKSAnICsgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyArICcgJyArIHRleHQpO1xuICAgIH1cbiAgICByZWZUcmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAnc3ViY2hhbm5lbF9yZWZjb3VudCcsICcoJyArIHRoaXMuY2hhbm5lbHpSZWYuaWQgKyAnKSAnICsgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyArICcgJyArIHRleHQpO1xuICAgIH1cbiAgICBmbG93Q29udHJvbFRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIEZMT1dfQ09OVFJPTF9UUkFDRVJfTkFNRSwgJygnICsgdGhpcy5jaGFubmVselJlZi5pZCArICcpICcgKyB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICsgJyAnICsgdGV4dCk7XG4gICAgfVxuICAgIGludGVybmFsc1RyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdzdWJjaGFubmVsX2ludGVybmFscycsICcoJyArIHRoaXMuY2hhbm5lbHpSZWYuaWQgKyAnKSAnICsgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyArICcgJyArIHRleHQpO1xuICAgIH1cbiAgICBrZWVwYWxpdmVUcmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAna2VlcGFsaXZlJywgJygnICsgdGhpcy5jaGFubmVselJlZi5pZCArICcpICcgKyB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICsgJyAnICsgdGV4dCk7XG4gICAgfVxuICAgIGhhbmRsZUJhY2tvZmZUaW1lcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGludWVDb25uZWN0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkVdLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBhIGJhY2tvZmYgdGltZXIgd2l0aCB0aGUgY3VycmVudCBuZXh0QmFja29mZiB0aW1lb3V0XG4gICAgICovXG4gICAgc3RhcnRCYWNrb2ZmKCkge1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnJ1bk9uY2UoKTtcbiAgICB9XG4gICAgc3RvcEJhY2tvZmYoKSB7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQuc3RvcCgpO1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnJlc2V0KCk7XG4gICAgfVxuICAgIHNlbmRQaW5nKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlc1NlbnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdTZW5kaW5nIHBpbmcgd2l0aCB0aW1lb3V0ICcgKyB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyArICdtcycpO1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnUGluZyB0aW1lb3V0IHBhc3NlZCB3aXRob3V0IHJlc3BvbnNlJyk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSwgdGhpcy5rZWVwYWxpdmVUaW1lb3V0TXMpO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRJZCkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5waW5nKChlcnIsIGR1cmF0aW9uLCBwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnUmVjZWl2ZWQgcGluZyByZXNwb25zZScpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmtlZXBhbGl2ZVRpbWVvdXRJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyogSWYgd2UgZmFpbCB0byBzZW5kIGEgcGluZywgdGhlIGNvbm5lY3Rpb24gaXMgbm8gbG9uZ2VyIGZ1bmN0aW9uYWwsIHNvXG4gICAgICAgICAgICAgKiB3ZSBzaG91bGQgZGlzY2FyZCBpdC4gKi9cbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0S2VlcGFsaXZlUGluZ3MoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMua2VlcGFsaXZlSW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2VuZFBpbmcoKTtcbiAgICAgICAgfSwgdGhpcy5rZWVwYWxpdmVUaW1lTXMpO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmtlZXBhbGl2ZUludGVydmFsSWQpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIC8qIERvbid0IHNlbmQgYSBwaW5nIGltbWVkaWF0ZWx5IGJlY2F1c2Ugd2hhdGV2ZXIgY2F1c2VkIHVzIHRvIHN0YXJ0XG4gICAgICAgICAqIHNlbmRpbmcgcGluZ3Mgc2hvdWxkIGFsc28gaW52b2x2ZSBzb21lIG5ldHdvcmsgYWN0aXZpdHkuICovXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3Aga2VlcGFsaXZlIHBpbmdzIHdoZW4gdGVybWluYXRpbmcgYSBjb25uZWN0aW9uLiBUaGlzIGRpc2NhcmRzIHRoZVxuICAgICAqIG91dHN0YW5kaW5nIHBpbmcgdGltZW91dCwgc28gaXQgc2hvdWxkIG5vdCBiZSBjYWxsZWQgaWYgdGhlIHNhbWVcbiAgICAgKiBjb25uZWN0aW9uIHdpbGwgc3RpbGwgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBzdG9wS2VlcGFsaXZlUGluZ3MoKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5rZWVwYWxpdmVJbnRlcnZhbElkKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMua2VlcGFsaXZlVGltZW91dElkKTtcbiAgICB9XG4gICAgY3JlYXRlU2Vzc2lvbihwcm94eUNvbm5lY3Rpb25SZXN1bHQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmIChwcm94eUNvbm5lY3Rpb25SZXN1bHQucmVhbFRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdGVOYW1lID0gdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHByb3h5Q29ubmVjdGlvblJlc3VsdC5yZWFsVGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2NyZWF0aW5nIEhUVFAvMiBzZXNzaW9uIHRocm91Z2ggcHJveHkgdG8gJyArIHByb3h5Q29ubmVjdGlvblJlc3VsdC5yZWFsVGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3RlTmFtZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdjcmVhdGluZyBIVFRQLzIgc2Vzc2lvbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldEF1dGhvcml0eSA9IHJlc29sdmVyXzEuZ2V0RGVmYXVsdEF1dGhvcml0eSgoX2EgPSBwcm94eUNvbm5lY3Rpb25SZXN1bHQucmVhbFRhcmdldCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5jaGFubmVsVGFyZ2V0KTtcbiAgICAgICAgbGV0IGNvbm5lY3Rpb25PcHRpb25zID0gdGhpcy5jcmVkZW50aWFscy5fZ2V0Q29ubmVjdGlvbk9wdGlvbnMoKSB8fCB7fTtcbiAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMubWF4U2VuZEhlYWRlckJsb2NrTGVuZ3RoID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIGlmICgnZ3JwYy1ub2RlLm1heF9zZXNzaW9uX21lbW9yeScgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5tYXhTZXNzaW9uTWVtb3J5ID0gdGhpcy5vcHRpb25zWydncnBjLW5vZGUubWF4X3Nlc3Npb25fbWVtb3J5J107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBCeSBkZWZhdWx0LCBzZXQgYSB2ZXJ5IGxhcmdlIG1heCBzZXNzaW9uIG1lbW9yeSBsaW1pdCwgdG8gZWZmZWN0aXZlbHlcbiAgICAgICAgICAgICAqIGRpc2FibGUgZW5mb3JjZW1lbnQgb2YgdGhlIGxpbWl0LiBTb21lIHRlc3RpbmcgaW5kaWNhdGVzIHRoYXQgTm9kZSdzXG4gICAgICAgICAgICAgKiBiZWhhdmlvciBkZWdyYWRlcyBiYWRseSB3aGVuIHRoaXMgbGltaXQgaXMgcmVhY2hlZCwgc28gd2Ugc29sdmUgdGhhdFxuICAgICAgICAgICAgICogYnkgZGlzYWJsaW5nIHRoZSBjaGVjayBlbnRpcmVseS4gKi9cbiAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLm1heFNlc3Npb25NZW1vcnkgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWRkcmVzc1NjaGVtZSA9ICdodHRwOi8vJztcbiAgICAgICAgaWYgKCdzZWN1cmVDb250ZXh0JyBpbiBjb25uZWN0aW9uT3B0aW9ucykge1xuICAgICAgICAgICAgYWRkcmVzc1NjaGVtZSA9ICdodHRwczovLyc7XG4gICAgICAgICAgICAvLyBJZiBwcm92aWRlZCwgdGhlIHZhbHVlIG9mIGdycGMuc3NsX3RhcmdldF9uYW1lX292ZXJyaWRlIHNob3VsZCBiZSB1c2VkXG4gICAgICAgICAgICAvLyB0byBvdmVycmlkZSB0aGUgdGFyZ2V0IGhvc3RuYW1lIHdoZW4gY2hlY2tpbmcgc2VydmVyIGlkZW50aXR5LlxuICAgICAgICAgICAgLy8gVGhpcyBvcHRpb24gaXMgdXNlZCBmb3IgdGVzdGluZyBvbmx5LlxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc1snZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUnXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNzbFRhcmdldE5hbWVPdmVycmlkZSA9IHRoaXMub3B0aW9uc1snZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUnXTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5ID0gKGhvc3QsIGNlcnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRsc18xLmNoZWNrU2VydmVySWRlbnRpdHkoc3NsVGFyZ2V0TmFtZU92ZXJyaWRlLCBjZXJ0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLnNlcnZlcm5hbWUgPSBzc2xUYXJnZXROYW1lT3ZlcnJpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdXRob3JpdHlIb3N0bmFtZSA9IChfYyA9IChfYiA9IHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KHRhcmdldEF1dGhvcml0eSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ob3N0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnbG9jYWxob3N0JztcbiAgICAgICAgICAgICAgICAvLyBXZSB3YW50IHRvIGFsd2F5cyBzZXQgc2VydmVybmFtZSB0byBzdXBwb3J0IFNOSVxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLnNlcnZlcm5hbWUgPSBhdXRob3JpdHlIb3N0bmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm94eUNvbm5lY3Rpb25SZXN1bHQuc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgLyogVGhpcyBpcyBwYXJ0IG9mIHRoZSB3b3JrYXJvdW5kIGZvclxuICAgICAgICAgICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzI5MjIuIFdpdGhvdXQgdGhhdCBidWcsXG4gICAgICAgICAgICAgICAgICogcHJveHlDb25uZWN0aW9uUmVzdWx0LnNvY2tldCB3b3VsZCBhbHdheXMgYmUgYSBwbGFpbnRleHQgc29ja2V0IGFuZFxuICAgICAgICAgICAgICAgICAqIHRoaXMgd291bGQgc2F5XG4gICAgICAgICAgICAgICAgICogY29ubmVjdGlvbk9wdGlvbnMuc29ja2V0ID0gcHJveHlDb25uZWN0aW9uUmVzdWx0LnNvY2tldDsgKi9cbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5jcmVhdGVDb25uZWN0aW9uID0gKGF1dGhvcml0eSwgb3B0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm94eUNvbm5lY3Rpb25SZXN1bHQuc29ja2V0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBJbiBhbGwgYnV0IHRoZSBtb3N0IHJlY2VudCB2ZXJzaW9ucyBvZiBOb2RlLCBodHRwMi5jb25uZWN0IGRvZXMgbm90IHVzZVxuICAgICAgICAgICAgICogdGhlIG9wdGlvbnMgd2hlbiBlc3RhYmxpc2hpbmcgcGxhaW50ZXh0IGNvbm5lY3Rpb25zLCBzbyB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAgKiBlc3RhYmxpc2ggdGhhdCBjb25uZWN0aW9uIGV4cGxpY2l0bHkuICovXG4gICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5jcmVhdGVDb25uZWN0aW9uID0gKGF1dGhvcml0eSwgb3B0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3h5Q29ubmVjdGlvblJlc3VsdC5zb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5Q29ubmVjdGlvblJlc3VsdC5zb2NrZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKiBuZXQuTmV0Q29ubmVjdE9wdHMgaXMgZGVjbGFyZWQgaW4gYSB3YXkgdGhhdCBpcyBtb3JlIHJlc3RyaWN0aXZlXG4gICAgICAgICAgICAgICAgICAgICAqIHRoYW4gd2hhdCBuZXQuY29ubmVjdCB3aWxsIGFjdHVhbGx5IGFjY2VwdCwgc28gd2UgdXNlIHRoZSB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAqIGFzc2VydGlvbiB0byB3b3JrIGFyb3VuZCB0aGF0LiAqL1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV0LmNvbm5lY3QodGhpcy5zdWJjaGFubmVsQWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0aW9uT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29ubmVjdGlvbk9wdGlvbnMpLCB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzKTtcbiAgICAgICAgLyogaHR0cDIuY29ubmVjdCB1c2VzIHRoZSBvcHRpb25zIGhlcmU6XG4gICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iLzcwYzMyYTZkMTkwZTJiNWQ3YjlmZjlkNWI2YTQ1OWQxNGU4YjdkNTkvbGliL2ludGVybmFsL2h0dHAyL2NvcmUuanMjTDMwMjgtTDMwMzZcbiAgICAgICAgICogVGhlIHNwcmVhZCBvcGVyYXRvciBvdmVyaWRlcyBlYXJsaWVyIHZhbHVlcyB3aXRoIGxhdGVyIG9uZXMsIHNvIGFueSBwb3J0XG4gICAgICAgICAqIG9yIGhvc3QgdmFsdWVzIGluIHRoZSBvcHRpb25zIHdpbGwgYmUgdXNlZCByYXRoZXIgdGhhbiBhbnkgdmFsdWVzIGV4dHJhY3RlZFxuICAgICAgICAgKiBmcm9tIHRoZSBmaXJzdCBhcmd1bWVudC4gSW4gYWRkaXRpb24sIHRoZSBwYXRoIG92ZXJyaWRlcyB0aGUgaG9zdCBhbmQgcG9ydCxcbiAgICAgICAgICogYXMgZG9jdW1lbnRlZCBmb3IgcGxhaW50ZXh0IGNvbm5lY3Rpb25zIGhlcmU6XG4gICAgICAgICAqIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvbmV0Lmh0bWwjbmV0X3NvY2tldF9jb25uZWN0X29wdGlvbnNfY29ubmVjdGxpc3RlbmVyXG4gICAgICAgICAqIGFuZCBmb3IgVExTIGNvbm5lY3Rpb25zIGhlcmU6XG4gICAgICAgICAqIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdGxzLmh0bWwjdGxzX3Rsc19jb25uZWN0X29wdGlvbnNfY2FsbGJhY2suIEluXG4gICAgICAgICAqIGVhcmxpZXIgdmVyc2lvbnMgb2YgTm9kZSwgaHR0cDIuY29ubmVjdCBwYXNzZXMgdGhlc2Ugb3B0aW9ucyB0b1xuICAgICAgICAgKiB0bHMuY29ubmVjdCBidXQgbm90IG5ldC5jb25uZWN0LCBzbyBpbiB0aGUgaW5zZWN1cmUgY2FzZSB3ZSBzdGlsbCBuZWVkXG4gICAgICAgICAqIHRvIHNldCB0aGUgY3JlYXRlQ29ubmVjdGlvbiBvcHRpb24gYWJvdmUgdG8gY3JlYXRlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAqIGV4cGxpY2l0bHkuIFdlIGNhbm5vdCBkbyB0aGF0IGluIHRoZSBUTFMgY2FzZSBiZWNhdXNlIGh0dHAyLmNvbm5lY3RcbiAgICAgICAgICogcGFzc2VzIG5lY2Vzc2FyeSBhZGRpdGlvbmFsIG9wdGlvbnMgdG8gdGxzLmNvbm5lY3QuXG4gICAgICAgICAqIFRoZSBmaXJzdCBhcmd1bWVudCBqdXN0IG5lZWRzIHRvIGJlIHBhcnNlYWJsZSBhcyBhIFVSTCBhbmQgdGhlIHNjaGVtZVxuICAgICAgICAgKiBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvbm5lY3Rpb24gd2lsbCBiZSBlc3RhYmxpc2hlZCBvdmVyIFRMUyBvciBub3QuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBzZXNzaW9uID0gaHR0cDIuY29ubmVjdChhZGRyZXNzU2NoZW1lICsgdGFyZ2V0QXV0aG9yaXR5LCBjb25uZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIHRoaXMuY2hhbm5lbHpTb2NrZXRSZWYgPSBjaGFubmVsel8xLnJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQodGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZywgKCkgPT4gdGhpcy5nZXRDaGFubmVselNvY2tldEluZm8oKSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyLnJlZkNoaWxkKHRoaXMuY2hhbm5lbHpTb2NrZXRSZWYpO1xuICAgICAgICB9XG4gICAgICAgIHNlc3Npb24udW5yZWYoKTtcbiAgICAgICAgLyogRm9yIGFsbCBvZiB0aGVzZSBldmVudHMsIGNoZWNrIGlmIHRoZSBzZXNzaW9uIGF0IHRoZSB0aW1lIG9mIHRoZSBldmVudFxuICAgICAgICAgKiBpcyB0aGUgc2FtZSBvbmUgY3VycmVudGx5IGF0dGFjaGVkIHRvIHRoaXMgc3ViY2hhbm5lbCwgdG8gZW5zdXJlIHRoYXRcbiAgICAgICAgICogb2xkIGV2ZW50cyBmcm9tIHByZXZpb3VzIGNvbm5lY3Rpb24gYXR0ZW1wdHMgY2Fubm90IGNhdXNlIGludmFsaWQgc3RhdGVcbiAgICAgICAgICogdHJhbnNpdGlvbnMuICovXG4gICAgICAgIHNlc3Npb24ub25jZSgnY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlc3Npb24gPT09IHNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2Vzc2lvbi5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlc3Npb24gPT09IHNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdjb25uZWN0aW9uIGNsb3NlZCcpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkddLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSk7XG4gICAgICAgICAgICAgICAgLyogVHJhbnNpdGlvbmluZyBkaXJlY3RseSB0byBJRExFIGhlcmUgc2hvdWxkIGJlIE9LIGJlY2F1c2Ugd2UgYXJlIG5vdFxuICAgICAgICAgICAgICAgICAqIGRvaW5nIGFueSBiYWNrb2ZmLCBiZWNhdXNlIGEgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQgYXQgc29tZVxuICAgICAgICAgICAgICAgICAqIHBvaW50ICovXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFldLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNlc3Npb24ub25jZSgnZ29hd2F5JywgKGVycm9yQ29kZSwgbGFzdFN0cmVhbUlELCBvcGFxdWVEYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXNzaW9uID09PSBzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgLyogU2VlIHRoZSBsYXN0IHBhcmFncmFwaCBvZlxuICAgICAgICAgICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL3Byb3Bvc2FsL2Jsb2IvbWFzdGVyL0E4LWNsaWVudC1zaWRlLWtlZXBhbGl2ZS5tZCNiYXNpYy1rZWVwYWxpdmUgKi9cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JDb2RlID09PSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9FTkhBTkNFX1lPVVJfQ0FMTSAmJlxuICAgICAgICAgICAgICAgICAgICBvcGFxdWVEYXRhLmVxdWFscyh0b29NYW55UGluZ3NEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVNcyA9IE1hdGgubWluKDIgKiB0aGlzLmtlZXBhbGl2ZVRpbWVNcywgS0VFUEFMSVZFX01BWF9USU1FX01TKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2luZy5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCBgQ29ubmVjdGlvbiB0byAke3VyaV9wYXJzZXJfMS51cmlUb1N0cmluZyh0aGlzLmNoYW5uZWxUYXJnZXQpfSBhdCAke3RoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmd9IHJlamVjdGVkIGJ5IHNlcnZlciBiZWNhdXNlIG9mIGV4Y2VzcyBwaW5ncy4gSW5jcmVhc2luZyBwaW5nIGludGVydmFsIHRvICR7dGhpcy5rZWVwYWxpdmVUaW1lTXN9IG1zYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ2Nvbm5lY3Rpb24gY2xvc2VkIGJ5IEdPQVdBWSB3aXRoIGNvZGUgJyArXG4gICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORywgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFldLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNlc3Npb24ub25jZSgnZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8qIERvIG5vdGhpbmcgaGVyZS4gQW55IGVycm9yIHNob3VsZCBhbHNvIHRyaWdnZXIgYSBjbG9zZSBldmVudCwgd2hpY2ggaXNcbiAgICAgICAgICAgICAqIHdoZXJlIHdlIHdhbnQgdG8gaGFuZGxlIHRoYXQuICAqL1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnY29ubmVjdGlvbiBjbG9zZWQgd2l0aCBlcnJvciAnICtcbiAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsb2dnaW5nLmlzVHJhY2VyRW5hYmxlZChUUkFDRVJfTkFNRSkpIHtcbiAgICAgICAgICAgIHNlc3Npb24ub24oJ3JlbW90ZVNldHRpbmdzJywgKHNldHRpbmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnbmV3IHNldHRpbmdzIHJlY2VpdmVkJyArXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnNlc3Npb24gIT09IHNlc3Npb24gPyAnIG9uIHRoZSBvbGQgY29ubmVjdGlvbicgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAnOiAnICtcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2Vzc2lvbi5vbignbG9jYWxTZXR0aW5ncycsIChzZXR0aW5ncykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ2xvY2FsIHNldHRpbmdzIGFja25vd2xlZGdlZCBieSByZW1vdGUnICtcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc2Vzc2lvbiAhPT0gc2Vzc2lvbiA/ICcgb24gdGhlIG9sZCBjb25uZWN0aW9uJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICc6ICcgK1xuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShzZXR0aW5ncykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRDb25uZWN0aW5nSW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIC8qIFBhc3MgY29ubmVjdGlvbiBvcHRpb25zIHRocm91Z2ggdG8gdGhlIHByb3h5IHNvIHRoYXQgaXQncyBhYmxlIHRvXG4gICAgICAgICAqIHVwZ3JhZGUgaXQncyBjb25uZWN0aW9uIHRvIHN1cHBvcnQgdGxzIGlmIG5lZWRlZC5cbiAgICAgICAgICogVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzI5MjJcbiAgICAgICAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMtbm9kZS9wdWxsLzEzNjkgZm9yIG1vcmUgaW5mby4gKi9cbiAgICAgICAgY29uc3QgY29ubmVjdGlvbk9wdGlvbnMgPSB0aGlzLmNyZWRlbnRpYWxzLl9nZXRDb25uZWN0aW9uT3B0aW9ucygpIHx8IHt9O1xuICAgICAgICBpZiAoJ3NlY3VyZUNvbnRleHQnIGluIGNvbm5lY3Rpb25PcHRpb25zKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5BTFBOUHJvdG9jb2xzID0gWydoMiddO1xuICAgICAgICAgICAgLy8gSWYgcHJvdmlkZWQsIHRoZSB2YWx1ZSBvZiBncnBjLnNzbF90YXJnZXRfbmFtZV9vdmVycmlkZSBzaG91bGQgYmUgdXNlZFxuICAgICAgICAgICAgLy8gdG8gb3ZlcnJpZGUgdGhlIHRhcmdldCBob3N0bmFtZSB3aGVuIGNoZWNraW5nIHNlcnZlciBpZGVudGl0eS5cbiAgICAgICAgICAgIC8vIFRoaXMgb3B0aW9uIGlzIHVzZWQgZm9yIHRlc3Rpbmcgb25seS5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNbJ2dycGMuc3NsX3RhcmdldF9uYW1lX292ZXJyaWRlJ10pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzc2xUYXJnZXROYW1lT3ZlcnJpZGUgPSB0aGlzLm9wdGlvbnNbJ2dycGMuc3NsX3RhcmdldF9uYW1lX292ZXJyaWRlJ107XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eSA9IChob3N0LCBjZXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0bHNfMS5jaGVja1NlcnZlcklkZW50aXR5KHNzbFRhcmdldE5hbWVPdmVycmlkZSwgY2VydCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5zZXJ2ZXJuYW1lID0gc3NsVGFyZ2V0TmFtZU92ZXJyaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCdncnBjLmh0dHBfY29ubmVjdF90YXJnZXQnIGluIHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAvKiBUaGlzIGlzIG1vcmUgb3IgbGVzcyBob3cgc2VydmVybmFtZSB3aWxsIGJlIHNldCBpbiBjcmVhdGVTZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAqIGlmIGEgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsbHkgZXN0YWJsaXNoZWQgdGhyb3VnaCB0aGUgcHJveHkuXG4gICAgICAgICAgICAgICAgICAgICAqIElmIHRoZSBwcm94eSBpcyBub3QgdXNlZCwgdGhlc2UgY29ubmVjdGlvbk9wdGlvbnMgYXJlIGRpc2NhcmRlZFxuICAgICAgICAgICAgICAgICAgICAgKiBhbnl3YXkgKi9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0UGF0aCA9IHJlc29sdmVyXzEuZ2V0RGVmYXVsdEF1dGhvcml0eSgoX2EgPSB1cmlfcGFyc2VyXzEucGFyc2VVcmkodGhpcy5vcHRpb25zWydncnBjLmh0dHBfY29ubmVjdF90YXJnZXQnXSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICdsb2NhbGhvc3QnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG9zdFBvcnQgPSB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCh0YXJnZXRQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuc2VydmVybmFtZSA9IChfYiA9IGhvc3RQb3J0ID09PSBudWxsIHx8IGhvc3RQb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBob3N0UG9ydC5ob3N0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0YXJnZXRQYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBodHRwX3Byb3h5XzEuZ2V0UHJveGllZENvbm5lY3Rpb24odGhpcy5zdWJjaGFubmVsQWRkcmVzcywgdGhpcy5vcHRpb25zLCBjb25uZWN0aW9uT3B0aW9ucykudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVNlc3Npb24ocmVzdWx0KTtcbiAgICAgICAgfSwgKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElOR10sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZURpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpO1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuZGlzY29ubmVjdExpc3RlbmVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZSBhIHN0YXRlIHRyYW5zaXRpb24gZnJvbSBhbnkgZWxlbWVudCBvZiBvbGRTdGF0ZXMgdG8gdGhlIG5ld1xuICAgICAqIHN0YXRlLiBJZiB0aGUgY3VycmVudCBjb25uZWN0aXZpdHlTdGF0ZSBpcyBub3QgaW4gb2xkU3RhdGVzLCBkbyBub3RoaW5nLlxuICAgICAqIEBwYXJhbSBvbGRTdGF0ZXMgVGhlIHNldCBvZiBzdGF0ZXMgdG8gdHJhbnNpdGlvbiBmcm9tXG4gICAgICogQHBhcmFtIG5ld1N0YXRlIFRoZSBzdGF0ZSB0byB0cmFuc2l0aW9uIHRvXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc3RhdGUgY2hhbmdlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgdHJhbnNpdGlvblRvU3RhdGUob2xkU3RhdGVzLCBuZXdTdGF0ZSkge1xuICAgICAgICBpZiAob2xkU3RhdGVzLmluZGV4T2YodGhpcy5jb25uZWN0aXZpdHlTdGF0ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmNvbm5lY3Rpdml0eVN0YXRlXSArXG4gICAgICAgICAgICAnIC0+ICcgK1xuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbbmV3U3RhdGVdKTtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmNvbm5lY3Rpdml0eVN0YXRlXSArICcgLT4gJyArIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHRoaXMuY29ubmVjdGl2aXR5U3RhdGU7XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgc3dpdGNoIChuZXdTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWTpcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BCYWNrb2ZmKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnNvY2tldC5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbiA9PT0gc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydEtlZXBhbGl2ZVBpbmdzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRCYWNrb2ZmKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydENvbm5lY3RpbmdJbnRlcm5hbCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldENoYW5uZWx6U29ja2V0SW5mbygpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcEtlZXBhbGl2ZVBpbmdzKCk7XG4gICAgICAgICAgICAgICAgLyogSWYgdGhlIGJhY2tvZmYgdGltZXIgaGFzIGFscmVhZHkgZW5kZWQgYnkgdGhlIHRpbWUgd2UgZ2V0IHRvIHRoZVxuICAgICAgICAgICAgICAgICAqIFRSQU5TSUVOVF9GQUlMVVJFIHN0YXRlLCB3ZSB3YW50IHRvIGltbWVkaWF0ZWx5IHRyYW5zaXRpb24gb3V0IG9mXG4gICAgICAgICAgICAgICAgICogVFJBTlNJRU5UX0ZBSUxVUkUgYXMgdGhvdWdoIHRoZSBiYWNrb2ZmIHRpbWVyIGlzIGVuZGluZyByaWdodCBub3cgKi9cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYmFja29mZlRpbWVvdXQuaXNSdW5uaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUJhY2tvZmZUaW1lcigpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Q2hhbm5lbHpTb2NrZXRJbmZvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wS2VlcGFsaXZlUGluZ3MoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXRlOiB1bmtub3duIENvbm5lY3Rpdml0eVN0YXRlICR7bmV3U3RhdGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogV2UgdXNlIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSBzdGF0ZUxpc3RlbmVycyBhcnJheSBpbiBjYXNlIGEgbGlzdGVuZXJcbiAgICAgICAgICogaXMgcmVtb3ZlZCBkdXJpbmcgdGhpcyBpdGVyYXRpb24gKi9cbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBbLi4udGhpcy5zdGF0ZUxpc3RlbmVyc10pIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKHRoaXMsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHN1YmNoYW5uZWwgYXNzb2NpYXRlZCB3aXRoIHplcm8gY2FsbHMgYW5kIHdpdGggemVybyBjaGFubmVscy5cbiAgICAgKiBJZiBzbywgc2h1dCBpdCBkb3duLlxuICAgICAqL1xuICAgIGNoZWNrQm90aFJlZmNvdW50cygpIHtcbiAgICAgICAgLyogSWYgbm8gY2FsbHMsIGNoYW5uZWxzLCBvciBzdWJjaGFubmVsIHBvb2xzIGhhdmUgYW55IG1vcmUgcmVmZXJlbmNlcyB0b1xuICAgICAgICAgKiB0aGlzIHN1YmNoYW5uZWwsIHdlIGNhbiBiZSBzdXJlIGl0IHdpbGwgbmV2ZXIgYmUgdXNlZCBhZ2Fpbi4gKi9cbiAgICAgICAgaWYgKHRoaXMuY2FsbFJlZmNvdW50ID09PSAwICYmIHRoaXMucmVmY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdTaHV0dGluZyBkb3duJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYodGhpcy5jaGFubmVselJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsbFJlZigpIHtcbiAgICAgICAgdGhpcy5yZWZUcmFjZSgnY2FsbFJlZmNvdW50ICcgK1xuICAgICAgICAgICAgdGhpcy5jYWxsUmVmY291bnQgK1xuICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgICh0aGlzLmNhbGxSZWZjb3VudCArIDEpKTtcbiAgICAgICAgaWYgKHRoaXMuY2FsbFJlZmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5yZWYoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0S2VlcGFsaXZlUGluZ3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxSZWZjb3VudCArPSAxO1xuICAgIH1cbiAgICBjYWxsVW5yZWYoKSB7XG4gICAgICAgIHRoaXMucmVmVHJhY2UoJ2NhbGxSZWZjb3VudCAnICtcbiAgICAgICAgICAgIHRoaXMuY2FsbFJlZmNvdW50ICtcbiAgICAgICAgICAgICcgLT4gJyArXG4gICAgICAgICAgICAodGhpcy5jYWxsUmVmY291bnQgLSAxKSk7XG4gICAgICAgIHRoaXMuY2FsbFJlZmNvdW50IC09IDE7XG4gICAgICAgIGlmICh0aGlzLmNhbGxSZWZjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi51bnJlZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC51bnJlZigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscykge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5rZWVwYWxpdmVJbnRlcnZhbElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hlY2tCb3RoUmVmY291bnRzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmKCkge1xuICAgICAgICB0aGlzLnJlZlRyYWNlKCdyZWZjb3VudCAnICtcbiAgICAgICAgICAgIHRoaXMucmVmY291bnQgK1xuICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgICh0aGlzLnJlZmNvdW50ICsgMSkpO1xuICAgICAgICB0aGlzLnJlZmNvdW50ICs9IDE7XG4gICAgfVxuICAgIHVucmVmKCkge1xuICAgICAgICB0aGlzLnJlZlRyYWNlKCdyZWZjb3VudCAnICtcbiAgICAgICAgICAgIHRoaXMucmVmY291bnQgK1xuICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgICh0aGlzLnJlZmNvdW50IC0gMSkpO1xuICAgICAgICB0aGlzLnJlZmNvdW50IC09IDE7XG4gICAgICAgIHRoaXMuY2hlY2tCb3RoUmVmY291bnRzKCk7XG4gICAgfVxuICAgIHVucmVmSWZPbmVSZWYoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZmNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnVucmVmKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGEgc3RyZWFtIG9uIHRoZSBjdXJyZW50IHNlc3Npb24gd2l0aCB0aGUgZ2l2ZW4gYG1ldGFkYXRhYCBhcyBoZWFkZXJzXG4gICAgICogYW5kIHRoZW4gYXR0YWNoIGl0IHRvIHRoZSBgY2FsbFN0cmVhbWAuIE11c3Qgb25seSBiZSBjYWxsZWQgaWYgdGhlXG4gICAgICogc3ViY2hhbm5lbCdzIGN1cnJlbnQgY29ubmVjdGl2aXR5IHN0YXRlIGlzIFJFQURZLlxuICAgICAqIEBwYXJhbSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSBjYWxsU3RyZWFtXG4gICAgICovXG4gICAgc3RhcnRDYWxsU3RyZWFtKG1ldGFkYXRhLCBjYWxsU3RyZWFtLCBleHRyYUZpbHRlcnMpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG1ldGFkYXRhLnRvSHR0cDJIZWFkZXJzKCk7XG4gICAgICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX0FVVEhPUklUWV0gPSBjYWxsU3RyZWFtLmdldEhvc3QoKTtcbiAgICAgICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfVVNFUl9BR0VOVF0gPSB0aGlzLnVzZXJBZ2VudDtcbiAgICAgICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFXSA9ICdhcHBsaWNhdGlvbi9ncnBjJztcbiAgICAgICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfTUVUSE9EXSA9ICdQT1NUJztcbiAgICAgICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfUEFUSF0gPSBjYWxsU3RyZWFtLmdldE1ldGhvZCgpO1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9URV0gPSAndHJhaWxlcnMnO1xuICAgICAgICBsZXQgaHR0cDJTdHJlYW07XG4gICAgICAgIC8qIEluIHRoZW9yeSwgaWYgYW4gZXJyb3IgaXMgdGhyb3duIGJ5IHNlc3Npb24ucmVxdWVzdCBiZWNhdXNlIHNlc3Npb24gaGFzXG4gICAgICAgICAqIGJlY29tZSB1bnVzYWJsZSAoZS5nLiBiZWNhdXNlIGl0IGhhcyByZWNlaXZlZCBhIGdvYXdheSksIHRoaXMgc3ViY2hhbm5lbFxuICAgICAgICAgKiBzaG91bGQgc29vbiBzZWUgdGhlIGNvcnJlc3BvbmRpbmcgY2xvc2Ugb3IgZ29hd2F5IGV2ZW50IGFueXdheSBhbmQgbGVhdmVcbiAgICAgICAgICogUkVBRFkuIEJ1dCB3ZSBoYXZlIHNlZW4gcmVwb3J0cyB0aGF0IHRoaXMgZG9lcyBub3QgaGFwcGVuXG4gICAgICAgICAqIChodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlYXBpcy9ub2RlanMtZmlyZXN0b3JlL2lzc3Vlcy8xMDIzI2lzc3VlY29tbWVudC02NTMyMDQwOTYpXG4gICAgICAgICAqIHNvIGZvciBkZWZlbnNlIGluIGRlcHRoLCB3ZSBqdXN0IGRpc2NhcmQgdGhlIHNlc3Npb24gd2hlbiB3ZSBzZWUgYW5cbiAgICAgICAgICogZXJyb3IgaGVyZS5cbiAgICAgICAgICovXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBodHRwMlN0cmVhbSA9IHRoaXMuc2Vzc2lvbi5yZXF1ZXN0KGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhlYWRlcnNTdHJpbmcgPSAnJztcbiAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgICAgICAgIGhlYWRlcnNTdHJpbmcgKz0gJ1xcdFxcdCcgKyBoZWFkZXIgKyAnOiAnICsgaGVhZGVyc1toZWFkZXJdICsgJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdjYWxsX3N0cmVhbScsICdTdGFydGluZyBzdHJlYW0gWycgKyBjYWxsU3RyZWFtLmdldENhbGxOdW1iZXIoKSArICddIG9uIHN1YmNoYW5uZWwgJyArXG4gICAgICAgICAgICAnKCcgKyB0aGlzLmNoYW5uZWx6UmVmLmlkICsgJykgJyArXG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICcgd2l0aCBoZWFkZXJzXFxuJyArXG4gICAgICAgICAgICBoZWFkZXJzU3RyaW5nKTtcbiAgICAgICAgdGhpcy5mbG93Q29udHJvbFRyYWNlKCdsb2NhbCB3aW5kb3cgc2l6ZTogJyArXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uc3RhdGUubG9jYWxXaW5kb3dTaXplICtcbiAgICAgICAgICAgICcgcmVtb3RlIHdpbmRvdyBzaXplOiAnICtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zdGF0ZS5yZW1vdGVXaW5kb3dTaXplKTtcbiAgICAgICAgY29uc3Qgc3RyZWFtU2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5pbnRlcm5hbHNUcmFjZSgnc2Vzc2lvbi5jbG9zZWQ9JyArXG4gICAgICAgICAgICBzdHJlYW1TZXNzaW9uLmNsb3NlZCArXG4gICAgICAgICAgICAnIHNlc3Npb24uZGVzdHJveWVkPScgK1xuICAgICAgICAgICAgc3RyZWFtU2Vzc2lvbi5kZXN0cm95ZWQgK1xuICAgICAgICAgICAgJyBzZXNzaW9uLnNvY2tldC5kZXN0cm95ZWQ9JyArXG4gICAgICAgICAgICBzdHJlYW1TZXNzaW9uLnNvY2tldC5kZXN0cm95ZWQpO1xuICAgICAgICBsZXQgc3RhdHNUcmFja2VyO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbFN0YXJ0ZWQoKTtcbiAgICAgICAgICAgIGNhbGxTdHJlYW0uYWRkU3RhdHVzV2F0Y2hlcihzdGF0dXMgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbFN1Y2NlZWRlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbFN0YXJ0ZWQoKTtcbiAgICAgICAgICAgIGNhbGxTdHJlYW0uYWRkU3RyZWFtRW5kV2F0Y2hlcihzdWNjZXNzID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtU2Vzc2lvbiA9PT0gdGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbFN1Y2NlZWRlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1UcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdHNUcmFja2VyID0ge1xuICAgICAgICAgICAgICAgIGFkZE1lc3NhZ2VTZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZXNTZW50ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFkZE1lc3NhZ2VSZWNlaXZlZDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VzUmVjZWl2ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdHNUcmFja2VyID0ge1xuICAgICAgICAgICAgICAgIGFkZE1lc3NhZ2VTZW50OiAoKSA9PiB7IH0sXG4gICAgICAgICAgICAgICAgYWRkTWVzc2FnZVJlY2VpdmVkOiAoKSA9PiB7IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FsbFN0cmVhbS5hdHRhY2hIdHRwMlN0cmVhbShodHRwMlN0cmVhbSwgdGhpcywgZXh0cmFGaWx0ZXJzLCBzdGF0c1RyYWNrZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgc3ViY2hhbm5lbCBpcyBjdXJyZW50bHkgSURMRSwgc3RhcnQgY29ubmVjdGluZyBhbmQgc3dpdGNoIHRvIHRoZVxuICAgICAqIENPTk5FQ1RJTkcgc3RhdGUuIElmIHRoZSBzdWJjaGFubmVsIGlzIGN1cnJlbnQgaW4gVFJBTlNJRU5UX0ZBSUxVUkUsXG4gICAgICogdGhlIG5leHQgdGltZSBpdCB3b3VsZCB0cmFuc2l0aW9uIHRvIElETEUsIHN0YXJ0IGNvbm5lY3RpbmcgYWdhaW4gaW5zdGVhZC5cbiAgICAgKiBPdGhlcndpc2UsIGRvIG5vdGhpbmcuXG4gICAgICovXG4gICAgc3RhcnRDb25uZWN0aW5nKCkge1xuICAgICAgICAvKiBGaXJzdCwgdHJ5IHRvIHRyYW5zaXRpb24gZnJvbSBJRExFIHRvIGNvbm5lY3RpbmcuIElmIHRoYXQgZG9lc24ndCBoYXBwZW5cbiAgICAgICAgICogYmVjYXVzZSB0aGUgc3RhdGUgaXMgbm90IGN1cnJlbnRseSBJRExFLCBjaGVjayBpZiBpdCBpc1xuICAgICAgICAgKiBUUkFOU0lFTlRfRkFJTFVSRSwgYW5kIGlmIHNvIGluZGljYXRlIHRoYXQgaXQgc2hvdWxkIGdvIGJhY2sgdG9cbiAgICAgICAgICogY29ubmVjdGluZyBhZnRlciB0aGUgYmFja29mZiB0aW1lciBlbmRzLiBPdGhlcndpc2UgZG8gbm90aGluZyAqL1xuICAgICAgICBpZiAoIXRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEVdLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZUNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3ViY2hhbm5lbCdzIGN1cnJlbnQgY29ubmVjdGl2aXR5IHN0YXRlLlxuICAgICAqL1xuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aXZpdHlTdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBzdWJjaGFubmVsJ3NcbiAgICAgKiBjb25uZWN0aXZpdHkgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGxpc3RlbmVyIHByZXZpb3VzbHkgYWRkZWQgd2l0aCBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgQSByZWZlcmVuY2UgdG8gYSBmdW5jdGlvbiBwcmV2aW91c2x5IHBhc3NlZCB0b1xuICAgICAqICAgICBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcbiAgICAgKi9cbiAgICByZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVySW5kZXggPSB0aGlzLnN0YXRlTGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICBpZiAobGlzdGVuZXJJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlTGlzdGVuZXJzLnNwbGljZShsaXN0ZW5lckluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGREaXNjb25uZWN0TGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0TGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJlbW92ZURpc2Nvbm5lY3RMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGJhY2tvZmYgdGltZW91dCwgYW5kIGltbWVkaWF0ZWx5IHN0YXJ0IGNvbm5lY3RpbmcgaWYgaW4gYmFja29mZi5cbiAgICAgKi9cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucmVzZXQoKTtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkVdLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HKTtcbiAgICB9XG4gICAgZ2V0QWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmc7XG4gICAgfVxuICAgIGdldENoYW5uZWx6UmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVselJlZjtcbiAgICB9XG4gICAgZ2V0UmVhbFN1YmNoYW5uZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuU3ViY2hhbm5lbCA9IFN1YmNoYW5uZWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJjaGFubmVsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlN1YmNoYW5uZWwiLCJodHRwMiIsInJlcXVpcmUiLCJ0bHNfMSIsImNvbm5lY3Rpdml0eV9zdGF0ZV8xIiwiYmFja29mZl90aW1lb3V0XzEiLCJyZXNvbHZlcl8xIiwibG9nZ2luZyIsImNvbnN0YW50c18xIiwiaHR0cF9wcm94eV8xIiwibmV0IiwidXJpX3BhcnNlcl8xIiwic3ViY2hhbm5lbF9hZGRyZXNzXzEiLCJjaGFubmVsel8xIiwiY2xpZW50VmVyc2lvbiIsInZlcnNpb24iLCJUUkFDRVJfTkFNRSIsIkZMT1dfQ09OVFJPTF9UUkFDRVJfTkFNRSIsIk1JTl9DT05ORUNUX1RJTUVPVVRfTVMiLCJJTklUSUFMX0JBQ0tPRkZfTVMiLCJCQUNLT0ZGX01VTFRJUExJRVIiLCJNQVhfQkFDS09GRl9NUyIsIkJBQ0tPRkZfSklUVEVSIiwiS0VFUEFMSVZFX01BWF9USU1FX01TIiwiS0VFUEFMSVZFX1RJTUVPVVRfTVMiLCJIVFRQMl9IRUFERVJfQVVUSE9SSVRZIiwiSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRSIsIkhUVFAyX0hFQURFUl9NRVRIT0QiLCJIVFRQMl9IRUFERVJfUEFUSCIsIkhUVFAyX0hFQURFUl9URSIsIkhUVFAyX0hFQURFUl9VU0VSX0FHRU5UIiwiY29uc3RhbnRzIiwidW5pZm9ybVJhbmRvbSIsIm1pbiIsIm1heCIsIk1hdGgiLCJyYW5kb20iLCJ0b29NYW55UGluZ3NEYXRhIiwiQnVmZmVyIiwiZnJvbSIsImNvbnN0cnVjdG9yIiwiY2hhbm5lbFRhcmdldCIsInN1YmNoYW5uZWxBZGRyZXNzIiwib3B0aW9ucyIsImNyZWRlbnRpYWxzIiwiY29ubmVjdGl2aXR5U3RhdGUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIklETEUiLCJzZXNzaW9uIiwiY29udGludWVDb25uZWN0aW5nIiwic3RhdGVMaXN0ZW5lcnMiLCJkaXNjb25uZWN0TGlzdGVuZXJzIiwiU2V0Iiwia2VlcGFsaXZlVGltZU1zIiwia2VlcGFsaXZlVGltZW91dE1zIiwia2VlcGFsaXZlV2l0aG91dENhbGxzIiwiY2FsbFJlZmNvdW50IiwicmVmY291bnQiLCJjaGFubmVsekVuYWJsZWQiLCJjYWxsVHJhY2tlciIsIkNoYW5uZWx6Q2FsbFRyYWNrZXIiLCJjaGlsZHJlblRyYWNrZXIiLCJDaGFubmVsekNoaWxkcmVuVHJhY2tlciIsImNoYW5uZWx6U29ja2V0UmVmIiwicmVtb3RlTmFtZSIsInN0cmVhbVRyYWNrZXIiLCJrZWVwYWxpdmVzU2VudCIsIm1lc3NhZ2VzU2VudCIsIm1lc3NhZ2VzUmVjZWl2ZWQiLCJsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAiLCJsYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wIiwidXNlckFnZW50IiwiZmlsdGVyIiwiZSIsImpvaW4iLCJrZWVwYWxpdmVJbnRlcnZhbElkIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsImtlZXBhbGl2ZVRpbWVvdXRJZCIsImJhY2tvZmZPcHRpb25zIiwiaW5pdGlhbERlbGF5IiwibWF4RGVsYXkiLCJiYWNrb2ZmVGltZW91dCIsIkJhY2tvZmZUaW1lb3V0IiwiaGFuZGxlQmFja29mZlRpbWVyIiwic3ViY2hhbm5lbEFkZHJlc3NTdHJpbmciLCJzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nIiwiY2hhbm5lbHpUcmFjZSIsIkNoYW5uZWx6VHJhY2UiLCJjaGFubmVselJlZiIsInJlZ2lzdGVyQ2hhbm5lbHpTdWJjaGFubmVsIiwiZ2V0Q2hhbm5lbHpJbmZvIiwiYWRkVHJhY2UiLCJ0cmFjZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1bmRlZmluZWQiLCJzdGF0ZSIsImNoaWxkcmVuIiwiZ2V0Q2hpbGRMaXN0cyIsInRhcmdldCIsImdldENoYW5uZWx6U29ja2V0SW5mbyIsIl9hIiwiX2IiLCJfYyIsInNlc3Npb25Tb2NrZXQiLCJzb2NrZXQiLCJyZW1vdGVBZGRyZXNzIiwic3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyIsInJlbW90ZVBvcnQiLCJsb2NhbEFkZHJlc3MiLCJsb2NhbFBvcnQiLCJ0bHNJbmZvIiwiZW5jcnlwdGVkIiwidGxzU29ja2V0IiwiY2lwaGVySW5mbyIsImdldENpcGhlciIsImNlcnRpZmljYXRlIiwiZ2V0Q2VydGlmaWNhdGUiLCJwZWVyQ2VydGlmaWNhdGUiLCJnZXRQZWVyQ2VydGlmaWNhdGUiLCJjaXBoZXJTdWl0ZVN0YW5kYXJkTmFtZSIsInN0YW5kYXJkTmFtZSIsImNpcGhlclN1aXRlT3RoZXJOYW1lIiwibmFtZSIsImxvY2FsQ2VydGlmaWNhdGUiLCJyYXciLCJyZW1vdGVDZXJ0aWZpY2F0ZSIsInNvY2tldEluZm8iLCJzZWN1cml0eSIsInN0cmVhbXNTdGFydGVkIiwiY2FsbHNTdGFydGVkIiwic3RyZWFtc1N1Y2NlZWRlZCIsImNhbGxzU3VjY2VlZGVkIiwic3RyZWFtc0ZhaWxlZCIsImNhbGxzRmFpbGVkIiwia2VlcEFsaXZlc1NlbnQiLCJsYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wIiwibGFzdENhbGxTdGFydGVkVGltZXN0YW1wIiwibGFzdFJlbW90ZVN0cmVhbUNyZWF0ZWRUaW1lc3RhbXAiLCJsb2NhbEZsb3dDb250cm9sV2luZG93IiwibG9jYWxXaW5kb3dTaXplIiwicmVtb3RlRmxvd0NvbnRyb2xXaW5kb3ciLCJyZW1vdGVXaW5kb3dTaXplIiwicmVzZXRDaGFubmVselNvY2tldEluZm8iLCJ1bnJlZ2lzdGVyQ2hhbm5lbHpSZWYiLCJ1bnJlZkNoaWxkIiwidGV4dCIsIkxvZ1ZlcmJvc2l0eSIsIkRFQlVHIiwiaWQiLCJyZWZUcmFjZSIsImZsb3dDb250cm9sVHJhY2UiLCJpbnRlcm5hbHNUcmFjZSIsImtlZXBhbGl2ZVRyYWNlIiwidHJhbnNpdGlvblRvU3RhdGUiLCJUUkFOU0lFTlRfRkFJTFVSRSIsIkNPTk5FQ1RJTkciLCJzdGFydEJhY2tvZmYiLCJydW5PbmNlIiwic3RvcEJhY2tvZmYiLCJzdG9wIiwicmVzZXQiLCJzZW5kUGluZyIsImhhbmRsZURpc2Nvbm5lY3QiLCJ1bnJlZiIsImNhbGwiLCJwaW5nIiwiZXJyIiwiZHVyYXRpb24iLCJwYXlsb2FkIiwiUkVBRFkiLCJzdGFydEtlZXBhbGl2ZVBpbmdzIiwic2V0SW50ZXJ2YWwiLCJzdG9wS2VlcGFsaXZlUGluZ3MiLCJjbGVhckludGVydmFsIiwiY3JlYXRlU2Vzc2lvbiIsInByb3h5Q29ubmVjdGlvblJlc3VsdCIsInJlYWxUYXJnZXQiLCJ1cmlUb1N0cmluZyIsInRhcmdldEF1dGhvcml0eSIsImdldERlZmF1bHRBdXRob3JpdHkiLCJjb25uZWN0aW9uT3B0aW9ucyIsIl9nZXRDb25uZWN0aW9uT3B0aW9ucyIsIm1heFNlbmRIZWFkZXJCbG9ja0xlbmd0aCIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJtYXhTZXNzaW9uTWVtb3J5IiwiYWRkcmVzc1NjaGVtZSIsInNzbFRhcmdldE5hbWVPdmVycmlkZSIsImNoZWNrU2VydmVySWRlbnRpdHkiLCJob3N0IiwiY2VydCIsInNlcnZlcm5hbWUiLCJhdXRob3JpdHlIb3N0bmFtZSIsInNwbGl0SG9zdFBvcnQiLCJjcmVhdGVDb25uZWN0aW9uIiwiYXV0aG9yaXR5Iiwib3B0aW9uIiwiY29ubmVjdCIsImFzc2lnbiIsInJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQiLCJyZWZDaGlsZCIsIm9uY2UiLCJlcnJvckNvZGUiLCJsYXN0U3RyZWFtSUQiLCJvcGFxdWVEYXRhIiwiTkdIVFRQMl9FTkhBTkNFX1lPVVJfQ0FMTSIsImVxdWFscyIsImxvZyIsIkVSUk9SIiwiZXJyb3IiLCJtZXNzYWdlIiwiaXNUcmFjZXJFbmFibGVkIiwib24iLCJzZXR0aW5ncyIsInN0YXJ0Q29ubmVjdGluZ0ludGVybmFsIiwiQUxQTlByb3RvY29scyIsInRhcmdldFBhdGgiLCJwYXJzZVVyaSIsInBhdGgiLCJob3N0UG9ydCIsImdldFByb3hpZWRDb25uZWN0aW9uIiwidGhlbiIsInJlc3VsdCIsInJlYXNvbiIsImxpc3RlbmVyIiwidmFsdWVzIiwib2xkU3RhdGVzIiwibmV3U3RhdGUiLCJpbmRleE9mIiwicHJldmlvdXNTdGF0ZSIsImNsb3NlIiwiaXNSdW5uaW5nIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiRXJyb3IiLCJjaGVja0JvdGhSZWZjb3VudHMiLCJjYWxsUmVmIiwicmVmIiwiY2FsbFVucmVmIiwidW5yZWZJZk9uZVJlZiIsInN0YXJ0Q2FsbFN0cmVhbSIsIm1ldGFkYXRhIiwiY2FsbFN0cmVhbSIsImV4dHJhRmlsdGVycyIsImhlYWRlcnMiLCJ0b0h0dHAySGVhZGVycyIsImdldEhvc3QiLCJnZXRNZXRob2QiLCJodHRwMlN0cmVhbSIsInJlcXVlc3QiLCJoZWFkZXJzU3RyaW5nIiwiaGVhZGVyIiwia2V5cyIsImdldENhbGxOdW1iZXIiLCJzdHJlYW1TZXNzaW9uIiwiY2xvc2VkIiwiZGVzdHJveWVkIiwic3RhdHNUcmFja2VyIiwiYWRkQ2FsbFN0YXJ0ZWQiLCJhZGRTdGF0dXNXYXRjaGVyIiwic3RhdHVzIiwiY29kZSIsIlN0YXR1cyIsIk9LIiwiYWRkQ2FsbFN1Y2NlZWRlZCIsImFkZENhbGxGYWlsZWQiLCJhZGRTdHJlYW1FbmRXYXRjaGVyIiwic3VjY2VzcyIsImFkZE1lc3NhZ2VTZW50IiwiRGF0ZSIsImFkZE1lc3NhZ2VSZWNlaXZlZCIsImF0dGFjaEh0dHAyU3RyZWFtIiwic3RhcnRDb25uZWN0aW5nIiwiZ2V0Q29ubmVjdGl2aXR5U3RhdGUiLCJhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyIiwicHVzaCIsInJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIiLCJsaXN0ZW5lckluZGV4Iiwic3BsaWNlIiwiYWRkRGlzY29ubmVjdExpc3RlbmVyIiwiYWRkIiwicmVtb3ZlRGlzY29ubmVjdExpc3RlbmVyIiwiZGVsZXRlIiwicmVzZXRCYWNrb2ZmIiwiZ2V0QWRkcmVzcyIsImdldENoYW5uZWx6UmVmIiwiZ2V0UmVhbFN1YmNoYW5uZWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/tls-helpers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getDefaultRootsData = exports.CIPHER_SUITES = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nexports.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;\nconst DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;\nlet defaultRootsData = null;\nfunction getDefaultRootsData() {\n    if (DEFAULT_ROOTS_FILE_PATH) {\n        if (defaultRootsData === null) {\n            defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);\n        }\n        return defaultRootsData;\n    }\n    return null;\n}\nexports.getDefaultRootsData = getDefaultRootsData; //# sourceMappingURL=tls-helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdGxzLWhlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJCQUEyQixHQUFHQSxxQkFBcUIsR0FBRyxLQUFLO0FBQzNELE1BQU1JLEtBQUtDLG1CQUFPQSxDQUFDLGNBQUk7QUFDdkJMLHFCQUFxQixHQUFHTSxRQUFRQyxHQUFHLENBQUNDLHNCQUFzQjtBQUMxRCxNQUFNQywwQkFBMEJILFFBQVFDLEdBQUcsQ0FBQ0csZ0NBQWdDO0FBQzVFLElBQUlDLG1CQUFtQjtBQUN2QixTQUFTVDtJQUNMLElBQUlPLHlCQUF5QjtRQUN6QixJQUFJRSxxQkFBcUIsTUFBTTtZQUMzQkEsbUJBQW1CUCxHQUFHUSxZQUFZLENBQUNIO1FBQ3ZDO1FBQ0EsT0FBT0U7SUFDWDtJQUNBLE9BQU87QUFDWDtBQUNBWCwyQkFBMkIsR0FBR0UscUJBQzlCLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2FzaG1pdHQtZ3VwdGEvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdGxzLWhlbHBlcnMuanM/MGVkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXREZWZhdWx0Um9vdHNEYXRhID0gZXhwb3J0cy5DSVBIRVJfU1VJVEVTID0gdm9pZCAwO1xuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5leHBvcnRzLkNJUEhFUl9TVUlURVMgPSBwcm9jZXNzLmVudi5HUlBDX1NTTF9DSVBIRVJfU1VJVEVTO1xuY29uc3QgREVGQVVMVF9ST09UU19GSUxFX1BBVEggPSBwcm9jZXNzLmVudi5HUlBDX0RFRkFVTFRfU1NMX1JPT1RTX0ZJTEVfUEFUSDtcbmxldCBkZWZhdWx0Um9vdHNEYXRhID0gbnVsbDtcbmZ1bmN0aW9uIGdldERlZmF1bHRSb290c0RhdGEoKSB7XG4gICAgaWYgKERFRkFVTFRfUk9PVFNfRklMRV9QQVRIKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Um9vdHNEYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICBkZWZhdWx0Um9vdHNEYXRhID0gZnMucmVhZEZpbGVTeW5jKERFRkFVTFRfUk9PVFNfRklMRV9QQVRIKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdFJvb3RzRGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLmdldERlZmF1bHRSb290c0RhdGEgPSBnZXREZWZhdWx0Um9vdHNEYXRhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGxzLWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0RGVmYXVsdFJvb3RzRGF0YSIsIkNJUEhFUl9TVUlURVMiLCJmcyIsInJlcXVpcmUiLCJwcm9jZXNzIiwiZW52IiwiR1JQQ19TU0xfQ0lQSEVSX1NVSVRFUyIsIkRFRkFVTFRfUk9PVFNfRklMRV9QQVRIIiwiR1JQQ19ERUZBVUxUX1NTTF9ST09UU19GSUxFX1BBVEgiLCJkZWZhdWx0Um9vdHNEYXRhIiwicmVhZEZpbGVTeW5jIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/uri-parser.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.uriToString = exports.splitHostPort = exports.parseUri = void 0;\n/*\n * The groups correspond to URI parts as follows:\n * 1. scheme\n * 2. authority\n * 3. path\n */ const URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\\/\\/([^/]*)\\/)?(.+)$/;\nfunction parseUri(uriString) {\n    const parsedUri = URI_REGEX.exec(uriString);\n    if (parsedUri === null) {\n        return null;\n    }\n    return {\n        scheme: parsedUri[1],\n        authority: parsedUri[2],\n        path: parsedUri[3]\n    };\n}\nexports.parseUri = parseUri;\nconst NUMBER_REGEX = /^\\d+$/;\nfunction splitHostPort(path) {\n    if (path.startsWith(\"[\")) {\n        const hostEnd = path.indexOf(\"]\");\n        if (hostEnd === -1) {\n            return null;\n        }\n        const host = path.substring(1, hostEnd);\n        /* Only an IPv6 address should be in bracketed notation, and an IPv6\n         * address should have at least one colon */ if (host.indexOf(\":\") === -1) {\n            return null;\n        }\n        if (path.length > hostEnd + 1) {\n            if (path[hostEnd + 1] === \":\") {\n                const portString = path.substring(hostEnd + 2);\n                if (NUMBER_REGEX.test(portString)) {\n                    return {\n                        host: host,\n                        port: +portString\n                    };\n                } else {\n                    return null;\n                }\n            } else {\n                return null;\n            }\n        } else {\n            return {\n                host\n            };\n        }\n    } else {\n        const splitPath = path.split(\":\");\n        /* Exactly one colon means that this is host:port. Zero colons means that\n         * there is no port. And multiple colons means that this is a bare IPv6\n         * address with no port */ if (splitPath.length === 2) {\n            if (NUMBER_REGEX.test(splitPath[1])) {\n                return {\n                    host: splitPath[0],\n                    port: +splitPath[1]\n                };\n            } else {\n                return null;\n            }\n        } else {\n            return {\n                host: path\n            };\n        }\n    }\n}\nexports.splitHostPort = splitHostPort;\nfunction uriToString(uri) {\n    let result = \"\";\n    if (uri.scheme !== undefined) {\n        result += uri.scheme + \":\";\n    }\n    if (uri.authority !== undefined) {\n        result += \"//\" + uri.authority + \"/\";\n    }\n    result += uri.path;\n    return result;\n}\nexports.uriToString = uriToString; //# sourceMappingURL=uri-parser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdXJpLXBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLHFCQUFxQixHQUFHQSxnQkFBZ0IsR0FBRyxLQUFLO0FBQ3RFOzs7OztDQUtDLEdBQ0QsTUFBTUssWUFBWTtBQUNsQixTQUFTRCxTQUFTRSxTQUFTO0lBQ3ZCLE1BQU1DLFlBQVlGLFVBQVVHLElBQUksQ0FBQ0Y7SUFDakMsSUFBSUMsY0FBYyxNQUFNO1FBQ3BCLE9BQU87SUFDWDtJQUNBLE9BQU87UUFDSEUsUUFBUUYsU0FBUyxDQUFDLEVBQUU7UUFDcEJHLFdBQVdILFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCSSxNQUFNSixTQUFTLENBQUMsRUFBRTtJQUN0QjtBQUNKO0FBQ0FQLGdCQUFnQixHQUFHSTtBQUNuQixNQUFNUSxlQUFlO0FBQ3JCLFNBQVNULGNBQWNRLElBQUk7SUFDdkIsSUFBSUEsS0FBS0UsVUFBVSxDQUFDLE1BQU07UUFDdEIsTUFBTUMsVUFBVUgsS0FBS0ksT0FBTyxDQUFDO1FBQzdCLElBQUlELFlBQVksQ0FBQyxHQUFHO1lBQ2hCLE9BQU87UUFDWDtRQUNBLE1BQU1FLE9BQU9MLEtBQUtNLFNBQVMsQ0FBQyxHQUFHSDtRQUMvQjtrREFDMEMsR0FDMUMsSUFBSUUsS0FBS0QsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHO1lBQzFCLE9BQU87UUFDWDtRQUNBLElBQUlKLEtBQUtPLE1BQU0sR0FBR0osVUFBVSxHQUFHO1lBQzNCLElBQUlILElBQUksQ0FBQ0csVUFBVSxFQUFFLEtBQUssS0FBSztnQkFDM0IsTUFBTUssYUFBYVIsS0FBS00sU0FBUyxDQUFDSCxVQUFVO2dCQUM1QyxJQUFJRixhQUFhUSxJQUFJLENBQUNELGFBQWE7b0JBQy9CLE9BQU87d0JBQ0hILE1BQU1BO3dCQUNOSyxNQUFNLENBQUNGO29CQUNYO2dCQUNKLE9BQ0s7b0JBQ0QsT0FBTztnQkFDWDtZQUNKLE9BQ0s7Z0JBQ0QsT0FBTztZQUNYO1FBQ0osT0FDSztZQUNELE9BQU87Z0JBQ0hIO1lBQ0o7UUFDSjtJQUNKLE9BQ0s7UUFDRCxNQUFNTSxZQUFZWCxLQUFLWSxLQUFLLENBQUM7UUFDN0I7O2dDQUV3QixHQUN4QixJQUFJRCxVQUFVSixNQUFNLEtBQUssR0FBRztZQUN4QixJQUFJTixhQUFhUSxJQUFJLENBQUNFLFNBQVMsQ0FBQyxFQUFFLEdBQUc7Z0JBQ2pDLE9BQU87b0JBQ0hOLE1BQU1NLFNBQVMsQ0FBQyxFQUFFO29CQUNsQkQsTUFBTSxDQUFDQyxTQUFTLENBQUMsRUFBRTtnQkFDdkI7WUFDSixPQUNLO2dCQUNELE9BQU87WUFDWDtRQUNKLE9BQ0s7WUFDRCxPQUFPO2dCQUNITixNQUFNTDtZQUNWO1FBQ0o7SUFDSjtBQUNKO0FBQ0FYLHFCQUFxQixHQUFHRztBQUN4QixTQUFTRCxZQUFZc0IsR0FBRztJQUNwQixJQUFJQyxTQUFTO0lBQ2IsSUFBSUQsSUFBSWYsTUFBTSxLQUFLaUIsV0FBVztRQUMxQkQsVUFBVUQsSUFBSWYsTUFBTSxHQUFHO0lBQzNCO0lBQ0EsSUFBSWUsSUFBSWQsU0FBUyxLQUFLZ0IsV0FBVztRQUM3QkQsVUFBVSxPQUFPRCxJQUFJZCxTQUFTLEdBQUc7SUFDckM7SUFDQWUsVUFBVUQsSUFBSWIsSUFBSTtJQUNsQixPQUFPYztBQUNYO0FBQ0F6QixtQkFBbUIsR0FBR0UsYUFDdEIsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNobWl0dC1ndXB0YS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy91cmktcGFyc2VyLmpzPzJhYzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjAgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXJpVG9TdHJpbmcgPSBleHBvcnRzLnNwbGl0SG9zdFBvcnQgPSBleHBvcnRzLnBhcnNlVXJpID0gdm9pZCAwO1xuLypcbiAqIFRoZSBncm91cHMgY29ycmVzcG9uZCB0byBVUkkgcGFydHMgYXMgZm9sbG93czpcbiAqIDEuIHNjaGVtZVxuICogMi4gYXV0aG9yaXR5XG4gKiAzLiBwYXRoXG4gKi9cbmNvbnN0IFVSSV9SRUdFWCA9IC9eKD86KFtBLVphLXowLTkrLi1dKyk6KT8oPzpcXC9cXC8oW14vXSopXFwvKT8oLispJC87XG5mdW5jdGlvbiBwYXJzZVVyaSh1cmlTdHJpbmcpIHtcbiAgICBjb25zdCBwYXJzZWRVcmkgPSBVUklfUkVHRVguZXhlYyh1cmlTdHJpbmcpO1xuICAgIGlmIChwYXJzZWRVcmkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNjaGVtZTogcGFyc2VkVXJpWzFdLFxuICAgICAgICBhdXRob3JpdHk6IHBhcnNlZFVyaVsyXSxcbiAgICAgICAgcGF0aDogcGFyc2VkVXJpWzNdLFxuICAgIH07XG59XG5leHBvcnRzLnBhcnNlVXJpID0gcGFyc2VVcmk7XG5jb25zdCBOVU1CRVJfUkVHRVggPSAvXlxcZCskLztcbmZ1bmN0aW9uIHNwbGl0SG9zdFBvcnQocGF0aCkge1xuICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoJ1snKSkge1xuICAgICAgICBjb25zdCBob3N0RW5kID0gcGF0aC5pbmRleE9mKCddJyk7XG4gICAgICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG9zdCA9IHBhdGguc3Vic3RyaW5nKDEsIGhvc3RFbmQpO1xuICAgICAgICAvKiBPbmx5IGFuIElQdjYgYWRkcmVzcyBzaG91bGQgYmUgaW4gYnJhY2tldGVkIG5vdGF0aW9uLCBhbmQgYW4gSVB2NlxuICAgICAgICAgKiBhZGRyZXNzIHNob3VsZCBoYXZlIGF0IGxlYXN0IG9uZSBjb2xvbiAqL1xuICAgICAgICBpZiAoaG9zdC5pbmRleE9mKCc6JykgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPiBob3N0RW5kICsgMSkge1xuICAgICAgICAgICAgaWYgKHBhdGhbaG9zdEVuZCArIDFdID09PSAnOicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3J0U3RyaW5nID0gcGF0aC5zdWJzdHJpbmcoaG9zdEVuZCArIDIpO1xuICAgICAgICAgICAgICAgIGlmIChOVU1CRVJfUkVHRVgudGVzdChwb3J0U3RyaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogaG9zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6ICtwb3J0U3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhvc3QsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzcGxpdFBhdGggPSBwYXRoLnNwbGl0KCc6Jyk7XG4gICAgICAgIC8qIEV4YWN0bHkgb25lIGNvbG9uIG1lYW5zIHRoYXQgdGhpcyBpcyBob3N0OnBvcnQuIFplcm8gY29sb25zIG1lYW5zIHRoYXRcbiAgICAgICAgICogdGhlcmUgaXMgbm8gcG9ydC4gQW5kIG11bHRpcGxlIGNvbG9ucyBtZWFucyB0aGF0IHRoaXMgaXMgYSBiYXJlIElQdjZcbiAgICAgICAgICogYWRkcmVzcyB3aXRoIG5vIHBvcnQgKi9cbiAgICAgICAgaWYgKHNwbGl0UGF0aC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIGlmIChOVU1CRVJfUkVHRVgudGVzdChzcGxpdFBhdGhbMV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogc3BsaXRQYXRoWzBdLFxuICAgICAgICAgICAgICAgICAgICBwb3J0OiArc3BsaXRQYXRoWzFdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaG9zdDogcGF0aCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnNwbGl0SG9zdFBvcnQgPSBzcGxpdEhvc3RQb3J0O1xuZnVuY3Rpb24gdXJpVG9TdHJpbmcodXJpKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGlmICh1cmkuc2NoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0ICs9IHVyaS5zY2hlbWUgKyAnOic7XG4gICAgfVxuICAgIGlmICh1cmkuYXV0aG9yaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0ICs9ICcvLycgKyB1cmkuYXV0aG9yaXR5ICsgJy8nO1xuICAgIH1cbiAgICByZXN1bHQgKz0gdXJpLnBhdGg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMudXJpVG9TdHJpbmcgPSB1cmlUb1N0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVyaS1wYXJzZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidXJpVG9TdHJpbmciLCJzcGxpdEhvc3RQb3J0IiwicGFyc2VVcmkiLCJVUklfUkVHRVgiLCJ1cmlTdHJpbmciLCJwYXJzZWRVcmkiLCJleGVjIiwic2NoZW1lIiwiYXV0aG9yaXR5IiwicGF0aCIsIk5VTUJFUl9SRUdFWCIsInN0YXJ0c1dpdGgiLCJob3N0RW5kIiwiaW5kZXhPZiIsImhvc3QiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJwb3J0U3RyaW5nIiwidGVzdCIsInBvcnQiLCJzcGxpdFBhdGgiLCJzcGxpdCIsInVyaSIsInJlc3VsdCIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/proto-loader/build/src/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.loadFileDescriptorSetFromObject = exports.loadFileDescriptorSetFromBuffer = exports.fromJSON = exports.loadSync = exports.load = exports.IdempotencyLevel = exports.isAnyExtension = exports.Long = void 0;\nconst camelCase = __webpack_require__(/*! lodash.camelcase */ \"(ssr)/./node_modules/lodash.camelcase/index.js\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(ssr)/./node_modules/protobufjs/index.js\");\nconst descriptor = __webpack_require__(/*! protobufjs/ext/descriptor */ \"(ssr)/./node_modules/protobufjs/ext/descriptor/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/proto-loader/build/src/util.js\");\nconst Long = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/umd/index.js\");\nexports.Long = Long;\nfunction isAnyExtension(obj) {\n    return \"@type\" in obj && typeof obj[\"@type\"] === \"string\";\n}\nexports.isAnyExtension = isAnyExtension;\nvar IdempotencyLevel;\n(function(IdempotencyLevel) {\n    IdempotencyLevel[\"IDEMPOTENCY_UNKNOWN\"] = \"IDEMPOTENCY_UNKNOWN\";\n    IdempotencyLevel[\"NO_SIDE_EFFECTS\"] = \"NO_SIDE_EFFECTS\";\n    IdempotencyLevel[\"IDEMPOTENT\"] = \"IDEMPOTENT\";\n})(IdempotencyLevel = exports.IdempotencyLevel || (exports.IdempotencyLevel = {}));\nconst descriptorOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    defaults: true,\n    oneofs: true,\n    json: true\n};\nfunction joinName(baseName, name) {\n    if (baseName === \"\") {\n        return name;\n    } else {\n        return baseName + \".\" + name;\n    }\n}\nfunction isHandledReflectionObject(obj) {\n    return obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum;\n}\nfunction isNamespaceBase(obj) {\n    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\nfunction getAllHandledReflectionObjects(obj, parentName) {\n    const objName = joinName(parentName, obj.name);\n    if (isHandledReflectionObject(obj)) {\n        return [\n            [\n                objName,\n                obj\n            ]\n        ];\n    } else {\n        if (isNamespaceBase(obj) && typeof obj.nested !== \"undefined\") {\n            return Object.keys(obj.nested).map((name)=>{\n                return getAllHandledReflectionObjects(obj.nested[name], objName);\n            }).reduce((accumulator, currentValue)=>accumulator.concat(currentValue), []);\n        }\n    }\n    return [];\n}\nfunction createDeserializer(cls, options) {\n    return function deserialize(argBuf) {\n        return cls.toObject(cls.decode(argBuf), options);\n    };\n}\nfunction createSerializer(cls) {\n    return function serialize(arg) {\n        if (Array.isArray(arg)) {\n            throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);\n        }\n        const message = cls.fromObject(arg);\n        return cls.encode(message).finish();\n    };\n}\nfunction mapMethodOptions(options) {\n    return (options || []).reduce((obj, item)=>{\n        for (const [key, value] of Object.entries(item)){\n            switch(key){\n                case \"uninterpreted_option\":\n                    obj.uninterpreted_option.push(item.uninterpreted_option);\n                    break;\n                default:\n                    obj[key] = value;\n            }\n        }\n        return obj;\n    }, {\n        deprecated: false,\n        idempotency_level: IdempotencyLevel.IDEMPOTENCY_UNKNOWN,\n        uninterpreted_option: []\n    });\n}\nfunction createMethodDefinition(method, serviceName, options, fileDescriptors) {\n    /* This is only ever called after the corresponding root.resolveAll(), so we\n     * can assume that the resolved request and response types are non-null */ const requestType = method.resolvedRequestType;\n    const responseType = method.resolvedResponseType;\n    return {\n        path: \"/\" + serviceName + \"/\" + method.name,\n        requestStream: !!method.requestStream,\n        responseStream: !!method.responseStream,\n        requestSerialize: createSerializer(requestType),\n        requestDeserialize: createDeserializer(requestType, options),\n        responseSerialize: createSerializer(responseType),\n        responseDeserialize: createDeserializer(responseType, options),\n        // TODO(murgatroid99): Find a better way to handle this\n        originalName: camelCase(method.name),\n        requestType: createMessageDefinition(requestType, fileDescriptors),\n        responseType: createMessageDefinition(responseType, fileDescriptors),\n        options: mapMethodOptions(method.parsedOptions)\n    };\n}\nfunction createServiceDefinition(service, name, options, fileDescriptors) {\n    const def = {};\n    for (const method of service.methodsArray){\n        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);\n    }\n    return def;\n}\nfunction createMessageDefinition(message, fileDescriptors) {\n    const messageDescriptor = message.toDescriptor(\"proto3\");\n    return {\n        format: \"Protocol Buffer 3 DescriptorProto\",\n        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors\n    };\n}\nfunction createEnumDefinition(enumType, fileDescriptors) {\n    const enumDescriptor = enumType.toDescriptor(\"proto3\");\n    return {\n        format: \"Protocol Buffer 3 EnumDescriptorProto\",\n        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors\n    };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options:\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\n * name: string, options: Options): MessageTypeDefinition; function\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\n * EnumTypeDefinition;\n */ function createDefinition(obj, name, options, fileDescriptors) {\n    if (obj instanceof Protobuf.Service) {\n        return createServiceDefinition(obj, name, options, fileDescriptors);\n    } else if (obj instanceof Protobuf.Type) {\n        return createMessageDefinition(obj, fileDescriptors);\n    } else if (obj instanceof Protobuf.Enum) {\n        return createEnumDefinition(obj, fileDescriptors);\n    } else {\n        throw new Error(\"Type mismatch in reflection object handling\");\n    }\n}\nfunction createPackageDefinition(root, options) {\n    const def = {};\n    root.resolveAll();\n    const descriptorList = root.toDescriptor(\"proto3\").file;\n    const bufferList = descriptorList.map((value)=>Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));\n    for (const [name, obj] of getAllHandledReflectionObjects(root, \"\")){\n        def[name] = createDefinition(obj, name, options, bufferList);\n    }\n    return def;\n}\nfunction createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {\n    options = options || {};\n    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);\n    root.resolveAll();\n    return createPackageDefinition(root, options);\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename One or multiple file paths to load. Can be an absolute path\n *     or relative to an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.json Represent Infinity and NaN as strings in float fields,\n *     and automatically decode google.protobuf.Any values.\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */ function load(filename, options) {\n    return (0, util_1.loadProtosWithOptions)(filename, options).then((loadedRoot)=>{\n        return createPackageDefinition(loadedRoot, options);\n    });\n}\nexports.load = load;\nfunction loadSync(filename, options) {\n    const loadedRoot = (0, util_1.loadProtosWithOptionsSync)(filename, options);\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.loadSync = loadSync;\nfunction fromJSON(json, options) {\n    options = options || {};\n    const loadedRoot = Protobuf.Root.fromJSON(json);\n    loadedRoot.resolveAll();\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.fromJSON = fromJSON;\nfunction loadFileDescriptorSetFromBuffer(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;\nfunction loadFileDescriptorSetFromObject(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;\n(0, util_1.addCommonProtos)(); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx1Q0FBdUMsR0FBR0EsdUNBQXVDLEdBQUdBLGdCQUFnQixHQUFHQSxnQkFBZ0IsR0FBR0EsWUFBWSxHQUFHQSx3QkFBd0IsR0FBR0Esc0JBQXNCLEdBQUdBLFlBQVksR0FBRyxLQUFLO0FBQ2pOLE1BQU1VLFlBQVlDLG1CQUFPQSxDQUFDLHdFQUFrQjtBQUM1QyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyw0REFBWTtBQUNyQyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQywwRkFBMkI7QUFDdEQsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUMseUVBQVE7QUFDL0IsTUFBTUYsT0FBT0UsbUJBQU9BLENBQUMsb0RBQU07QUFDM0JYLFlBQVksR0FBR1M7QUFDZixTQUFTRCxlQUFlTyxHQUFHO0lBQ3ZCLE9BQU8sV0FBWUEsT0FBUyxPQUFPQSxHQUFHLENBQUMsUUFBUSxLQUFLO0FBQ3hEO0FBQ0FmLHNCQUFzQixHQUFHUTtBQUN6QixJQUFJRDtBQUNILFVBQVVBLGdCQUFnQjtJQUN2QkEsZ0JBQWdCLENBQUMsc0JBQXNCLEdBQUc7SUFDMUNBLGdCQUFnQixDQUFDLGtCQUFrQixHQUFHO0lBQ3RDQSxnQkFBZ0IsQ0FBQyxhQUFhLEdBQUc7QUFDckMsR0FBR0EsbUJBQW1CUCxRQUFRTyxnQkFBZ0IsSUFBS1AsQ0FBQUEsd0JBQXdCLEdBQUcsQ0FBQztBQUMvRSxNQUFNZ0Isb0JBQW9CO0lBQ3RCQyxPQUFPQztJQUNQQyxPQUFPRDtJQUNQRSxPQUFPRjtJQUNQRyxVQUFVO0lBQ1ZDLFFBQVE7SUFDUkMsTUFBTTtBQUNWO0FBQ0EsU0FBU0MsU0FBU0MsUUFBUSxFQUFFQyxJQUFJO0lBQzVCLElBQUlELGFBQWEsSUFB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QVNELFNBQVM2RyxRQUFRLEVBQUVwRSxPQUFPO0lBQy9CLE1BQU11RSxhQUFhLENBQUMsR0FBR3ZHLE9BQU93Ryx5QkFBeUIsRUFBRUosVUFBVXBFO0lBQ25FLE9BQU93RCx3QkFBd0JlLFlBQVl2RTtBQUMvQztBQUNBOUMsZ0JBQWdCLEdBQUdLO0FBQ25CLFNBQVNELFNBQVNtQixJQUFJLEVBQUV1QixPQUFPO0lBQzNCQSxVQUFVQSxXQUFXLENBQUM7SUFDdEIsTUFBTXVFLGFBQWF6RyxTQUFTcUIsSUFBSSxDQUFDN0IsUUFBUSxDQUFDbUI7SUFDMUM4RixXQUFXYixVQUFVO0lBQ3JCLE9BQU9GLHdCQUF3QmUsWUFBWXZFO0FBQy9DO0FBQ0E5QyxnQkFBZ0IsR0FBR0k7QUFDbkIsU0FBU0QsZ0NBQWdDb0gsYUFBYSxFQUFFekUsT0FBTztJQUMzRCxNQUFNa0UsdUJBQXVCbkcsV0FBVzJHLGlCQUFpQixDQUFDdEUsTUFBTSxDQUFDcUU7SUFDakUsT0FBT1IseUNBQXlDQyxzQkFBc0JsRTtBQUMxRTtBQUNBOUMsdUNBQXVDLEdBQUdHO0FBQzFDLFNBQVNELGdDQUFnQ3FILGFBQWEsRUFBRXpFLE9BQU87SUFDM0QsTUFBTWtFLHVCQUF1Qm5HLFdBQVcyRyxpQkFBaUIsQ0FBQzlELFVBQVUsQ0FBQzZEO0lBQ3JFLE9BQU9SLHlDQUF5Q0Msc0JBQXNCbEU7QUFDMUU7QUFDQTlDLHVDQUF1QyxHQUFHRTtBQUN6QyxJQUFHWSxPQUFPMkcsZUFBZSxLQUMxQixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc2htaXR0LWd1cHRhLy4vbm9kZV9tb2R1bGVzL0BncnBjL3Byb3RvLWxvYWRlci9idWlsZC9zcmMvaW5kZXguanM/NWZhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21PYmplY3QgPSBleHBvcnRzLmxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21CdWZmZXIgPSBleHBvcnRzLmZyb21KU09OID0gZXhwb3J0cy5sb2FkU3luYyA9IGV4cG9ydHMubG9hZCA9IGV4cG9ydHMuSWRlbXBvdGVuY3lMZXZlbCA9IGV4cG9ydHMuaXNBbnlFeHRlbnNpb24gPSBleHBvcnRzLkxvbmcgPSB2b2lkIDA7XG5jb25zdCBjYW1lbENhc2UgPSByZXF1aXJlKFwibG9kYXNoLmNhbWVsY2FzZVwiKTtcbmNvbnN0IFByb3RvYnVmID0gcmVxdWlyZShcInByb3RvYnVmanNcIik7XG5jb25zdCBkZXNjcmlwdG9yID0gcmVxdWlyZShcInByb3RvYnVmanMvZXh0L2Rlc2NyaXB0b3JcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgTG9uZyA9IHJlcXVpcmUoXCJsb25nXCIpO1xuZXhwb3J0cy5Mb25nID0gTG9uZztcbmZ1bmN0aW9uIGlzQW55RXh0ZW5zaW9uKG9iaikge1xuICAgIHJldHVybiAoJ0B0eXBlJyBpbiBvYmopICYmICh0eXBlb2Ygb2JqWydAdHlwZSddID09PSAnc3RyaW5nJyk7XG59XG5leHBvcnRzLmlzQW55RXh0ZW5zaW9uID0gaXNBbnlFeHRlbnNpb247XG52YXIgSWRlbXBvdGVuY3lMZXZlbDtcbihmdW5jdGlvbiAoSWRlbXBvdGVuY3lMZXZlbCkge1xuICAgIElkZW1wb3RlbmN5TGV2ZWxbXCJJREVNUE9URU5DWV9VTktOT1dOXCJdID0gXCJJREVNUE9URU5DWV9VTktOT1dOXCI7XG4gICAgSWRlbXBvdGVuY3lMZXZlbFtcIk5PX1NJREVfRUZGRUNUU1wiXSA9IFwiTk9fU0lERV9FRkZFQ1RTXCI7XG4gICAgSWRlbXBvdGVuY3lMZXZlbFtcIklERU1QT1RFTlRcIl0gPSBcIklERU1QT1RFTlRcIjtcbn0pKElkZW1wb3RlbmN5TGV2ZWwgPSBleHBvcnRzLklkZW1wb3RlbmN5TGV2ZWwgfHwgKGV4cG9ydHMuSWRlbXBvdGVuY3lMZXZlbCA9IHt9KSk7XG5jb25zdCBkZXNjcmlwdG9yT3B0aW9ucyA9IHtcbiAgICBsb25nczogU3RyaW5nLFxuICAgIGVudW1zOiBTdHJpbmcsXG4gICAgYnl0ZXM6IFN0cmluZyxcbiAgICBkZWZhdWx0czogdHJ1ZSxcbiAgICBvbmVvZnM6IHRydWUsXG4gICAganNvbjogdHJ1ZSxcbn07XG5mdW5jdGlvbiBqb2luTmFtZShiYXNlTmFtZSwgbmFtZSkge1xuICAgIGlmIChiYXNlTmFtZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYmFzZU5hbWUgKyAnLicgKyBuYW1lO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzSGFuZGxlZFJlZmxlY3Rpb25PYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIChvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5TZXJ2aWNlIHx8XG4gICAgICAgIG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlR5cGUgfHxcbiAgICAgICAgb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuRW51bSk7XG59XG5mdW5jdGlvbiBpc05hbWVzcGFjZUJhc2Uob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLk5hbWVzcGFjZSB8fCBvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5Sb290O1xufVxuZnVuY3Rpb24gZ2V0QWxsSGFuZGxlZFJlZmxlY3Rpb25PYmplY3RzKG9iaiwgcGFyZW50TmFtZSkge1xuICAgIGNvbnN0IG9iak5hbWUgPSBqb2luTmFtZShwYXJlbnROYW1lLCBvYmoubmFtZSk7XG4gICAgaWYgKGlzSGFuZGxlZFJlZmxlY3Rpb25PYmplY3Qob2JqKSkge1xuICAgICAgICByZXR1cm4gW1tvYmpOYW1lLCBvYmpdXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChpc05hbWVzcGFjZUJhc2Uob2JqKSAmJiB0eXBlb2Ygb2JqLm5lc3RlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmoubmVzdGVkKVxuICAgICAgICAgICAgICAgIC5tYXAobmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEFsbEhhbmRsZWRSZWZsZWN0aW9uT2JqZWN0cyhvYmoubmVzdGVkW25hbWVdLCBvYmpOYW1lKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjdW11bGF0b3IsIGN1cnJlbnRWYWx1ZSkgPT4gYWNjdW11bGF0b3IuY29uY2F0KGN1cnJlbnRWYWx1ZSksIFtdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBjcmVhdGVEZXNlcmlhbGl6ZXIoY2xzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlc2VyaWFsaXplKGFyZ0J1Zikge1xuICAgICAgICByZXR1cm4gY2xzLnRvT2JqZWN0KGNscy5kZWNvZGUoYXJnQnVmKSwgb3B0aW9ucyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlcmlhbGl6ZXIoY2xzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNlcmlhbGl6ZShhcmcpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2VyaWFsaXplIG1lc3NhZ2U6IGV4cGVjdGVkIG9iamVjdCB3aXRoICR7Y2xzLm5hbWV9IHN0cnVjdHVyZSwgZ290IGFycmF5IGluc3RlYWRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlID0gY2xzLmZyb21PYmplY3QoYXJnKTtcbiAgICAgICAgcmV0dXJuIGNscy5lbmNvZGUobWVzc2FnZSkuZmluaXNoKCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1hcE1ldGhvZE9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucyB8fCBbXSkucmVkdWNlKChvYmosIGl0ZW0pID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaXRlbSkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndW5pbnRlcnByZXRlZF9vcHRpb24nOlxuICAgICAgICAgICAgICAgICAgICBvYmoudW5pbnRlcnByZXRlZF9vcHRpb24ucHVzaChpdGVtLnVuaW50ZXJwcmV0ZWRfb3B0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sIHtcbiAgICAgICAgZGVwcmVjYXRlZDogZmFsc2UsXG4gICAgICAgIGlkZW1wb3RlbmN5X2xldmVsOiBJZGVtcG90ZW5jeUxldmVsLklERU1QT1RFTkNZX1VOS05PV04sXG4gICAgICAgIHVuaW50ZXJwcmV0ZWRfb3B0aW9uOiBbXSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1ldGhvZERlZmluaXRpb24obWV0aG9kLCBzZXJ2aWNlTmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKSB7XG4gICAgLyogVGhpcyBpcyBvbmx5IGV2ZXIgY2FsbGVkIGFmdGVyIHRoZSBjb3JyZXNwb25kaW5nIHJvb3QucmVzb2x2ZUFsbCgpLCBzbyB3ZVxuICAgICAqIGNhbiBhc3N1bWUgdGhhdCB0aGUgcmVzb2x2ZWQgcmVxdWVzdCBhbmQgcmVzcG9uc2UgdHlwZXMgYXJlIG5vbi1udWxsICovXG4gICAgY29uc3QgcmVxdWVzdFR5cGUgPSBtZXRob2QucmVzb2x2ZWRSZXF1ZXN0VHlwZTtcbiAgICBjb25zdCByZXNwb25zZVR5cGUgPSBtZXRob2QucmVzb2x2ZWRSZXNwb25zZVR5cGU7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogJy8nICsgc2VydmljZU5hbWUgKyAnLycgKyBtZXRob2QubmFtZSxcbiAgICAgICAgcmVxdWVzdFN0cmVhbTogISFtZXRob2QucmVxdWVzdFN0cmVhbSxcbiAgICAgICAgcmVzcG9uc2VTdHJlYW06ICEhbWV0aG9kLnJlc3BvbnNlU3RyZWFtLFxuICAgICAgICByZXF1ZXN0U2VyaWFsaXplOiBjcmVhdGVTZXJpYWxpemVyKHJlcXVlc3RUeXBlKSxcbiAgICAgICAgcmVxdWVzdERlc2VyaWFsaXplOiBjcmVhdGVEZXNlcmlhbGl6ZXIocmVxdWVzdFR5cGUsIG9wdGlvbnMpLFxuICAgICAgICByZXNwb25zZVNlcmlhbGl6ZTogY3JlYXRlU2VyaWFsaXplcihyZXNwb25zZVR5cGUpLFxuICAgICAgICByZXNwb25zZURlc2VyaWFsaXplOiBjcmVhdGVEZXNlcmlhbGl6ZXIocmVzcG9uc2VUeXBlLCBvcHRpb25zKSxcbiAgICAgICAgLy8gVE9ETyhtdXJnYXRyb2lkOTkpOiBGaW5kIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpc1xuICAgICAgICBvcmlnaW5hbE5hbWU6IGNhbWVsQ2FzZShtZXRob2QubmFtZSksXG4gICAgICAgIHJlcXVlc3RUeXBlOiBjcmVhdGVNZXNzYWdlRGVmaW5pdGlvbihyZXF1ZXN0VHlwZSwgZmlsZURlc2NyaXB0b3JzKSxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiBjcmVhdGVNZXNzYWdlRGVmaW5pdGlvbihyZXNwb25zZVR5cGUsIGZpbGVEZXNjcmlwdG9ycyksXG4gICAgICAgIG9wdGlvbnM6IG1hcE1ldGhvZE9wdGlvbnMobWV0aG9kLnBhcnNlZE9wdGlvbnMpLFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTZXJ2aWNlRGVmaW5pdGlvbihzZXJ2aWNlLCBuYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICBjb25zdCBkZWYgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBzZXJ2aWNlLm1ldGhvZHNBcnJheSkge1xuICAgICAgICBkZWZbbWV0aG9kLm5hbWVdID0gY3JlYXRlTWV0aG9kRGVmaW5pdGlvbihtZXRob2QsIG5hbWUsIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycyk7XG4gICAgfVxuICAgIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlRGVmaW5pdGlvbihtZXNzYWdlLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICBjb25zdCBtZXNzYWdlRGVzY3JpcHRvciA9IG1lc3NhZ2UudG9EZXNjcmlwdG9yKCdwcm90bzMnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmb3JtYXQ6ICdQcm90b2NvbCBCdWZmZXIgMyBEZXNjcmlwdG9yUHJvdG8nLFxuICAgICAgICB0eXBlOiBtZXNzYWdlRGVzY3JpcHRvci4kdHlwZS50b09iamVjdChtZXNzYWdlRGVzY3JpcHRvciwgZGVzY3JpcHRvck9wdGlvbnMpLFxuICAgICAgICBmaWxlRGVzY3JpcHRvclByb3RvczogZmlsZURlc2NyaXB0b3JzLFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVFbnVtRGVmaW5pdGlvbihlbnVtVHlwZSwgZmlsZURlc2NyaXB0b3JzKSB7XG4gICAgY29uc3QgZW51bURlc2NyaXB0b3IgPSBlbnVtVHlwZS50b0Rlc2NyaXB0b3IoJ3Byb3RvMycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZvcm1hdDogJ1Byb3RvY29sIEJ1ZmZlciAzIEVudW1EZXNjcmlwdG9yUHJvdG8nLFxuICAgICAgICB0eXBlOiBlbnVtRGVzY3JpcHRvci4kdHlwZS50b09iamVjdChlbnVtRGVzY3JpcHRvciwgZGVzY3JpcHRvck9wdGlvbnMpLFxuICAgICAgICBmaWxlRGVzY3JpcHRvclByb3RvczogZmlsZURlc2NyaXB0b3JzLFxuICAgIH07XG59XG4vKipcbiAqIGZ1bmN0aW9uIGNyZWF0ZURlZmluaXRpb24ob2JqOiBQcm90b2J1Zi5TZXJ2aWNlLCBuYW1lOiBzdHJpbmcsIG9wdGlvbnM6XG4gKiBPcHRpb25zKTogU2VydmljZURlZmluaXRpb247IGZ1bmN0aW9uIGNyZWF0ZURlZmluaXRpb24ob2JqOiBQcm90b2J1Zi5UeXBlLFxuICogbmFtZTogc3RyaW5nLCBvcHRpb25zOiBPcHRpb25zKTogTWVzc2FnZVR5cGVEZWZpbml0aW9uOyBmdW5jdGlvblxuICogY3JlYXRlRGVmaW5pdGlvbihvYmo6IFByb3RvYnVmLkVudW0sIG5hbWU6IHN0cmluZywgb3B0aW9uczogT3B0aW9ucyk6XG4gKiBFbnVtVHlwZURlZmluaXRpb247XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlZmluaXRpb24ob2JqLCBuYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgUHJvdG9idWYuU2VydmljZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU2VydmljZURlZmluaXRpb24ob2JqLCBuYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5UeXBlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVNZXNzYWdlRGVmaW5pdGlvbihvYmosIGZpbGVEZXNjcmlwdG9ycyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLkVudW0pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVudW1EZWZpbml0aW9uKG9iaiwgZmlsZURlc2NyaXB0b3JzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHlwZSBtaXNtYXRjaCBpbiByZWZsZWN0aW9uIG9iamVjdCBoYW5kbGluZycpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKHJvb3QsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWYgPSB7fTtcbiAgICByb290LnJlc29sdmVBbGwoKTtcbiAgICBjb25zdCBkZXNjcmlwdG9yTGlzdCA9IHJvb3QudG9EZXNjcmlwdG9yKCdwcm90bzMnKS5maWxlO1xuICAgIGNvbnN0IGJ1ZmZlckxpc3QgPSBkZXNjcmlwdG9yTGlzdC5tYXAodmFsdWUgPT4gQnVmZmVyLmZyb20oZGVzY3JpcHRvci5GaWxlRGVzY3JpcHRvclByb3RvLmVuY29kZSh2YWx1ZSkuZmluaXNoKCkpKTtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBvYmpdIG9mIGdldEFsbEhhbmRsZWRSZWZsZWN0aW9uT2JqZWN0cyhyb290LCAnJykpIHtcbiAgICAgICAgZGVmW25hbWVdID0gY3JlYXRlRGVmaW5pdGlvbihvYmosIG5hbWUsIG9wdGlvbnMsIGJ1ZmZlckxpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmO1xufVxuZnVuY3Rpb24gY3JlYXRlUGFja2FnZURlZmluaXRpb25Gcm9tRGVzY3JpcHRvclNldChkZWNvZGVkRGVzY3JpcHRvclNldCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHJvb3QgPSBQcm90b2J1Zi5Sb290LmZyb21EZXNjcmlwdG9yKGRlY29kZWREZXNjcmlwdG9yU2V0KTtcbiAgICByb290LnJlc29sdmVBbGwoKTtcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb24ocm9vdCwgb3B0aW9ucyk7XG59XG4vKipcbiAqIExvYWQgYSAucHJvdG8gZmlsZSB3aXRoIHRoZSBzcGVjaWZpZWQgb3B0aW9ucy5cbiAqIEBwYXJhbSBmaWxlbmFtZSBPbmUgb3IgbXVsdGlwbGUgZmlsZSBwYXRocyB0byBsb2FkLiBDYW4gYmUgYW4gYWJzb2x1dGUgcGF0aFxuICogICAgIG9yIHJlbGF0aXZlIHRvIGFuIGluY2x1ZGUgcGF0aC5cbiAqIEBwYXJhbSBvcHRpb25zLmtlZXBDYXNlIFByZXNlcnZlIGZpZWxkIG5hbWVzLiBUaGUgZGVmYXVsdCBpcyB0byBjaGFuZ2UgdGhlbVxuICogICAgIHRvIGNhbWVsIGNhc2UuXG4gKiBAcGFyYW0gb3B0aW9ucy5sb25ncyBUaGUgdHlwZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCBgbG9uZ2AgdmFsdWVzLlxuICogICAgIFZhbGlkIG9wdGlvbnMgYXJlIGBOdW1iZXJgIGFuZCBgU3RyaW5nYC4gRGVmYXVsdHMgdG8gYSBgTG9uZ2Agb2JqZWN0IHR5cGVcbiAqICAgICBmcm9tIGEgbGlicmFyeS5cbiAqIEBwYXJhbSBvcHRpb25zLmVudW1zIFRoZSB0eXBlIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVwcmVzZW50IGBlbnVtYCB2YWx1ZXMuXG4gKiAgICAgVGhlIG9ubHkgdmFsaWQgb3B0aW9uIGlzIGBTdHJpbmdgLiBEZWZhdWx0cyB0byB0aGUgbnVtZXJpYyB2YWx1ZS5cbiAqIEBwYXJhbSBvcHRpb25zLmJ5dGVzIFRoZSB0eXBlIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVwcmVzZW50IGBieXRlc2BcbiAqICAgICB2YWx1ZXMuIFZhbGlkIG9wdGlvbnMgYXJlIGBBcnJheWAgYW5kIGBTdHJpbmdgLiBUaGUgZGVmYXVsdCBpcyB0byB1c2VcbiAqICAgICBgQnVmZmVyYC5cbiAqIEBwYXJhbSBvcHRpb25zLmRlZmF1bHRzIFNldCBkZWZhdWx0IHZhbHVlcyBvbiBvdXRwdXQgb2JqZWN0cy4gRGVmYXVsdHMgdG9cbiAqICAgICBgZmFsc2VgLlxuICogQHBhcmFtIG9wdGlvbnMuYXJyYXlzIFNldCBlbXB0eSBhcnJheXMgZm9yIG1pc3NpbmcgYXJyYXkgdmFsdWVzIGV2ZW4gaWZcbiAqICAgICBgZGVmYXVsdHNgIGlzIGBmYWxzZWAuIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gKiBAcGFyYW0gb3B0aW9ucy5vYmplY3RzIFNldCBlbXB0eSBvYmplY3RzIGZvciBtaXNzaW5nIG9iamVjdCB2YWx1ZXMgZXZlbiBpZlxuICogICAgIGBkZWZhdWx0c2AgaXMgYGZhbHNlYC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqIEBwYXJhbSBvcHRpb25zLm9uZW9mcyBTZXQgdmlydHVhbCBvbmVvZiBwcm9wZXJ0aWVzIHRvIHRoZSBwcmVzZW50IGZpZWxkJ3NcbiAqICAgICBuYW1lXG4gKiBAcGFyYW0gb3B0aW9ucy5qc29uIFJlcHJlc2VudCBJbmZpbml0eSBhbmQgTmFOIGFzIHN0cmluZ3MgaW4gZmxvYXQgZmllbGRzLFxuICogICAgIGFuZCBhdXRvbWF0aWNhbGx5IGRlY29kZSBnb29nbGUucHJvdG9idWYuQW55IHZhbHVlcy5cbiAqIEBwYXJhbSBvcHRpb25zLmluY2x1ZGVEaXJzIFBhdGhzIHRvIHNlYXJjaCBmb3IgaW1wb3J0ZWQgYC5wcm90b2AgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIGxvYWQoZmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKDAsIHV0aWxfMS5sb2FkUHJvdG9zV2l0aE9wdGlvbnMpKGZpbGVuYW1lLCBvcHRpb25zKS50aGVuKGxvYWRlZFJvb3QgPT4ge1xuICAgICAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb24obG9hZGVkUm9vdCwgb3B0aW9ucyk7XG4gICAgfSk7XG59XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZnVuY3Rpb24gbG9hZFN5bmMoZmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsb2FkZWRSb290ID0gKDAsIHV0aWxfMS5sb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jKShmaWxlbmFtZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKGxvYWRlZFJvb3QsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5sb2FkU3luYyA9IGxvYWRTeW5jO1xuZnVuY3Rpb24gZnJvbUpTT04oanNvbiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGxvYWRlZFJvb3QgPSBQcm90b2J1Zi5Sb290LmZyb21KU09OKGpzb24pO1xuICAgIGxvYWRlZFJvb3QucmVzb2x2ZUFsbCgpO1xuICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihsb2FkZWRSb290LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZnJvbUpTT04gPSBmcm9tSlNPTjtcbmZ1bmN0aW9uIGxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21CdWZmZXIoZGVzY3JpcHRvclNldCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRlY29kZWREZXNjcmlwdG9yU2V0ID0gZGVzY3JpcHRvci5GaWxlRGVzY3JpcHRvclNldC5kZWNvZGUoZGVzY3JpcHRvclNldCk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uRnJvbURlc2NyaXB0b3JTZXQoZGVjb2RlZERlc2NyaXB0b3JTZXQsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5sb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tQnVmZmVyID0gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlcjtcbmZ1bmN0aW9uIGxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21PYmplY3QoZGVzY3JpcHRvclNldCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRlY29kZWREZXNjcmlwdG9yU2V0ID0gZGVzY3JpcHRvci5GaWxlRGVzY3JpcHRvclNldC5mcm9tT2JqZWN0KGRlc2NyaXB0b3JTZXQpO1xuICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbkZyb21EZXNjcmlwdG9yU2V0KGRlY29kZWREZXNjcmlwdG9yU2V0LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdCA9IGxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21PYmplY3Q7XG4oMCwgdXRpbF8xLmFkZENvbW1vblByb3RvcykoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21PYmplY3QiLCJsb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tQnVmZmVyIiwiZnJvbUpTT04iLCJsb2FkU3luYyIsImxvYWQiLCJJZGVtcG90ZW5jeUxldmVsIiwiaXNBbnlFeHRlbnNpb24iLCJMb25nIiwiY2FtZWxDYXNlIiwicmVxdWlyZSIsIlByb3RvYnVmIiwiZGVzY3JpcHRvciIsInV0aWxfMSIsIm9iaiIsImRlc2NyaXB0b3JPcHRpb25zIiwibG9uZ3MiLCJTdHJpbmciLCJlbnVtcyIsImJ5dGVzIiwiZGVmYXVsdHMiLCJvbmVvZnMiLCJqc29uIiwiam9pbk5hbWUiLCJiYXNlTmFtZSIsIm5hbWUiLCJpc0hhbmRsZWRSZWZsZWN0aW9uT2JqZWN0IiwiU2VydmljZSIsIlR5cGUiLCJFbnVtIiwiaXNOYW1lc3BhY2VCYXNlIiwiTmFtZXNwYWNlIiwiUm9vdCIsImdldEFsbEhhbmRsZWRSZWZsZWN0aW9uT2JqZWN0cyIsInBhcmVudE5hbWUiLCJvYmpOYW1lIiwibmVzdGVkIiwia2V5cyIsIm1hcCIsInJlZHVjZSIsImFjY3VtdWxhdG9yIiwiY3VycmVudFZhbHVlIiwiY29uY2F0IiwiY3JlYXRlRGVzZXJpYWxpemVyIiwiY2xzIiwib3B0aW9ucyIsImRlc2VyaWFsaXplIiwiYXJnQnVmIiwidG9PYmplY3QiLCJkZWNvZGUiLCJjcmVhdGVTZXJpYWxpemVyIiwic2VyaWFsaXplIiwiYXJnIiwiQXJyYXkiLCJpc0FycmF5IiwiRXJyb3IiLCJtZXNzYWdlIiwiZnJvbU9iamVjdCIsImVuY29kZSIsImZpbmlzaCIsIm1hcE1ldGhvZE9wdGlvbnMiLCJpdGVtIiwia2V5IiwiZW50cmllcyIsInVuaW50ZXJwcmV0ZWRfb3B0aW9uIiwicHVzaCIsImRlcHJlY2F0ZWQiLCJpZGVtcG90ZW5jeV9sZXZlbCIsIklERU1QT1RFTkNZX1VOS05PV04iLCJjcmVhdGVNZXRob2REZWZpbml0aW9uIiwibWV0aG9kIiwic2VydmljZU5hbWUiLCJmaWxlRGVzY3JpcHRvcnMiLCJyZXF1ZXN0VHlwZSIsInJlc29sdmVkUmVxdWVzdFR5cGUiLCJyZXNwb25zZVR5cGUiLCJyZXNvbHZlZFJlc3BvbnNlVHlwZSIsInBhdGgiLCJyZXF1ZXN0U3RyZWFtIiwicmVzcG9uc2VTdHJlYW0iLCJyZXF1ZXN0U2VyaWFsaXplIiwicmVxdWVzdERlc2VyaWFsaXplIiwicmVzcG9uc2VTZXJpYWxpemUiLCJyZXNwb25zZURlc2VyaWFsaXplIiwib3JpZ2luYWxOYW1lIiwiY3JlYXRlTWVzc2FnZURlZmluaXRpb24iLCJwYXJzZWRPcHRpb25zIiwiY3JlYXRlU2VydmljZURlZmluaXRpb24iLCJzZXJ2aWNlIiwiZGVmIiwibWV0aG9kc0FycmF5IiwibWVzc2FnZURlc2NyaXB0b3IiLCJ0b0Rlc2NyaXB0b3IiLCJmb3JtYXQiLCJ0eXBlIiwiJHR5cGUiLCJmaWxlRGVzY3JpcHRvclByb3RvcyIsImNyZWF0ZUVudW1EZWZpbml0aW9uIiwiZW51bVR5cGUiLCJlbnVtRGVzY3JpcHRvciIsImNyZWF0ZURlZmluaXRpb24iLCJjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbiIsInJvb3QiLCJyZXNvbHZlQWxsIiwiZGVzY3JpcHRvckxpc3QiLCJmaWxlIiwiYnVmZmVyTGlzdCIsIkJ1ZmZlciIsImZyb20iLCJGaWxlRGVzY3JpcHRvclByb3RvIiwiY3JlYXRlUGFja2FnZURlZmluaXRpb25Gcm9tRGVzY3JpcHRvclNldCIsImRlY29kZWREZXNjcmlwdG9yU2V0IiwiZnJvbURlc2NyaXB0b3IiLCJmaWxlbmFtZSIsImxvYWRQcm90b3NXaXRoT3B0aW9ucyIsInRoZW4iLCJsb2FkZWRSb290IiwibG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyIsImRlc2NyaXB0b3JTZXQiLCJGaWxlRGVzY3JpcHRvclNldCIsImFkZENvbW1vblByb3RvcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/proto-loader/build/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/proto-loader/build/src/util.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/util.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addCommonProtos = exports.loadProtosWithOptionsSync = exports.loadProtosWithOptions = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(ssr)/./node_modules/protobufjs/index.js\");\nfunction addIncludePathResolver(root, includePaths) {\n    const originalResolvePath = root.resolvePath;\n    root.resolvePath = (origin, target)=>{\n        if (path.isAbsolute(target)) {\n            return target;\n        }\n        for (const directory of includePaths){\n            const fullPath = path.join(directory, target);\n            try {\n                fs.accessSync(fullPath, fs.constants.R_OK);\n                return fullPath;\n            } catch (err) {\n                continue;\n            }\n        }\n        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);\n        return originalResolvePath(origin, target);\n    };\n}\nasync function loadProtosWithOptions(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            return Promise.reject(new Error(\"The includeDirs option must be an array\"));\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = await root.load(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptions = loadProtosWithOptions;\nfunction loadProtosWithOptionsSync(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            throw new Error(\"The includeDirs option must be an array\");\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = root.loadSync(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptionsSync = loadProtosWithOptionsSync;\n/**\n * Load Google's well-known proto files that aren't exposed by Protobuf.js.\n */ function addCommonProtos() {\n    // Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,\n    // and wrappers. compiler/plugin is excluded in Protobuf.js and here.\n    // Using constant strings for compatibility with tools like Webpack\n    const apiDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/api.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/api.json\");\n    const descriptorDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/descriptor.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/descriptor.json\");\n    const sourceContextDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/source_context.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/source_context.json\");\n    const typeDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/type.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/type.json\");\n    Protobuf.common(\"api\", apiDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common(\"descriptor\", descriptorDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common(\"source_context\", sourceContextDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common(\"type\", typeDescriptor.nested.google.nested.protobuf.nested);\n}\nexports.addCommonProtos = addCommonProtos; //# sourceMappingURL=util.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHVCQUF1QixHQUFHQSxpQ0FBaUMsR0FBR0EsNkJBQTZCLEdBQUcsS0FBSztBQUNuRyxNQUFNSyxLQUFLQyxtQkFBT0EsQ0FBQyxjQUFJO0FBQ3ZCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDLGtCQUFNO0FBQzNCLE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLDREQUFZO0FBQ3JDLFNBQVNHLHVCQUF1QkMsSUFBSSxFQUFFQyxZQUFZO0lBQzlDLE1BQU1DLHNCQUFzQkYsS0FBS0csV0FBVztJQUM1Q0gsS0FBS0csV0FBVyxHQUFHLENBQUNDLFFBQVFDO1FBQ3hCLElBQUlSLEtBQUtTLFVBQVUsQ0FBQ0QsU0FBUztZQUN6QixPQUFPQTtRQUNYO1FBQ0EsS0FBSyxNQUFNRSxhQUFhTixhQUFjO1lBQ2xDLE1BQU1PLFdBQVdYLEtBQUtZLElBQUksQ0FBQ0YsV0FBV0Y7WUFDdEMsSUFBSTtnQkFDQVYsR0FBR2UsVUFBVSxDQUFDRixVQUFVYixHQUFHZ0IsU0FBUyxDQUFDQyxJQUFJO2dCQUN6QyxPQUFPSjtZQUNYLEVBQ0EsT0FBT0ssS0FBSztnQkFDUjtZQUNKO1FBQ0o7UUFDQUMsUUFBUUMsV0FBVyxDQUFDLENBQUMsRUFBRVYsT0FBTyx1Q0FBdUMsRUFBRUosYUFBYSxDQUFDO1FBQ3JGLE9BQU9DLG9CQUFvQkUsUUFBUUM7SUFDdkM7QUFDSjtBQUNBLGVBQWVYLHNCQUFzQnNCLFFBQVEsRUFBRUMsT0FBTztJQUNsRCxNQUFNakIsT0FBTyxJQUFJRixTQUFTb0IsSUFBSTtJQUM5QkQsVUFBVUEsV0FBVyxDQUFDO0lBQ3RCLElBQUksQ0FBQyxDQUFDQSxRQUFRRSxXQUFXLEVBQUU7UUFDdkIsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNKLFFBQVFFLFdBQVcsR0FBRztZQUNyQyxPQUFPRyxRQUFRQyxNQUFNLENBQUMsSUFBSUMsTUFBTTtRQUNwQztRQUNBekIsdUJBQXVCQyxNQUFNaUIsUUFBUUUsV0FBVztJQUNwRDtJQUNBLE1BQU1NLGFBQWEsTUFBTXpCLEtBQUswQixJQUFJLENBQUNWLFVBQVVDO0lBQzdDUSxXQUFXRSxVQUFVO0lBQ3JCLE9BQU9GO0FBQ1g7QUFDQW5DLDZCQUE2QixHQUFHSTtBQUNoQyxTQUFTRCwwQkFBMEJ1QixRQUFRLEVBQUVDLE9BQU87SUFDaEQsTUFBTWpCLE9BQU8sSUFBSUYsU0FBU29CLElBQUk7SUFDOUJELFVBQVVBLFdBQVcsQ0FBQztJQUN0QixJQUFJLENBQUMsQ0FBQ0EsUUFBUUUsV0FBVyxFQUFFO1FBQ3ZCLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDSixRQUFRRSxXQUFXLEdBQUc7WUFDckMsTUFBTSxJQUFJSyxNQUFNO1FBQ3BCO1FBQ0F6Qix1QkFBdUJDLE1BQU1pQixRQUFRRSxXQUFXO0lBQ3BEO0lBQ0EsTUFBTU0sYUFBYXpCLEtBQUs0QixRQUFRLENBQUNaLFVBQVVDO0lBQzNDUSxXQUFXRSxVQUFVO0lBQ3JCLE9BQU9GO0FBQ1g7QUFDQW5DLGlDQUFpQyxHQUFHRztBQUNwQzs7Q0FFQyxHQUNELFNBQVNEO0lBQ0wsNEVBQTRFO0lBQzVFLHFFQUFxRTtJQUNyRSxtRUFBbUU7SUFDbkUsTUFBTXFDLGdCQUFnQmpDLG1CQUFPQSxDQUFDO0lBQzlCLE1BQU1rQyx1QkFBdUJsQyxtQkFBT0EsQ0FBQztJQUNyQyxNQUFNbUMsMEJBQTBCbkMsbUJBQU9BLENBQUM7SUFDeEMsTUFBTW9DLGlCQUFpQnBDLG1CQUFPQSxDQUFDO0lBQy9CRSxTQUFTbUMsTUFBTSxDQUFDLE9BQU9KLGNBQWNLLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDRCxNQUFNLENBQUNFLFFBQVEsQ0FBQ0YsTUFBTTtJQUN6RXBDLFNBQVNtQyxNQUFNLENBQUMsY0FBY0gscUJBQXFCSSxNQUFNLENBQUNDLE1BQU0sQ0FBQ0QsTUFBTSxDQUFDRSxRQUFRLENBQUNGLE1BQU07SUFDdkZwQyxTQUFTbUMsTUFBTSxDQUFDLGtCQUFrQkYsd0JBQXdCRyxNQUFNLENBQUNDLE1BQU0sQ0FBQ0QsTUFBTSxDQUFDRSxRQUFRLENBQUNGLE1BQU07SUFDOUZwQyxTQUFTbUMsTUFBTSxDQUFDLFFBQVFELGVBQWVFLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDRCxNQUFNLENBQUNFLFFBQVEsQ0FBQ0YsTUFBTTtBQUMvRTtBQUNBNUMsdUJBQXVCLEdBQUdFLGlCQUMxQixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc2htaXR0LWd1cHRhLy4vbm9kZV9tb2R1bGVzL0BncnBjL3Byb3RvLWxvYWRlci9idWlsZC9zcmMvdXRpbC5qcz82NDFkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWRkQ29tbW9uUHJvdG9zID0gZXhwb3J0cy5sb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jID0gZXhwb3J0cy5sb2FkUHJvdG9zV2l0aE9wdGlvbnMgPSB2b2lkIDA7XG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IFByb3RvYnVmID0gcmVxdWlyZShcInByb3RvYnVmanNcIik7XG5mdW5jdGlvbiBhZGRJbmNsdWRlUGF0aFJlc29sdmVyKHJvb3QsIGluY2x1ZGVQYXRocykge1xuICAgIGNvbnN0IG9yaWdpbmFsUmVzb2x2ZVBhdGggPSByb290LnJlc29sdmVQYXRoO1xuICAgIHJvb3QucmVzb2x2ZVBhdGggPSAob3JpZ2luLCB0YXJnZXQpID0+IHtcbiAgICAgICAgaWYgKHBhdGguaXNBYnNvbHV0ZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZGlyZWN0b3J5IG9mIGluY2x1ZGVQYXRocykge1xuICAgICAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoLmpvaW4oZGlyZWN0b3J5LCB0YXJnZXQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmcy5hY2Nlc3NTeW5jKGZ1bGxQYXRoLCBmcy5jb25zdGFudHMuUl9PSyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bGxQYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoYCR7dGFyZ2V0fSBub3QgZm91bmQgaW4gYW55IG9mIHRoZSBpbmNsdWRlIHBhdGhzICR7aW5jbHVkZVBhdGhzfWApO1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxSZXNvbHZlUGF0aChvcmlnaW4sIHRhcmdldCk7XG4gICAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRQcm90b3NXaXRoT3B0aW9ucyhmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgUHJvdG9idWYuUm9vdCgpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghIW9wdGlvbnMuaW5jbHVkZURpcnMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuaW5jbHVkZURpcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdUaGUgaW5jbHVkZURpcnMgb3B0aW9uIG11c3QgYmUgYW4gYXJyYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkSW5jbHVkZVBhdGhSZXNvbHZlcihyb290LCBvcHRpb25zLmluY2x1ZGVEaXJzKTtcbiAgICB9XG4gICAgY29uc3QgbG9hZGVkUm9vdCA9IGF3YWl0IHJvb3QubG9hZChmaWxlbmFtZSwgb3B0aW9ucyk7XG4gICAgbG9hZGVkUm9vdC5yZXNvbHZlQWxsKCk7XG4gICAgcmV0dXJuIGxvYWRlZFJvb3Q7XG59XG5leHBvcnRzLmxvYWRQcm90b3NXaXRoT3B0aW9ucyA9IGxvYWRQcm90b3NXaXRoT3B0aW9ucztcbmZ1bmN0aW9uIGxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMoZmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByb290ID0gbmV3IFByb3RvYnVmLlJvb3QoKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoISFvcHRpb25zLmluY2x1ZGVEaXJzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmluY2x1ZGVEaXJzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaW5jbHVkZURpcnMgb3B0aW9uIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRJbmNsdWRlUGF0aFJlc29sdmVyKHJvb3QsIG9wdGlvbnMuaW5jbHVkZURpcnMpO1xuICAgIH1cbiAgICBjb25zdCBsb2FkZWRSb290ID0gcm9vdC5sb2FkU3luYyhmaWxlbmFtZSwgb3B0aW9ucyk7XG4gICAgbG9hZGVkUm9vdC5yZXNvbHZlQWxsKCk7XG4gICAgcmV0dXJuIGxvYWRlZFJvb3Q7XG59XG5leHBvcnRzLmxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMgPSBsb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jO1xuLyoqXG4gKiBMb2FkIEdvb2dsZSdzIHdlbGwta25vd24gcHJvdG8gZmlsZXMgdGhhdCBhcmVuJ3QgZXhwb3NlZCBieSBQcm90b2J1Zi5qcy5cbiAqL1xuZnVuY3Rpb24gYWRkQ29tbW9uUHJvdG9zKCkge1xuICAgIC8vIFByb3RvYnVmLmpzIGV4cG9zZXM6IGFueSwgZHVyYXRpb24sIGVtcHR5LCBmaWVsZF9tYXNrLCBzdHJ1Y3QsIHRpbWVzdGFtcCxcbiAgICAvLyBhbmQgd3JhcHBlcnMuIGNvbXBpbGVyL3BsdWdpbiBpcyBleGNsdWRlZCBpbiBQcm90b2J1Zi5qcyBhbmQgaGVyZS5cbiAgICAvLyBVc2luZyBjb25zdGFudCBzdHJpbmdzIGZvciBjb21wYXRpYmlsaXR5IHdpdGggdG9vbHMgbGlrZSBXZWJwYWNrXG4gICAgY29uc3QgYXBpRGVzY3JpcHRvciA9IHJlcXVpcmUoJ3Byb3RvYnVmanMvZ29vZ2xlL3Byb3RvYnVmL2FwaS5qc29uJyk7XG4gICAgY29uc3QgZGVzY3JpcHRvckRlc2NyaXB0b3IgPSByZXF1aXJlKCdwcm90b2J1ZmpzL2dvb2dsZS9wcm90b2J1Zi9kZXNjcmlwdG9yLmpzb24nKTtcbiAgICBjb25zdCBzb3VyY2VDb250ZXh0RGVzY3JpcHRvciA9IHJlcXVpcmUoJ3Byb3RvYnVmanMvZ29vZ2xlL3Byb3RvYnVmL3NvdXJjZV9jb250ZXh0Lmpzb24nKTtcbiAgICBjb25zdCB0eXBlRGVzY3JpcHRvciA9IHJlcXVpcmUoJ3Byb3RvYnVmanMvZ29vZ2xlL3Byb3RvYnVmL3R5cGUuanNvbicpO1xuICAgIFByb3RvYnVmLmNvbW1vbignYXBpJywgYXBpRGVzY3JpcHRvci5uZXN0ZWQuZ29vZ2xlLm5lc3RlZC5wcm90b2J1Zi5uZXN0ZWQpO1xuICAgIFByb3RvYnVmLmNvbW1vbignZGVzY3JpcHRvcicsIGRlc2NyaXB0b3JEZXNjcmlwdG9yLm5lc3RlZC5nb29nbGUubmVzdGVkLnByb3RvYnVmLm5lc3RlZCk7XG4gICAgUHJvdG9idWYuY29tbW9uKCdzb3VyY2VfY29udGV4dCcsIHNvdXJjZUNvbnRleHREZXNjcmlwdG9yLm5lc3RlZC5nb29nbGUubmVzdGVkLnByb3RvYnVmLm5lc3RlZCk7XG4gICAgUHJvdG9idWYuY29tbW9uKCd0eXBlJywgdHlwZURlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcbn1cbmV4cG9ydHMuYWRkQ29tbW9uUHJvdG9zID0gYWRkQ29tbW9uUHJvdG9zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhZGRDb21tb25Qcm90b3MiLCJsb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jIiwibG9hZFByb3Rvc1dpdGhPcHRpb25zIiwiZnMiLCJyZXF1aXJlIiwicGF0aCIsIlByb3RvYnVmIiwiYWRkSW5jbHVkZVBhdGhSZXNvbHZlciIsInJvb3QiLCJpbmNsdWRlUGF0aHMiLCJvcmlnaW5hbFJlc29sdmVQYXRoIiwicmVzb2x2ZVBhdGgiLCJvcmlnaW4iLCJ0YXJnZXQiLCJpc0Fic29sdXRlIiwiZGlyZWN0b3J5IiwiZnVsbFBhdGgiLCJqb2luIiwiYWNjZXNzU3luYyIsImNvbnN0YW50cyIsIlJfT0siLCJlcnIiLCJwcm9jZXNzIiwiZW1pdFdhcm5pbmciLCJmaWxlbmFtZSIsIm9wdGlvbnMiLCJSb290IiwiaW5jbHVkZURpcnMiLCJBcnJheSIsImlzQXJyYXkiLCJQcm9taXNlIiwicmVqZWN0IiwiRXJyb3IiLCJsb2FkZWRSb290IiwibG9hZCIsInJlc29sdmVBbGwiLCJsb2FkU3luYyIsImFwaURlc2NyaXB0b3IiLCJkZXNjcmlwdG9yRGVzY3JpcHRvciIsInNvdXJjZUNvbnRleHREZXNjcmlwdG9yIiwidHlwZURlc2NyaXB0b3IiLCJjb21tb24iLCJuZXN0ZWQiLCJnb29nbGUiLCJwcm90b2J1ZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/proto-loader/build/src/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/package.json":
/*!*************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/package.json ***!
  \*************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"@grpc/grpc-js","version":"1.7.3","description":"gRPC Library for Node - pure JS implementation","homepage":"https://grpc.io/","repository":"https://github.com/grpc/grpc-node/tree/master/packages/grpc-js","main":"build/src/index.js","engines":{"node":"^8.13.0 || >=10.10.0"},"keywords":[],"author":{"name":"Google Inc."},"types":"build/src/index.d.ts","license":"Apache-2.0","devDependencies":{"@types/gulp":"^4.0.6","@types/gulp-mocha":"0.0.32","@types/lodash":"^4.14.108","@types/mocha":"^5.2.6","@types/ncp":"^2.0.1","@types/pify":"^3.0.2","@types/semver":"^7.3.9","clang-format":"^1.0.55","execa":"^2.0.3","gts":"^2.0.0","gulp":"^4.0.2","gulp-mocha":"^6.0.0","lodash":"^4.17.4","madge":"^5.0.1","mocha-jenkins-reporter":"^0.4.1","ncp":"^2.0.0","pify":"^4.0.1","rimraf":"^3.0.2","semver":"^7.3.5","ts-node":"^8.3.0","typescript":"^3.7.2"},"contributors":[{"name":"Google Inc."}],"scripts":{"build":"npm run compile","clean":"rimraf ./build","compile":"tsc -p .","format":"clang-format -i -style=\\"{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}\\" src/*.ts test/*.ts","lint":"npm run check","prepare":"npm run generate-types && npm run compile","test":"gulp test","check":"gts check src/**/*.ts","fix":"gts fix src/*.ts","pretest":"npm run generate-types && npm run generate-test-types && npm run compile","posttest":"npm run check && madge -c ./build/src","generate-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --includeDirs proto/ --include-dirs test/fixtures/ -O src/generated/ --grpcLib ../index channelz.proto","generate-test-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --include-dirs test/fixtures/ -O test/generated/ --grpcLib ../../src/index test_service.proto"},"dependencies":{"@grpc/proto-loader":"^0.7.0","@types/node":">=12.12.47"},"files":["src/**/*.ts","build/src/**/*.{js,d.ts,js.map}","proto/*.proto","LICENSE","deps/envoy-api/envoy/api/v2/**/*.proto","deps/envoy-api/envoy/config/**/*.proto","deps/envoy-api/envoy/service/**/*.proto","deps/envoy-api/envoy/type/**/*.proto","deps/udpa/udpa/**/*.proto","deps/googleapis/google/api/*.proto","deps/googleapis/google/rpc/*.proto","deps/protoc-gen-validate/validate/**/*.proto"]}');

/***/ })

};
;